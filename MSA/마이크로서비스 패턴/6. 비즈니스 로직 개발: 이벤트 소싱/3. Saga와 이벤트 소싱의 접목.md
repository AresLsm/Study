# Saga와 이벤트 소싱의 접목

- 이벤트 소싱에서는 코레오그래피 Saga를 쉽게 이용할 수 있다. 참여자는 자신의 Aggregate가  
  발생시킨 도메인 이벤트를 교환하고, 각 참여자의 Aggregate는 커맨드를 처리하고 새로운  
  이벤트를 발생시키는 식으로 이벤트를 처리한다. 물론 Aggregate 및 Aggregate를 업데이트하는  
  이벤트 핸들러 클래스는 개발자가 직접 작성해야 한다.

- 하지만 이벤트 소싱 기반의 비즈니스 로직을 오케스트레이션 Saga에 연계하는 일은 훨씬 어렵다.  
  이벤트 저장소의 트랜잭션 개념이 상당히 제한적이기 때문이다. 이벤트 저장소를 사용하는  
  애플리케이션은 Aggregate 하나만 생성, 수정하고 결과 이벤트들을 반환할 수 있는데,  
  Saga의 각 단계는 다음과 같이 반드시 원자적으로 수행되어야 하는 액션들로 구성된다.

  - **Saga 생성**: Saga를 시작한 서비스는 원자적으로 Aggregate를 생성, 수정하고 Saga  
    오케스트레이터를 생성해야 한다.
  - **Saga 오케스트레이션**: Saga 오케스트레이터는 원자적으로 응답을 소비하고, 자신의 상태를  
    업데이트한 후 커맨드 메시지를 전송해야 한다.
  - **Saga 참여자**: Saga 참여자는 원자적으로 메시지를 소비하고, 중복 메시지를 솎아 내고,  
    Aggregate를 생성 및 수정하고, 응답 메시지를 전송해야 한다.

- 이처럼 이벤트 저장소의 트랜잭션 능력과 요건 사이에 맞지 않는 부분이 있기 때문에  
  오케스트레이션 Saga와 이벤트 소싱을 연계하는 작업은 쉽지 않은 도전이 될 가능성이 있다.

- 이벤트 저장소의 RDBMS/NoSQL 사용 여부는 이벤트 소싱과 오케스트레이션 Saga의 연계 가능성을  
  가늠하는 핵심 기준이다. Eventuate Tram Saga 프레임워크와 그 하부를 지지하는 Tram Messaging  
  프레임워크는 RDBMS에서 지원하는 유연한 ACID 트랜잭션에 의존한다. Saga 오케스트레이터와  
  참여자는 ACID 트랜잭션을 걸고 DB를 원자적으로 업데이트한 후, 메시지를 교환한다.  
  Eventuate Local 등 RDBMS 기반의 이벤트 저장소를 사용하는 애플리케이션은 융통성 있게  
  Eventuate Tram Saga 프레임워크를 호출해서 이벤트 저장소를 ACID 트랜잭션으로 업데이트할 수 있다.  
  그러나 NoSQL DB를 쓰는 이벤트 저장소는 Eventuate Tram Saga 프레임워크와 동일한 트랜잭션에  
  참여할 수 없기에 다른 방법을 궁리해야 한다.

- 해결해야할 이슈와 가능한 시나리오를 정리해보자.

  - 코레오그래피 Saga 구현
  - 오케스트레이션 Saga 생성
  - 이벤트 소싱 기반의 Saga 참여자 구현
  - 이벤트 소싱을 이용하여 Saga 오케스트레이터 구현

## 코레오그래피 Saga 구현: 이벤트 소싱

- 이벤트 소싱은 속성상 이벤트가 모든 것을 주도하므로 코레오그래피 Saga를 매우 쉽게 구현할 수 있다.  
  Aggregate가 업데이트되면 Saga가 이벤트를 발생시키고, 제각기 배정된 이벤트 핸들러는 해당 이벤트를  
  소비한 후 Aggregate를 업데이트한다. 이벤트 소싱 프레임워크는 각 이벤트 핸들러를 알아서 멱등하게 만든다.

- 이전에 주문 생성 Saga를 코레오그래피 기반으로 구현했을 때, `ConsumerService`, `KitchenService`,  
  `AccountingService`는 `OrderService`의 이벤트를 구독하고, 반대로 `OrderService` 역시  
  이 세 서비스의 이벤트를 구독했다. 각 서비스는 이벤트 핸들러를 갖고 있다. 이벤트 핸들러가 해당 Aggregate를  
  업데이트하면 또 다른 이벤트가 발생한다.

- 이벤트 소싱과 코레오그래피 Saga는 찰떡궁합니다. 이벤트 소싱은 메시징 기반의 IPC, 메시지 중복 제거, 원자적  
  상태 업데이트와 메시지 전송 등 Saga가 필요로하는 여러 가지 메커니즘을 제공한다. 물론 코레오그래피 Saga는  
  단순해서 좋지만, 단점도 많다. 특히 이벤트 소싱에서만 해당되는 단점이 하나 있다.

- 코레오그래피 Saga에 이벤트를 사용하면 이벤트의 목적이 이원화되는 문제가 있다. 이벤트 소싱은 상태 변화를  
  나타내기 위해 이벤트를 이용하는데, 이벤트를 코레오그래피 Saga에 갖다 쓰면 Aggregate는 상태변화가 없어도  
  무조건 이벤트를 발생시켜야 한다. 가령 Aggregate를 업데이트하면 비즈니스 규칙에 위배될 경우, Aggregate는  
  이런 상황에도 반드시 이벤트를 발생시켜 오류를 보고해야 한다. 더 큰 문제는 Saga 참여자가 Aggregate를 생성할 수 없는  
  경우이다. 에러 이벤트를 발생시킬 Aggregate가 하나도 없을 것이다.

- 이런 문제가 있어서 조금 더 복잡하지만 오케스트레이션 Saga를 구현하는 것이 최선이다.  
  먼저 `OrderService#createOrder()` 같은 서비스 메소드에서 Saga 오케스트레이터를  
  생성하는 방법을 살펴보자.

<hr/>

## 오케스트레이션 Saga 생성

- Saga 오케스트레이터는 일부 서비스 메소드에 의해 생성된다. `OrderService#createOrder()`같은  
  다른 서비스 메소드는 Aggregate를 생성, 수정하고 Saga 오케스트레이터를 생성하는 두 가지 일을 한다.  
  서비스는 이 두 가지 액션을 첫 번째 액션이 수행되면 두 번째 액션은 최종적으로 실행되는 방식으로 수행한다.  
  두 액션이 서비스에서 반드시 수행되도록 보장하는 방법은 이벤트 저장소의 종류마다 다르다.

### Saga 오케스트레이터 작성: RDBMS 이벤트 저장소 사용 서비스

- RDBMS 이벤트 저장소를 사용하는 서비스에서는 이벤트 저장소를 업데이트하고, Saga 오케스트레이터를  
  생성하는 작업을 하나의 트랜잭션으로 묶을 수 있다. 예를 들어, `OrderService`가 Eventuate Local 및  
  Eventuate Tram Saga 프레임워크를 사용한다면, `createOrder()`는 아래처럼 구현할 수 있다.

```java
class OrderService {

    //..

    @Autowired
    private SagaManager<CreateOrderSagaState> createOrderSagaManager;

    @Transactional
    public EntityWithIdAndVersion<Order> createOrder(OrderDetails orderDetails) {

	// Order Aggregate 생성
	EntityWithIdAndVersion<Order> order = orderRepository.save(new CreateOrder(orderDetails));

	// CreateOrderSaga 생성
	CreateOrderSagaState sagaState = new CreateOrderSagaState(order.getId(), orderDetails);
	createOrderSagaManager.create(sagaState, Order.class, order.getId());

	return order;
    }
}
```

- Eventuate Local은 RDBMS를 사용하므로 Eventuate Tram Saga 프레임워크와 동일한 ACID  
  트랜잭션에 참여할 수 있다. 하지만 NoSQL 이벤트 저장소를 사용하는 서비스는 Saga 오케스트레이터를  
  생성하는 것이 이렇게 간단하지 않다.

### Saga 오케스트레이터 작성: NoSQL 이벤트 저장소 사용 서비스

- NoSQL 이벤트 저장소를 사용하는 서비스는 이벤트 저장소를 업데이트하고, Saga 오케스트레이터를  
  생성하는 액션을 원자적으로 수행할 수 없다. Saga 오케스트레이션 프레임워크가 전혀 다른 DB를  
  사용할 수도 있을 것이다. 설사 동일한 NoSQL DB를 사용한다 하더라도 NoSQL DB 특성상 트랜잭션  
  모델이 제한적이므로 애플리케이션에서 상이한 두 객체를 원자적으로 생성, 수정할 수 없다.  
  그 대신 서비스는 Aggregate가 발생시킨 도메인 이벤트에 반응하여 Saga 오케스트레이터를  
  생성하는 이벤트 핸들러를 갖고 있어야 한다.

- 주문 서비스가 `OrderCreated` 이벤트 핸들러로 `CreateOrderSaga`를 생성하는 과정을 보자.  
  주문 서비스가 `Order` Aggregate를 만들어 이벤트 저장소에 저장하면, 이벤트 저장소는  
  `OrderCreated` 이벤트를 발행하고, 이벤트 핸들러는 이 이벤트를 소비한다. 이벤트 핸들러는  
  Eventuate Tram Saga 프레임워크를 호출하여 `CreateOrderSaga`를 호출한다.

- Saga 오케스트레이터를 생성하는 이벤트 핸들러를 작성할 때 주의할 점은 **중복 이벤트를 처리해야 한다**는  
  사실이다. 적어도 한 번은 메시지를 전달하기 때문에 Saga를 생성하는 이벤트 핸들러가 여러 번  
  호출될 수도 있을 것이다. Saga 인스턴스를 정확히 하나만 생성하도록 하는 방법은 무엇일까?

- 가장 쉬운 방법은 이벤트의 유일한 속성에서 Saga ID를 추출하는 것이다. 방법은 두 가지가 있는데,  
  첫째, **이벤트를 발생시킨 Aggregate ID를 Saga ID로 사용하는 것**이다. Aggregate 생성  
  이벤트에 반응하여 생성되는 Saga에 적합한 방식이다.

- 둘째, **이벤트 ID를 Saga ID로 쓰는 것**이다. 이벤트 ID는 유일하므로 Saga ID 역시 반드시  
  유일하다. 중복 이벤트라면 이벤트 핸들러가 Saga 생성을 시도할 때 해당 ID가 이미 존재할 테니  
  실패할 것이다. 동일한 Saga 인스턴스가 여럿 존재할 가능성이 있을 때 괜찮은 방법이 된다.

- RDBMS 이벤트 저장소를 사용하는 서비스 역시 동일한 이벤트 주도 방식으로 Saga를 생성할 수 있다.  
  `OrderService`같은 서비스가 더 이상 명시적으로 Saga 인스턴스를 생성하지 않으므로  
  느슨한 결합이 장려되는 장점이 있다.

<hr/>
