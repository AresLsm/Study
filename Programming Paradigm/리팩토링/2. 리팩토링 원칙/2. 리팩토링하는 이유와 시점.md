# 리팩토링의 이유와 시점

<h2>리팩토링하는 이유</h2>

- 리팩토링이 소프트웨어의 모든 문제점을 해결하는 만병통치약은 절대 아니다.  
  하지만 코드를 건강한 상태로 유지하는 데 도와주는 약임은 분명하다.  
  리팩토링은 다양한 용도로 활용할 수 있고, 또 반드시 그래야 하는 도구이다.

<h3>리팩토링하면 소프트웨어 설계가 좋아진다</h3>

- 리팩토링하지 않으면 소프트웨어의 내부 설계(아키텍쳐)가 훼손되기 쉽다. 아키텍쳐를 충분히 이해하지 못한 채 단기 목표만을  
  위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다. 그러면 코드만 봐서는 설계를 파악하기 어려워진다. 코드 구조가 무너지기  
  시작하면 악효과가 누적된다. 코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어려워지고, 설계가 부패되는 속도는  
  더욱 빨라진다. 반면 규칙적인 리팩토링은 코드의 구조를 지탱해준다.

- 같은 일을 하더라도 설계가 나쁘면 코드가 길어지기 십상이다. 사실상 같은 일을 하는 코드가 여러 곳에 나타날 수 있기 때문이다.  
  그래서 중복 코드 제거는 설계 개선 작업의 중요한 한 축을 차지한다. 코드량을 줄인다고 시스템이 빨라지는 것은 아니다.  
  프로그램의 용량이 속도에 영향을 주는 경우는 별로 없다. 하지만 코드량이 줄면 수정하는 데 드는 노력은 크게 달라진다.  
  코드가 길 수록 실수 없이 수정하기 어려워진다. 이해해야할 코드량도 늘어난다. 비슷한 일을 하는 코드가 산재해 있다면 한 부분만  
  살짝 바꿔서는 시스템이 예상대로 동작하지 않을 수 있다. 반면 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을  
  보장할 수 있으며, 이는 바람직한 설계의 핵심이다.

<h3>리팩토링하면 소프트웨어를 이해하기 쉬워진다</h3>

- 프로그래밍은 여러 면에서 컴퓨터에게 시킬 일을 표현하는 행위이다. 컴퓨터에게 시키려는 일과 이를 표현하는 코드의 차이를  
  최대한 줄이는 것은 매우 중요하다. 프로그래밍은 결국 개발자가 원하는 바를 명확히 표현하는 것이다.  
  그런데 내 소스를 컴퓨터만 사용하는 것이 아니고, 예를 들어 몇 달이 지나 누군가가 내 코드를 수정하고자 읽게될 수 있다.  
  사실 프로그래밍에서는 사람이 가장 중요하지만 소홀하기 쉽다. 다른 프로그래머가 내 코드를 제대로 이해했다면 한 시간에 끝낼  
  수정을 일주일이나 걸리게 될 수도 있다.

- 문제는 프로그램을 동작시키는 데만 신경쓰면 나중에 내 코드를 다룰 개발자를 배려하지 못한다는 데 있다.  
  코드를 이해하기 쉽게 만들려면 일하는 리듬에 변화를 줘야 한다. 리팩토링은 코드가 더 잘 읽히게 도와준다.  
  잘 작동하지만 이상적인 구조는 아닌 코드가 있다면, 잠깐 시간을 내서 리팩토링하자. 그러면 코드의 목적이 더 잘 드러나게, 다시말해  
  내 의도를 더 명확하게 전달하도록 개선할 수 있다.

- 단지 다른 사람을 배려하기 위해서가 아니다. 사실 그 다른 사람이 바로 나 자신일 때가 많다.  
  그래서 더더욱 리팩토링이 중요하다.

<h3>리팩토링하면 버그를 쉽게 찾을 수 있다</h3>

- 코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다.  
  리팩토링을 하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다.  
  프로그램의 구조를 명확하게 다듬으면 그냥 *이럴 것이다*라고 가정하던 점들이 분명히 드러나는데,  
  버그를 지나치려야 지나칠 수 없을 정도까지 명확해진다.

<h3>리팩토링하면 프로그래밍 속도를 높일 수 있다</h3>

- 지금까지 본 장점들을 한 마디로 정리하면, 리팩토링하면 코드 개발 속도를 높일 수 있다는 말과 같다.  
  사람들은 리팩토링에 대해 알게 되면 품질을 높일 수 있다는 점에는 대개 수긍한다.  
  내부 설계와 가독성이 개선되고 버그가 줄어든다는 점은 모두 품질 향상에 직결된다.

- 오랜 시간이 지난 프로젝트는 새로운 기능을 추가할 때 초기에 비해 시간이 훨씬 오래 걸리는 경향이 있다.  
  즉, 새로운 기능을 추가할수록 기존 코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 늘어난다는 것이다.  
  게다가 기능을 추가하고 나면 버그가 발생하는 일이 잦고, 이를 해결하는 시간은 한층 더 걸린다.  
  이러한 부담은 기능 추가 속도를 계속 떨어뜨리면서, 차라리 처음부터 새로 개발하는 편이 낫겠다고 생각하는 지경에 이른다.

- 시간이 x축, 기능의 누적이 y축인 그래프가 있을 때 나쁜 설계는 루트 그래프를 띄며,  
  좋은 설계는 x=y 형식의 그래프를 띈다.  
  이렇게 차이나는 원인은 소프트웨어의 내부 품질에 있다.  
  내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다.  
  모듈화가 잘 되어있으면 전체 코드베이스 중 작은 부분만 이해하면 된다.  
  코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉽다.  
  내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.

<hr/>

<h2>언제 리팩토링해야 할까?</h2>

- 저자는 프로그래밍할 때 거의 한 시간 간격으로 리팩토링한다.  
  아래는 Don Roberts가 제시한 가이드이다.

> 1. 처음에는 그냥 한다.
> 2. 비슷한 일을 두 번째로 하게 되면(중복이 생기면) 일단 계속 진행한다.
> 3. 비슷한 일을 세 번째 하게 되면 리팩토링한다.

<h3>준비를 위한 리팩토링: 기능을 쉽게 추가하게 만들기</h3>

- 리팩토링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.  
  이 시점에서 현재 코드를 살펴보자. 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.  
  가령 요구사항을 거의 만족하지만 리터럴 값 몇 개가 방해되는 함수가 있을 수 있다. 함수를 복제해서 해당 값만  
  수정하면 되지만, 이는 중복 코드를 발생시킨다. 나중에는 이 부분을 변경할 일이 생기면 원래 코드와  
  복제한 코드를 모두 수정해야 하며, 더 심한 경우는 복제한 코드가 어디 있는지까지 일일이 찾아내야 한다.  
  이렇게 복사, 붙여넣기 방식으로 처리하면 나중에 새로운 기능을 약간 변형한 버전을 만들어야 할 때 번거롭다.  
  그래서 이럴 때는 리팩토링 모자를 쓰고 **함수 매개변수화하기**를 적용한다. 그러고 나면 그 함수에 필요한 매개변수를  
  지정해서 호출하기만 하면 된다.

- 버그를 잡을 때도 마찬가지다. 오류를 일으키는 코드가 세 곳에 복제되어 퍼져있다면, 우선 한 곳으로 합치는 편이  
  작업하기에 훨씬 편하다. 또는 질의 코드에 섞여 있는 갱신 로직을 분리하면 두 작업이 꼬여서 생기는 오류를 크게 줄일 수 있다.  
  이처럼 *준비를 위한 리팩토링*으로 상황을 개선해 놓으면 버그가 수정된 상태가 오래 지속될 가능성을 높이는 동시에  
  같은 곳에서 다른 버그가 발생할 가능성을 줄일 수도 있다.

<h3>이해를 위한 리팩토링: 코드를 이해하기 쉽게 만들기</h3>

- 코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다. 그 코드를 작성한 사람은 자신일 수도 있고 다른 사람일 수도 있다.  
  코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩토링할 여지가 없는지 찾아보자. 조건부 로직의 구조가 이상하지  
  않은지 살펴보기도 하고, 함수 이름을 잘못 정해서 실제로 하는 일을 파악하는 데 시간이 오래 걸리지는 않았는지도 살펴보자.

- 리팩토링을 하면 위 과정에서 발견한 부분들을 코드로 옮겨 담을 수 있다. 그런 다음 수정한 코드를 테스트해봐서 생각이 맞았는지  
  확인할 수도 있다.

<h3>쓰레기 줍기 리팩토링</h3>

- 코드를 파악해보면 일을 비효율적으로 처리하는 모습을 발견할 때가 있다. 로직이 쓸데없이 복잡하거나, 매개변수화한 함수 하나면 될  
  일을 거의 똑같은 함수 여러 개로 작성해놨을 수 있다. 간단히 수정할 수 있는 것들은 즉시 고치고, 시간이 좀 걸릴 것 같은 일들은  
  추후에 처리하도록 하자. 여기서 앞에서 말했던 리팩토링의 멋진 점인 리팩토링 각각의 작은 단계가 코드를 깨뜨리지 않는다는게 부각된다.

<h3>계획된 리팩토링과 수시로 하는 리팩토링</h3>

- 위에서 본 _준비를 위한 리팩토링_, _이해를 위한 리팩토링_, *쓰레기 줍기 리팩토링*은 모두 기회가 될 때만 진행한다.  
  저자는 개발에 들어가기 전 리팩토링 일정을 따로 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩토링도 함께 한다.  
  즉 두 가지를 프로그래밍 과정에 자연스럽게 녹인 것이다. 기능을 추가할 때든 버그를 잡을 때든 리팩토링은 눈앞의 문제뿐 아니라  
  앞으로 할 작업에도 도움을 준다. 이는 간과하기 쉽지만 매우 중요한 점이다. **리팩토링은 프로그래밍과 구분되는 별개의 활동이 아니다.**

> 보기 싫은 코드를 발견하면 리팩토링하자. 그런데 잘 작성된 코드 역시 수많은 리팩토링을 거쳐야 한다.

- 리팩토링은 과거에 저지른 실수를 바로잡거나 보기 싫은 코드를 정리하는 작업이라고 오해하기 쉽다. 보기 싫은 코드를 보면 리팩토링해야함은  
  당연하지만, 잘 작성된 코드 역시 수많은 리팩토링을 거쳐야 한다. 코드를 작성할 때 마다 매개변수화하거나 개별 함수로 나누는 기준 등을  
  스스로 타협하자. 이후에 상황이 변해 기준을 변경해야할 때 코드가 이미 깔끔하다면 리팩토링하기가 더 쉽다.

> 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고, 그런 다음 쉽게 수정하자.

- 소프트웨어 개발에서 새로운 기능을 추가하기 쉽도록 코드를 *수정*하는 것이 그 기능을 가장 빠르게 추가하는 길임을 명심하자.  
  개발은 끝이 있는 작업이 아니며, 새로운 기능이 필요할 때마다 소프트웨어는 이를 반영하기 위해 수정된다.  
  이때 새로 작성해 넣는 코드보다 기존 코드의 수정량이 더 큰 경우가 대체로 많다.

- 그렇다고 해서 계획된 리팩토링이 무조건 나쁘다는 말은 아니다. 리팩토링에 그동한 소홀했다면, 따로 시간을 내서 새로운 기능을 추가하기 쉽도록  
  코드베이스를 개선할 필요가 분명히 있다.

<h3>오래 걸리는 리팩토링</h3>

- 리팩토링은 대부분 길어야 몇 시간 정도에 끝나지만, 팀 전체가 달려들어도 몇 주는 걸리는 대규모 리팩토링도 있다.  
  라이브러리를 교체하는 작업일 수도 있고, 일부 코드를 다른 팀과 공유하기 위해 컴포넌트로 빼내는 작업일 수도 있다.

<h3>코드 리뷰에 리팩토링 활용하기</h3>

- 코드 리뷰에 리팩토링을 잘 활용하자!

<hr/>

<h2>리팩토링 시 고려할 문제</h2>

<h3>새 기능 개발 속도 저하</h3>

- 많은 사람들이 리팩토링 때문에 새 기능을 개발하는 속도가 느려진다 여기지만, 리팩토링의 궁극적인 목적은 개발 속도를 높이는 것이다.

> 리팩토링의 궁극적인 목적은 개발 속도를 높여서 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

- 상황에 알맞게 잘 조율하자. 예컨데 대대적인 리팩토링이 필요해 보이지만, 추가하려는 새 기능이 아주 작아 기능 추가부터 하고 싶은  
  상황에 마주칠 수 있다. 이럴 때는 개발자로서의 경험을 잘 발휘해서 결정하자.

- 리팩토링의 본질은 clean code 등 코드베이스를 예쁘게 꾸미는 데 있지 않다. 오로지 개발 기간을 단축시키고자 하는 것임을 명심하자.

<h3>코드 소유권</h3>

- 함수명을 바꾸고 싶고, 그 함수를 호출하는 곳을 모두 찾을 수 있디면 **함수 선언 바꾸기**로 선언 자체와 호출하는 곳 모두를 한번에 바꿀 수 있다.  
  하지만 이렇게 간단하지 않을 때도 있다. 예를 들어 함수를 호출하는 코드의 소유자가 다른 팀이어서 쓰기 권한이 없거나,  
  바꾸려는 함수가 고객에게 API로 제공된 것이라면 실제로 쓰이거나 하는지조차 모를 수도 있다.

- 코드 소유권이 나누어져 있으면 리팩토링에 방해가 된다. 클라이언트에게 영향을 주지 않고서는 원하는 형태로 변경할 수 없기 때문이다.  
  그렇다고 리팩토링을 못하는건 아니다. 예를 들어 함수명을 변경할 때는 **함수 이름 바꾸기**를 적용하는 한편, 기존 함수도 그대로 유지하되  
  함수 본문에서 새 함수를 호출하도록 수정한다. 인터페이스는 복잡해지지만 클라이언트에 영향을 주지 않으려면 어쩔 수 없다.

<hr/>
