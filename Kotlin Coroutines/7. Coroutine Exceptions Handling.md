# Coroutine Exceptions Handling

## Exception Propagation

- Coroutine builder는 크게 두 가지로 나뉜다. `launch()`와 `actor()` 처럼 예외들을 자동으로 전파(propatate)하는 것과,  
  `async()`와 `produce()` 처럼 사용자에게 노출(expose)하는 것이 있다. 이들 builder들은 다른 coroutine의 자식 coroutine이 아니라  
  root coroutine을 만드는데, `launch()`와 `actor()`는 예외를 Java의 `Thread.uncaughtExceptionHandler`처럼 Uncaught exception 처럼  
  취급하고, `async()`와 `produce()`는 사용자들로 하여금 최종적으로 예외를 consume하도록 한다.

- `GlobalScope`에서 root coroutine을 만드는 간단한 예제를 통해 확인해보자.

```kt
@OptIn(DelicateCoroutinesApi::class)
fun main() = runBlocking {
	val job = GlobalScope.launch {
		println("Throwing exception from launch")
		throw IndexOutOfBoundException()
	}
	job.join()
	println("Joined failed job")
	val deffered = GlobalScope.async {
		println("Throwing exception from async")
		throw ArithmeticException()
	}
	try {
		deferred.await()
		println("Unreached")
	} catch(e: ArithmeticException) {
		println("Caught ArihmeticException")
	}
}

/*
Throwing exception from launch
Exception in thread "DefaultDispatcher-worker-2 @coroutine#2" java.lang.IndexOutOfBoundsException
Joined failed job
Throwing exception from async
Caught ArithmeticException
*/
```

---
