# Coroutine Exceptions Handling

## Exception Propagation

- Coroutine builder는 크게 두 가지로 나뉜다. `launch()`와 `actor()` 처럼 예외들을 자동으로 전파(propatate)하는 것과,  
  `async()`와 `produce()` 처럼 사용자에게 노출(expose)하는 것이 있다. 이들 builder들은 다른 coroutine의 자식 coroutine이 아니라  
  root coroutine을 만드는데, `launch()`와 `actor()`는 예외를 Java의 `Thread.uncaughtExceptionHandler`처럼 Uncaught exception 처럼  
  취급하고, `async()`와 `produce()`는 사용자들로 하여금 최종적으로 예외를 consume하도록 한다.

- `GlobalScope`에서 root coroutine을 만드는 간단한 예제를 통해 확인해보자.

```kt
@OptIn(DelicateCoroutinesApi::class)
fun main() = runBlocking {
	val job = GlobalScope.launch {
		println("Throwing exception from launch")
		throw IndexOutOfBoundException()
	}
	job.join()
	println("Joined failed job")
	val deffered = GlobalScope.async {
		println("Throwing exception from async")
		throw ArithmeticException()
	}
	try {
		deferred.await()
		println("Unreached")
	} catch(e: ArithmeticException) {
		println("Caught ArihmeticException")
	}
}

/*
Throwing exception from launch
Exception in thread "DefaultDispatcher-worker-2 @coroutine#2" java.lang.IndexOutOfBoundsException
Joined failed job
Throwing exception from async
Caught ArithmeticException
*/
```

---

## CoroutineExceptionHandler

- Uncaught exception은 기본적으로 콘솔에 예외 정보를 출력하고 마는데, 이러한 기본적인 동작을 customize할 수 있다.  
  Root coroutine의 context element인 `CoroutineExceptionHandler`은 root coroutine과 해당 root coroutine의  
  자식 coroutine들에 대한 `catch { .. }` block처럼 사용될 수 있다. `Thread.uncaughtExceptionHandler`와 비슷하다.  
  `CoroutineExceptionHandler`에 도달했다는 것은 이미 해당 예외를 발생시킨 coroutine이 종료되었음을 의미하기 때문에  
  `CoroutineExceptionHandler` 내에서는 exception recovery가 불가하다. 이 `CoroutineExceptionHandler`는 보통  
  exception을 logging하고, 특정 에러 메시지를 보내고, 애플리케이션을 종료하거나 재시작하는 등에 사용된다.

- `CoroutineExceptionHandler`는 오로지 uncaught exception들에 대해서만 호출된다. 즉, 어떠한 방식으로든 handling되지 않은  
  예외들에 의해서만 호출된다는 것이다. 자식 coroutine들은 예외가 발생하면 parent로 delegate하고, parent는 또 그의 parent로  
  delegate하고, 이렇게 root coroutine에게까지 위임하게 된다. 그러면 child coroutine scope 내에 있는 `CoroutineExceptionHandler`는  
  아무런 일도 하지 못하게 된다.(의미가 없다.) 추가적으로 `async()` builder는 모든 예외들을 catch하고 이를 `Deffered`에 담아 반환하기에  
  여기에서도 `CoroutineExceptionHandler`의 사용은 무의미하다.

```kt
val handler = CoroutineExceptionHandler { _, exception ->
	println("CoroutineExceptionHandler got $exception")
}

val job = GlobalScope.launch(handler) {
	throw AssertionError()
}

val deffered = GlobalScope.async(handler) {
	throw ArithmeticException()
}

joinAll(job, deferred)

/*
CoroutineExceptionHandler got java.lang.AssertionError
*/
```

- 위 코드로 `async()` builder 내에서 throw된 `ArithmeticException`은 `CoroutineExceptionHandler`에 의해 처리되지 않음을 볼 수 있다.

---
