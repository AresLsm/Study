# 람다 식과 멤버 참조

## 람다 소개: 코드 블록을 함수 인자로 넘기기

- _"이벤트가 발생하면 이 핸들러를 실행하자"_ 또는 _"데이터 구조의 모든 원소에 이 연산을 적용하자"_ 와 같은  
  생각을 코드로 표현하기 위해 일련의 동작을 변수에 저장하거나 다른 함수에 넘겨야 하는 경우가 자주 있다.  
  예전에 Java에서는 무명 내부 클래스를 사용해 이런 목적을 달성했다. 무명 내부 클래스를 사용하면 코드를  
  함수에 넘기거나 변수에 저장할 수 있기는 하지만, 상당히 번거롭다.

- 이와 달리 함수형 프로그래밍에서는 함수를 값처럼 다루는 접근 방법을 택함으로써 이 문제를 해결했다.  
  클래스를 선언하고, 그 클래스의 인스턴스를 함수에 넘기는 대신 함수형 언어에서는 함수를 직접  
  다른 함수에 전달할 수 있다. 람다 식을 사용하면 코드가 더욱 간결해진다. 람다 식을 사용하면 함수를  
  선언할 필요가 없고, 코드 블록을 함수의 인자로 전달할 수 있다.

- 예제를 하나 보자. 버튼 클릭에 따른 동작을 정의하고 싶다. 그런 경우 클릭 이벤트를 처리하는 리스너를 추가한다.  
  버튼 클릭 리스너는 `onClick()` 메소드가 들어있는 `OnClickListener`를 구현해야 한다.

```java
button.setOnClickListener(new OnClickListener() {
    @Override public void onClick(View view) {
	//..
    }
});
```

- 위 코드는 Java 방식이다. 무명 내부 클래스를 선언해야 하기 때문에 코드가 번잡스러워졌다. 이와 비슷한 작업을  
  많이 수행해야 하는 경우, 그런 번잡함은 난잡함으로 변해 개발자를 괴롭힌다. 클릭 시 벌어질 동작을 간단히  
  기술할 수 있는 표기법이 있다면 이런 불필요한 코드를 제거할 수 있을 것이다. 코틀린에서는 Java8과 마찬가지로  
  람다를 쓸 수 있다.

```kt
button.setOnClickListener { /* 클릭 시 수행할 동작 */ }
```

- 이 코틀린 코드는 앞서 본 Java 무명 클래스와 같은 역할을 하지만, 훨씬 더 간결하고 읽기 쉽다.  
  이 예제는 람다를 메소드가 하나뿐인 무명 객체 대신 사용할 수 있다는 사실을 보여준다.

<hr/>

## 람다와 컬렉션

- 코드에서 중복을 제거하는 것은 프로그래밍 스타일을 개선하는 중요한 방법 중 하나다.  
  컬렉션을 다룰 때 수행하는 대부분의 작업은 몇 가지 일반적인 패턴에 속한다. 따라서 그런 패턴은  
  라이브러리 내에 있어야 한다. 하지만 람다가 없다면 컬렉션을 편리하게 처리할 수 있는 좋은 라이브러리를  
  제공하기 어렵다. 그런 이유로 Java8 이전에는 Java에서 쓰기 편한 컬렉션 라이브러리가 적었으며, 그에  
  따라 Java 개발자들은 필요한 컬렉션 기능을 직접 작성하곤 했다.

- 사람의 이름과 나이를 저장하는 `Person` 클래스를 사용해보자.

```kt
data class Person(val name: String, val age: Int)
```

- `Person`들로 이뤄진 리스트가 있고, 그중에 가장 나이가 많은 사람을 찾고 싶다. 람다를 사용해본 경험이  
  없는 개발자라면 루프를 써서 직접 검색을 구현했을 것이다.

```kt
fun findTheOldest(people: List<Person>) {
    val maxAge = 0
    var theOldest: Person? = null
    for(person in people) {
	if(person.age > maxAge) {
	    maxAge = person.age
	    theOldest = person
	}
    }
    println(theOldest)
}
```

- 이 루프는 작성하기 쉽지만, 상당히 많은 코드가 들어있기 때문에 작성하다 실수를 저지르기도 쉽다.  
  예를 들어, 비교 연산자를 잘못 사용하면 최대값 대신 최소값을 찾게 된다.

- 코틀린에서는 더 좋은 방법이 있다. 라이브러리 함수를 쓰는 것이다.

```kt
val people = listOf(Person("Alice", 29), Person("Bob", 31))
println(people.maxBy { it.age })
```

- 모든 컬렉션에 대해 `maxBy()` 함수를 호출할 수 있다. `maxBy()`는 가장 큰 원소를 찾기 위해 비교에 사용할  
  값을 돌려주는 함수를 인자로 받는다. `{ it.age }`는 바로 비교에 사용할 값을 돌려주는 함수다. 이 코드는 컬렉션의  
  원소를 인자로 받아서 비교에 사용할 값을 반환한다. 이 예시에서는 컬렉션의 원소가 `Person` 객체였으므로 이 함수가  
  반환하는 값은 `Person` 객체의 age 필드에 저장된 나이 정보다.

- 이런 식으로 단지 함수나 프로퍼티를 반환하는 역할을 수행하는 람다는 멤버 참조로 대치할 수 있다.

```kt
people.maxBy(Person::age)
```

<hr/>

## 람다 식의 문법

- 람다는 값처럼 여기저기 전달할 수 있는 동작의 모음이다. 람다를 따로 선언해서 변수에 저장할 수도 있다.  
  하지만 함수에 인자로 넘기면서 바로 람다를 정의하는 경우가 대부분이다.

- 코틀린 람다식은 항상 중괄호(`{}`)로 둘러싸여 있다. 인자 목록 주변에 괄호 또한 없다.  
  화살표(`->`)가 인자 목록과 람다의 본문을 구별해준다.

- 람다 식을 변수에 저장할 수도 있다. 람다가 저장된 변수를 다른 일반 함수와 마찬가지로 다룰 수 있다.  
  (변수명 뒤에 괄호를 놓고, 그 안에 필요한 인잘르 넣어 람다를 호출할 수 있다.)

```kt
val sum = { x: Int, y: Int -> x + y }
println(sum(1, 2)) // 3
```

- 원한다면 람다식을 직접 호출할 수도 있다.

```kt
{ println(42) }()
// 42
```

- 하지만 이와 같은 구문은 읽기 어렵고, 그다지 쓸모도 없다. 굳이 람다를 만들자마자 바로 호출하느니, 람다 본문을  
  직접 실행하는 편이 낫다. 이렇게 코드의 일부분을 블록으로 둘러싸 실행할 필요가 있다면 run을 사용한다.  
  run은 인자로 받은 람다를 실행해주는 라이브러리 함수다.

```kt
run { println(42) }
// 42
```

- 실행 시점에 코틀린 람다 호출에는 아무런 부가 비용이 들지 않으며, 프로그램의 기본 구성 요소와 비슷한 성능을 낸다.  
  사람 목록에서 가장 연장자를 찾는 코드를 다시 보자.

```kt
val people = listOf(Person("Alice", 29), Person("Bob", 31))
println(people.maxBy { it.age })
```

- 위 코드에서 코틀린이 코트를 줄여 쓸 수 있게 제공했던 기능을 제거하고, 정식으로 람다를 작성하면 아래와 같다.

```kt
println(people.maxBy({ p: Person -> p.age })
```

- 여기서 어떤 일이 벌어지고 있는지 더 명확히 알 수 있다. 중괄호 안에 있는 코드는 람다 식이고, 그 람다식을  
  `maxBy()`에 넘긴다. 람다 식은 `Person` 타입의 값을 인자로 받아 인자의 age를 반환한다.

- 하지만 이 코드는 번잡하다. 우선 구분자가 너무 많이 쓰여서 가독성이 떨어진다. 그리고 컴파일러가 문맥으로부터  
  유추할 수 있는 인자 타입을 굳이 적을 필요는 없다. 마지막으로 인자가 단 하나뿐인 경우, 굳이 인자에 이름을  
  붙이지 않아도 된다.

- 이런 개선을 적용해보자. 먼저 중괄호부터 시작해보자. 코틀린에는 함수 호출 시 맨 뒤에 있는 인자가  
  람다 식이라면, 그 람다를 괄호 밖으로 빼낼 수 있다는 문법 관습이 있다. 이 예시에서는 람다가 유일한  
  인자이므로 마지막 인자이기도 하다.

```kt
people.maxBy() { p: Person -> p.age }
```

- 이 코드처럼 람다가 어떤 함수의 유일한 인자이고, 괄호 뒤에 람다를 썼다면 호출 시 빈 괄호를 없애도 된다.

```kt
people.maxBy { p: Person -> p.age }
```

- 이 세가지 형태는 모두 같은 뜻이지만, 가장 마지막 문장이 읽기 제일 쉽다. 람다가 함수의 유일한 인자라면 분명  
  괄호 없이 람다를 바로 쓰기를 원할 것이다. 인자가 여럿 있는 경우에는 람다를 밖으로 빼낼 수도 있고, 람다를 괄호 안에  
  유지해서 함수의 인자임을 분명하게 할 수도 있다. 두 방식 모두 정당하다. 둘 이상의 람다를 인자로 받는 함수라고 해도  
  인자 목록의 맨 마지막 람다만 밖으로 뺄 수 있다. 따라서 그런 경우에는 괄호를 사용하는 일반적인 함수 호출 구문을  
  사용하는 편이 낫다.

- 이 세 가지 방식을 더 복잡한 함수 호출에 적용한 모습을 보기 위해 이전에 봤던 `joinToString()` 메소드를 보자.  
  코틀린 표준 라이브러리에도 `joinToString()`이라는 함수가 있지만, 표준 라이브러리의 `joinToString()`은  
  맨 마지막 인자로 함수를 받는다는 차이가 있다. 리스트의 원소를 `toString()`이 아닌 다른 방식을 통해 문자열로  
  변환하고 싶은 경우에 이 인자를 활용한다.

```kt
val people = listOf(Person("Alice", 29), Person("Bob", 31))
val names = people.joinToString(
    separator = " ",
    transform = { p: Person -> p.name })
println(name)
// Alice Bob
```

- 이 함수 호출에서 함수를 괄호 밖으로 빼낸 모습은 아래와 같다.

```kt
val names = people.joinToString(" ") { p: Person -> p.name }
```

- 아래처럼 파라미터 타입을 생략해 더 간단히 할 수 있다.

```kt
val names = people.joinToString(" ") { p -> p.name }
```

- 로컬 변수처럼 컴파일러는 람다 파라미터의 타입 또한 추론해낼 수 있다. 따라서 파라미터 타입을 따로 명시할 필요가 없다.  
  이전에 본 `maxBy()`의 경우, 파라미터의 타입은 항상 컬렉션 원소의 타입과 같다. 컴파일러는 `Person` 타입의 객체가  
  들어 있는 컬렉션에 대해 `maxBy()`를 호출한다는 사실을 알고 있으므로 람다의 파라미터도 `Person`이라는 사실을  
  이해할 수 있다.

> - 컴파일러가 람다 파라미터의 타입을 추론하지 못하는 경우도 있다.

- 파라미터 중 일부의 타입은 지정하고 나머지 파라미터는 타입을 지정하지 않고 이름만 남겨둬도 된다.  
  컴파일러가 파라미터 타입 중 일부를 추론하지 못하거나, 타입 정보가 코드를 읽을 때 도움이 된다면  
  그렇게 일부 타입만 표시하면 편하다.

- 마지막으로 람다의 파라미터명을 디폴트 이름인 it으로 바꾸면 람다식을 더 간단히 만들 수 있다.  
  람다의 파라미터가 하나뿐이고, 그 타입을 컴파일러가 추론할 수 있을 때 it을 쓸 수 있다.

```kt
val names = people.joinToString(" ") { it.name }
```

- 람다 파라미터명을 따로 지정하지 않은 경우에만 it이라는 이름이 자동으로 만들어진다.

> - it을 사용하는 관습은 코드를 아주 간단하게 만들어주지만, 남용해서는 안된다.  
>   특히 람다 안에 또다른 람다가 중첩되는 경우에는 it보다는 각 람다의 파라미터를 명시하는 게 낫다.  
>   파라미터를 명시하지 않으면 각각의 it이 가리키는 파라미터가 어떤 람다에 속했는지 파악하기  
>   어려울 수 있다. 문맥에서 람다 파라미터의 의미나 파라미터 타입을 쉽게 알 수 없는 경우에도  
>   파라미터를 명시적으로 선언하면 도움이 된다.

- 람다를 변수에 저장할 때는 파라미터의 타입을 추론할 문맥이 존재하지 않는다.  
  따라서 반드시 파라미터 타입을 명시해야 한다.

```kt
val getAge = { p: Person -> p.age }
people.maxBy(getAge)
```

- 지금까지는 한 문장(식 또는 명령)으로만 이뤄진 작은 람다만을 봤다.  
  본문이 여러 줄로 이뤄진 경우, 본문의 맨 마지막에 있는 식이 람다의 결과값이 된다.

```kt
val sum = { x: Int, y: Int ->
    println("Computing the sum of $x and $y")
    x + y
}

println(sum(1, 2))
// Computing the sum of 1 and 2
// 3
```

<hr/>
