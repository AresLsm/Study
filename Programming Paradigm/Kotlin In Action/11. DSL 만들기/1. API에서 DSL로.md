# API에서 DSL로

- DSL에 대해 보기 전에, 우리가 해결하려 하는 문제에 대해 더 자세히 알아보자. 궁극적인 목표는 코드의 가독성과 유지보수성을  
  가장 좋게 유지하는 것이다. 그런 목표를 달성하려면 개별 클래스에 집중하는 것만으로는 충분하지 않다. 클래스에 있는 코드 중  
  대부분은 다른 클래스와 상호작용한다. 따라서 그런 상호작용이 일어나는 연결 지점(interface)을 살펴봐야 한다.  
  즉, 클래스의 API를 살펴봐야 한다는 것이다.

- 라이브러리를 만드는 사람들에게만 API를 훌륭하게 만들 책임이 있는 것이 아니라는 사실이 중요하다. 사실 모든 개발자는 API를  
  훌륭하게 만들기 위해 노력해야 한다. 라이브러리가 외부 사용자에게 프로그래밍 API를 지원하는 것처럼 애플리케이션 안의 모든  
  클래스는 다른 클래스에게 자신과 상호작용할 수 있는 가능성을 제공한다. 이런 상호작용을 이해하기 쉽고 명확하게 표현할 수 있어야  
  프로젝트를 쉽게 계속 유지 보수할 수 있다.

- 지금까지 이 책에서 클래스를 위한 API를 깔끔하게 작성할 수 있게 도와주는 여러 코틀린 특성을 살펴보았다.  
  그렇다면 _API가 깔끔하다_ 는 말은 말은 어떤 뜻일까? 이 말에는 아래의 두 가지 뜻이 있다.

  - 코드를 읽는 독자들이 어떤 일이 벌어질지 명확히 이해할 수 있어야 한다. 이름과 개념을 잘 선택하면 이런 목적을 달성할 수 있다.  
    어떤 언어를 사용하든 이름을 잘 붙이고 적절한 개념을 사용하는 것은 매우 중요하다.

  - 코드가 간결해야 한다. 불필요한 구문이나 번잡한 준비 코드가 가능한 한 적어야 한다.  
    깔끔한 API는 언어에 내장된 기능과 거의 구분할 수 없다.

- 아래 표는 코틀린이 _간결한 구문_ 을 어떻게 제공하는지의 예시를 담은 것이다.

| 일반 구문                        | 간결한 구문                             | 사용한 언어 특성               |
| :------------------------------- | --------------------------------------- | ------------------------------ |
| `StringUtil.capitalize(s)`       | `s.capitalize()`                        | 확장 함수                      |
| `l.to("one")`                    | `l to "one"`                            | 중위 호출                      |
| `set.add(2)`                     | `set += 2`                              | 연산자 오버로딩                |
| `map.get("key")`                 | `map["key"]`                            | `get()` 메소드에 대한 관례     |
| `file.use((f -> f.read()))`      | `file.use { it.read() }`                | 람다를 괄호 밖으로 빼내는 관례 |
| `sb.append("a"); sb.append("b")` | `with(sb) { append("a"); append("b") }` | 수신 객체 지정 람다            |

- 여기서는 깔끔한 API에서 한걸음 더 나아가 DSL 구축을 도와주는 코틀린 기능을 살펴본다.  
  코틀린 DSL은 간결한 구문을 제공하는 기능과 그런 구문을 확장해 여러 메소드의 호출을 조합함으로써 구조를 만들어내는 기능에 의존한다.  
  그 결과로 DSL은 메소드 호출만을 제공하는 API에 비해 더 표현력이 풍부하고 사용하기 편해진다.

- 코틀린 언어의 다른 특성과 마찬가지로, 코틀린 DSL도 온전히 컴파일 시점에 타입이 정해진다. 따라서 컴파일 시점 오류 감지, IDE 지원 등 모든  
  정적 타입 지정 언어의 장점을 코틀린 DSL을 사용할 때도 누릴 수 있다.

- 예시로 코틀린 DSL이 할 수 있는 일을 몇 가지 살펴보자.  
  아래 식은 시간을 되돌려서 하루 전 날을 반환한다.

```kt
val yesterday = 1.days.ago
```

- 아래 함수는 HTML Table을 생성한다.

```kt
fun createSimpleTable = createHTML().
	table {
		tr {
			td { +"cell" }
		}
	}
```

- 이 장에서는 위와 같은 예제들을 어떻게 구현하는지 살펴본다.  
  구현 부분을 보기 전에, 먼저 DSL이 무엇인지부터 알아보자.

---

## DSL: Domain Specific Language

- DSL이라는 개념은 프로그래밍 언어라는 개념과 거의 마찬가지로 오래된 개념이다. 우리는 컴퓨터가 발명된 초기부터 컴퓨터로 풀 수 있는 모든 문제를 충분히  
  풀 수 있는 기능을 제공하는 **범용 프로그래밍 언어(general-purpose programming language)** 와 특정 과업 또는 영역에 초점을 맞추고 그  
  영역에 필요하지 않은 기능을 없앤 **영역 특화 언어**를 구분해왔다.

- 일반 사람들에게 가장 익숙한 DSL로는 SQL과 정규식이 있다. 이 두 언어는 데이터베이스 조작과 문자열 조작이라는 특정 작업에 가장 적합하다.  
  하지만 전체 애플리케이션을 정규식이나 SQL로 작성하는 경우는 없다.

- 이런 DSL이 스스로 제공하는 기능을 제한함으로써 오히려 더 효율적으로 자신의 목표를 달성할 수 있다는 점을 생각해보자.  
  SQL문을 실행할 필요가 있는 경우, 클래스나 함수를 선언하는 것부터 시작할 필요가 없다. 대신 모든 SQL문장은 첫 키워드가 수행하려는  
  연산의 종류를 지정하고, 각 연산은 처리해야 할 작업에 맞춰 각각 서로 다른 문법과 키워드를 사용한다. 정규식 언어의 경우 문법은 훨씬 더 단순하다.  
  정규식 프로그램은 압축적인 기호 문법을 사용해 텍스트가 어떻게 달라질 수 있는지를 지정함으로써 대상 텍스트를 직접 기술한다.  
  이런 압축적인 문법을 사용함으로써 DSL은 범용 언어를 사용하는 경우보다 특정 영역에 대한 연산을 더 간결하게 기술할 수 있다.

- 그리고 DSL이 범용 프로그래밍 언어와 달리 더 **선언적(declarative)** 이라는 점이 중요하다. 범용 프로그래밍 언어는 보통  
  **명령적(imperative)** 이다. 명령적 언어는 어떤 연산을 완수하기 위해 필요한 각 단계를 순서대로 기술하는 반면, 선언적 언어는 원하는  
  결과를 기술하기만 하고 그 결과를 달성하기 위해 필요한 세부 실행은 언어를 해석하는 엔진에게 맡긴다. 실행 엔진이 결과를 얻는 과정을 전체적으로  
  한꺼번에 최적화하기 때문에 선언적 언어가 더 효율적인 경우가 자주 있다. 반면 명령적 접근법에서는 각 연산에 대한 구현을 독립적으로 최적화해야 한다.

- 하지만 DSL에도 단점은 있다. 그 단점은 바로 DSL을 범용 언어로 만든 host application과 함께 조합하기가 어렵다는 점이다.  
  DSL은 자체 문법이 있기에 다른 언어의 프로그램 안에 직접 포함시킬 수가 없다. 따라서 DSL로 작성한 프로그램을 다른 언어에서 호출하려면  
  DSL 프로그램을 별도의 파일이나 문자열 리터럴로 작성해야 한다. 하지만 이런식으로 DSL을 저장하면 host program과 DSL의 상호작용을  
  컴파일 시점에 제대로 검증하거나, DSL 프로그램을 디버깅하거나, DSL 코드 작성을 돕는 IDE 기능을 제공하기 어려워진다는 문제가 있다.  
  또한 DSL과 host 언어의 문법이 서로 다르므로 두 언어를 함께 배워야 하고, 코드를 읽기가 어려워지는 경우도 있다.

- 이러한 문제들을 해결하면서 DSL의 다른 이점은 살리는 방법으로 **Internal DSL** 이라는 개념이 점점 유명해지고 있다.

---
