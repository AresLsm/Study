# 기본적인 리팩토링(2)

<h2>매개변수 객체 만들기</h2>

```js
// 리팩토링 적용 전
function amountInvoiced(startDate, endDate) {
  /* ... */
}
function amountReceived(startDate, endDate) {
  /* ... */
}
function amountOverdue(startDate, endDate) {
  /* ... */
}

// 리팩토링 적용 후
function amountInvoiced(dateRange) {
  /* ... */
}
function amountReceived(dateRange) {
  /* ... */
}
function amountOverdue(dateRange) {
  /* ... */
}
```

<h3>배경</h3>

- 데이터 항목 여러 개가 이 함수에서 저 함수로 함께 몰려다니는 경우는 자주  
  볼 수 있다. 이런 경우, 데이터 무리를 발견하면 하나의 데이터 구조로  
  모아주자.

- 데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해진다는  
  이점을 얻는다. 게다가 함수가 이 데이터 구조를 받게 하면 매개변수의  
  수가 줄어든다. 같은 데이터 구조를 사용하는 모든 함수가 원소를  
  참조할 때 항상 똑같은 이름을 사용하기에 일관성도 높여준다.

- 하지만 이 리팩토링의 진정한 힘은 **코드를 더 근본적으로 바꿔준다**는 데 있다.  
  이런 데이터 구조를 새로 발견하면, 이 데이터 구조를 활용하는 형태로 프로그램을  
  재구성할 수 있다. 데이터 구조에 담길 데이터에 공통으로 적용되는 동작을  
  추출해서 함수로 만드는 것이다. 이 과정에서 새로 만든 데이터 구조가 문제 영역을  
  훨씬 간결하게 표현하는 새로운 추상 개념으로 격상되면서, 코드의 개념적인 그림을  
  다시 그릴 수도 있다. 그러면 놀라울 정도로 강력한 효과를 낸다.  
  하지만 이 모든것의 시작은 매개변수 객체 만들기부터다.

<h3>절차</h3>

- (1) 적당한 데이터 구조가 아직 마련되어 있지 않다면 새로 만든다.

- (2) 테스트한다.

- (3) 함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가한다.

- (4) 테스트한다.

- (5) 함수 호출 시 새로운 데이터 구조 인스턴스를 넘기도록 수정한다.  
  하나씩 수정할 때마다 테스트한다.

- (6) 기존 매개변수를 사용하던 코드를 새 데이터 구조의 원소를 사용하도록 바꾼다.

- (7) 다 바꿨다면 기존 매개변수를 제거하고, 테스트한다.

- 이 리팩토링은 새로 생성한 객체로 동작까지 옮기는 더 큰 작업의  
  첫 단계로 수행될 때가 많기 때문에 JS의 객체가 아닌 클래스로  
  데이터 구조를 만들도록 하자.

- 또한 새로 생긴 데이터 구조는 값 객체로 만들 가능성이 높기 때문에  
  getter만 제공하자.(setter는 제공하지 않아도 된다).  
  물론 값 객체가 아니라면 필요한 메소드를 제공해야 한다.

<hr/>

<h2>여러 함수를 클래스로 묶기</h2>

```js
// 리팩토링 적용 전
function base(reading) {
  /* ... */
}
function taxableCharge(reading) {
  /* ... */
}
function calculateBaseCharge(reading) {
  /* ... */
}

// 리팩토링 적용 후
class Reading {
  base() {
    /* ... */
  }
  taxableCharge() {
    /* ... */
  }
  calculateBaseCharge() {
    /* ... */
  }
}
```

<h3>배경</h3>

- 클래스는 대다수의 프로그래밍 언어가 제공하는 기본적인 빌딩 블록이다.  
  클래스는 데이터와 함수를 하나의 공유 환경으로 묶은 후, 다른 프로그램 요소와  
  어우러질 수 있도록 그중 일부를 외부에 제공한다. 클래스는 객체 지향 언어의  
  기본인 동시에 다른 패러다임 언어에도 유용하다.

- 저자는 흔히 함수 호출 시 인자로 전달되는 공통 데이터를 중심으로 긴밀하게 엮여  
  작동하는 함수 무리를 발견하면, 클래스 하나로 묶는다. 클래스로 묶는다면  
  이 함수들이 공유하는 공통 환경을 더 명확하게 표현할 수 있고, 각 함수에 전달되는  
  인수를 줄여서 객체 안에서의 함수 호출을 간결하게 만들 수 있다. 또한 이런 객체를  
  시스템의 다른 부분에 전달하기 위한 참조를 제공할 수 있다.

- 이 리팩토링은 이미 만들어진 함수들을 재구성할 때는 물론, 새로 만든 클래스와  
  관련하여 놓친 연산을 찾아서 새로운 클래스의 메소드로 뽑아내는 데도 좋다.

- 함수를 한데 묶는 또다른 방법으로는 **여러 함수를 변환 함수로 묶기**가 있다.  
  어느 방식으로 진행할지는 프로그램 문맥을 넓게 살펴보고 정해야 한다.  
  클래스로 묶을 때의 두드러진 장점은 클라이언트가 객체의 핵심 데이터를 변경할 수 있고,  
  파생 객체들을 일관되게 관리할 수 있다는 것이다.

- 이런 함수들을 중첩 함수 형태로 묶어도 된다. 저자는 중첩 함수보다 클래스를 선호하는데,  
  중첩 함수는 테스트하기가 까다로울 수 있기 때문이다. 또한 한 울타리로 묶을 함수들 중  
  외부에 공개할 함수가 여러 개일때는 클래스를 사용할 수밖에 없다.

<h3>절차</h3>

- (1) 함수들이 공유하는 공통 데이터 레코드를 캡슐화한다.  
  공통 데이터가 레코드 구조로 묶여 있지 않다면 먼저 **매개변수 객체 만들기**를 적용해  
  데이터를 하나로 묶는 레코드를 만든다.

- (2) 공통 레코드를 사용하는 함수 각각을 새로운 클래스로 옮긴다.  
  공통 레코드의 멤버는 함수 호출문의 인수 목록에서 제거한다.

- (3) 데이터를 조작하는 로직들은 **함수로 추출**해서 새 클래스로 옮긴다.

<hr/>

<h2>여러 함수를 변환 함수로 묶기</h2>

```js
// 리팩토링 적용 전
function base(reading) {
  /* ... */
}
function taxableCharge(reading) {
  /* ... */
}

// 리팩토링 적용 후
function enrichReading(argReading) {
  const reading = _.cloneDeep(argReading);
  reading.baseCharge = base(reading);
  reading.taxableCharge = taxableCharge(reading);
  return reading;
}
```

<h3>배경</h3>

- 소프트웨어는 데이터를 입력받아 여러 가지 정보를 도출하곤 한다. 이렇게 도출된 정보는  
  여러 곳에서 사용될 수 있는데, 그러다 보면 이 정보가 사용되는 곳마다 같은 도출 로직이  
  반복되기도 한다. 저자는 이런 도출 작업들을 한데로 모아두길 좋아한다.  
  모아두면 검색과 갱신을 일관된 장소에서 처리할 수 있고 로직의 중복도 막을 수 있다.

- 이렇게 하기 위한 방법으로는 **변환 함수**를 사용할 수 있다. 변환 함수는 원본  
  데이터를 입력받아 필요한 정보를 모두 도출한 뒤, 각각을 출력 데이터의 필드에 넣어  
  반환한다. 이렇게 해두면 도출 과정을 검토할 일이 생겼을 때 변환 함수면 살펴보면 된다.

- 이 리팩토링 대신 **여러 함수를 클래스로 묶기** 로 처리해도 된다.  
  둘 중 어느 것을 적용해도 좋으며, 저자는 대체로 소프트웨어에 이미 반영된 프로그래밍  
  스타일을 따르는 것이다. 그런데 둘 사이에는 중요한 차이점이 하나 있다. **원본 데이터가**  
  **코드 안에서 갱신될 때는 클래스로 묶는 편이 훨씬 낫다.** 변환 함수로 묶으면 가공한 데이터를  
  새로운 레코드에 저장하므로, 원본 데이터가 수정되면 일관성이 깨질 수 있기 때문이다.

- 여러 함수를 한데 묶는 이유 하나는 **도출 로직이 중복되는 것을 방지하기 위해서다.**  
  이 로직을 함수로 추출하는 것만으로도 같은 효과를 볼 수 있지만, 데이터 구조와 이를 사용하는  
  함수가 근처에 있지 않으면 함수를 발견하기 어려울 때가 많다. 변환 함수 또는 클래스로 묶으면  
  이런 함수들을 쉽게 찾아낼 수 있다.

<h3>절차</h3>

- (1) 변환한 레코드를 입력받아서, 값을 그대로 반환하는 반환 함수를 만든다.  
  이 작업은 대체로 **깊은 복사**로 처리해야 한다. 변환 함수가 원본 레코드를 바꾸지 않는지  
  검사하는 테스트를 마련해두면 도움이 될 때가 많다.

- (2) 묶을 함수 중 함수 하나를 골라서 본문 코드를 변환 함수로 옮기고, 처리 결과를 레코드에  
  새로운 필드로 기록한다. 그런 다음 클라이언트 코드가 이 필드를 사용하도록 수정한다.

- (3) 테스트한다.

- (4) 나머지 관련 함수도 위 과정에 따라 처리한다.

<hr/>
