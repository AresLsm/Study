# Coroutines Basics

- *Coroutine*은 suspendable한 컴퓨팅 작업이다.  
  개념적으로는 다른 코드와 병렬적으로 특정 코드를 수행한다는 점에서 `Thread`와 유사하다.  
  하지만 Coroutine은 특정 Thread에 한정되지 않는다.  
  예를 들어, Thread A에서의 실행을 멈추고 Thread B에서 실행을 하도록 할 수 있다.

- Coroutine은 하나의 경량화된 Thread라고 볼 수도 있는데, 실제 thread의 동작 방식과  
  매우 다른 중요한 포인트들이 있다.

- Kotlin에서 Coroutine을 사용하기 위해서는 아래의 의존성을 추가해주면 된다.

```gradle
// Other codes..

dependencies {
    testImplementation(kotlin("test"))
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.5.0")
}
```

- 이제 아래의 코드를 작성해보자.

```kotlin
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking

fun main() = runBlocking { // this: CoroutineScope
    launch { // 새로운 Coroutine을 생성한다.
        delay(1000L) // 1초 동안 Blocking Delay
        println("World!") // Delay 후 수행
    }
    println("Hello") // Main Coroutine은 이전 것이 delay되도 수행된다.
}

/*
Output:
Hello
World!
*/
```

- 위 코드가 어떻게 작동하는지 살펴보자.
- 우선 `launch`는 *Coroutine Builder*이다. 이는 새로운 Coroutine을 나머지 코드와  
  병렬적으로 수행되도록 생성한다. 즉, launch 블록 내부의 코드는 나머지 코드의 수행 여부에 관계없이  
  병렬적으로 수행된다는 것이다.

- `delay`는 특별한 *Suspending Function*으로, Coroutine을 지정한 ms만큼 멈춘다.  
  Coroutine을 멈추는(suspend) 것은 기반이 되는 Thread를 Block시키지 않으며,  
  다른 Coroutine들이 동일한 Thread 상에서 작동하도록 해준다.

- `runBlocking`은 `launch`와 같이 또다른 *Coroutine Builder*인데, Coroutine이 아닌  
  `main()` 함수와 Coroutine을 사용하는 블록을 연결해주는 역할을 한다.

- 만약 위 코드에서 `runBlocking`을 없앤다면, `launch`가 작동할 때 에러가 발생한다.  
  이 이유는 `launch`가 단순히 `CoroutineScope`에서만 선언되어 있기 때문이다.  
  `CoroutineScope`은 Coroutine이 사용되는 범위(Scope)을 의미한다.

- `runBlocking`의 의미는 네이밍에서 느껴지듯이 이 코드를 실행하는 Thread(이 경우 Main Thread)가  
 `runBlocking` 내부의 Coroutine들이 작업을 마칠때까지 block된다는 것을 의미한다.  
 종종 `runBlocking`이 Application의 Top-Level에 사용되고, 하위 코드에서는 사용되지 않는 것을 볼 수 있다.  
 이는 Thread 자체가 매우 비용이 큰 리소스이며 이를 Blocking하는 것은 비효율적이기 때문이다.
<hr/>

<h3>Structured Concurrency</h3>

- Coroutine은 구조적 병렬(Structured Concurrenty)를 따르기에, 새로운 Coroutine들은 오직  
  CoroutineScope 내에서만 생성될 수 있다. 위에서 작성한 코드가 "World!"가 출력되기 전까지 끝나지 않고  
  기다리는 이유가 바로 그 예시인데, 이는 `runBlocking`이 CoroutineScope을 만들어서 내부의 Coroutine들이  
  작업을 마칠 때 까지 Thread가 기다리게 하기 때문이다.

- 실제 코드를 작성하다 보면 여러 개의 Coroutine들을 생성해야 한다.  
  구조적 병렬은 Coroutine들이 누수되거나 잃어버리지 않게끔 보장해준다.  
  외부 scope의 코드는 내부 scope의 Coroutine들이 작업이 끝나기 전까지 작업을 마칠 수 없다.

- 구조적 병렬은 코드 내의 에러가 제대로 보고되고 절대 누수되지 않음 또한 보장한다.

<hr/>
