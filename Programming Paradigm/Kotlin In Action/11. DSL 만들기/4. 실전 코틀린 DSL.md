# 실전 코틀린 DSL

## 중위 호출 연쇄: 테스트 프레임워크와 `should()`

- 깔끔한 구문은 Internal DSL의 핵심 특징 중 하나다. DSL을 깔끔하게 만들려면 코드에 쓰이는 기호의 수를 줄여야 한다.  
  대부분의 Internal DSL은 메소드 호출을 연쇄시키는 형태로 만들어지기 때문에 메소드 호출 시 발생하는 잡음을 줄여주는  
  기능이 있다면 큰 도움이 될 수 있다. 코틀린에서는 이전에 봤던 람다 호출을 간결하게 해주는 기능이나 중위 함수 호출이  
  메소드 호출에 따른 잡음을 줄여주는 기능이다.

- 이번에는 DSL에서 중위 호출을 어떻게 활용하는지 살펴보자. Kotlintest DSL에서 중위 호출을 어떻게 하는지 살펴보자.

```kt
s should startWith("kot")
```

- s에 들어있는 값이 "kot"로 시작하지 않으면 이 assertion은 실패한다. 이 코드는 거의 자연스러운 영어 문장처럼 읽힌다.  
  이런 목적을 달성하기 위해 `should()` 함수 선언 앞에 infix 변경자를 붙여야 한다.

```kt
infix fun <T> T.shouldBe(matcher: Matcher<T>) = matcher.test(this)
```

- `should()` 함수는 `Matcher`의 인스턴스를 요구한다. `Matcher`는 값에 대한 assertion을 표현하는 제네릭 인터페이스이다.  
  `startWith()`는 `Matcher`를 구현하며, 어떤 문자열이 주어진 문자열로 시작하는지 검사한다.

```kt
interface Matcher<T> {
	fun test(value: T)
}

class startWith(val prefix: String) : Matcher<String> {
	override fun test(value: String) {
		if(!value.startsWith(prefix)) {
			throw AssertionError("String $value does not start with $prefix")
		}
	}
}
```

- 평범한 프로그램이라면 `startWith` 클래스의 첫 글자를 대문자로 명명했어야 한다. 하지만 DSL에서는 그런 일반적인 명명 규칙을 벗어나야 할  
  때가 많다. 위 코드는 DSL에서 아주 쉽게 중위 호출을 적용할 수 있다는 사실을 보여주며, 중위 호출이 코드의 잡음을 효과적으로 줄여준다는  
  사실도 보았다. 약간 더 기교를 부리면 잡음을 더 많이 감소시킬 수 있다.

```kt
"kotlin" should start with "kot"
```

- 위 문장은 처음 코틀린 문장처럼 전혀 보이지 않는다. 이 문장이 어떻게 작동하는지 이해하려면 중위 호출을 일반 메소드 호출로 바꿔봐야 한다.

```kt
"kotlin".should(start).with("kot")
```

- 위 코드를 보면 `should()`와 `with()`라는 두 메소드를 연쇄적으로 중위 호출한다는 사실과 start가 `should()`의 인자라는 사실을 알 수 있다.  
  여기서 start는 싱글톤 객체 선언을 참조하며, `should()`와 `with()`는 중위 호출 구문으로 쓰인 함수다.

- `should()` 함수 중에는 start 객체를 파라미터 타입으로 사용하는 특별한 오버로딩 버전이 있다.  
  이 오버로딩한 `should()` 함수는 중간 wrapper 객체를 돌려주는데, 이 wrapper 객체 안에는 중위 호출 가능한 `with()` 메소드가 들어있다.

```kt
object start

infix fun String.should(x: start): StartWrapper = StartWrapper(this)

class StartWrapper(val value: String) {
	infix fun with(prefix: String) =
		if (!value.startsWith(prefix))
			throw AssertionError("String does not start with $prefix: $value")
		else
			Unit
}
```

- DSL이라는 맥락 밖에서는 object로 선언한 타입을 파라미터 타입으로 사용할 이유가 거의 없다. 싱글톤 객체에는 인스턴스가 단 하나밖에 없기 때문에  
  굳이 그 객체를 인자로 넘기지 않아도 직접 그 인스턴스에 접근할 수 있다. 하지만 여기서는 객체를 파라미터 타입으로 사용한 타당한 이유가 있다.  
  여기서 `start` 객체는 함수에 데이터를 넘기기 위해서가 아니라 DSL의 문법을 정의하기 위해 사용된다. `start`를 인자로 넘김으로써  
  `should()`를 오버로딩한 함수 중에서 적절한 함수를 선택할 수 있고, 그 함수를 호출한 결과로 `StartWrapper` 인스턴스를 받을 수 있다.  
  `StartWrapper` 클래스에는 assertion의 검사를 수행하기 위해 필요한 값을 인자로 받는 `with()`라는 멤버가 있다.

- Kotlintest 라이브러리는 다른 `Matcher`도 지원하며, 그 `Matcher`들은 모두 일반 영어 문장처럼 보이는 assertion을 구성한다.

```kt
"kotlin" should end with "in"
"kotlin" should have substring "otl"
```

- 이런 문장을 지원하기 위해 `should()`에는 `end`나 `have` 같은 싱글톤 객체 인스턴스를 취하는 오버로딩 버전이 더 존재한다.  
  이들은 싱글톤의 종류에 따라 각각 `EndWrapper`와 `HaveWrapper` 인스턴스를 반환한다.

- 이렇게 중위 호출과 object로 정의한 싱글톤 객체 인스턴스를 조합하면 DSL에 상당히 복잡한 문법을 도입할 수 있고, 그런 문법을 사용하면  
  DSL 구문을 깔끔하게 만들 수 있다.

---

## 원시 타입에 대한 확장 함수 정의: 날짜 처리

- 이전에 본 예제를 다시 보자.

```kt
val yesterday = 1.days.ago
val tomorrow = 1.days.fromNow
```

- Java8의 `java.time` API와 코틀린을 사용해 이 API를 구현하는 데는 단지 몇 줄의 코드로 충분하다.

```kt
val Int.days: Period
	get() = Period.ofDays(this)

val Period.ago: LocalDate
	get() = LocalDate.now() - this

val Period.fromNow: LocalDate
	get() = LocalDate.now() + this
```

- 여기서 days는 `Int` 타입의 확장 프로퍼티이다. 코틀린에서는 아무런 타입이 확장 함수의 수신 객체 타입이 될 수 있다.  
  따라서 편하기 원시 타입에 대한 확장 함수를 정의하고 원시 타입 상수에 대해 그 확장 함수를 호출할 수 있다.  
  days 프로퍼티는 `Period` 타입의 값을 반환한다. `Period`는 두 날짜 사이의 간격을 나타내는 JDK8 타입이다.

- 문장을 마무리 하는 ago를 지원하기 위해 다른 확장 프로퍼티를 더 정의해야 한다.  
  이번에는 `Period`에 대한 확장 함수가 필요하다. 그 프로퍼티의 타입은 `LocalDate`로 날짜를 표현한다. ago 프로퍼티의 구현에 사용한  
  `-` 연산은 코틀린이 제공하는 확장함수가 아니고, `LocalDate`의 `minus()`가 코틀린의 `-` 연산자 관례와 일치하기 때문에 가능한 것이다.  
  따라서 코틀린은 ago의 본문에 사용한 `-` 연산을 자동으로 `LocalDate`의 `minus()` 호출로 바꿔준다.

---
