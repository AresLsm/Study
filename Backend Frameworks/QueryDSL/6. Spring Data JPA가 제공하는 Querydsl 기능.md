# Spring Data JPA가 지원하는 Querydsl 기능

> 이 기능들은 제약이 커서 테이블이 많은 실무 환경에서 사용하기에는 부적절하다.  
> 그렇지만 어떤 기능이 제공되며, 왜 부족한지도 알아보자.

## 인터페이스 지원 - `QuerydslPredicateExecutor`

```java
public interface QuerydslPredicateExecutor<T> {
    Optional<T> findById(Predicate predicate);

    Iterable<T> findAll(Predicate predicate);

    long count(Predicate predicate);

    boolean exists(Predicate predicate);

    // more functionality omitted.
}
```

- 기존에 작성한 `MemberRepository`가 `QuerydslPredicateExecutor`를 상속하도록 해주자.

```kt
@Repository
interface MemberRepository : JpaRepository<Member, Long>, MemberRepositoryCustom, QuerydslPredicateExecutor<Member> {
    fun findByUsername(username: String): List<Member>
}
```

- 이제 이를 사용하는 코드를 보자.

```kt
@Test
fun querydslPredicateExecutorTest() {
    val result: Iterable<Member> = memberRepository.findAll(
        member.age.between(10, 40).and(member.username.eq("member3"))
    )
    //..
}
```

- Querydsl로 작성한 쿼리 메소드를 사용할 수 있다.

- 하지만 아래와 같은 한계점들이 있다.

  - JOIN이 불가능하다.(묵시적 JOIN은 가능하나, LEFT JOIN은 불가하다.)
  - 클라이언트가 Querydsl에 의존하게 된다. 즉, 서비스 레이어가 Querydsl이라는 Repository Layer의  
    구현 기술에 의존해야 한다.
  - 복잡한 실무 환경에 사용하기에는 한계가 명확하다.

<hr/>

## Querydsl Web 지원

- 공식 문서에 나와 있는 샘플 코드를 보자.

```java
@Controller
class UserController {

    @Autowired UserRepository userRepository;

    @RequestMapping(value = "/", method = RequestMethod.GET)
    String index(
	Model model,
	@QuerydslPredicate(root = User.class) Predicate predicate,
	Pageable pageable,
	@RequestParam MultiValueMap<String, String> parameters
    ) {
	model.addAttribute("users", userRepository.findAll(predicate, pageable));
	return "index";
    }
}
```

- 컨트롤러 메소드에 `@QuerydslPredicate`와 Root Entity를 함께 지정해주면 `Predicate`에  
  알맞게 파라미터 바인딩을 수행해준다. 예를 들어 `/?name=sangwoo&surname=ra`와 같은 파라미터가 오면  
  아래의 Querydsl의 `Predicate`로 변환된다.

```java
QUser.user.name.eq("sangwoo").and(QUser.user.suername.eq("ra"));
```

- 만약 위 기능을 조금 수정해 사용하고 싶다면 `UserRepository`가 `QuerydslBinderCustomizer<QUser>`를  
  상속하게끔 하고, `customize(QuerydslBindings, QUser)` 메소드를 재정의해야 한다.

- 이 방식의 한계점은 아래와 같다.
  - 단순한 조건만 사용할 수 있다.
  - 조건을 커스터마이징하기 쉽지 않다.(기능이 복잡하고, 명시적이지 않다.)
  - Controller Layer가 Querydsl에 의존한다.

<hr/>
