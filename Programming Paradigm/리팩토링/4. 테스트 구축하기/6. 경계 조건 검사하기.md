# 경게 조건 검사하기

- 지금까지 작성한 테스트는 모든 일이 순조롭고 사용자도 우리 의도대로 사용하는, 일명  
  _꽃길_ 상황에 집중했다. 그런데 이 범위를 벗어나는 경게 지점에서 문제가 생기면  
  어떤 일이 벌어지는지 확인하는 테스트도 함께 작성하면 좋다.

- 한 예시로, producers와 같은 컬렉션과 마주했을 때 그 컬렉션이 비어있을 때  
  어떤 일이 일어나는지 확인해보자.

```js
describe("no producers", () => {
  let noProducers;
  beforeEach(() => {
    const data = {
      name: "No producers",
      producers: [],
      demand: 30,
      price: 20,
    };
    noProducers = new Province(data);
  });
  it("shortfall", () => {
    expect(noProducers.shortfall).equal(30);
  });
  it("profit", () => {
    expect(noProducers.profit).equal(0);
  });
});
```

- 숫자형이라면 0일때를 검사해본다.

```js
describe("province", () => {
  //..

  it("zero demand", () => {
    asia.demand = 0;
    expect(asia.shortfall).equal(-25);
    expect(asia.profit).equal(0);
  });
});
```

- 음수도 넣어보면 좋다.

```js
describe("province", () => {
  //..

  it("negative demand", () => {
    asia.demand = -1;
    expect(asia.shortfall).equal(-26);
    expected(asia.profit).equal(-10);
  });
});
```

- 여기서 한 가지 의문점이 들 수 있다. 수요가 음수일 때 수익이 음수가 나온다는 것이  
  이 프로그램을 사용하는 고객 관점에서 말이 되는 소리일까? 수요의 최솟값은 0이어야 하지 않나?  
  그래서 수요 setter에 전달된 인수가 음수라면 에러를 던지거나 무조건 0으로 설정하는 식으로  
  정상적인 경우와 다르게 처리해야하지 않을까?

- 위 의문들은 예리한 지적이다. 이처럼 경계를 확인하는 테스트를 작성해보면 프로그램에서 이런  
  특이 상황들을 어떻게 처리하는게 좋을 지 생각해볼 수 있다.

> 문제가 생길 가능성이 있는 경계 조건을 생각해보고 그 부분을 집중적으로 테스트하자.

- 이 프로그램의 setter들은 의미상 숫자를 입력받아야만 하지만 UI로부터 문자열을 취하고 있다.  
  그러다보니 필드가 아예 비어있을 수 있고, 이때도 의도한 대로 잘 처리하는지 반드시 테스트해야 한다.

```js
describe("province", () => {
  //..

  it("empty string demand", () => {
    asia.demand = "";
    expect(asia.shortfall).NaN;
    expect(asia.profit).NaN;
  });
});
```

- 위와 같이 의식적으로 프로그램을 망가뜨리는 방법을 모색하는 것 자체가  
  생산성과 재미를 끌어올려준다.

- 아래 테스트를 보자.

```js
describe("string for producers", () => {
  it("", () => {
    const data = {
      name: "String producers",
      producers: "",
      demand: 30,
      price: 20,
    };
    const province = new Province(data);
    expect(province.shortfall).equal(0);
  });
});
```

- 위 테스트는 단순히 생산 부족분이 0이 아니라는 실패 메시지를 출력하는 대신,  
  아래와 같이 출력한다.

```
1) string for producers :
	TypeError: doc.producers.forEach is not a function
	at new Province
	at Context.<anonymous>
```

- Mocha는 이 경우를 실패 처리한다. 하지만 mocha와 달리 에러와 실패를 구분하는  
  테스트 프레임워크도 많다. _실패(failure)_ 란 검증 단계에서 실제 값이 예상 범위를  
  벗어났다는 뜻이다. _에러(Error)_ 는 성격이 다르다. 검증보다 앞선 과정(여기서는 설정 단계)에서  
  발생한 예외 상황을 말한다. 코드 작성자가 이 상황을 미처 예상하지 못한 것이고, 그래서 JS 개발자라면  
  지긋지긋하게 보는 오류 메시지인 "... is not a function"이 출력된 것이다.

- 프로그램은 이 상황에 어떻게 대응해야 할까? 에러 상황을 지금보다 더 잘 처리하도록 코드를  
  추가하는 방법도 있다. 더 의미 있는 오류 메시지를 출력할 수도 있고, 그냥 로그 메시지만 남기고  
  producers를 빈 배열로 설정할 수도 있다. 물론 지금 상태로 남겨둘 합당한 이유가 있을 수도 있다.  
  예를 들어 입력 객체를 신뢰할 수 있는 곳에서 만들어주는 경우가 여기에 속한다.  
  같은 코드베이스의 모듈 사이에 유효성 검사 코드가 너무 많으면 다른 곳에서 확인할 걸 중복으로  
  검증하여 오히려 문제가 될 수 있다. 반면, JSON으로 인코딩된 요청처럼 외부에서 들어온 입력 객체는  
  유효한지 확인해봐야 하므로 테스트를 작성한다. 어떤 경우든 경계 조건을 검사하는 테스트를 작성하다 보면  
  이런 고민들을 하게 된다.

- 리팩토링하기 전이라면 이런 테스트를 작성하지 말자. 리팩토링은 겉보기 동작에 영향을 주지 않아야 하며,  
  이런 오류는 겉보기 동작에 해당하지 않는다. 따라서 경계 조건에 대응하는 동작이 리팩토링 때문에  
  변하는지는 신경 쓸 필요 없다.

> 이런 오류로 인해 프로그램 내부에 잘못된 데이터가 흘러서 디버깅하기 어려운 문제가 발생한다면  
> **assertion 추가하기**를 적용해서 오류가 최대한 빨리 드러나게 하자. assertion도 일종의  
> 테스트로 볼 수 있으니 테스트 코드를 따로 작성할 필요는 없다.

- 그렇다면 테스트를 어느 수준까지 해야할까? 아무리 테스트해도 버그 없는 완벽한 프로그램을 만들 수는  
  없다는 말은 많다. 맞는 말이지만, 테스트가 프로그래밍 속도를 높여준다는 사실에는 변함이 없다.  
  테스트에도 *수확 체감 법칙*이 적용된다. 또, 테스트를 너무 많이 작성하다 보면 오히려  
  의욕이 떨어져 나중에는 하나도 작성하지 않게 될 위험도 있다. 따라서 **위험한 부분에 집중**하는게 좋다.  
  코드에서 처리 과정이 복잡한 부분을 찾아보자. 함수에서 오류가 생길만한 부분을 찾아보자.  
  테스트가 모든 버그를 걸러주지는 못할지라도, 안심하고 리팩토링할 수 있는 보호막은  
  되어준다. 그리고 리팩토링을 하면서 프로그램을 더욱 깊이 이해하게 되어 더 많은 버그를  
  찾게 된다.

> 어짜피 모든 버그를 잡아낼 수는 없다고 생각하여 테스트를 작성하지 않는다면, 대다수의 버그를  
> 잡을 수 있는 기회를 날리는 셈이다.

<hr/>
