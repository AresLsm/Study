# 프로세스 + 스레드 종합

## 스레드

- 스레드: CPU 스케줄러가 CPU에 전달하는 일의 단위.
- CPU가 처리하는 작업의 단위는 프로세스로부터 전달받은 스레드이다.

- **OS 입장에서의 작업 단위는 프로세스, CPU 입장에서의 작업 단위는 스레드이다.**

- 프로세스와 스레드의 차이

  - 프로세스끼리는 약하게 연결되어 있지만, 스레드끼리는 강하게 연결되어 있다.

- 멀티 태스크와 멑리 스레드의 차이

  - 멀티 태스크: OS가 CPU에게 작업을 줄 때 시간을 잘게 나눠 배분한다.
    - 여러 개의 프로세스로 구성
  - 멀티 스레드: 하나의 프로세스가 여러 개의 스레드로 구성된 것
    - 프로세스 내의 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄인다.
  - 멀티프로세싱: CPU를 여러 개 사용해 여러 개의 스레드를 동시에 처리

- CPU 멀티스레드

  - 한 번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용해 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법
  - 하드웨어적인 방법으로, 하나의 CPU에셔 여러 스레드들을 동시에 처리하는 병렬 처리 기법이다.  
    반면, 멀티 스레드는 OS가 소프트웨어적으로 프로세스를 작은 단위의 스레드들로 분할해 운영하는 기법이다.

- 멀티 태스킹의 낭비 요소

  - `fork()` syscall로 프로세스를 복사하면 코드 영역과 데이터 영역의 일부가 메모리에 중복 존재하게 된다.  
    또한 parent-child 관계이지만 서로 독립적인 프로세스이므로 이런 낭비 요소 제거가 불가하다.

- 멀티태스크 vs 멀티스레드

  - `fork()` syscall로 여러 개의 프로세스를 만들면 필요 없는 정적 영역이 여러 개 생성된다.
  - **멀티스레드는 코드, 파일 등의 자원을 공유** 함으로써 자원의 낭비를 막고 효율성을 향상시킨다.

- 멀티스레드의 장단점

  - 장점

    - 응답성 향상
    - 자원 공유
    - 효율성 향상
    - 다중 CPU 지원

  - 단점
    - 모든 스레드가 자원을 공유하기에 한 스레드에 문제가 생기면 전체 프로세스에 영향을 미치게 된다.

- 멀티스레드 모델

  - 커널 스레드: 커널이 직접 생성하고 관리하는 스레드
  - 사용자 스레드: 라이브러리에 의해 구현된 일반적인 스레드

- 프로그램: 저장장치에 저장되어 있는 **정적**인 상태(수동적)
- 프로세스: 실행을 위해 메모리에 올라온 **동적**인 상태(능동적)

### 프로세스 제어 블록(PCB, Process Control Block)

- OS가 해당 프로세스를 위해 관리하는 자료 구조

  - PID, Process State, Program counter 등..

- 프로그램이 프로세스가 된다는 것은 곧 **OS로부터 PCB를 얻는다는 것** 이다.  
  그리고 프로세스가 종료된다는 것은 해당 PCB가 폐기된다는 뜻이다.

### 프로세스의 상태

![picture 20](/images/OTHERS_TMP_1.png)

- new(생성): 프로세스가 메모리에 올라와 실행 준비를 마친 상태
  - PCB를 할당받으며, 생성된 프로세스는 바로 실행되지 않고 ready 상태로 가 자신의 순서를 기다린다.  
    이때 PCB도 함께 ready state로 옮겨진다.
- ready(준비): 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태
  - PCB는 ready queue에서 기다리며 CPU 스케쥴러에 의해 관리된다.
- running(실행): ready 상태였던 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태
  - Running 상태의 프로세스는 자신에게 주어진 time slice 동안만 작업을 할 수 있다.  
    그 시간을 다 사용하면 `timeout(PID)`가 발생해 다시 Ready state로 옮겨진다.
  - 시간 내에 작업이 완료되면 `exit(PID)`가 실행되어 프로세스가 정상 종료된다.
  - Running 상태에 있는 프로세스가 입출력을 요청하면 CPU는 입출력 관리자에게 입출력을 요청하고 `block(PID)`를 실행한다.  
    `block(PID)`는 입출력이 완료될 때까지 작업을 진행할 수 없게하기에 해당 프로세스는 ready state로 옮겨지고 CPU 스케쥴러는  
    새로운 프로세스를 Running 상태로 전환한다.
- waiting(대기): Running 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 가디리는 상태
  - Waiting state의 프로세스는 입출력 장치별로 마련된 큐에서 기다리다가 완료되면 interrupt가 발생하고, waiting 상태에 있는  
    여러 프로세스 중 해당 interrupt로 깨어낼 프로세스를 `wakeup(PID)`로 찾는다.
  - `wakeup(PID)`로 해당 프로세스의 PCB가 ready state로 이동한다.
- terminated(완료): 실행 상태의 프로세스가 주어진 시간 동안 작업을 마치면 진입하는 상태, PCB가 사라진 상태이다.
  - 코드, 사용했던 데이터 등을 메모리에서 삭제하고 PCB를 폐기한다.
  - 정상 종료는 `exit()`으로 처리하고, 오류나 다른 프로세스에 의해 비정상적으로 종료되는 강제 종료를 만나면 디버깅을 위해 종료 직전의  
    메모리 상태를 core dump를 통해 저장 장치로 옮긴다.
- 휴식: 프로세스가 작업을 일시적으로 쉬고 있는 상태, 종료 상태가 아니기에 원할 때 다시 시작할 수 있다.
- 보류: 프로세스가 메모리에서 잠시 쫓겨난 상태로, 아래와 같은 경우 보류 상태가 된다.
  - 메모리가 가득찬 경우
  - 프로그램의 오류가 발생한 경우
  - 바이러스 등과 같이 악의적인 공격을 하는 프로세스로 판단된 경우
  - 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없는 경우
  - 입출력을 기다리는 프로세스의 입출력이 계속 지연되는 경우
- dispatch: ready인 프로세스 중 하나를 골라 running으로 바꾸는 CPU 스케쥴러의 작업
- timeout: 프로세스가 자신에게 주어진 하나의 time slice 동안 작업을 끝나지 못하면 다시 ready 상태로 돌아가는 것

![picture 21](/images/OTHERS_TMP_2.png)
![picture 22](/images/OTHERS_TMP_3.png)

### 프로세스 구조

- 코드 영역

  - 프로그램의 본문이 기술된 곳으로 프로그래머가 작성한 코드가 탑재되고, 읽기 전용으로 처리된다.

- 데이터 영역

  - 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓은 것
  - 데이터는 가변적이기에 읽기, 쓰기 모두 가능하다.

- 스택 영역
  - OS가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳
  - OS가 사용자의 프로세스를 작동하기 위해 유지하는 영역이므로 사용자게에는 보이지 않는다.

### 프로세스의 생성과 복사

- `fork()` syscall

  - 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수
  - 즉, 실행 중인 프로세스와 똑같은 프로세스가 하나 더 만들어진다.  
    실행 중이던 프로세스: parent, 복사되어 생긴 프로세스: child
  - PCB의 다음 부분은 변경된다.

    - PID
    - 메모리 관련 정보
    - Parent PID와 Child PID

  - 장점
    - 프로세스의 생성 속도가 빠르다.
    - 추가 작업 없이 자원을 상속할 수 있다.
    - 시스템 관리를 효율적으로 할 수 있다.

### 프로세스의 전환

- `exec()` syscall

  - 기존의 프로세스를 새로운 프로세스로 전환(재사용)하는 함수
    - `fork()`: 새로운 프로세스를 복사하는 syscall
    - `exec()`: 프로세스는 그대로 둔 채 내용만 바꾸는 syscall

### 프로세스의 계층 구조

- Unix에서 모든 프로세스는 `init` 프로세스의 children이 되어 tree 구조를 이룬다.

- 프로세스 계층 구조의 장점:

  - 여러 작업을 동시에 처리할 수 있다.
  - 프로세스의 재사용이 용이하다.
  - 자원 회수가 쉽다.

- Orphan(고아) 프로세스
  - 프로세스가 종료된 후에도 비정상적으로 남아 있는 프로세스 중 parent 프로세스가 child보다 먼저 죽는 경우
