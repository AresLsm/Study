# 모놀리틱 지옥에서 벗어나라

<h2>서서히 모놀리틱 지옥에 빠져들다</h2>

<h3>모놀리틱 아키텍쳐의 장점</h3>

- 개발이 간단하다: IDE 등 개발 툴은 단일 애플리케이션 구축에 초점이 맞추어져 있다.
- 애플리케이션을 쉽게 변경할 수 있다: 코드, DB 스키마를 변경해서 빌드, 배포하기 용이하다.
- 테스트하기 쉽다
- 배포하기 쉽다
- 확장하기 쉽다: Load balancer의 뒷면에 애플리케이션 인스턴스를 여러 개 실행할 수 있다.

<h3>모놀리틱 지옥의 실상</h3>

- 모놀리틱 아키텍쳐는 근본적인 한계점이 있다. 덩치가 계속 커지는 애플리케이션은 모놀리틱 아키텍쳐라는 옷이  
  더 이상 맞지 않게 커진다. 개발 팀이 sprint를 할 때마다 추가 구현할 기능이 늘어났고, 그만큼 코드베이스와  
  관리 오버헤드 역시 증가한다.

- 하나의 애플리케이션에 계속해서 기능을 추가하다보면, 초반에는 소수였던 개발 팀도 나중에는 기능 분야가 특화된  
  scrum 팀들로 분리될 때, 코드가 너무 많아 버그를 고치고 새로운 기능을 정확하게 구현해가기 힘들고,  
  시간도 오래 걸린다. 또한 당연하게도 빌드 시간도 계속해서 길어질 것이고, 이는 곧 개발자의 생산성을 떨어뜨린다.

- 애플리케이션은 모듈 단위로 분리할 수 있는데, 모듈 A는 인메모리 데이터베이스를 사용하기 때문에 메모리 성능이 좋아야 하고,  
  모듈 B는 CPU를 많이 소모해서 CPU 코어 수가 많은 서버에 배포하는 것이 좋다고 해보자. 이렇게 같은 애플리케이션이라도  
  리소스 요건이 상이한 모듈이 존재하게 되면 서버 구성 시 리소스 배분에 신경 써야 하며, 이는 확장을 어렵게 만든다.

- 애플리케이션 자체가 워낙 덩치가 커서 철저하게 테스트하기 어렵고, 이는 곧 프로덕션에 버그가 발생할 가능성을 높인다.

<hr/>

<h2>MSA가 답이다</h2>

- 소프트웨어 아키텍쳐는 기능 요건과는 거의 무관하다. 애플리케이션의 기능 요건(Functional requirement), 즉 use case는  
  그 어느 아키텍쳐든 구현할 수 있다. 그러나 아키텍쳐는 **~성(~ibility)으로 끝나는 갖가지 서비스 품질 요건에 영향을 미친다**.  
  예를 들어, 소프트웨어의 관리성(maintainability), 확장성(extensibility), 테스트성(testability) 등이 있다.

<h3>확장 큐브와 마이크로서비스</h3>

- MSA의 여러 가지 정의론 중, 확장 큐브를 생각해보자.

> 확장 큐브는 애플리케이션을 확장하는 세 가지 방법을 정의한다.
> X축 확장은 동일한 다중 인스턴스에 들어온 요청을 부하 분산한다.  
> Z축 확장은 요청의 속성에 따라 요청을 라우팅하며, Y축 확장은 애플리케이션을  
> 기능에 따라 서비스로 분해한다.

- 이 모델에 따르면 애플리케이션을 X, Y, Z의 3가지 방향으로 확장시킬 수 있다.

<h4>X축 확장: 다중 인스턴스에 고루 요청 분산</h4>

- X축 확장은 일반적인 모놀리틱 애플리케이션의 확장 수단이다.  
  Load Balancer의 뒷단에 애플리케이션의 인스턴스를 N개 띄워 놓고 Load balancer는  
  들어온 요청을 이들 인스턴스에 골고루 분배한다. 이는 애플리케이션의 능력과 가용성을 개선할 수 있는 좋은 방법이다.

<h4>Z축 확장: 요청 속성별 라우팅</h4>

- 모놀리틱 애플리케이션의 다중 인스턴스를 실행하는 것은 X축 확장과 같지만, 인스턴스별로 주어진 데이터 하위 집합(subset)만  
  처리하도록 설정하는 방법이다. 인스턴스의 앞면에 위치한 라우터는 요청의 속성에 알맞은 인스턴스로 요청을 라우팅한다.  
  userId에 따라 요청을 분산하는 경우를 생각해보자. 각 애플리케이션 인스턴스는 자신에게 배정된 사용자 하위 집합만 처리한다.  
  라우터는 요청 헤더 중 Authorization에 포함된 userId를 보고 N개의 동일한 애플리케이션 인스턴스 중 하나를 선택한다.  
  이렇게 Z축 확장은 애플리케이션을 확장해서 증가하는 트랜잭션 및 데이터 볼륨을 처리하기 좋은 수단이다.  
  여러 개의 인스턴스 중 1번 인스턴스는 userId가 a-g인 요청을 받고, 2번 인스턴스는 userId가 h-n인 요청을 받고,  
  3번 인스턴스는 o-z인 요청을 처리한다.

<h4>Y축 확장: 기능에 따라 애플리케이션을 서비스로 분해</h4>

- X, Z축 확장을 하면 애플리케이션 능력과 가용성은 개선되지만, 애플리케이션이 점점 복잡해지는 문제는 해결되지 않는다.  
  따라서 Y축 확장, 즉 기능 분해가 필요하다.

- 쇼핑몰을 생각해보자. 하나의 서비스를 주문 관리, 고객 관리 등 지엽적 기능이 구현된 미니 애플리케이션으로 나눌 수 있을 것이다.  
  서비스에 따라 X, Z축 확장도 가능하다.

- 이렇게 MSA는 고수준에서 바라보면 하나의 애플리케이션을 여러 서비스로 기능 분해하는 아키텍쳐 스타일이다.  
  여기서 중요한 것은 크기가 아니라, 각 서비스가 집중(focus), 응집(cohesive)된 책임을 맡고 있다는 사실이다.

<h3>마이크로서비스의 모듈성</h3>

- 모듈성(Modularity)는 크고 복잡한 애플리케이션을 개발할 때 꼭 필요한 특성이다.  
  요즘 애플리케이션은 규모가 방대하고 내용이 너무 복잡해서 어느 한 개인이 전부 다 이해하고 개발할 수 없다.  
  따라서 여러 사람들이 이해하고 개발할 수 있게끔 애플리케이션을 여러 모듈로 분해한다.

- MSA에서는 모듈성의 단위가 서비스가 된다. 각 서비스는 다른 서비스가 함부로 규칙을 거기고 침투하지 못하게끔  
  API라는 경계선을 갖고 있어서 다른 서비스 API를 우회하여 그 내부 클래스에 마음대로 접근할 수 없다.  
  따라서 시간이 지나도 애플리케이션의 모듈성을 유지하기에 훨씬 수월하다.  
  또 서비스를 각각 독립적으로 배포, 확장할 수 있는 부가적인 장점도 있다.

<h3>서비스마다 DB가 따로 있다</h3>

- 마이크로서비스는 서로 느슨하게 결합되어 있고, **오직 API를 통해서만 통신** 이 가능하다.  
  이렇게 느슨하게 결합된 서비스는 각각 자체 DB를 갖게 된다.  
  서비스마다 다른 DB를 사용한다면 개발 단계에서 다른 서비스 개발자와 일일이 협의하지 않고도 개발자 본인이 담당한  
  서비스 스키마를 변경할 수 있다. 런타임에 서비스는 서로 완전히 분리되어 있기 때문에, 이를테면 다른 서비스가 DB Lock을  
  획득해 서비스를 blocking하는 일은 일어나지 않는다.

<h3>마이크로서비스 아키텍쳐와 SOA</h3>

- SOA(Self Oriented Architecture)와 MSA는 아래의 근본적인 차이점들이 있다.

<h4>서비스 간의 통신</h4>

- SOA 애플리케이션은 SOAP 및 WS 표준 등 무거운 기술들을 주로 사용하고, 서비스를 통합하는 비즈니스와  
  메시지 처리 로직이 포함된 ESB라는 Smart Pipe를 사용한다.  
  반면, MSA에서 애플리케이션은 대개 가벼운 오픈 소스 기술을 사용하며, Message Broker, REST, gRPC와 같이  
  가벼운 프로토콜을 위주의 Dumb Pipe를 사용하여 서비스 간의 통신을 진행한다.

<h4>데이터</h4>

- SOA는 보통 전역 데이터 모델링을 하고, DB도 공유하지만 MSA는 각각 자체의 DB, 자체의 도메인 모델을 소유한다.

<h4>서비스의 크기</h4>

- SOA는 대부분 크고 복잡한 모놀리틱 애플리케이션들을 통합하는 용도로 사용된다.  
  마이크로서비스라고 해서 항상 작은 것은 아니지만, 대체로 SOA보다는 훨씬 규모가 작다.  
  SOA 애플리케이션은 덩치가 큰 서비스 몇 개로 구성되지만, 마이크로서비스 애플리케이션은 이보다 작은  
  수십 ~ 수백개의 서비스로 구성된다.

<hr/>

<h2>MSA의 장단점</h2>

<h3>MSA의 장점</h3>

- 마이크로서비스 아키텍처는 아래와 같은 장점들이 있다.

<h4>크고 복잡한 애플리케이션의 지속적인 전달, 배포</h4>

- MSA로 구축하면 크고 복잡한 애플리케이션을 지속적으로 전달 및 배포할 수 있다.  
  이러한 Continous Delivery는 소프트웨어를 빠르게, 자주, 확실하게 전달하는 관례이다.  
  MSA는 아래의 3가지 방법으로 CD를 실현한다.

  - 테스트성: CD를 하려면 자동화 테스트가 꼭 필요하다. 마이크로서비스는 상대적으로 크기가 작아서  
    자동화 테스트를 작성하기 쉽고, 더 빨리 실행되며, 애플리케이션 버그도 적은 편이다.
  - 배포성: 마이크로서비스는 독립적으로 배포할 수 있기에 개발자가 자신이 담당한 서비스 변경분을  
    배포할 때 굳이 다른 개발자와 협의할 필요가 없다.
  - 자율성, 느슨한 결합: 작은 팀이 여럿 결합된 기술 조직을 꾸려갈 수 있다.  
    팀별로 하나 이상의 관련 서비스를 개발, 배포하는 업무만 담당할 수 있고, 다른 팀과 독립적으로  
    개발, 배포, 확장할 수 있으므로 개발 속도는 더 빨라진다.

<h4>서비스가 작아 관리하기 용이하다</h4>

- 마이크로서비스는 비교적 크기가 작아서 개발자가 코드를 이해하기 쉽다.  
  코드베이스가 작으면 IDE도 느려지지 않으므로 개발 생산성도 올라가며, 덩치 큰 모놀리틱  
  애플리케이션보다 각 서비스를 시동하는 시간이 훨씬 빠르기 때문에 개발자가 작업 후  
  배포하는 과정 역시 더 빠르고 생산적이다.

<h4>서비스를 독립적으로 배포, 확장할 수 있다</h4>

- 마이크로서비스는 독립적으로 X축, Z축 확장을 할 수 있고, 서비스마다 상이한 리소스 요건에 맞추어  
  하드웨어에 배포할 수 있다. 리소스 요건이 전혀 다른(ex. CPU vs Memory) 컴포넌트를 무조건  
  함께 배포할 수 밖에 없었던 모놀리틱 아키텍쳐와는 큰 차이가 있다.

<h4>결함 격리가 잘 된다</h4>

- MSA는 결함 격리가 잘 된다. 가령 어느 서비스에서 메모리 누수가 발생하더라도 해당 서비스만  
  영향을 받고, 다른 서비스는 계속 정상 가동된다. 모놀리틱 아키텍쳐는 어느 한 곳이 고장나면  
  전체 시스템에 영향을 끼친다.

<h3>MSA의 단점</h3>

- MSA는 장점도 있지만, 단점 또한 분명히 있다.

<h4>딱 맞는 서비스를 찾기 쉽지 않다</h4>

- MSA에 맞게 시스템을 여러 서비스로 분해하는, 구체적으로 정립된 알고리즘은 따로 없다.  
  만약 시스템을 잘못 분해할 경우, 모놀리틱, MSA의 단점만 있는 분산 모놀리스를 구축하게 된다.  
  즉, 반드시 함께 배포해야 하는 결합도가 높은 서비스들로 이루어진 시스템이 만들어지는 것이다.

<h4>분산 시스템은 복잡하다</h4>

- 분산 시스템(Distributed System)이라는 또 다른 복잡성은 개발자가 감당해야 한다.  
  서비스 간 통신에 필수적인 IPC 역시 단순 메소드 호출보다는 복잡하며, 사용 불능 또는  
  latency가 긴 원격 서비스, 부분 실패한 서비스를 처리할 수 있게끔 설계해야 한다.

- 여러 서비스를 상대로 use case를 구현하려면 익숙지 않은 기술도 동원해야 한다.  
  특히 서비스마다 DB가 따로 있기 때문에 다중 DB에 접속하여 조회하고, 트랜잭션을  
  구현하는 일이 어렵다. 그래서 마이크로서비스 아키텍쳐는 Saga라는 기술로 서비스 간  
  데이터의 일관성을 유지한다. 또 단순 쿼리로는 여러 서비스에 있는 데이터를 조회할 수 없으므로  
  API를 조합하거나, CQRS View로 쿼리한다.

- 운영 복잡도 역시 증가하는데, 종류가 다른 서비스가 여러 개의 인스턴스로 떠 있으니 프로덕션에서  
  관리해야 할 가동부가 더 늘어난다.

<h4>여러 서비스에 걸친 공통 기능은 배포할 때 잘 살펴야 한다</h4>

- 여러 서비스에 걸친 기능을 배포할 때에는 여러 개발 팀 간에 세심한 조율이 필요할 수 있다.  
  그러므로 서비스 간 의존성에 따라 배포 계획을 빈틈없이 수립해야 한다.  
  이는 여러 컴포넌트를 쉽게 원자적으로 업데이트할 수 있는 모놀리틱 아키텍쳐와는 다소 차이가 있다.

<h4>도입 시기를 결정하기 어렵다</h4>

<hr/>
