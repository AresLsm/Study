# Spring Data JPA와 Querydsl

## Spring Data JPA Repository

- 이전에 순수 JPA와 Querydsl을 함께 사용해 만든 레포지토리 코드를 Spring Data JPA를 사용하도록 바꿔보자.

```kt
@Repository
interface MemberRepository : JpaRepository<Member, Long> {
    fun findByUsername(username: String): List<Member>
}
```

- 여기까지는 항상 해왔던대로 `spring-data-jpa`가 제공하는 `JpaRepository`를 상속받는 인터페이스를 만들어서  
  레포지토리를 정의했다.

- 하지만 여기에 Querydsl이 필요한 메소드가 필요하다면 어떻게 할까?

<hr/>

## 사용자 정의 레포지토리

- `spring-data-jpa`의 레포지토리는 클래스가 아니라 인터페이스로 정의해야 한다. 그렇다면 Querydsl을 사용해야 하는  
  메소드에는 어떻게 해야할까?

- `spring-data-jpa`와 Querydsl을 함께 사용하는 방법은 아래와 같다.

  - (1) 사용자 정의 레포지토리 인터페이스 생성
  - (2) 사용자 정의 레포지토리 인터페이스 구현체 생성
  - (3) `spring-data-jpa`의 레포지토리가 사용자 정의 인터페이스를 상속하게 하기

- 하나하나씩 해보자. 먼저 _(1) 사용자 정의 레포지토리 인터페이스를 생성_ 해보자.

```kt
interface MemberRepositoryCustom {
    fun search(condition: MemberSearchCondition): List<MemberTeamDto>
}
```

- 다음으로 _(2) 사용자 정의 레포지토리 인터페이스인 `MemberRepositoryCustom`의 구현체를 만들어보자._

```kt
class MemberRepositoryImpl(private val query: JPAQueryFactory ) : MemberRepositoryCustom {

    override fun search(condition: MemberSearchCondition): List<MemberTeamDto> {
        return query
            .select(
                QMemberTeamDto(
                member.id!!.`as`("memberId"),
                member.username,
                member.age,
                team.id!!.`as`("teamId"),
                team.name.`as`("teamName")
            )
            )
            .from(member)
            .leftJoin(member.team, team)
            .where(
                usernameEq(condition.username),
                teamNameEq(condition.teamName),
                ageGoe(condition.ageGoe),
                ageLoe(condition.ageLoe)
            )
            .fetch()
    }

    private fun usernameEq(username: String?) : BooleanExpression? {
        return if (StringUtils.hasText(username)) member.username.eq(username) else null
    }

    private fun teamNameEq(teamName: String?): BooleanExpression? {
        return if(StringUtils.hasText(teamName)) team.name.eq(teamName) else null
    }

    private fun ageGoe(ageGoe: Int?): BooleanExpression? {
        return if(ageGoe == null) null else member.age.goe(ageGoe)
    }

    private fun ageLoe(ageLoe: Int?): BooleanExpression? {
        return if(ageLoe == null) null else member.age.loe(ageLoe)
    }
}
```

- `search()`와 내부에서 쓰이는 helper 메소드들 모두 이전 코드에서 복사해왔다.

- 마지막으로 _(3) `spring-data-repository`를 상속받는 `MemberRepository`가 사용자 정의 인터페이스인_  
  _`MemberRepositoryCustom`을 상속받게 해보자._

```kt
@Repository
interface MemberRepository : JpaRepository<Member, Long>, MemberRepositoryCustom {
    fun findByUsername(username: String): List<Member>
}
```

- 주의할 점이 있다면, **`MemberRepositoryImpl`의 클래스명은 정해진 규칙에 따른 것이다.**  
  **만약 `MemberRepositoryImpl`의 이름이 다르다면 Spring Bean Container 초기화에 실패한다.**

> `MemberRepositoryCustomImpl`로 해도 정상 작동한다.

<hr/>

## Spring Data의 페이징 활용

- 페이징 기능이 추가된 `search()`를 만들어보자.  
  `searchPageSimple()`은 COUNT Query와 데이터 조회 Query를 함께 한 번에 날리는 메소드이며,  
  `searchPageComplex()`는 COUNT Query와 데이터 조회 Query를 각각 따로 날리는 메소드이다.

```kt
interface MemberRepositoryCustom {
    fun search(condition: MemberSearchCondition): List<MemberTeamDto>

    // COUNT Query와 데이터 조회 Query를 한 번에 함께 함
    fun searchPageSimple(condition: MemberSearchCondition, pageable: Pageable): Page<MemberTeamDto>

    // COUNT Query와 나머지 Query를 분리시킴
    fun searchPageComplex(condition: MemberSearchCondition, pageable: Pageable): Page<MemberTeamDto>
}
```

- 바로 구현체를 만들어보자.

```kt
class MemberRepositoryCustomImpl(private val query: JPAQueryFactory ) : MemberRepositoryCustom {

    //..

    override fun searchPageSimple(condition: MemberSearchCondition, pageable: Pageable): Page<MemberTeamDto> {
        val results =  query
            .select(
                QMemberTeamDto(
                    member.id!!.`as`("memberId"),
                    member.username,
                    member.age,
                    team.id!!.`as`("teamId"),
                    team.name.`as`("teamName")
                )
            )
            .from(member)
            .leftJoin(member.team, team)
            .where(
                usernameEq(condition.username),
                teamNameEq(condition.teamName),
                ageGoe(condition.ageGoe),
                ageLoe(condition.ageLoe)
            )
            .offset(pageable.offset)
            .limit(pageable.pageSize.toLong())
            .fetchResults()
        val content: List<MemberTeamDto> = results.results
        val total: Long = results.total
        return PageImpl(content, pageable, total)
    }

    override fun searchPageComplex(condition: MemberSearchCondition, pageable: Pageable): Page<MemberTeamDto> {
        val content =  query
            .select(
                QMemberTeamDto(
                    member.id!!.`as`("memberId"),
                    member.username,
                    member.age,
                    team.id!!.`as`("teamId"),
                    team.name.`as`("teamName")
                )
            )
            .from(member)
            .leftJoin(member.team, team)
            .where(
                usernameEq(condition.username),
                teamNameEq(condition.teamName),
                ageGoe(condition.ageGoe),
                ageLoe(condition.ageLoe)
            )
            .offset(pageable.offset)
            .limit(pageable.pageSize.toLong())
            .fetch()

        val total: Long = query
            .select(member)
            .from(member)
            .leftJoin(member.team, team)
            .where(
                usernameEq(condition.username),
                teamNameEq(condition.teamName),
                ageGoe(condition.ageGoe),
                ageLoe(condition.ageLoe)
            )
            .fetchCount()

        return PageImpl(content, pageable, total)
    }
}
```

- `searchPageSimple()`은 `fetchResults()`를 사용해 데이터를 조회하는 쿼리와 COUNT 쿼리가 별도로 실행되도록 한다.  
  이 메소드가 수행하는 쿼리는 아래와 같다.

```sql
## COUNT Query
select
        count(member0_.id) as col_0_0_
    from
        member member0_
    left outer join
        team team1_
            on member0_.team_id=team1_.id;

## 데이터 조회 Query
select
        member0_.id as col_0_0_,
        member0_.username as col_1_0_,
        member0_.age as col_2_0_,
        team1_.id as col_3_0_,
        team1_.name as col_4_0_
    from
        member member0_
    left outer join
        team team1_
            on member0_.team_id=team1_.id limit ?;
```

- offset 조건이 들어가지 않은 이유는 코드 상의 offset을 0으로 주었기 때문이다.

- 반면, `searchPageComplex()`에 의해 실행되는 쿼리는 아래와 같다.

```sql
## 데이터 조회 Query
select
        member0_.id as col_0_0_,
        member0_.username as col_1_0_,
        member0_.age as col_2_0_,
        team1_.id as col_3_0_,
        team1_.name as col_4_0_
    from
        member member0_
    left outer join
        team team1_
            on member0_.team_id=team1_.id limit ?;

## COUNT Query
 select
        count(member0_.id) as col_0_0_
    from
        member member0_
    left outer join
        team team1_
            on member0_.team_id=team1_.id
```

- 지금 쿼리문만 봐서는 완전 동일해 보이지만, `searchPageComplex()`를 구현한 것처럼 쿼리를 별도로 수행하도록 하면  
  예를 들어 COUNT가 특정 조건 이하일 때 데이터 조회 쿼리를 실행시키지 않는다는 등 둘중 하나의 쿼리를 실행조차  
  시키지 않음으로 최적화를 할 수 있다는 장점이 있다. 반면, `searchPageSimple()`은 `fetchResults()`를  
  호출하기에 무조건 데이터 조회 쿼리와 COUNT 쿼리가 각각 함께 발생된다.

<hr/>
