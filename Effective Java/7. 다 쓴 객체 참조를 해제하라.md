# 다 쓴 객체 참조를 해제하라

- C, C++ 처럼 메모리를 직접 관리해야 하는 언어를 쓰다가 Java처럼 GC를 갖춘 언어로 넘어오면, 프로그래머로써의  
  삶이 훨씬 평안해진다. 다 쓴 객체를 GC가 알아서 회수해 가기 때문이다. 이는 개발자가 메모리 관리에 더 이상  
  신경쓰지 않아도 된다고 오해를 일으킬 수 있는데, 아래 코드를 보자.

```java
public class Stack {
	private Object[] elements;
	private int size = 0;
	private static final int DEFAULT_INITIAL_CAPACITY = 16;

	public Stack() {
		elements = new Object[DEFAULT_INITIAL_CAPACITY];
	}

	public void push(Object o) {
		ensureCapacity();
		elements[size++] = o;
	}

	public Object pop() {
		if(size == 0) {
			throw new EmptyStackException();
		}
		return elements[--size];
	}

	/**
	* 원소를 위한 공간을 적어도 1개 이상 확보한다.
	* 배열 크기를 늘려야할 때마다 대략 2배씩 늘린다.
	*/
	private void ensureCapacity() {
		if(elements.length == size) {
			elements = Arrays.copyOf(elements, size * 2 + 1);
		}
	}
}
```

- 위 `Stack`의 코드에서 특별한 문제점은 보이지 않는다. 하지만 위 코드에는 **메모리 누수** 가 일어난다.  
  이 Stack을 사용하는 프로그램을 오래 실행하다 보면 점차 GC 활동과 메모리 사용량이 늘어나 결국에는  
  성능이 저하될 것이다. 상대적으로 드문 경우이긴 하지만, 디스크 페이징이나 `OutOfMemoryError`를 일으켜  
  프로그램이 예기치 않게 종료될 수도 있다.

- 그렇다면 위 코드에서 메모리 누수는 어디에서 일어날까? 위 코드에서는 Stack이 커졌다가 줄어들 때  
  Stack에서 꺼내진 객체들을 GC가 회수하지 않는다. 프로그램에서 그 객체들을 더 이상 사용하지 않더라도 말이다.  
  이 Stack이 그 객체들의 다 쓴 참조(Obsolete Reference)를 여전히 갖고 있기 때문이다.  
  여기서 *다 쓴 참조*란 문자 그대로 다시 쓰지 않을 참조를 뜻한다.  
  위 코드에서는 elements 배열의 _활성 영역_ 밖의 참조들이 모두 여기에 해당한다.  
  활성 영역은 인덱스가 size보다 작은 원소들로 구성된다.

- GC가 지원되는 언어에서는 의도치 않게 객체를 살려두게 됨으로써 발생하는 메모리 누수를 찾기가 매우 까다롭다.  
  객체 참조 하나를 살려두면, GC는 그 객체 뿐 아니라 그 객체가 참조하는 객체, 또 그 객체가 참조하는 객체들을  
  모두 회수해가지 못한다. 그래서 단 몇 개의 객체가 매우 많은 객체를 회수되지 못하게 할 수 있고,  
  잠재적으로 성능에 큰 악영향을 줄 수 있다.
