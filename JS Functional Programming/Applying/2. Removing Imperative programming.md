# 명령형 습관 지우기

- 명령형 프로그래밍이 습관 되었다면 함수형 프로그래밍을 할 때 `reduce()`를  
  남발하게 될 수 있다.

- 아래 데이터가 있다고 해보자.

```js
const users = [
  { name: "AA", age: 35 },
  { name: "BB", age: 26 },
  { name: "CC", age: 28 },
  { name: "CC", age: 34 },
  { name: "EE", age: 23 },
];
```

- 위 users의 모든 age를 합산하는 코드를 작성해보자.

```js
console.log(_.reduce((total, user) => total + user.age, 0, users));
```

- 위 코드가 복잡하다고 생각되는 이유는, `user` 객체를 인자로 받아 그 객체의 age를 빼서  
  total에 누적시키도록 `reduce()`를 사용하기 때문이다. 이보다 아래와 같이 `reduce()`에  
  결과로 나올 한가지 타입만 준다면, 훨씬 깔끔해질 것이다.

```js
console.log(
  _.reduce(
    (a, b) => a + b,
    L.map((u) => u.age, users)
  )
);
```

- 위처럼 기존의 `reduce()`보다 `reduce()`는 하나의 타입에 대해서만 연산을 하도록 해주면 훨씬  
  가독성이 좋고 깔끔한 코드를 만들 수 있다.

<hr/>

<h2>reduce 하나보다 map + filter + reduce</h2>

- 이번에는 위의 예제외 동일하게 나이를 합산하는데, 30세 미만인 사람들의 나이만 합산하도록 조건을 추가해보자.

```js
// 기존의 함수
console.log(_.reduce((total, user) => total + user.age, 0, users));

// 수정된 함수
console.log(
  _.reduce(
    (total, user) => {
      if (user.age >= 30) return total;
      return total + user.age;
    },
    0,
    users
  )
);
```

- 위처럼 `reduce()` 하나만 사용하여 코드를 구성했을 때, 다른 조건들이 추가되면 사이에 if문을  
  사용함으로써 조건을 만족하게 된다. (삼항 연산자로 할 수도 있다.)  
  하지만 조건이 바뀌면 코드는 더 복잡해질 수 있다.

- 이러한 경우에 다양한 함수들을 조합하는 식으로 바꾸면, 훨씬 깔끔해진다.  
  (조건 함수를 추가 또는 제거해주기만 하면 되기 때문, 가독성도 좋다.)

```js
// 나이 먼저 filter 후 map
console.log(
  _.reduce(
    (a, b) => a + b,
    L.map(
      (u) => u.age,
      L.filter((u) => u.age < 30, users)
    )
  )
);

// 나이 먼저 map후 filter
console.log(
  _.reduce(
    (a, b) => a + b,
    L.filter(
      (n) => n < 30,
      L.map((u) => u.age, users)
    )
  )
);
```

<hr/>
