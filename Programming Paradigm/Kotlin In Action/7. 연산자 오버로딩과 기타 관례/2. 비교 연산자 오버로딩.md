# 비교 연산자 오버로딩

- 코틀린에서는 산술 연산자와 마찬가지로 원시 타입 값 뿐만 아니라 모든 객체에 대해 비교 연산을  
  수행할 수 있다. `equals()`나 `compareTo()`를 호출해야만 하는 Java와 달리, 코틀린에서는  
  `==` 비교 연산자를 직접 사용할 수 있어서 비교 코드가 `equals()`나 `compareTo()`를 사용한  
  코드보다 더 간결하며 이해하기 쉽다.

## 동등성 연산자: `equals()`

- 이전에 코틀린이 `==` 연산자 호출을 `equals()` 호출로 컴파일한다는 것을 보았다. 사실 이는 특별한  
  경우는 아니고, 지금까지 본 여러 관례를 적용한 것에 불과하다.

- `!=` 연산자를 사용하는 식도 `equals()` 호출로 컴파일된다. 물론 당연히 비교 결과를 뒤집은 값을  
  결과 값으로 사용한다. `==`와 `!=`는 내부에서 인자가 null인지 검사하므로 다른 연산과 달리, null이  
  될 수 있는 값에도 적용할 수 있다. `a == b`라는 비교를 처리할 때 코틀린은 알아서 a가 null인지  
  판단해서 null이 아닌 경우에만 `a.equals(b)`를 호출한다. 만약 a가 null이라면 b도 null인  
  경우에만 결과가 true이다.

- 위에서 본 `Point`의 경우, data class이기에 컴파일러가 자동으로 `equals()`를 생성해준다.  
  하지만 직접 `equals()`를 구현한다면 아래와 같을 것이다.

```kt
class Point(val x: Int, val y: Int) {
    override fun equals(other: Any?): Boolean {
	if (other === this) return true
	if (other !is Point) return false
	return other.x == x && other.y == y
    }
}
```

- **식별자 비교(identity equals)** 연산자인 `===`를 사용해 `equals()`의 파라미터가 수신 객체와  
  같은지 살펴본다. 식별자 비교 연산자는 Java의 `==`와 같다. 따라서 `===`는 자신의 두 피연산자가  
  서로 같은 객체를 가리키는지(원시 타입의 경우 같은 값인지) 비교한다. `equals()`를 구현할 때는  
  `===`를 사용해 자기 자신과의 비교를 최적화하는 경우가 많다. `===`를 오버로딩할 수 없다는 사실 또한  
  기억하자.

- `equals()`에는 override가 붙어있다. 다른 연산자 오버로딩 관례와 달리, `equals()`는 `Any`에  
  정의된 메소드이므로 override가 필요하다. 상위 클래스에서 정의된 메소드를 오버라이드한다는 사실을  
  알면 `equals()` 앞에 operator를 붙이지 않는 이유를 알 수 있다. `Any`의 `equals()`에는  
  operator가 붙어있지만, 그 메소드를 오버라이드하는 하위 클래스의 메소드 앞에는 operator를  
  붙이지 않아도 자동으로 상위 클래스의 operator 지정이 적용된다. 또한 `Any`에서 상속받은  
  `equals()`가 확장 함수보다 우선순위가 높기에 `equals()`를 확장 함수로 정의할 수도 없다.

<hr/>
