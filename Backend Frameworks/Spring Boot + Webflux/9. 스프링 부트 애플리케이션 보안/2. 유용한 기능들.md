## 사용자 컨텍스트 접근

- 보안 관리 기능을 추가한다는 것은 **현재 사용자의 세부정보에 접근할 수 있다는 점**에서  
  또다른 중요한 의미를 갖는다.

- 사용자별로 다른 리소스를 보여줘야 할 때, 로그인한 사용자의 세부 정보에 접근할 수 있으므로  
  쉽게 처리할 수 있다. 예를 들어, 아래 코드처럼 구현할 수 있다.

```kt
@GetMapping
fun home(auth: Authentication): Mono<Rendering> {
    return Mono.just(Rendering.view("home.html")
        .modelAttribute("items", inventoryService.getInventory())
	.modelAttribute("cart", inventoryService.getCart(cartName(auth))
	    .defaultIfEmpty(Cart(cartName(auth))))
	.modelAttribute("auth", auth)
	.build())
}
```

- 위 코드처럼 컨트롤러 레벨에 `Authentication`을 메소드 인자로 추가하면 Spring Security가  
  **구독자 컨텍스트(Subscriber Context)** 에서 `Authentication` 정보를 추출해서  
  인자로 주입해준다.

- `Authentication` 정보를 활용하기 전에, 위 코드에서 사용한 `cartName()` 메소드를 보자.

```kt
class Controller {
    //..
    companion object {
	private fun cartName(auth: Authentication): String {
	    return "${auth.name}'s cart"
	}
    }
}
```

- 이렇게 컨트롤러 메소드에서 사용자 컨텍스트에 접근하기 위해 인자로 `Authentication`을 넘겨준 뒤에  
  할 일은 **메소드 수준의 보안 적용**이다.

<hr/>

## 메소드 수준 보안

- 지금까지 적용한 기본적인 보안은 아직 이슈가 많이 있다.

  - 컨트롤러 클래스를 변경하면 Security 정책도 함께 변경돼야 한다.
  - 컨트롤러가 추가될수록 `SecurityWebFilterChain` bean에 추가해야 할 규칙도 늘어난다.

- 웹 엔트포인트와 직접적으로 연결되지는 않지만, 역할 기반의 보안 규칙을 적용하려면 어떻게 해야할까?

- 이런 문제를 해결하기 위해 **메소드 수준 보안(Method Level Security)** 가 등장했다.

- Spring Security의 어노테이션을 메소드에 직접 명시해서 비즈니스 로직이 있는 곳에  
  필요한 보안 조치를 직접 적용할 수 있다. 수십 개의 컨트롤러의 수많은 URL에 대한 보안 규칙을  
  `SecurityConfig`에 정의하는 대신, 비즈니스 로직에 따라 적절한 보안 규칙을 비즈니스 로직  
  바로 곁에 둘 수 있는 것이다.

- 메소드 수준 보안을 더 자세히 보기 전에, 몇 가지 웹 컨트롤러 메소드보다 더 실질적인 예제를 만들어보자.  
  Spring HATEOAS를 사용하는 REST API를 추가해보자.

- 우선 메소드 수준 보안은 기본적으로는 활성화되지 않으며, `@EnableReactiveMethodSecurity`를  
  적용해야만 활성화된다. 이 어노테이션은 물론 아무 클래스에 추가하는 것보다 보안 설정 클래스에  
  추가하는 것이 가장 좋다.

- 또한 메소드 수준 보안으로 변경하기 위해 `pathMatcher()`를 제거해보자.  
  코드는 아래와 같다.

```kt
@Configuration
@EnableReactiveMethodSecurity
class SecurityConfig {

    @Bean
    fun userDetailsService(repository: UserRepository): ReactiveUserDetailsService { // <1>
        return ReactiveUserDetailsService { username: String ->
            repository.findByName(username)
                .map { user ->
                    User.withDefaultPasswordEncoder()
                        .username(user.name)
                        .password(user.password)
                        .authorities(*user.roles.toTypedArray())
                        .build()
                }
        }
    }

    companion object {
        private const val USER = "USER"
        private const val INVENTORY = "INVENTORY"
    }

    @Bean
    fun customSecurityPolicy(http: ServerHttpSecurity): SecurityWebFilterChain {
        return http
            .authorizeExchange{ exchanges -> exchanges
                    .anyExchange().authenticated()
                    .and()
                    .httpBasic()
                    .and()
                    .formLogin()
            }.csrf().disable()
            .build()
    }
}
```

- `pathMatcher()`를 모두 제거했다.

- 이제 컨트롤러를 작성해보자.  
  새로운 `Item`을 생성하는 메소드를 볼 것인데, 인가된 사용자에 의해서만 실행되도록 해보자.

```kt
@RestController
class HypermediaItemController(
    private val itemRepository: ItemRepository
) {

    @GetMapping("/hypermedia/items/{id}", produces =[MediaTypes.HAL_FORMS_JSON_VALUE])
    fun findOne(@PathVariable id: String, auth: Authentication): Mono<EntityModel<Item>> {
        val controller = methodOn(HypermediaItemController::class.java)
        val selfLink = linkTo(controller.findOne(id, auth)).withSelfRel()
            .andAffordance(controller.updateItem(null, id, auth)).toMono()
        val aggregateLink = linkTo(controller.findAll(auth))
            .withRel(IanaLinkRelations.ITEM).toMono()
        return Mono.zip(itemRepository.findById(id), selfLink, aggregateLink)
            .map { o -> EntityModel.of(o.t1, Links.of(o.t2, o.t3)) }
    }

    @PreAuthorize("hasRole('INVENTORY')") // (1)
    @PostMapping("/hypermedia/items")
    fun addNewItem(@RequestBody item: Item, auth: Authentication): Mono<ResponseEntity<*>> { // (2)
        return itemRepository.save(item)
            .mapNotNull { savedItem -> savedItem.id }
            .flatMap { id -> findOne(id!!, auth)}
            .map { newModel -> ResponseEntity.created(newModel
                .getRequiredLink(IanaLinkRelations.SELF)
                .toUri()).build<EntityModel<Item>>()}
    }
}
```

- 코드 설명을 보자.

  - (1) `@PreAuthorize()`는 메소드 수준에서 보안을 적용할 수 있게 해주는 Spring Security의  
    핵심 어노테이션이다. Spring Security의 SpEL(Spring Expression Language) 표현식을  
    사용해서 이 메소드를 호출하는 사용자가 `INVENTORY` 역할을 갖고 있는지 단언한다.

  - (2) 이 메소드도 `Authentication` 객체를 인자로 받는다. 어떤 이유에서든 메소드가 현재 사용자의  
    보안 컨텍스트를 사용할 필요가 있다면 이 방식으로 주입받을 수 있다.

- 테스트 코드는 위에서 작성한 것처럼 인가된 사용자, 인가되지 않은 사용자에 대해 동일하게 작성하면 된다.

- 보안 관점에서 가장 중요한 첫 번째 원칙은 **권한이 부족한 사용자가 인가받지 않은 기능을 사용하지 못하게**  
  **하는 것**이며, 바로 위에서 그 부분을 다뤘다. 두 번째 원칙은 **첫 번째 원칙을 위배할 수 있는 어떠한**  
  **단서도 사용자에게 보여주지 않는 것**이다. 하이퍼미디어의 관점에서는 인가받지 못한 사용자가 접근할 수  
  없는 링크는 제공하지 말아야 함을 의미한다.

- 이 두 번째 원칙을 지킬 수 있도록 Hypermedia Record를 보여주는 `findOne()`을 수정해서  
  불필요한 정보를 인가되지 않은 사용자에게 전달하지 않도록 해보자.

```kt
@RestController
class HypermediaItemController(
    private val itemRepository: ItemRepository
) {

    companion object {
        private val ROLE_INVENTORY = SimpleGrantedAuthority("ROLE_INVENTORY")
    }

    @GetMapping("/hypermedia/items/{id}", produces =[MediaTypes.HAL_FORMS_JSON_VALUE])
    fun findOne(@PathVariable id: String, auth: Authentication): Mono<EntityModel<Item>> {
        val controller = methodOn(HypermediaItemController::class.java)
        val selfLink = linkTo(controller.findOne(id, auth)).withSelfRel()
            .andAffordance(controller.updateItem(null, id, auth)).toMono()
        val aggregateLink = linkTo(controller.findAll(auth))
            .withRel(IanaLinkRelations.ITEM).toMono()

        val allLinks: Mono<Links>

        if(auth.authorities.contains(ROLE_INVENTORY)) {
            val deleteLink = linkTo(controller.deleteItem(id)).withRel("delete")
                .toMono()
            allLinks = Mono.zip(selfLink, aggregateLink, deleteLink)
                .map { links -> Links.of(links.t1, links.t2, links.t3 )}
        } else {
            allLinks = Mono.zip(selfLink, aggregateLink)
                .map { links -> Links.of(links.t1, links.t2)}
        }

        return itemRepository.findById(id)
            .zipWith(allLinks)
            .map { o -> EntityModel.of(o.t1, o.t2)}
    }

    //..
}
```

- `findOne()` 메소드 하나에 굉장히 많은 내용이 포함되어 있는데, 핵심 부분은 `ROLE_INVENTORY`를 가지는지에 따라  
  분기하여 반환값에 다른 link를 추가할지 말지 정한다는 것이다.

- 또 주의 깊게 봐야할 것은 `Mono.zip()`를 사용한다는 것이다. `zip()`은 함수형 프로그래밍에서는 매우  
  친숙한 개념이다. **리액터에서는 여러 개의 결과가 필요하지만 각 결과가 언제 종료될지 알 수 없을 때 `zip()`을 사용**한다.  
  예를 들어, 3개의 원격 호출이 필요하고 3개의 결과를 모두 하나로 묶어서 받고 싶다고 해보자.  
  `Mono.zip()`은 3개의 응답을 모두 받았을 때 callback을 호출해서 결과를 묶음 처리한다.

- 위 API 에 대한 테스트 코드를 작성해보자.

```kt
@SpringBootTest
@EnableHypermediaSupport(type = [HypermediaType.HAL])
@AutoConfigureWebTestClient
class ApiItemControllerTest {

    @Autowired
    private lateinit var webTestClient: WebTestClient

    @Autowired
    private lateinit var itemRepository: ItemRepository

    @Autowired
    private lateinit var webClientConfigurer: HypermediaWebClientConfigurer

    @BeforeEach
    fun setUp() {
        webTestClient = webTestClient.mutateWith(webClientConfigurer)
    }

    @Test
    @WithMockUser(username = "Alice", roles = ["INVENTORY"])
    fun navigateToItemWithInventoryAuthority() {

        // `/api` 에 GET 요청
        val root: RepresentationModel<*> = webTestClient
            .get().uri("/api").exchange()
            .expectBody(RepresentationModel::class.java)
            .returnResult().responseBody!!

        // Item의 Aggregate Root link에 GET 요청
        val items: CollectionModel<EntityModel<Item>> = webTestClient
            .get().uri(root.getRequiredLink(IanaLinkRelations.ITEM).toUri())
            .exchange()
            .expectBody(TypeReferences.CollectionModelType<EntityModel<Item>>())
            .returnResult().responseBody!!

        assertThat(items.links).hasSize(2)
        assertTrue(items.hasLink(IanaLinkRelations.SELF))
        assertTrue(items.hasLink("add"))

        // 첫 번째 Item의 EntityModel 획득
        val first: EntityModel<Item> = items.content.iterator().next()

        // 첫 번째 Item의 EntityModel에서 SELF 링크를 통해 첫 번째 Item 정보 획득
        val item: EntityModel<Item> = webTestClient.get()
            .uri(first.getRequiredLink(IanaLinkRelations.SELF).toUri())
            .exchange()
            .expectBody(TypeReferences.EntityModelType<Item>())
            .returnResult().responseBody!!

        assertThat(item.links).hasSize(3)
        assertTrue(item.hasLink(IanaLinkRelations.SELF))
        assertTrue(item.hasLink(IanaLinkRelations.ITEM))
        assertTrue(item.hasLink("delete"))
    }
}
```

- 첫 번째 webTestClient는 `/api`에 GET 요청을 전송해서 링크 목록을 반환받는다.  
  링크 목록만 포함돼 있으므로 `RepresentationModel<*>` 객체로 추출할 수 있다.

- 이제 `Item` 링크를 요청해서 URI를 추출하고, Aggregate Root의 응답을 `CollectionModel<EntityModel<Item>>`으로  
  변환한다. `CollectionModel<EntityModel<Item>>`은 도메인 객체 컬렉션을 감싸고 링크를 추가할 수 있는  
  모델이기에 링크 정보도 포함되어 있다. 인가받은 사용자에 대한 테스트이므로 SELF 링크 뿐만아니라  
  add 링크도 포함돼 있어야 하며, 이는 단언문을 통해 확인된다.

- 그 후 `CollectionModel`에서 첫 번째 `EntityModel<Item>`을 가져와 SELF 링크를 알아내고,  
  알아낸 SELF 링크로 GET 요청을 보내서 `Item`의 세부 정보를 가져와 delete 링크가 포함돼 있는지  
  확인한다.

- 이렇게 메소드 수준에서 세밀하게 보안 제어를 적용할 수 있는 방법을 살펴봤다.

<hr/>
