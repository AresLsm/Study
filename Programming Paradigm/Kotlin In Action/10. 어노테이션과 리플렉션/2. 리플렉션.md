# 리플렉션: 실행 시점에 코틀린 객체 내부 관찰

- 간단히 말해 **리플렉션(reflection)** 은 실행 시점에 동적으로 객체의 프로퍼티와 메소드에 접근할 수 있게 해주는 방법이다.  
  보통 객체의 메소드나 프로퍼티에 접근할 때는 프로그램 소스코드 안에 구체적인 선언이 있는 메소드나 프로퍼티명을 사용하며, 컴파일러는 그런  
  이름이 실제로 가리키는 선언을 컴파일 시점에 정적으로 찾아내 해당하는 선언이 실재함을 보장한다. 하지만 타입과 관계없이 객체를 다뤄야 하거나  
  객체가 제공하는 메소드나 프로퍼티명을 오직 실행 시점에만 알 수 있는 경우가 있다. JSON 직렬화 라이브러리가 그런 경우다.  
  직렬화 라이브러리는 어떤 객체든 JSON으로 변환할 수 있어야 하고, 실행 시점이 되기 전까지는 라이브러리가 직렬화할 프로퍼티나 클래스에 대한  
  정보를 알 수 없다. 이런 경우 리플렉션을 사용해야 한다.

- 코틀린에서 리플렉션을 사용하려면 두 가지 서로 다른 리플렉션 API를 다뤄야 한다.  
  첫 번째는 Java가 `java.lang.reflect` 패키지를 통해 제공하는 표준 리플렉션이다. 코틀린 클래스는 일반 Java 바이트코드로 컴파일되므로  
  Java 리플렉션 API도 코틀린 클래스를 컴파일한 바이트코드를 완벽히 지원한다. 이는 리플렉션을 사용하는 Java 라이브러리와 코틀린 코드가  
  완전히 호환된다는 뜻이므로 특히 중요하다.

- 두 번째 API는 코틀린이 `kotlin.reflect` 패키지를 통해 제공하는 코틀린 리플렉션 API이다. 이 API는 Java에는 없는 프로퍼티나 nullable한  
  타입과 같은 코틀린 고유 개념에 대한 리플렉션을 제공한다. 하지만 현재 코틀린 리플렉션 API는 Java 리플렉션 API를 완전히 대체할 수 있는  
  복잡한 기능을 제공하지는 않는다. 따라서 경우에 따라 Java 리플렉션 API를 대안으로 사용해야 하는 경우가 생긴다.  
  또한 코틀린 리플렉션 API가 코틀린 클래스만 다룰 수 있는 것은 아니라는 점을 잘 알아둬야 한다. 코틀린 리플렉션 API를 사용해도 다른 JVM 언어에서  
  생성한 바이트코드를 충분히 다룰 수 있다.

---

## 코틀린 리플렉션 API: KClass, KCallable, KFunction, KProperty

- 코틀린 리플렉션 API를 사용할 때 처음 접하게 되는 것은 클래스를 표현하는 `KClass`이다. `java.lang.Class`에 해당하는 `KClass`를 사용하면  
  클래스 안에 있는 모든 선언을 열거하고 각 선언에 접근하거나 클래스의 상위 클래스를 얻는 등의 작업이 가능하다.  
  `MyClass::class`라는 식을 쓰면 `KClass`의 인스턴스를 얻을 수 있다. 실행 시점에 객체의 클래스를 얻으려면 먼저 객체의 `javaClass`  
  프로퍼티를 사용해 객체의 Java 클래스를 얻어야 한다. `javaClass`는 `java.lang.Object.getClass()`와 같다.  
  일단 Java 클래스를 얻었으면 `.kotlin` 확장 프로퍼티를 통해 Java에서 코틀린 리플렉션 API로 옮겨올 수 있다.

```kt
class Person(val name: String, val age: Int)

// Client
import kotlin.reflect.full.* // import memberProperties extension function

val person = Person("Alice", 29)
val kClass = person.javaClass.kotlin
println(kClass.simpleName) // Person
kClass.memberProperties.forEach { println(it.name) } // name, age
```

- 위 예시 코드는 클래스명과 그 클래스에 들어있는 프로퍼티명을 출력하고, memberProperties를 통해 클래스와 모든 조상 클래스 내부에 정의된  
  비확장 프로퍼티를 모두 가져온다.

- `KClass` 선언을 찾아보면, 클래스 내부를 살펴볼 때 사용할 수 있는 다양한 메소드들을 볼 수 있다.

```kt
interface KClass<T: Any> {
	val simpleName: String?
	val qualifiedName: String?
	val members: Collection<KCallable<*>>
	val constructors: Collection<KFunction<T>>
	val nestedClasses: Collection<KClass<*>>
	//...
}
```

- memberProperties를 비롯해 `KClass`에 대해 사용할 수 있는 다양한 기능들은 실제로는 `kotlin-reflect` 라이브러리를 통해 제공하는 확장 함수다.  
  이런 확장 함수를 사용하려면 `import kotlin.reflect.full.*`로 확장 함수 선언을 import해야 한다.

- 위 `KClass` 선언을 보면, 모든 멤버의 목록이 `KCallable` 인스턴스의 컬렉션이라는 사실을 알 수 있다.  
  `KCallable`은 함수와 프로퍼티를 아우르는 공통 상위 인터페이스이다. 그 안에는 `call()` 메소드가 들어 있다.  
  `call()`을 사용하면 함수나 프로퍼티의 getter를 호출할 수 있다.

```kt
interface KCallable<out R> {
	fun call(vararg args: Any?): R
	// ...
}
```

- `call()`을 사용할 때는 함수 인자를 vararg 리스트로 전달한다. 아래 코드는 리플렉션이 제공하는 `call()`을 사용해 함수를 호출할 수 있음을 보여준다.

```kt
fun foo(x: Int) = println(x)

val kFunction = ::foo
kFunction.call(42) // 42
```

- 위 코드에서 알 수 있듯이 `::foo` 식의 값 타입은 리플렉션 API에 있는 `KFunction` 클래스의 인스턴스이다. 이 함수 참조가 가리키는 함수를 호출하려면  
  `KCallable.call()`을 호출한다. 위에서는 42 하나만 인자로 넘긴다. `call()`에 넘긴 인자의 개수와 원래 함수에 정의된 파라미터 개수가 맞아 떨어져야 한다.  
  예를 들어 파라미터를 1개 받는 `KFunction` 인스턴스를 `KCallable.call()`로 호출하면 `IllegalArgumentException`이 발생한다.

- 하지만 여기서는 함수를 호출하기 위해 더 구체적인 메소드를 사용할 수도 있다. `::foo`의 타입 `KFunction1<int, Unit>`에는 파라미터와 반환 값  
  타입 정보가 들어있다. `KFunction1`의 `1`은 이 함수의 파라미터가 1개라는 뜻이다. `KFunction1` 인터페이스를 통해 함수를 호출하려면  
  `invoke()`를 사용해야 한다. `invoke()`는 정해진 개수의 인자만을 받아들이며, 인자 타입은 `KFunction1` 제네릭 인터페이스의 첫 번째  
  타입 파라미터와 같다. 게다가 `kFunction`을 직접 호출할 수도 있다.

```kt
import kotlin.reflect.KFunction2

fun sum(x: Int, y: Int) = x + y

val kFunctino = KFunction2<Int, Int, Int> = ::sum
println(kFunction.invoke(1, 2) + kFunction(3, 4)) // 10

kFunction(1) // ERROR: No value passed for parameter p2
```

- `KFunction`의 `invoke()`를 호출할 때는 인자 개수나 타입이 맞아 떨이지지 않으면 컴파일이 안된다. 따라서 `KFunction`의 인자 타입과  
  반환 타입을 모두 다 안다면, `invoke()`를 호출하는 것이 낫다. `call()`은 모든 타입의 함수에 적용할 수 있는 일반적인 메소드이지만  
  타입 안정성을 보장해주지는 않는다.

> **언제, 그리고 어떻게 `KFunctionN` 인터페이스가 정의되는가?**
>
> `KFunction1`과 같은 타입은 파라미터 개수가 다른 여러 함수를 표현한다. 각 `KFunctionN` 타입은 `KFunction`을 확장하며, `N`과  
> 파라미터 개수가 같은 `invoke()`를 추가로 포함한다. 예를 들어 `KFunction<P1, P2, R>`에는 `operator fun invoke(p1: P1, p2: P2): R`  
> 선언이 들어 있다.
>
> 이런 함수 타입들은 컴파일러가 생성한 합성 타입(synthetic compiler-generated type)이다.  
> 따라서 `kotlin.reflect` 패키지에서 이런 타입의 정의를 찾을 수는 없다. 코틀린에서 컴파일러가 생성한 합성 타입을 사용하기 때문에, 원하는 수만큼  
> 많은 파라미터를 갖는 함수에 대한 인터페이스를 사용할 수 있다. 이런 합성 타입을 사용하기에 코틀린은 `kotlin-runtime.jar`의 크기를 줄일 수 있고,  
> 함수 파라미터 개수에 대한 인위적인 제약을 피할 수 있다.

- `Kproperty`의 `call()`을 호출할 수도 있다. `KProperty.call()`은 프로퍼티의 getter를 호출한다. 하지만 프로퍼티 인터페이스는  
  프로퍼티 값을 얻는 더 좋은 방법으로 `get()` 메소드를 제공한다.

- `get()` 메소드에 접근하려면 프로퍼티가 선언된 방법에 따라 올바른 인터페이스를 사용해야 한다. 최상위 프로퍼티는 `KProperty0` 인터페이스의 인스턴스로  
  표현되며, `KProperty0` 안에는 인자가 없는 `get()` 메소드가 있다.

```kt
var counter = 0

val kProperty = ::counter
kProperty.setter.call(21)
println(kProperty.get()) // 21
```

- 멤버 프로퍼티는 `KProperty1` 인스턴스로 표현된다. 그 안에는 인자가 1개인 `get()` 메소드가 들어있다. 멤버 프로퍼티는 어떤 객체에 속해 있는  
  프로퍼티이므로 멤버 프로퍼티의 값을 가져오려면 `get()` 메소드에 프로퍼티를 얻고자 하는 객체 인스턴스를 넘겨야 한다.  
  아래 코드는 memberProperty 변수에 대해 프로퍼티 참조를 저장한 다음, `memberProperty.get(person)`을 호출해 person 인스턴스의  
  프로퍼티 값을 가져온다. 따라서 memberProperty가 `Person`의 age 프로퍼티를 참조한다면, `memberProperty.get(person)`은 동적으로  
  `person.age`를 가져온다.

```kt
class Person(val name: String, val age: Int)

val person = Person("Alice", 29)
val memberProperty = Person::age
println(memberProperty.get(person)) // 29
```

- `KProperty1`은 제네릭 클래스다. memberProperty 변수는 `KProperty<Person, Int>` 타입으로 첫 번째 타입 파라미터는 수신 객체 타입,  
  두 번째 타입 파라미터는 프로퍼티의 타입을 표현한다. 따라서 수신 객체를 넘길 때는 `KProperty1`의 타입 파라미터와 일치하는 타입의 객체만을  
  넘길 수 있고, `memberProperty.get("Alice")`와 같은 호출은 컴파일되지 않는다.

- 최상위 수준이나 클래스 내에 정의된 프로퍼티만 리플렉션으로 접근할 수 있고, 함수의 로컬 변수에는 접근할 수 없다는 점을 알아야 한다.  
  함수 안에서 로컬 변수 x를 정의하고 `::x`로 그 변수에 대한 참조를 얻으려 시도하면 `"References to variables aren't supported yet"`라는  
  오류가 발생한다.

- 위 그림은 실행 시점에 소스코드 요소에 접근하기 위해 사용할 수 있는 인터페이스의 계층 구조를 보여준다.  
  `KClass`, `KFunction`, `KParameter`는 모두 `KAnnotatedElement`를 확장한다. `KClass`는 클래스와 객체를 표현할 때 쓰인다.  
  `KProperty`는 모든 프로퍼티를 표현할 수 있고, 그 하위 클래스인 `KMutableProperty`는 var로 정의한 변경 가능한 프로퍼티를 표현한다.  
  `KProperty`와 `KMutableProperty`에 선언된 `Getter`, `Setter` 인터페이스로 프로퍼티 접근자를 함수처럼 다룰 수 있다.  
  따라서 접근자 메소드에 붙어 있는 어노테이션을 알아내려면 `Getter`와 `Setter`를 통해야 한다. `Getter`와 `Setter`는 모두  
  `KFunction`을 확장한다.

![picture 26](/images/KIA_REFLECTION_1.png)

---
