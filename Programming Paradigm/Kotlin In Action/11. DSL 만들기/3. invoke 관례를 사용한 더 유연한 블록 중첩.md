# `invoke()` 관례를 사용한 더 유연한 블록 중첩

- `invoke()` 관례를 사용하면 객체를 함수처럼 호출할 수 있다. 이미 함수 타입의 객체(`Function1` 등)를 함수처럼 호출하는 경우를 살펴봤다.  
  마찬가지로 `invoke()` 관례를 사용하면 함수처럼 호출할 수 있는 객체를 만드는 클래스를 정의할 수 있다.

- 하지만 이 기능이 일상적으로 사용하라고 만들어진 기능은 아니라는 점에 유의하자. `invoke()` 관례를 남용하면 `1()`과 같이 이해하기 어려운  
  코드가 생길 수 있다. 하지만 DSL에서는 `invoke()` 관례가 유용할 때가 자주 있다.

## `invoke()` 관례: 함수처럼 호출할 수 있는 객체

- 관례는 특별한 이름이 붙은 함수를 일반 메소드 호출 구문으로 호출하지 않고 더 간단한 다른 구문으로 호출할 수 있게 지원하는 기능이다.  
  예를 들어 foo라는 변수가 있고 `foo[bar]`를 쓰게 되면 이는 `foo.get(bar)`로 변환된다. 이때 `get()`은 `Foo`라는 클래스  
  내에 정의된 함수거나 `Foo`에 대해 정의된 확장 함수여야 한다.

- `invoke()` 관례도 결국 마찬가지의 역할을 한다. 다만 `invoke()`는 `get()`과 달리 각괄호 대신 괄호를 사용한다.  
  operator 변경자가 붙은 `invoke()` 메소드 정의가 들어있는 클래스의 객체를 함수처럼 호출할 수 있다.

```kt
class Greeter(val greeting: String) {
	operator fun invoke(name: String) {
		println("$greeting, $name!")
	}
}

// client
val greeter = Greeter("Servus")
greeter("Dmitry") // "Servus, Dmitry!"
```

- 위 코드는 `Greeter` 안에 `invoke()` 메소드를 정의한다. 따라서 `Greeter` 인스턴스를 함수처럼 호출할 수 있다.  
  `greeter("Dmitry")`는 내부적으로 `greeter.invoke("Dmitry")`로 컴파일된다. 이 코드에는 아무런 신비로움도 없고, 단지 다른  
  관례와 마찬가지일 뿐이다. 즉 미리 정해둔 이름을 사용한 메소드를 통해 긴 식 대신 더 짧고 간결한 식을 쓸 수 있게 해준다.

- `invoke()` 메소드의 시그니처에 대한 요구사항은 없다. 따라서 원하는대로 파라미터 개수나 타입을 지정할 수 있다.  
  심지어 여러 파라미터 타입을 지원하기 위해 `invoke()`를 오버로딩할 수도 있다. 이렇게 오버로딩한 `invokde()`가 있는 클래스의  
  인스턴스를 함수처럼 사용할 때는 오버로딩한 여러 시그니처를 모두 다 활용할 수 있다. 이런 관례를 실제로 어떻게 활용할 수 있는지 살펴보자.

---
