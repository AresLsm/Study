# 기본 문법

<h2>JPQL vs Querydsl</h2>

- username이 member1인 `Member`를 조회하는 쿼리를 각각 JPQL, Querydsl로  
  작성하는 간단한 테스트 코드를 짜보자.

```kt
@SpringBootTest
@Transactional
class QuerydslBasicTest {

    @Autowired
    private lateinit var entityManager: EntityManager

    @BeforeEach
    fun before() {
        val teamA = Team("teamA")
        val teamB = Team("teamB")
        entityManager.persist(teamA)
        entityManager.persist(teamB)

        val member1 = Member("member1", 10, teamA)
        val member2 = Member("member2", 20, teamA)
        val member3 = Member("member3", 30, teamB)
        val member4 = Member("member4", 40, teamB)
        entityManager.persist(member1)
        entityManager.persist(member2)
        entityManager.persist(member3)
        entityManager.persist(member4)

        entityManager.flush()
        entityManager.clear()
    }

    @Test
    fun jpqlTest() {
        // Find member1 with JPQL
        val member = entityManager.createQuery(
            "SELECT m FROM Member m WHERE m.username = :username", Member::class.java
        )
            .setParameter("username", "member1")
            .singleResult

        assertEquals("member1", member.username)
    }

    @Test
    fun querydslTest() {
        // Find member1 with Querydsl
        val query = JPAQueryFactory(entityManager)
        // QMember가 필요하므로 ./gradlew compileQuerydslKotlin 실행
        val qMember = QMember("m")

        val member = query.select(qMember)
            .from(qMember)
            .where(qMember.username.eq("member1"))
            .fetchOne()!!

        assertEquals("member1", member.username)
    }
}
```

- JPQL로 했을 때는 쿼리문을 문자열로 전달하고, 파라미터 바인딩을 해줬다.  
  반면 Querydsl로 작성한 쿼리는 모두 함수로 작성했으며, 별도의 파라미터  
  바인딩을 해주지 않았다.

- 아래는 Querydsl로 수행된 쿼리문이다.

```sql
select
    member0_.id as id1_1_,
    member0_.age as age2_1_,
    member0_.team_id as team_id4_1_,
    member0_.username as username3_1_
from
    member member0_
where
    member0_.username=?
```

- 이렇게 Querydsl로 만들어진 쿼리문은 기본적으로 JDBC의 `PreparedStatement`를  
  만들고, 이후에 파라미터 바인딩을 수행한다.

<hr/>

<h2>기본 Q-Type 활용</h2>

- Q Class를 사용하는 방법에는 두 가지가 있다.  
  위처럼 `QMember("m")`처럼 별칭(m)을 지정하고 인스턴스를 만드는 방법과,  
  `QMember.member`처럼 기본 인스턴스를 사용하는 방법이 있다.

```kt
val qMember = QMember("m") // 직접 별칭 지정

val qMember = QMember.member // 기본 인스턴스 사용
```

- 위에서 작성한 코드를 기본 인스턴스를 사용하도록 바꿔보자.

```kt
@Test
fun querydslTest() {
    // Find member1 with Querydsl

    // QMember가 필요하므로 ./gradlew compileQuerydslKotlin 실행
    val qMember = QMember.member

    val member = query.select(qMember)
        .from(qMember)
        .where(qMember.username.eq("member1"))
        .fetchOne()!!

    assertEquals("member1", member.username)
}
```

- 이렇게 해도 되는 이유는 `QMember`를 직접 보면 알 수 있다.

```java
@Generated("com.querydsl.codegen.EntitySerializer")
public class QMember extends EntityPathBase<Member> {

    //..

    public static final QMember member = new QMember("member1");

    //..
}
```

- Java의 경우에는 Static Import를 사용하여 간단하게 처리할 수 있을 것이다.

- Querydsl로 작성한 쿼리는 결국 JPQL이 된다. 즉 Querydsl은 JPQL을 함수로  
  작성하기 위한 빌더 함수들이다. 이를 확인하려면 아래 속성을 지정해주면 된다.

```properties
spring.jpa.properties.hibernate.use_sql_comments=true
```

- 위 테스트 코드에서 실행되는 JPQL은 아래와 같다.

```sql
SELECT member1 FROM Member member1 WHERE member1.username = ?1
```

- 별칭이 member1으로 지정된 것을 볼 수 있는데, 이는 `QMember`의 member 필드가  
  생성될 때 인자로 지정된 값과 동일하다.

- 비즈니스 로직에 의해 같은 테이블을 JOIN 하지 않는 이상, `QMember.member`를  
  사용하자.

<hr/>

<h2>검색 조건 쿼리</h2>

- 아래처럼 Querydsl은 JPQL이 제공하는 모든 검색 조건을 메소드로 표현할 수 있게 해준다.

```kt
@SpringBootTest
@Transactional
class QuerydslBasicTest {

    //..

    @Test
    fun search() {

        // SELECT * FROM members WHERE username = "member1" AND age = 10;
        val findMember = query
            .selectFrom(member)
            .where(member.username.eq("member1").and(member.age.eq(10)))
            .fetchOne()!!

        assertEquals("member1", findMember.username)

        // SELECT * FROM members WHERE username != "member1";
        val findMember2 = query
            .selectFrom(member)
            .where(member.username.ne("member1"))

        val findMember3 = query
            .selectFrom(member)
            .where(member.username.eq("member1").not())

        // SELECT * FROM members WHERE username IS NOT NULL;

        val findMember4 = query
            .selectFrom(member)
            .where(member.username.isNotNull)

        // SELECT * FROM members WHERE age IN (10, 20);
        val findMember5 = query
            .selectFrom(member)
            .where(member.age.`in`(10, 20))

        // SELECT * FROM members WHERE age NOT IN (10, 20);
        val findMember6 = query
            .selectFrom(member)
            .where(member.age.notIn(10, 20))

        // SELECT * FROM members WHERE age BETWEEN 10, 20;
        val findMember7 = query
            .selectFrom(member)
            .where(member.age.between(10, 20))

        // SELECT * FROM members WHERE age >= 30;
        val findMember8 = query
            .selectFrom(member)
            .where(member.age.goe(30))

        // SELECT * FROM members WHERE age > 30;
        val findMember9 = query
            .selectFrom(member)
            .where(member.age.gt(30))

        // SELECT * FROM members WHERE age <= 30;
        val findMember10 = query
            .selectFrom(member)
            .where(member.age.loe(30))

        // SELECT * FROM members WHERE age < 30;
        val findMember11 = query
            .selectFrom(member)
            .where(member.age.lt(30))

        // SELECT * FROM members WHERE username LIKE "member%";
        val findMember12 = query
            .selectFrom(member)
            .where(member.username.like("member%"))

        // SELECT * FROM members WHERE username LIKE "%member%";
        val findMember13 = query
            .selectFrom(member)
            .where(member.username.contains("member"))

        // SELECT * FROM members WHERE username LIKE "member%";
        val findMember14 = query
            .selectFrom(member)
            .where(member.username.startsWith("member"))
    }
}
```

- AND 로 여러 조건을 합쳐야 하는 경우, 두 가지 방법을 사용할 수 있다.

```kt
@SpringBootTest
@Transactional
class QuerydslBasicTest {

    //..

    @Test
    fun searchAND1() {
        val findMember = query
            .selectFrom(member)
            .where(
                member.username.eq("member1")
                    .and(member.age.eq(10))
            )
            .fetchOne()!!

        assertEquals("member1", findMember.username)
    }

    @Test
    fun searchAND2() {
        val findMember = query
            .selectFrom(member)
            .where(member.username.eq("member1"), member.age.eq(10))
            .fetchOne()!!

        assertEquals("member1", findMember.username)
    }
}
```

- 즉, 명시적으로 `where()`안에서 `.and()`를 호출하여 AND 연산임을 표현해줄 수도 있고,  
  그냥 두 개 이상의 조건을 `,`를 구분자로 하여 지정해줘도 된다.

<hr/>

<h2>결과 조회</h2>

- QueryDSL이 제공하는 함수들로 쿼리를 구성하고, 결과를 조회하기 위해 마지막으로 호출해주는 함수들을 보자.

  - `fetch()`: 리스트 조회, 데이터가 없다면 빈 리스트를 반환한다.
  - `fetchOne()`: 단건 조회
    - 결과가 없으면 null, 결과가 둘 이상이라면 `com.querydsl.core.NonUniqueResultException`를 발생시킨다.
  - `fetchFirst()`: `limit(1).fetchOne()`과 동일하다.
  - `fetchResults()`: 페이징 정보를 포함한 결과를 반환한다. total count 쿼리를 추가로 실행한다.
  - `fetchCount()`: count 쿼리로 변경해서 count수를 조회한다.

```kt
@SpringBootTest
@Transactional
class QuerydslBasicTest {

    //..

    @Test
    fun resultFetching() {
        val result: List<Member> = query
            .selectFrom(member)
            .fetch()

        val result2: Member? = query
            .selectFrom(member)
            .fetchOne()

        val result3: Member? = query
            .selectFrom(member)
            .fetchFirst()

        val result4: QueryResults<Member> = query
            .selectFrom(member)
            .fetchResults()

        // 4개의 member를 저장했으므로
        assertEquals(4, result4.total)

        val content: List<Member> = result4.results
        assertEquals(4, content.size)

        println(result4.limit)
        println(result4.offset)
        println(result4.total)

        val total: Long = query
            .selectFrom(member)
            .fetchCount()
        assertEquals(4, total)
    }
}
```

- `fetchResults()`와 `fetchCount()`에 의해 수행되는 쿼리는 아래와 같다.

```sql
select
    count(member0_.id) as col_0_0_
from
    member member0_;
```

<hr/>

<h2>정렬</h2>

<hr/>

<h2>페이징</h2>

<hr/>

<h2>집합</h2>

<hr/>

<h2>join - 기본 join</h2>

<hr/>

<h2>join - ON 절</h2>

<hr/>

<h2>join - Fetch join</h2>

<hr/>

<h2>서브 쿼리</h2>

<hr/>

<h2>CASE 문</h2>

<hr/>

<h2>상수, 문자 더하기</h2>

<hr/>
