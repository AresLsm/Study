# 코드에서 나는 악취(3)

<h2>메시지 체인</h2>

- 메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤, 방금 얻은 객체에  
  또다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.  
  가령 `getSomething()` 같은 geter가 꼬리에 꼬리를 물고 이어지거나, 임시 변수들이  
  줄줄이 나열되는 코드가 있다. 이는 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미한다.  
  그래서 내비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야 한다.

- 이 문제는 **위임 숨기기**로 해결한다. 이 리팩토링은 메시지 체인의 다양한 연결점에  
  적용할 수 있다. 원칙적으로 체인을 구성하는 모든 객체에 적용할 수 있지만, 그러다 보면 중간 객체들이  
  모두 중개자가 돼버리기 쉽다. 그러니 **최종 결과 객체가 어떻게 쓰이는지부터 살펴보는게 좋다.**  
  **함수 추출하기**로 결과 객체를 사용하는 코드 일부를 따로 빼낸 다음 **함수 옮기기**로  
  체인을 숨길 수 있는지 살펴보자. 체인을 구성하는 객체 중 특정 하나를 사용하는 클라이언트 중  
  그 이후의 객체들도 사용하길 원하는 클라이언트가 제법 많다면, 이 요구를 처리해줄 메소드를 추가한다.

- **위임 숨기기**는 이해하기 난해할 수 있는 방법이니, 예시를 살펴보자.  
  우선 아래 코드가 메시지 체인의 전형적인 예시이다.

```js
const managerName = person.department.manager.name;
```

- _"체인을 구성하는 모든 객체에 위임 숨기기를 적용할 수 있다."_ 고 함은 managerName을  
  바로 반환하는 메소드를 `Person` 클래스에 추가할 수도 있고, `Department` 클래스에  
  추가할 수도 있다는 뜻이다.

```js
// Manager의 존재를 숨김
const managerName = person.department.managerName;

// Department의 존재를 숨김
const managerName = person.manager.name;

// Department, Manager의 존재를 모두 숨김
const managerName = person.managerName;
```

- 이 체인의 최종 결과 객체는 결국 `Manager.name`이다.  
  이 객체가 다음처럼 쓰인다고 해보자.

```js
const managerName = person.department.manager.name;
let report = `${managerName}의 보고서 ~~~~`;
console.log(report);
```

- 여기서 report 생성 로직을 함수로 추출한 다음 적당한 모듈로 옮기면 체인의 존재가 감춰진다.

```js
console.log(reportGenerator.report(person));
```

- 마지막으로 체인의 중간 단계인 `Department` 정보를 얻어 사용하는 다수의 클라이언트가 `Manager.name`도  
  함께 사용한다면 `Department` 클래스에 `managerName()` 메소드를 추가하여 체인을 단축할 수 있다.

<hr/>

<h2>중개자</h2>

- 객체의 대표적인 기능 하나로, 외부로부터 세부사항을 숨겨주는 **캡슐화**가 있다.  
  캡슐화하는 과정에서는 **위임**이 자주 활용된다. 예를 들어 여러분이 팀장에게 미팅을  
  요청한다 해보자. 팀장은 자신의 일정을 확인한 후 답을 준다. 이러면 끝이다.  
  팀장이 종이 다이어리를 쓰든, 일정 서비스를 쓰든 이는 알바가 아니다.

- 하지만 지나치면 문제가 된다. 클래스가 제공하는 메소드 중 절반 이상이 다른 클래스에  
  구현을 위임하고 있다면 어떨까? 이럴 때는 **중개자 제거하기**를 활용하여 실제로 일을 하는 객체와  
  직접 소통하게 하자. 위임 메소드를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인하자.(**함수 인라인하기**)

<hr/>

<h2>내부자 거래</h2>

- 소프트웨어 개발자는 모듈 사이에 벽을 두껍게 세우는 것을 좋아하며, 그래서 모듈 사이의 데이터 거래가  
  많으면 결합도가 높아진다고 주장한다. 일을 돌아가게 하려면 거래가 많아질 수 밖에 없지만,  
  그 양을 최소로 줄이고 모두 투명하게 처리해야 한다.

- 커피 자판기 옆에서 은밀히 데이터를 주고받는 모듈들이 있다면 **함수 옮기기**와 **필드 옮기기**로  
  떼어놓아서 사적으로 처리하는 부분을 줄인다. 여러 모듈이 같은 관심사를 공유한다면 공통 부분을  
  정식으로 처리하는 제3의 모듈을 새로 만들거나 **위임 숨기기**를 이용하여 다른 모듈이  
  중간자 역할을 하게 만든다.

- 상속 구조에서는 부모 자식 사이에 결탁이 생길 때가 있다.  
  자식 클래스는 항상 부모 클래스가 공개하고 싶은 것 이상으로 부모에 대해 알려고 한다.  
  그러다가 부모 품을 떠나야할 때가 온다면 **서브클래스를 위임으로 바꾸기**나 **슈퍼클래스를 위임으로 바꾸기**를 활용하자.

<hr/>

<h2>거대한 클래스</h2>

- 한 클래스가 너무 많은 일을 하려다보면 필드 수가 상당히 늘어난다.  
  그리고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.

- 이럴 때는 **클래스 추출하기**로 필드들 일부를 따로 묶자. 같은 컴포넌트에 모아두는 것이 합당해 보이는  
  필드들을 선택하면 된다. 가령 `depositAmount`와 `depositCurrency` 필드는 같은 컴포넌트에  
  두는 것이 좋을 것이다. 더 일반적으로는, 한 클래스 안에서 접두어나 접미어가 같은 필드들이  
  함께 추출할 후보들이다. 이렇게 분리할 컴포넌트를 원래 클래스와 상속 관계로 만드는게 좋다면  
  **클래스 추출하기** 보다는 **슈퍼클래스 추출하기**나, 실질적으로 서브클래스 추출하기에 해당하는  
  **타입코드를 서브클래스로 바꾸기**를 적용하는 편이 더 쉬울 것이다.

- 클래스가 항시 모든 필드를 사용하지 않을 수도 있다.  
  이럴 때는 앞서 언급한 추출 기법들을 여러 차례 수행해야 할지도 모른다.

- 필드가 너무 많은 클래스와 마찬가지로 코드량이 너무 많은 클래스도 중복 코드와 혼동을  
  일으킬 여지가 크다. 가장 간단한 해법은 그 클래스 안에서 자체적으로 중복을 제거하는 것이다.  
  가령 부분부분 상당량의 로직이 똑같은 100줄짜리 메소드가 5개가 있다면 각각의 공통 부분을  
  작은 메소드들로 뽑아내자. 그러면 원래의 다섯 메소드들에는 작은 메소드를 호출하는  
  코드 10줄만 남게 될지도 모른다.

- 클라이언트들이 거대 클래스를 이용하는지 패턴을 파악하여 그 클래스를 어떻게 쪼갤지  
  단서를 얻을 수도 있다. 먼저 클라이언트들이 거대 클래스의 특정 기능 그룹만 주로 사용하는지 살피자.  
  이때, 그렇게 발견된 각각의 기능 그룹이 개별 클래스로 추출될 후보이다. 유용한 기능 그룹을 찾았다면  
  **클래스 추출하기**, **슈퍼클래스 추출하기**, **타입코드를 서브클래스로 바꾸기** 등을 활용해서  
  여러 클래스로 분리하자.

<hr/>

<h2>서로 다른 인터페이스의 대안 클래스들</h2>

- 클래스를 사용할 때의 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 점이다.  
  단, 교체하려면 인터페이스가 같아야 한다. 따라서 **함수 선언 바꾸기**로 메소드 시그니처를  
  일치시킨다. 때로는 이것만으로는 부족한데, 이럴 때는 **함수 옮기기**를 이용하여 인터페이스가  
  같아질 때까지 필요한 동작들을 클래스 안으로 밀어 넣는다. 그러다 대안 클래스들 사이에  
  중복 코드가 생기면 **슈퍼클래스 추출하기**를 적용할지 고려해본다.

<hr/>

<h2>데이터 클래스</h2>

- 데이터 클래스란 데이터 필드와 getter, setter 메소드로만 구성된 클래스를 말한다.  
  그저 데이터 저장 용도로만 사용되다 보니 다른 클래스가 너무 깊이까지 함부로 다룰 때가 많다.  
  이런 클래스에 public 필드가 있다면 누가 보기 전에 얼른 **레코드 캡슐화하기**로 숨기자.  
  변경하면 안되는 필드는 **세터 제거하기**로 접근을 원천 봉쇄한다.

- 다른 클래스에서 데이터 클래스나 getter, setter를 사용하는 메소드를 찾아서 **함수 옮기기**로  
  그 메소드를 데이터 클래스로 옮길 수 있는지 살펴보자. 메소드를 통째로 옮기기 어렵다면  
  **함수 추출하기**를 이용해서 옮길 수 있는 부분만 별도 메소드로 뽑아낸다.

- 한편, 데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의되어 있다는 신호일 수 있다.  
  이런 경우라면 클라이언트 코드를 데이터 클래스로 옮기기만 해도 대폭 개선된다. 물론 예외도 있다.  
  특히 다른 함수를 호출해 얻은 결과 레코드(데이터 객체)로는 동작 코드를 넣을 이유가 없다.  
  대표적인 예로 **단계 쪼개기**의 결과로 나온 중간 데이터 구조가 있다.  
  이런 데이터 구조는 immutable하다. 불변 필드는 굳이 캡슐화할 필요가 없고, 불변 데이터로부터  
  나오는 정보는 getter를 통하지 않고 그냥 필드 자체를 공개해도 된다.

<hr/>

<h2>상속 포기</h2>

- 서브클래스는 부모로부터 메소드와 데이터를 물려받는다. 하지만 부모의 유산을 원치 않거나  
  필요 없다면 어떻게 해야할까? 수많은 유산 중에서 관심 있는 몇 개만 받고 끝내려는 경우는  
  얼마든지 있을 수 있다.

- 예전에는 계층구조를 잘못 설계했기에 이런 일이 발생한 것이라 생각했다.  
  이 관점에서의 해법은 먼저 같은 계층에 서브클래스를 하나 새로 만들고, **메소드 내리기**와  
  **필드 내리기**를 활용해서 물려받지 않을 부모 코드를 모조리 새로 만든 서브클래스로 넘기는 것이다.  
  그러면 부모 클래스에는 공통된 부분만 남는다. 한 걸음 더 나아가 부모 클래스는 모두 추상 클래스여야  
  한다고 말하는 사람도 많다.

- 앞에서 _"예전에는"_ 이라고 한 데서 눈치챘겠지만, 저자는 이 방식을 권하지 않는다.  
  일부 동작을 재활용하기 위한 목적으로 상속을 활용하기도 하는데, 실무 관점에서 아주 유용한 방식이다.  
  따라서 상속을 포기할 시 혼란과 문제가 생긴다면 앞서 설명한 예전 방식을 따르자.  
  단, 무조건 이래야 한다는 생각은 버리자.

- 상속 포기 냄새는 서브클래스가 부모의 동작은 필요로하지만, 인터페이스는 따르고 싶지 않을 때  
  특히 심하게 난다. 구현을 따르지 않는 것은 이해할 수 있지만 인터페이스를 따르지 않는다는 것은  
  상당히 무례한 태도다. 이럴 때는 **서브클래스를 위임으로 바꾸기**나 **슈퍼클래스를 위임으로 바꾸기**를  
  활용해서 아예 상속 메커니즘에서 벗어나보자.

<hr/>

<h2>주석</h2>

- 주석은 악취가 아닌 향기를 남기지만, 문제는 주석을 탈취제처럼 사용하는 데 있다.  
  주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 의외로 많다.

- 특정 코드 블록이 하는 일에 주석을 남기고 싶다면 **함수 추출하기**를 적용하자.  
  이미 추출되어 있는 함수임에도 불구하고 여전히 설명이 필요하다면 **함수 선언 바꾸기**로  
  함수명을 바꿔보자. 시스템이 동작하기 위한 선행조건을 명시하고 싶다면 **assertion 추가하기**가  
  대기하고 있다.

> 주석을 남겨야겠다는 생각이 든다면, 가장 먼저 **주석이 없는 코드로 리팩토링** 해보자.

- 뭘 할지 모를 때라면 주석을 달아두는 것이 좋다.  
  현재 진행 상황 뿐만 아니라 확실하지 않은 부분에 주석을 남긴다.  
  코드를 지금처럼 작성한 이유를 설명하는 용도로 달 수도 있다.  
  이런 정보는 나중에 코드를 수정해야할 프로그래머에게, 특히 건망증이 심한 프로그래머에게 도움될 것이다.

<hr/>
