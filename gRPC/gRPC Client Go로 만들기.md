# gRPC Client Go로 만들기

- [원본 코드](https://github.com/Example-Collection/go-grpc-client)

- Proto 파일을 컴파일하고 import하는 과정은 [여기](https://github.com/sang-w0o/Study/blob/master/gRPC/gRPC%20Server%20Go%EB%A1%9C%20%EB%A7%8C%EB%93%A4%EA%B8%B0.md#grpc-server-go%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0)에서 확인할 수 있다.

<details><summary>Proto File</summary>

<p>

```proto
syntax = "proto3";

package proto;

option go_package="github.com/Example-Collection/go-grpc-client/proto";

service PersonService {
  // 사용자 정보 저장 요청, Unary RPC
  rpc GetPersonInformation(PersonRequest) returns (PersonResponse) {}

  // email이 일치하는 모든 사용자 정보 요청, Server Streaming RPC
  rpc ListPersons(ListPersonRequest) returns (stream PersonResponse) {}

  // 다수의 사용자 저장 요청, Client Streaming RPC
  rpc savePersons(stream PersonRequest) returns (BasicResponse) {}

  // 사용자 정보 실시간 요청, Bidirectional Streaming RPC
  rpc askAndGetPersons(stream PersonRequest) returns (stream PersonResponse) {}
}

message PersonRequest {
  string name = 1;
  int64 age = 2;
  string email = 3;
  string password = 4;
}

message PersonResponse {
  string name = 1;
  int64 age = 2;
  string email = 3;
  string message = 4;
}

message ListPersonRequest {
  string email = 1;
}

message BasicResponse {
  string message = 1;
}
```

</p></details>

## Client 구축하기

- Client를 실행하기 위한 코드부터 보자.

```go
var (
	serverAddr = flag.String("addr", "localhost:8081", "The server address in the format of host:port")
)

func main() {

  // Create gRPC Channel
	conn, err := grpc.Dial(*serverAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Fatalf("failed to dial: %v", err)
	}

  // Close gRPC Channel when function main() ends.
	defer conn.Close()

  // Get Stub, which is generated by protoc.
	client := pb.NewPersonServiceClient(conn)

	// Unary RPC
	personRequest := &pb.PersonRequest{
		Name:     "Sangwoo",
		Age:      25,
		Email:    "robbyra@gmail.com",
		Password: "sangwooPassword",
	}
	printResponseAfterCallingGetPersonInformation(client, personRequest)
}
```

- Service 메소드를 클라이언트에서 호출하기 위해서는 우선 특정 host, port에 대해 *gRPC Channel*을 만들어야 한다.  
  gRPC Channel은 `grpc.Dial()`을 통해 gRPC Channel을 만들 수 있다.
  그리고 `main()`이 종료되면 꼭 Channel이 _closed_ 상태로 바뀔 수 있도록 `defer conn.Close()`를 추가했다.

> gRPC Channel: gRPC 서버의 특정 host, port에 대한 connection

- Channel이 만들어졌다면, 다음으로는 클라이언트에서 service에 정의된 메소드를 구현한 *Stub*을 사용해 RPC를  
  수행할 수 있어야 한다. 이는 proto file을 컴파일해 나온 `NewPersonServiceClient()`를 사용해 가져올 수 있다.

### Unary RPC

- 가장 먼저 Unary RPC인 `GetPersonInformation`을 구현해보자.  
  아래 코드의 핵심은 Stub인 `pb.PersonServiceClient`에 대해 `GetInformation()`을 호출했다는 것이다.  
  호출 전, 호출 후에는 콘솔에 내용을 출력하도록 했다.

```go
func printResponseAfterCallingGetPersonInformation(client pb.PersonServiceClient, req *pb.PersonRequest) {

  // Print to console beefore sending request.
	log.Printf("Sending request to save person (name: %v, age: %d, email: %v)", req.Name, req.Age, req.Email)

  // Create context with deadline.(10 seconds)
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

  // Call RPC
	response, err := client.GetPersonInformation(ctx, req)
	if err != nil {
		log.Fatalf("%v.GetPersonInformation(_) = _, %v", client, err)
	}
	log.Printf("Response: Person(name: %v, message: %v", response.Name, response.Message)
}
```

- `context.WithTimeout()`으로는 10초의 Deadline이 있는 `Context`를 만들었다.  
  만약 서버에서 10초 내에 응답이 오지 않으면, 아래의 예외가 발생한다.

```
2022/01/06 14:55:05 &{0x140001b2000}.GetPersonInformation(_) = _, rpc error: code = DeadlineExceeded desc = context deadline exceeded
```

- 위에서 만든 `Context`와 request 파라미터(`*pb.PersonRequest`)와 함께 stub에 대해 `GetPersonInformation()`을 호출한다.  
   그리고 마지막에 응답이 오면 콘솔에 출력한다.

- 성공적으로 완성된 RPC는 아래와 같은 결과가 콘솔에 출력된다.

```
2022/01/06 14:58:38 Sending request to save person (name: Sangwoo, age: 25, email: robbyra@gmail.com)
2022/01/06 14:58:38 Response: Person(name: Sangwoo, message: Successfully saved!(name:Sangwoo)
```

### Server Streaming RPC

- 이제 Server Streaming RPC를 구현해보자. Server Streaming RPC는 서버에서 단일 응답을 주는게 아니라 일련의 message들을  
  담은 Stream을 반환한다. 따라서 stream에서 message들을 하나씩 읽어오는 부분을 유의해서 보자.

```go
func printResponseAfterCallingListPersons(client pb.PersonServiceClient, req *pb.ListPersonRequest) {
	log.Printf("Sending request to get all persons with email: %v", req.Email)

  // Deadline: 1 hour
	ctx, cancel := context.WithTimeout(context.Background(), time.Hour)
	defer cancel()

  // Get stream
	stream, err := client.ListPersons(ctx, req)
	if err != nil {
		log.Fatalf("%v.ListPersons(_) = _, %v", client, err)
	}

  // Read messages from stream
	for {
    // Read single message
		person, err := stream.Recv()

    // If err is EOF, break for statement.
		if err == io.EOF {
			break
		}

		if err != nil {
			log.Fatalf("%v.ListPersons(_) = _, %v", client, err)
		}
		log.Printf("Response: Person(name: %v, message: %v)", person.Name, person.Age)
	}
}
```

- 생각보다 단순한데, stub에 대해 Server Streaming RPC인 `ListPersons()`를 호출하면 stream이 반환된다.  
  그리고 for문을 이용해 한 번 반복될 때마다 stream의 `Recv()`를 이용해 message를 꺼내온다.  
  이때, 메시지가 더이상 없다면 `EOF` 값을 담은 error가 반환되기에, 이 경우를 검사해 break를 지정해주었다.

- 정상적으로 요청이 수행되면, 서버에서 1초 간격으로 stream에 message를 담게 했기에 아래 내용이 콘솔에도 1초 간격으로 출력된다.

```
2022/01/06 15:19:07 Response: Person(name: sangwooAged25, message: 25)
2022/01/06 15:19:08 Response: Person(name: sangwooAged26, message: 26)
2022/01/06 15:19:09 Response: Person(name: sangwooAged27, message: 27)
```

### Client Streaming RPC

### Bidirectional Streaming RPC
