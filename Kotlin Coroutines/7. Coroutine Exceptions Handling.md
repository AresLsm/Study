# Coroutine Exceptions Handling

## Exception Propagation

- Coroutine builder는 크게 두 가지로 나뉜다. `launch()`와 `actor()` 처럼 예외들을 자동으로 전파(propatate)하는 것과,  
  `async()`와 `produce()` 처럼 사용자에게 노출(expose)하는 것이 있다. 이들 builder들은 다른 coroutine의 자식 coroutine이 아니라  
  root coroutine을 만드는데, `launch()`와 `actor()`는 예외를 Java의 `Thread.uncaughtExceptionHandler`처럼 Uncaught exception 처럼  
  취급하고, `async()`와 `produce()`는 사용자들로 하여금 최종적으로 예외를 consume하도록 한다.

- `GlobalScope`에서 root coroutine을 만드는 간단한 예제를 통해 확인해보자.

```kt
@OptIn(DelicateCoroutinesApi::class)
fun main() = runBlocking {
	val job = GlobalScope.launch {
		println("Throwing exception from launch")
		throw IndexOutOfBoundException()
	}
	job.join()
	println("Joined failed job")
	val deffered = GlobalScope.async {
		println("Throwing exception from async")
		throw ArithmeticException()
	}
	try {
		deferred.await()
		println("Unreached")
	} catch(e: ArithmeticException) {
		println("Caught ArihmeticException")
	}
}

/*
Throwing exception from launch
Exception in thread "DefaultDispatcher-worker-2 @coroutine#2" java.lang.IndexOutOfBoundsException
Joined failed job
Throwing exception from async
Caught ArithmeticException
*/
```

---

## CoroutineExceptionHandler

- Uncaught exception은 기본적으로 콘솔에 예외 정보를 출력하고 마는데, 이러한 기본적인 동작을 customize할 수 있다.  
  Root coroutine의 context element인 `CoroutineExceptionHandler`은 root coroutine과 해당 root coroutine의  
  자식 coroutine들에 대한 `catch { .. }` block처럼 사용될 수 있다. `Thread.uncaughtExceptionHandler`와 비슷하다.  
  `CoroutineExceptionHandler`에 도달했다는 것은 이미 해당 예외를 발생시킨 coroutine이 종료되었음을 의미하기 때문에  
  `CoroutineExceptionHandler` 내에서는 exception recovery가 불가하다. 이 `CoroutineExceptionHandler`는 보통  
  exception을 logging하고, 특정 에러 메시지를 보내고, 애플리케이션을 종료하거나 재시작하는 등에 사용된다.

- `CoroutineExceptionHandler`는 오로지 uncaught exception들에 대해서만 호출된다. 즉, 어떠한 방식으로든 handling되지 않은  
  예외들에 의해서만 호출된다는 것이다. 자식 coroutine들은 예외가 발생하면 parent로 delegate하고, parent는 또 그의 parent로  
  delegate하고, 이렇게 root coroutine에게까지 위임하게 된다. 그러면 child coroutine scope 내에 있는 `CoroutineExceptionHandler`는  
  아무런 일도 하지 못하게 된다.(의미가 없다.) 추가적으로 `async()` builder는 모든 예외들을 catch하고 이를 `Deffered`에 담아 반환하기에  
  여기에서도 `CoroutineExceptionHandler`의 사용은 무의미하다.

```kt
val handler = CoroutineExceptionHandler { _, exception ->
	println("CoroutineExceptionHandler got $exception")
}

val job = GlobalScope.launch(handler) {
	throw AssertionError()
}

val deffered = GlobalScope.async(handler) {
	throw ArithmeticException()
}

joinAll(job, deferred)

/*
CoroutineExceptionHandler got java.lang.AssertionError
*/
```

- 위 코드로 `async()` builder 내에서 throw된 `ArithmeticException`은 `CoroutineExceptionHandler`에 의해 처리되지 않음을 볼 수 있다.

---

## Cancellation and exceptions

- Cancellation은 예외와 밀접한 연관 관계를 갖는다. Coroutine들은 내부적으로 cancellation을 위해 `CancellationException`을 사용하고,  
  모든 handler들은 이 예외를 무시한다. 이 예외는 debug를 위해 사용될 수 있고, `catch { .. }` block으로 catch될 수 있다.  
  Coroutine이 `Job.cancel()`로 cancel되면 해당 coroutine은 작업 종료되지만, parent까지 종료시키지는 않는다.

```kt
val job = launch {
	val child = launch {
		try {
			delay(Long.MAX_VALUE)
		} finally {
			println("Child is cancelled")
		}
	}
	yield()
	println("Cancelling child")
	child.canel()
	child.join()
	yield()
	println("Parent is not cancelled")
}
job.join()

/*
Cancelling child
Child is cancelled
Parent is not cancelled
*/
```

- 만약 coroutine이 `CancellationException`이 아닌 다른 예외를 발생시키게 되면, 그 coroutine은 해당 예외와 함께 부모 coroutine도  
  종료시킨다. Structured concurrency를 위해 이런 coroutine의 동작은 override가 불가하다.

- 아래 예외 코드에서 알 수 있듯이 모든 children들이 terminate되면, exception은 부모에 의해 handling된다.

```kt
val handler = CoroutineExceptionHandler { _, exception ->
	println("CoroutineExceptionHandler got $exception")
}

val job = GlboalScope.launch(handler) {
	launch {
		try {
			delay(Long.MAX_VALUE)
		} finally {
			withContext(NonCancellable) {
				println("Children are cancelled, but exception is not handled until all children terminate")
				delay(100)
				println("The first child finished its non cancallable block")
			}
		}
	}
	launch {
		delay(10)
		println("Second child throws an exception")
		throw ArithmeticException()
	}
}
job.join()

/*
Second child throws an exception
Children are cancelled, but exception is not handled until all children terminate
The first child finished its non cancallable block
CoroutineExceptionHandler got java.lang.ArithmeticException
*/
```

---

## Exceptions aggregation

- 만약 여러 개의 child roroutine들이 예외를 발생시키며 실패하면, 일반적으로는 _"첫 번째 예외가 이기는"_ 규칙, 즉 첫 번째 예외만 handling된다.  
  첫 번째 예외 이후에 발생하는 모든 예외들은 첫 번째 예외에 _attach_ 되며, suppress 처리된다.

```kt
@OptIn(DelicateCoroutinesApi::class)
fun main() = runBlocking {
	var handler = CoroutineExceptionHandler { _, exception ->
		println("CoroutineExceptionHandler got $exception with suppressed ${exception.suppressed.contentToString()}")
	}
	val job = GlobalScope.launch(handler) {
		launch {
			try {
				delay(Long.MAX_VALUE)
			} finally {
				throw ArithmeticException()
			}
		}
		launch {
			delay(100)
			throw IOException()
		}
		delay(Long.MAX_VALUE)
	}
	job.join()
}

/*
CoroutineExceptionHandler got java.io.IOException with suppressed [java.lang.ArithmeticException]
*/
```

- 반면 `CancellationException`은 투명하고, 기본적으로 unwrap된다.

```kt
val handler = CoroutineExceptionHandler { _, exception ->
	println("CoroutineExceptionHandler got $exception")
}

val job = GlobalScope.launch(handler) {
	val inner = launch {
		launch {
			launch {
				throw IOException()
			}
		}
	}
	try {
		inner.join()
	} catch(e: CancellationException) {
		println("Rethrowing CancellationException with original cause")
		throw e
	}
}
job.join()

/*
Rethrowing CancellationException with original cause
CoroutineExceptionHandler got java.io.IOException
*/
```

- 위 코드에서 첫 번째로 발생한 예외는 `IOException`이다. 하지만 try-catch block에서 `CancellationException`이 catch 되었다.  
  즉, `CancellationException`은 다른 예외들 처럼 처음 발생한 예외인 `IOException`에 attach 되고, suppress 처리되지 않는다는 뜻이다.

---
