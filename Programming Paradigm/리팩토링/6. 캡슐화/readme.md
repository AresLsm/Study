# 캡슐화

- 모듈을 분리하는 가장 중요한 기준은 아마도 시스템에서 각 모듈이 자신을 제외한 다른 부분에 드러내지  
  않아야할 비밀을 얼마나 잘 숨기느냐에 있을 것이다. 이러한 비밀 중 대표적인 형태인 데이터 구조는  
  **레코드 캡슐화하기**와 **컬렉션 캡슐화하기**로 캡슐화해서 숨길 수 있다. 심지어 기본형 데이터도  
  **기본형을 객체로 바꾸기**를 적용해 캡슐화할 수 있다. 리팩토링할 때 임시 변수가 자주 걸리는데,  
  정확한 순서로 계산해야 하고 리팩토링 후에도 그 값을 사용하는 코드에서 접근할 수 있어야 하기 때문이다.  
  이럴 때는 **임시 변수를 질의 함수로 바꾸기**가 상당히 도움된다. 특히 길이가 너무 긴 함수를  
  쪼개는 데 유용하다.

- 클래스는 본래 정보를 숨기는 용도로 설계되었다. 앞 장에서는 **여러 함수를 클래스로 묶기**로 클래스를  
  만드는 방법을 봤다. 이 외에도 흔히 사용하는 추출하기/인라인하기 리팩토링의 클래스 버전인 **클래스 추출하기**와  
  **클래스 인라인하기**도 활용할 수 있다.

- 클래스는 내부 정보뿐 아니라 클래스 사이의 연결 관계를 숨기는데도 유용하다. 이 용도로는 **위임 숨기기**가  
  있다. 하지만 너무 많이 숨기려다 보면 인터페이스가 비대해질 수 있으니 반대 기법인 **중개자 제거하기**도 필요하다.

- 가장 큰 캡슐화 단위는 클래스와 모듈이지만, 함수도 구현을 캡슐화한다. 때로는 알고리즘을 통째로 바꿔야할 때가  
  있는데, **함수 추출하기**로 알고리즘 전체를 함수 하나에 담은 뒤, **알고리즘 교체하기**를 적용하면 된다.

## 레코드 캡슐화하기

```js
// 리팩토링 적용 전
const organization = { name: "Study", country: "KR" };

// 리팩토링 적용 후
class Organization {
  constructor(data) {
    this._name = data.name;
    this._country = data.country;
  }

  get name() {
    return this._name;
  }
  set name(arg) {
    this._name = arg;
  }
  get country() {
    return this._country;
  }
  set country(arg) {
    this._country = arg;
  }
}
```

### 배경

- 대부분의 프로그래밍 언어는 데이터 레코드를 표현하는 구조를 제공한다. 레코드는 연관된 여러  
  데이털들 직관적인 방식으로 묶을 수 있어서 각각을 따로 취급할 때보다 훨씬 의미 있는 단위로  
  전달할 수 있게 해준다. 하지만 단순한 레코드에는 단점이 있다. 특히, 계산해서 얻을 수 있는  
  값과 그렇지 않은 값을 명확히 구분해 저장해야 하는 점이 번걸보다. 가령, 값의 범위를 표현하려면  
  `{start: 1, end: 5}`나 `{start:1, length: 5}` 등의 방식으로 저장할 수 있다.  
  어떤 식으로 저장하든 _시작_ 과 _끝_ 의 _길이_ 를 알 수 있어야 한다.

- 바로 이 때문에 **가변 데이터를 저장하는 용도로는 레코드보다 객체가 더 적합**하다.  
  객체를 사용하면 어떻게 저장했는지를 숨긴 채 세 가지 값을 각각의 메소드로 제공할 수 있다.  
  사용자는 무엇이 저장된 값이고, 무엇이 계산된 값인지 알 필요가 없다. 캡슐화하면 이름을  
  바꿀 때도 좋다. 필드명을 바꿔도 기존 이름과 새 이름 모두를 각각의 메소드로 제공할 수 있어서,  
  사용자 모두가 새로운 메소드로 옮겨갈 때까지 점진적으로 수정할 수 있기 때문이다.

- 저자는 _가변_ 데이터일 때 객체를 선호한다. 값일 분면이라면 단순히 _시작_ 과 _끝_ 의 _길이_ 를  
  모두 구해서 레코드에 저장하면 된다. 이름을 바꿀 때는 그저 필드를 복제하면 된다. 그러면 앞서 객체를  
  활용해 수정 전후의 두 메소드를 동시에 제공한 방식과 비슷하게 점진적으로 수정할 수 있다.

- 레코드 구조는 두 가지로 구분할 수 있다. 하나는 필드명을 노출하는 형태고, 다른 하나는 필드를 외부로부터  
  숨겨 개발자가 원하는 이름을 쓸 수 있는 형태다. 후자는 주로 라이브러리에서 Hash, Map, HashMap,  
  Dictionary, 연관 배열(Associative Array) 등의 이름으로 제공한다. 많은 프로그래밍 언어가  
  HashMap을 쉽게 만드는 문법을 제공한다. HashMap은 다양한 프로그래밍 작업에 유용하지만, 필드를 명확히  
  알려주지 않는다는 것이 단점이 될 수 있다. 범위를 `{시작, 끝}` 또는 `{시작, 길이}` 중 어떤 방식으로  
  표현하는지 알아내는 유일한 길은 HashMap을 생성하고 사용하는 코드를 직접 확인하는 방법 뿐이다.  
  프로그램에서 HashMap을 쓰는 부분이 적다면 문제되지 않지만, 사용하는 곳이 많을수록 불분명함으로 인해  
  발생하는 문제가 커진다. 이러한 불투명한 레코드를 명시적인 레코드로 리팩토링해도 되지만, 그럴 바에는 레코드  
  대신 클래스를 사용하는 편이 낫다.

- 코드를 작성하다보면 중첩된 리스트나 해시맵을 받아서 JSON, XML 등의 포맷으로 직렬화할 때가 많다.  
  이런 구조 역시 캡슐화할 수 있는데, 그러면 나중에 포맷을 바꾸거나 추적하기 어려운 데이터를 수정하기가  
  수월해진다.

### 절차

- (1) 레코드를 담은 변수를 캡슐화한다.  
  레코드를 캡슐화하는 함수명은 검색하기 쉽게 지어준다.

- (2) 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다. 이 클래스에 원본 레코드를 반환하는 접근자도  
  정의하고, 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정한다.

- (3) 테스트한다.

- (4) 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다.

- (5) 레코드를 반환하는 예전 함수를 사용하는 코드를 `(4)`에서 만든 새 함수를 사용하도록 바꾼다.  
  필드에 접근할 때는 객체의 접근자를 사용하며, 적절한 접근자가 없다면 추가한다. 한 부분을 바꿀 때마다 테스트한다.  
  클라이언트가 데이터를 읽기만 한다면 데이터의 복제본이나, 읽기 전용 proxy를 반환할지 고려해본다.

- (6) 클래스에서 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수들을 제거한다.

- (7) 테스트한다.

- (8) 레코드의 필드도 데이터 구조인 중첩 구조라면, 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용한다.

### 예시: 간단한 레코드 캡슐화하기

```js
const organization = { name: "Study", country: "KR" };
```

- 위 상수는 프로그램 곳곳에서 레코드 구조로 사용하는 JS 객체로서, 아래와 같이 읽고 쓴다.

```js
result += `<h1>${organization.name}</h1>`; // 읽기
organization.name = "newName"; // 쓰기
```

- 가장 먼저 _(1) 레코드를 담은 변수를 캡슐화_ 해보자.

```js
function getRawDataOrganization() {
  return organization;
}
```

- 그러면 읽고 쓰는 코드는 아래처럼 바뀐다.

```js
result += `<h1>${getRawDataOrganization().name}</h1>`; // 읽기
getRawDataOrganization().name = "newName"; // 쓰기
```

- 그런데 방금 **변수 캡슐화하기**를 정식으로 따르지 않고, getter를 찾기 쉽도록 의도적으로  
  이상한 이름을 붙였다. 이 getter는 임시적으로 사용할 것이기 때문이다.

- 레코드를 캡슐화하는 목적은 변수 자체는 물론, 그 내용을 조작하는 방식도 통제하기 위함이다.  
  이렇게 하려면 _(2) 레코드를 클래스로 바꾸고_, _(4) 새 클래스의 인스턴스를 반환하는 함수를 새로 만든다._

```js
class Organization {
  constructor(data) {
    this._data = data;
  }
}

const organization = new Organization({ name: "Study", country: "KR" });
function getRawDataOrganization() {
  return organization._data;
}
function getOrganization() {
  return organization;
}
```

- 객체로 만드는 작업이 끝났으니, _(5) 레코드를 사용하던 코드를 살펴보자._  
  레코드를 갱신하던 코드는 모두 setter를 사용하도록 고친다.

```js
class Organization {
  //..
  set name(aString) {
    this._data.name = aString;
  }
}

// client
getOrganization().name = "newName";
```

- 마찬가지로, 레코드를 읽는 코드는 모두 getter를 사용하도록 바꾼다.

```js
class Organization {
  //..
  get name() {
    return this._data.name;
  }
}

// client
result += `<h1>${getOrganization().name}</h1>`;
```

- _(6) 다 바꿨다면 앞서 이상한 이름으로 지었던 임시 함수를 제거한다._  
  마지막으로, \_data의 필드들을 객체 안에 바로 펼쳐놓으면 더 깔끔할 것 같다.

```js
class Organization {
  constructor(data) {
    this._name = data.name;
    this._country = data.country;
  }
  get name() {
    return this._name;
  }
  set name(aString) {
    this._name = aString;
  }
  get country() {
    return this._country;
  }
  set country(aCountryCode) {
    this._country = aCountryCode;
  }
}
```

- 이렇게 하면 입력 데이터 레코드와의 연결을 끊어준다는 이점이 생긴다. 특히 이 레코드를 참조하여  
  캡슐화를 깰 우려가 있는 코드가 많을 때 좋다. 데이터를 개별 필드로 펼치지 않았다면  
  \_data 를 대입할 때 복제하는 식으로 처리했을 것이다.

### 중첩된 레코드 캡슐화하기

- 앞서는 단순한 레코드를 캡슐화하는 방법을 보았는데, JSON 문서처럼 여러 겹 중첩된 레코드라면  
  어떻게 해야할까? 리팩토링의 기본 절차는 똑같고 갱신하는 코드에 주의해야 한다는 점도 같지만,  
  읽는 코드를 다룰 때는 선택지가 몇 가지 더 생긴다.

- 중첩 정도가 심할수록 읽거나 쓸 때 데이터 구조 안으로 더 깊숙히 들어가야 한다.  
  예를 들어, 아래처럼 될 수 있다.

```js
customerData[customerID].usage[year][month] = amount;
```

- 가장 먼저 앞서 본 예시와 마찬가지로 **변수 캡슐화**를 진행하고, 그런 다음 전체 데이터 구조를 표현하는  
  클래스를 정의하고, 이를 반환하는 함수를 새로 만들자.

- 기본 절차에 따르면 customerData 객체를 반환하고, 필요한 접근자를 만들어서 사용하게 하면 된다.  
  따라서 데이터 구조 안으로 들어가는 코드를 setter로 뽑아내야 한다. 그런 다음, 뽑아낸 setter함수를  
  데이터 클래스로 옮긴다.

- 데이터 구조의 덩치가 클 수록 **쓰기 부분에 집중**해야 한다. 캡슐화에서는 값을 수정하는 부분을 명확하게  
  드러내고 한 곳에 모아두는 일이 굉장히 중요하다.

- 읽기 부분을 처리할 때는 몇 가지 방법이 있다.  
  첫째, **setter 때와 같은 방법을 적용할 수 있다. 즉, 읽는 코드를 모두 독립 함수로 추출한 다음 클래스로**  
  **옮기는 것이다.** 이 방법의 가장 큰 장점은 클래스의 모든 쓰임을 명시적인 API로 제공한다는 것이다.  
  클래스만 봐도 데이터 사용 방법을 모두 파악할 수 있다. 하지만 읽는 패턴이 다양하면, 그만큼 작성할  
  코드량이 늘어난다. 요즘 언어들에서는 List-Hash 데이터구조를 쉽게 다룰 수 있는데, 이런 언어를 사용한다면  
  클라이언트에 데이터를 이 형태로 넘겨주는 것도 좋다.

> List-Hash: Hashmap이 List의 원소로 된 자료 구조, <a href="https://martinfowler.com/bliki/ListAndHash.html">링크</a>

- 다른 방법으로, 클라이언트가 데이터 구조를 요청할 때 실제 데이터를 제공해도 된다. 하지만 이렇게 하면  
  클라이언트가 데이터를 직접 수정하지 못하게 막을 방법이 없어서 _모든 쓰기를 함수내에서 처리한다._ 는  
  캡슐화의 핵심 원칙이 깨지게 된다. 따라서 가장 간단한 방법은 내부 데이터를 복제해서 제공하는 것이다.

- 이 방법은 간단하지만 문제가 있다. 바로 눈에 띄는 데이터 구조가 클수록 복제 비용이 커지기에  
  성능이 느려질 수 있다는 것이다. 하지만 다른 경우와 마찬가지로 성능 비용을 감당할 수 있는  
  상황일 수도 있다. 막연히 걱정만 하지 말고, 얼마나 영향을 주는지 실제로 측정 해보자.  
  또다른 문제는, 클라이언트가 원본을 수정하고 있다고 착각할 수 있다는 것이다. 이럴 때는 읽기 전용  
  proxy를 제공하거나, 복제본을 동결(freeze)시켜 데이터를 수정하려 할 때 에러를 던지도록 할 수 있다.

<hr/>
