<h1>고급 스타일링 기법</h1>

<h2>플랫폼별 크기와 스타일</h2>

* `Platform.select`를 통해 iOS 또는 안드로이드에서만 사용할 수 있는 폰트를 선택할 수 있다.
```js
// 예제
const styles = StyleSheet.create({
    centeredText: {
        textAlign: 'center',
        margin: 10,
        fontSize: 24,
        ...Platform.select({
            ios: {
                fontFamily: 'American Typewriter'
            },
            android: {
                fontFamily: 'monospace'
            }
        })
    }
})
```
* 위와 같이 항상 __두 개의 다른 플랫폼에서 동작하는 앱을 개발하고 있다는 점__ 을 염두해야 한다.   
  이전까지 `width`를 지정할 때 값을 `px` 단위로 지정한 적이 없다. 이 이유는 크기의 개념이 iOS와 안드로이드에서 다르기 때문이다.

<h3>픽셀(px), 포인트(pt), dp</h3>

* `픽셀`은 디스플레이에 표현되는 프로그래밍할 수 있는 가장 작은 단위의 색상이며, `RGB`로 구성된다. 각 RGB 값의 농도를   
  조절해서 픽셀은 사용자가 보는 생상을 만들어낸다. 픽셀 단위는 화면의 크기나 1인치당 도트의 수와 같이 물리적인 단위로   
  수치가 정해지지 않는다면 아무런 의미를 가지지 못한다.
* `화면 크기`는 한 모서리부터 대각선 모서리까지의 대각선 길이를 나타낸다.
* `해상도`는 디스플레이에 표시되는 픽셀 수 이며, 보통 디바이스의 높이와 폭에 표현되는 픽셀 수를 의미한다.

* 화면 크기와 해상도를 알아야 픽셀 밀도인 1인치당 픽셀 수(PPI)를 계산할 수 있다. DPI는 1인치당 도트의 수 이며, DPI는   
  인쇄에서 사용되는 용어이다. 따라서 화면에 대해 언급할 때 DPI를 보게 된다면 실제로 이는 PPI를 의미한 것이다.

* iOS나 안드로이드는 디바이스의 화면에 내용물들을 렌더링할 때 실제 물리 단위를 사용하지 않는다.   
  iOS는 `Point`라는 추상적인 단위를 사용하며, 안드로이드는 이와 유사하게 추상적인 단위인 `DP`를 사용한다.

* 예를 들어 아이폰4는 전작과 동일한 화면 크기로 출시되었지만, 기존은 320X480의 해상도인 반면, 아이폰4는 640X960의 해상도로,   
  기존의 앱을 1:1비율로 아이폰4에서 렌더링한다면, 크기가 1/4로 축소돼 보였을 것이다. 이러한 문제를 해결하기 위해 애플은   
  `Point-PT`라는 논리적인 개념을 도입했다. `Point`는 디바이스의 해상도와 상관없이 확대나 축소될 수 있는 거리의 단위이다.

* React Native에서 스타일을 정의할 때, 픽셀의 논리적인 개념을 이용한다. 즉, iOS에서는 PT를, 안드로이드에서는 DP를 사용한다.   
  Native 언어를 사용하여 앱을 개발할 때에는 간혹 논리적인 픽셀 단위의 화면에 화면 크기(scale)를 곱해서 디바이스 픽셀로   
  작업할 필요도 있다.

<h3>shadowPropTypesIOS와 elevation 속성으로 음영 넣기</h3>

* iOS와 안드로이드 모두 `Text` 컴포넌트에 음영을 넣는 기능을 지원하지만, `View` 컴포넌트에 대해서는 iOS와 안드로이드에서   
  공통으로 사용할 수 있는 스타일 속성이 없다. iOS는 `shadowPropTypesIOS` 스타일 속성을 이용하고, 안드로이드는 `elevation`   
  속성으로 음영 효과를 낼 수 있다. `shadowPropTypesIOS`는 컴포넌트의 z-order에 영향을 주지 않으며, `elevation`은 z-order에   
  영향을 준다.

* `shadowPropTypesIOS` 스타일 속성을 이용하여 `View` 컴포넌트에 음영을 넣는 방법은 아래와 같다.
  * `shadowOpacity`속성값을 지정하지 않으면 음영이 나타나지 않는다. (1 : 완전히 불투명, 0.2 : 좀 더 투명하게 보임)
  * `shadowOffset`값은 폭과 높이로 표시하지만, 음영을 x와 y방향으로 이동한다고 생각해도 무방하며, 음수값을 지정할 수 있다.
  * `shadowRadius` : 음영의 모서리를 blur 처리하여 표현하여 좀 더 분산되어 보이게 한다.

* 안드로이드에서 iOS와 동일한 음영 효과를 낼 수는 없지만, 안드로이드의 `elevation` 스타일 속성을 이용하여 컴포넌트의   
  z-order에 영향을 줄 수는 있다. 두 개 이상의 컴포넌트가 같은 공간에 있을 때, 전면에 나올 컴포넌트에 더 높은 `elevation`값,   
  즉 더 높은 z-index 값을 지정해서 약간의 음영 효과를 낼 수 있다. 하지만 iOS에서와 같이 두드러진 음영 효과를 기대할 순 없다.

```js
const styles = StyleSheet.create({
    
    //..

    ,
    cardImageContainer: {
        paddingTop: 15,
        Platform.select({
            ios: {
                shadowColor: 'black',
                shadowOffset: {
                    height: 10
                },
                shadowOpacity: 1
            },
            android: {
                borderWidth: 3,
                borderColor: 'black',
                elevation: 15
            }
        })
    }
})
```
* 위 코드는 `Platform.select`를 사용하여 플랫폼에 따라 컴포넌트에 다른 스타일을 적용하도록 하고 있다.
<hr/>

<h2>컴포넌트의 이동, 회전, 크기 변경, 기울이기</h2>

* 다른 컴포넌트와 상관없이 하나의 컴포넌트를 화면 내에서 위치나 방향을 조작하는 것은 변형을 이용하면 된다.   
  React Native는 3차원에서 컴포넌트의 모양이나 위치를 변경할 수 있는 다수의 유용한 변형 스타일들을 제공한다.

* `transform` 스타일은 컴포넌트에 어떠한 변형 효과들을 적용할 것인지를 정의하는 `transform`속성들의 배열을 인수로 갖는다.   
  아래 예시는 컴포넌트를 90도로 회전하고 그 크기를 50%로 축소한다.
```js
transform: [{rotate: '90dg', sacle: .5}]
```
  * `transform` 스타일은 아래의 속성들을 지원한다.
    * `perspective`
    * `translateX`, `translateY`
    * `rotateX`, `rotateY`, `rotateZ(rotate)`
    * `scale`, `scaleX`, `scaleY`
    * `skewX`, `skewY`

<h3>3D 효과를 내기 위한 perspective 속성</h3> 

* `perspective` 속성은 사용자와 화면 사이의 거리를 조정해서 화면 내 요소들에 3차원 공간을 만든다. 3차원 효과(3D Effect)를   
  내기 위해서 이 속성에 다른 속성들을 함께 사용하게 된다. `perspective` 속성값이 커질수록 컴포넌트의 z-index값도 커지며,   
  컴포넌트가 사용자에게 좀 더 가깝게 보이도록 한다. z-index값이 음수이면, 컴포넌트는 멀리 떨어진 것 처럼 보이게 된다.

<h3>translateX, translateY 속성으로 이동하기</h3>

* `translation` 속성들은 하나의 요소를 현 위치에서 x축 또는 y축을 따라 이동시킨다. 이 속성은 컴포넌트를 화면의 한 곳에서   
  다른 곳으로 이동시키는 애니메이션 효과를 낼 때에는 유용하게 사용할 수 있다.

* 한 개의 컴포넌트는 `translateX`와 `translateY` 속성으로 기존 위치에서 8방위로 이동시킬 수 있다. Z 평면으로는   
  컴포넌트를 이동시킬 수 있다. Z 축은 사용자가 바라보고 있는 화면과 수직이므로 컴포넌트의 크기 변화 없이는 컴포넌트를   
  앞이나 뒤로 이동시켜도 그 변화를 인지할 수 없다. Z 축을 통한 시각 효과를 내려면 `perspective` 속성을 이용하면 된다.

<h3>rotateX, rotateY, rotateZ 속성으로 컴포넌트 회전하기</h3>

* `rotation` 속성들은 요소를 회전시킨다. 회전은 x, y, z 축을 따라 일어나며, 회전의 기준점(origin)은 어떠한 변형도   
  적용되기 전의 요소의 중앙이다. `translateX`와 `translateY` 속성을 이용할 때에는 컴포넌트의 원래 위치의 축을 기준으로   
  회전한다는 점을 명심해야 한다. 회전의 정도는 도(deg) 또는 라디안(rad)로 지정한다.   
  아래의 예시는 도를 사용한다.
```js
transform: [{rotate: '45deg'}]
transform: [{rotate: '0.785398rad'}]
```

* 예시 : 책 p.207

* `transform` 속성은 변형의 배열이며, 이를 이용해서 복수의 변형을 한 번에 적용할 수 있다. 이 때, 적용되는 순서가 중요하다.   
  즉, 변형의 속성값 배열에서 변형 효과들의 순서를 바꾸면 전혀 다른 결과를 나타낸다.

<h3>90도 이상 회전할 때 visibility 속성 지정하기</h3>

* `backfaceVisibility` 속성은 요소가 90도 이상 회전할 때, 해당 요소를 표시할지를 지정한다. 이 속성의 값으로는 'visible',             
  'hidden'으로 지정할 수 있다. 이 속성은 요소의 변형 효과는 아니지만, 물체의 뒷면을 보여주거나 안 보이도록 처리할 수 있다.   
  기본값은 'visiblie'이며, 이 속성값을 'hidden'으로 바꾸면 컴포넌트를 X축 또는 Y축 방향으로 90도 이상 회전할 때   
  요소를 볼 수 없게 된다.

<h3>scale, scaleX, scaleY 속성으로 화면에서 크기 변경하기</h3>

* 크기 변경(scaling)은 화면 위 물체의 크기를 변경하는데, 이는 다양한 패턴이 있다. 예를 들어, 요소의 섬네일을 만들 때   
  크기 변경을 이용할 수 있다. 많은 앱에서도 사용하는 방법으로 사용자가 섬네일을 탭하면 애니메이션 효과로 요소를 천천히   
  원래의 크기로 표시하며, 시각적인 효과를 주는 일반적인 변형 방법이다.

* `scale` 속성은 요소의 크기를 자신에 지정된 값 만큼 확대/축소하는데, 기본값은 1이다. 요소의 크기를 키우려면 1보다 큰   
  값으로 지정하고, 축소하려면 1보다 작은 값을 지정하면 된다.

* `scaleX` 또는 `scaleY` 속성을 이용하면 요소를 특정한 축을 기준으로 크기 변경할 수 있다. `scaleX` 속성은 X축을 기준으로   
  수평으로 요소의 크기를 변경하며, `scaleY` 속성은 Y축을 기준으로 수직으로 요소의 크기를 변경한다.

<h3>skewX와 skewY 속성을 이용해 X축과 Y축을 따라 기울이기</h3>

* `skewX` 속성은 요소를 X축을 따라 기울이고, `skewY` 속성은 요소를 Y축을 따라 기울인다.   
  `skewX`는 안드로이드에서 제대로 동작하지 않을 수 있으니 주의한다.

<h3>핵심 정리</h3>

* X축과 Y축의 기준점은 __왼쪽 위__ 로, Y축의 양의 방향은 화면의 아래쪽이다. 즉, 기하학에서 익숙한 것과 반대이다.
* 회전과 이동의 기준점은 __항상 요소의 원래 위치__ 이며, X 또는 Y 방향으로 이동한 후에 새로운 중심점에서 회전할 수 없다.

<hr/>

<h2>flexbox를 이용해서 컴포넌트 배치하기</h2>

* `flexbox`는 사용자가 UI를 만들고 위치 조정을 효율적으로 할 수 있도록 React Native가 사용하는 레이아웃 구현체이다.   
  또한 `flexbox`는 `View` 컴포넌트에만 사용할 수 있다.

* 아래는 `flexbox` 레이아웃을 조정하는 정렬 속성들이다.
  * `flex`, `flexDirection`, `justifyContent`, `alignItems`, `alignSelf`, `flexWrap`

<h3>flex 속성으로 컴포넌트의 면적 변경하기</h3> 

* `flex` 속성은 컴포넌트가 속한 컨테이너에서 컴포넌트가 차지하는 면적을 변경할 수 있게 해준다. 이 속성값은 같은 컨테이너에   
  속한 다른 컴포넌트에 지정한 `flex` 속성값에 상대적으로 지정한다.

* 아래는 A와 B가 같은 컨테이너에 속한 컴포넌트라고 가정하여 작성한 예시이다.
```js
// A와 B가 1:1 비율로 배치되어 각각 50%씩의 공간을 차지한다.
A = {flex: 1}, B = {flex: 1}

// C와 D는 1:2 비율로 배치되어 C는 1/3, D는 2/3의 공간을 차지한다.
C = {flex: 1}, D = {flex: 2}
```

* 위와 같이 `flex` 속성값은 비율로 지정할 수도 있지만, 퍼센트 처럼 생각해서 지정할 수 있다. 예를 들어, 아래의 두 예시는   
  동일한 결과를 도출한다.
```js
A = {flex: 1}, B = {flex: 2}

A = {flex: 33}, B = {flex: 66}
```

<h3>flexDirection 속성으로 flex 진행 방향 지정하기</h3>

* 기본적으로 `flex`가 적용된 컨테이너 내의 각 컴포넌트는 Y축으로 배치되어 있다. `flexDirection` 속성을 이용해서 레이아웃의   
  진행 축(axis)를 변경해서 레이아웃의 방향을 바꿀 수 있다. `flexDirection` 속성은 부모 `View` 컨테이너에 지정한다.

* `flexDirection`의 속성값으로는 'row', 'column'이 있으며, 기본값은 'column'이다. 'column'은 수직으로 방향을 배치하며,   
  'row'는 수평 방향으로 배치하게 된다.

<h3>justifyContent 속성으로 컴포넌트 주위 여백 정하기</h3>

* `flex` 속성을 이용하면 각 컴포넌트가 부모 컨테이너에서 어느 정도의 공간을 차지할지 지정할 수 있다. 만약 부모 컨테이너의   
  전체 공간을 사용하지 않게 하려면 `justifyContent` 속성을 이용하면 된다. 

* `justifyContent` 속성은 컨테이너의 `flexDirection`에 따라 배치되는 `flex` 적용 대상들의 사이 간격과 주변 여백을 지정한다.   
  `justifyContent` 속성은 부모 컨테이너에 적용하며, 아래의 5개 옵션을 사용할 수 있다.
  * `center` : 부모 컨테이너 내의 자식 요소들을 중앙에 배치한다. 남는 여백은 모여 있는 자식 요소들의 양 측면에 배치한다.
  * `flex-start` : `flexDirection` 속성에 지정된 값을 기준으로 row 또는 column의 시작점부터 자식 요소들을 배치한다.
  * `flex-end` : `flex-start`의 반대로, 자식 요소들을 부모 컨테이너의 끝에 배치한다.
  * `space-around` : 각 요소 주변으로 공간을 고르게 배치한다. 부모 컨테이너에 요소들을 같은 간격으로 배치하는 것과 혼동하면   
    안되며, 여백을 자식 요소들 주변으로 배치한다. 실제로는 __여백-요소-여백-여백-요소-여백__ 와 같은 배치 결과를 만든다.
  * `space-between` : 컨테이너의 시작과 끝에 여백을 주지 않는다. 연속된 요소들 사이의 여백은 동일하게 배치한다.

<h3>alignItems 속성으로 하위 요소들 정렬하기</h3>

* `alignItems` 속성은 부모 컨테이너의 보조 축을 따라 자식 요소들을 어떻게 정렬할 것인지를 지정한다. 이 속성은   
  `flexDirection`과 마찬가지로 부모 `View` 컴포넌트에 선언하며, `flex`가 적용 가능한 자식 요소들에 영향을 미친다.   
  속성값으로는 'stretch', 'flex-start', 'flex-end'를 사용할 수 있다. 기본값은 'stretch'이다.
  * 보조 축은 진행 축과 상대되는 개념으로, 진행 축의 90도 방향을 의미한다.   
  * `flex-start`는 보조 축의 시작 부분에 자식 요소를 배치하며, `flex-end`는 `flex-start`의 반대이다.

<h3>alignSelf 속성으로 부모에 지정된 정렬 기준 재정의하기</h3>

* `alignSelf` 속성은 위에 나온 `flex` 속성들과 달리, 자식 요소에 직접 적용한다. `alignSelf` 속성으로 부모 컨테이너 내의   
  자식 요소에서 `alignItems` 속성을 조정할 수 있다. `alignSelf` 속성은 부모 컨테이너에 지정된 정렬 기준을 재정의해서   
  특정한 자식 요소가 다른 자식 요소들과는 별개로 정렬할 수 있게 한다. 이 속성에 사용 가능한 값은 'auto', 'stretch',   
  'center', 'flex-start', 'flex-end' 이다. 기본 속성값은 'auto'이며, 부모 컨테이너에 적용된 `alignItems`속성값을   
  그대로 사용한다.

<h3>flexWrap 속성으로 잘려나가지 않도록 하기</h3>

* `flexDirection` 속성은 옵션값으로 'column(기본값)' 과 'row'가 있으며, 'column'은 항목들을 수직으로 배치하며 'row'는   
  항목들을 수평 방향으로 배치한다. 여러 개의 항목이 있는 경우, 컨테이너 공간이 모자라서 밖으로 벗어나는 상황이 발생할 수 있다.

* `flexWrap` 속성은 'nowrap'과 'wrap'의 두 가지 속성값을 가진다. 기본값은 'nowrap'이며, 항목들이 많아서 화면에 공간이   
  모자라게 되면 어떤 항목들은 화면 밖으로 벗어나게 된다. 사용자는 잘려나간 항목이 무엇인지 제대로 볼 수 없으며, 이 문제를   
  해결하려면 'wrap' 속성값을 사용하면 된다.
<hr/>