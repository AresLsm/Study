# 문자열과 정규식 다루기

- 코틀린 문자열은 Java 문자열과 같다. 코틀린 코드가 만들어낸 문자열을 아무 Java 메소드에  
  넘겨도 되며, Java 코드에서 받은 문자열을 아무 코틀린 표준 라이브러리 함수에 전달해도 전혀  
  문제 없다. 특별한 변환도 필요 없고, Java 문자열을 감싸는 별도의 wrapper도 생기지 않는다.

- 코틀린은 다양한 확장 함수를 제공함으로써 표준 Java 문자열을 더 쉽게 다루게 해준다. 또한,  
  혼동이 야기될 수 있는 일부 메소드에 대해 더 명확히 코틀린 확장 함수를 제공함으로써 프로그래머의  
  실수를 줄여준다. Java와 코틀린 API의 차이를 알아보기 위한 첫 번째 예시로 문자열을 구분  
  문자열에 따라 나누는 작업을 코틀린에서 어떻게 처리하는지 보자.

## 문자열 나누기

- Java 개발자라면 `String#split()`에 익숙할 것이다. 모든 Java 개발자가 그렇진 않지만, 이에  
  불만을 표시하는 사람도 있다. 예를 들어 `"12.345-6.A".split(".")`의 결과가 `[12, 345-6, A]`이라고  
  생각하는 실수를 저지르는 개발자가 많다. 하지만 Java의 `split()`은 빈 배열을 반환한다. `split()`의  
  구분 문자열은 실제로는 정규식(regular expression)이기 때문이다. 따라서 마침표(`.`)는 모든 문자를  
  나타내는 정규식으로 해석된다.

- 코틀린에서는 Java의 `split()` 대신 여러 가지 다른 조합의 파라미터를 받는 `split()`  
  확장함수를 제공함으로써 혼동을 야기하는 메소드를 감춘다. 정규식을 파라미터로 받는 함수는 `String`이  
  아닌 `Regex` 타입의 값을 받는다. 따라서 코틀린에서는 `split()`에 전달하는 값의 타입에 따라  
  정규식이나 일반 텍스트 중 어느 것으로 문자열을 분리하는지 쉽게 알 수 있다.

- 아래 코드는 마침표나 `-`로 문자열을 분리하는 예시를 보여준다.

```kt
println("12.345-6.A".split("\\.|-".toRegex()))
// (12, 345, 6, A)
```

- 코틀린 정규식 문법은 Java와 똑같다. 위의 패턴은 마침표나 대시에 매치된다. 정규식을 처리하는  
  API는 표준 Java 라이브러리 API와 비슷하지만, 조금 더 코틀린답게 변경되었다. 예를 들어  
  코틀린에서는 `toRegex()` 확장함수를 사용해 문자열을 정규식으로 변환할 수 있다.

- 이런 간단한 경우에는 꼭 정규식을 쓸 필요가 없다. `split()` 확장 함수를 오버로딩한 버전 중에는  
  구분 문자열을 하나 이상 인자로 받는 함수가 있다.

```kt
println("12.345-6.A".split(".", "-"))
// (12, 345, 6, A)
```

- 위 경우에는 `split(".", "-")` 대신 `split('.', '-')`처럼 문자열 대신 문자를 인자로  
  넘겨도 마찬가지 결과를 볼 수 있다. 이렇게 여러 문자를 받을 수 있는 코틀린 확장 함수는 Java에  
  있는 단 하나의 문자만 받을 수 있는 메소드를 대신한다.

<hr/>

## 정규식과 3중 따옴표로 묶은 문자열

- 다른 예로 두 가지 다른 구현을 만들어보자. 첫 번째 구현은 `String`을 확장한 함수를 사용하고,  
  두 번째 구현은 정규식을 사용한다.

- 구현해볼 것은 파일의 전체 경로명을 디렉토리, 파일명, 확장자로 구분하는 것이다.  
  코틀린 표준 라이브러리에는 어떤 문자열에서 구분 문자열이 맨 처음 또는 마지막에 나타난 곳의 앞 또는 뒤의  
  부분 분자열을 반환하는 함수가 있다. 이런 함수들을 이용해 구현한 코드는 아래와 같다.

```kt
fun parsePath(path: String) {
    val directory = path.substringBeforeLast("/")
    val fullName = path.substringAfterLast("/")

    val fileName = fullName.substringBeforeLast(".")
    val extension = fullName.substringAfterLast(".")

    println("Dir: $directory, name: $fileName, ext: $extension")
}
```

- 코틀린에서는 정규식을 사용하지 않고도 문자열을 쉽게 파싱할 수 있다. 정규식은 강력하긴 하지만, 나중에 알아보기  
  힘든 경우가 많다. 정규식이 필요할 때는 코틀린 라이브러리를 사용하면 더 편하다. 같은 작업을 정규식을 통해  
  구현한 코드를 보자.

```kt
fun parsePath(path: String) {
    val regex = """(.+)/(.+)\.(.+)""".toRegex()
    val matchResult = regex.matchEntire(path)
    if(matchResult != null) {
	val (directory, filename, extension) = matchResult.destructured
	println("Dir: $directory, name: $filename, ext: $extension")
    }
}
```

- 위 ㅇ씨에서는 3중 따옴표 문자열을 사용해 정규식을 썼다. 3중 따옴표 문자열에서는 역슬래시(`\`)를 포함한  
  어떤 문자도 escape할 필요가 없다. 예를 들어, 일반 문자열을 사용해 정규식을 작성하는 경우, 마침표 기호를  
  escape하려면 (`\\.`)라고 써야 하지만, 3중 따옴표 문자열에서는 `\.`라 쓰면 된다.

<hr/>
