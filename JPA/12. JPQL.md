<h1>JPQL</h1>

* JPQL은 JPA Query Language의 약자로 JPA에서 사용하는 query언어이다. JPQL의 문법은 SQL문법과 매우 유사하다. 차이점이 있다면   
  __테이블과 컬럼명 대신 매핑한 Entity이름과 속성 이름을 사용한다__ 는 점이다.

```java
TypedQuery<Review> query = entityManager.createQuery(
    "SELECT r FROM Review r WHERE r.hotel = :hotel ORDER BY r.id DESC", Review.class);
query.setParameter("hotel", hotel);
query.setFirstResult(0);
query.setMaxResults(3);

List<Review> reviews = query.getResultList();
```
<hr/>

<h2>JPQL 기본 코드</h2>

* JPQL의 기본 구조는 다음과 같다.
```sql
SELECT 별칭 FROM Entity이름 AS 별칭
```

* from절 뒤의 Entity이름은 `@Entity`를 적용한 클래스의 이름이다. 별칭은 JPQL에서 Entity를 참조할 때 사용하는 이름이다.   
  __별칭은 필수__ 이며, select 절은 선택할 대상을 지정한다. select 대상으로 Entity의 별칭을 지정하면, 해당 Entity를 선택한다.

* 아래는 모든 `User` Entity를 선택하는 JPQL의 예시이다.
```sql
SELECT u FROM User AS u;
SELECT u FROM User u;
SELECT user FROM User user;
```

* JPQL을 실행하려면 `EntityManager#createQuery()` 메소드로 `Query`를 생성해야 한다. SELECT의 결과 타입을 알고 있는 경우엔   
  `EntityManager#createQuery(String, Class)` 메소드를 이용해서 `javax.persistence.TypedQuery` 객체를 생성한다. 예를 들어   
  select의 결과가 `User` 타입이라면 아래와 같이 `createQuery()`의 두 번째 인자의 값으로 `User.class`를 전달한다.
```java
TypedQuery<User> query = entityManager.createQuery("SELECT u FROM User u", User.class);
List<User> users = query.getResultList();
```
  * `TypedQuery#getResultList()` 메소드는 JPQL에 해당하는 SQL문을 실행하고 그 결과를 반환한다. 위 코드에서는 SELECT절에서 `User`   
    타입을 선택했으므로 query의 결과로 `User` Entity를 담은 리스트를 반환한다.

* `EntityManager#createQuery(String)` 메소드를 이용해서 `javax.persistence.Query` 객체를 생성할 수도 있다.
```java
Query query = entityManager.createQuery("SELECT u FROM User u");
List users = query.getResultList();
```

* 조회 대상 타입을 지정하는 `TypedQuery`와는 달리 `Query`는 선택 타입을 지정하지 않는다. 이런 이유로 `Query#getResultList()`로 구한   
  List에서 데이터를 구할 때에는 알맞게 타입을 변환해주어야 한다.

<h3>ORDER BY를 이용한 정렬</h3>

* order by 절을 이용하면 정렬 순서를 지정할 수 있다. 정렬 순서를 지정할 때는 Entity의 속성을 사용한다. Entity의 속성은 "별칭.속성"의   
  형식으로 지정한다. 아래 코드는 order by절을 사용한 JPQL의 예시이다.
```sql
SELECT p FROM Player p ORDER BY p.name ASC;
SELECT p FROM Player p ORDER BY p.name;
SELECT p FROM Player p ORDER BY p.name DESC;
```

* 오름차순과 내림차순의 정렬은 각각 ASC와 DESC로 지정한다. SQL과 마찬가지로 정렬 순서를 생략하면 오름차순을 사용한다.

* 두 개 이상의 속성을 사용해서 정렬하고 싶다면 콤마로 구분한다.
```sql
SELECT p FROM Player p ORDER BY p.team.id, p.name;
```

* 만약 `Player`가 `Team`을 `@ManyToOne`으로 참조하고 있고, `@JoinColumn(name = "team_id")`가 적용되어 있다면, 위 JPQL은 아래의   
  SQL문을 실행한다.
```sql
SELECT p.player_id, ...생략 FROM Player p ORDER BY p.team_id, p.name;
```

* 연관 객체의 식별자뿐만 아니라 다른 속성도 ORDER BY 절에서 사용할 수 있다.
<hr/>

<h2>검색 조건 지정</h2>

* where 절을 사용해서 특정 조건을 충족하는 Entity를 검색할 수 있다. 다음은 where절을 사용한 코드의 예시이다.
```java
TypedQuery<Player> query = entityManager.createQuery(
    "SELECT p FROM Player p WHERE p.team.id = 'T1'", Player.class);
List<Player> players = query.getResultList();
```

* 다음과 같이 AND, OR, 괄호를 사용해서 조건을 조합할 수도 있다.
```sql
SELECT p FROM Player p WHERE p.team.id = 'T1' AND p.salary > 1000;
```

* 비교할 값이 고정되지 않은 경우에는 입력 파라미터를 사용해서 코드에서 값을 할당할 수도 있다.
```java
TypedQuery<Player> query = entityManager.createQuery(
    "SELECT p FROM Player p WHERE p.team.id = ? AND p.salary > ?", Player.class);
query.setParameter(0, "T1");
query.setParameter(1, 1000);
List<Player> players = query.getResultList();
```

* 위 코드는 인덱스 기반 파라미터인 물음표를 사용해서 입력 파라미터를 지정했다. 인덱스 기반의 파라미터 값은 `setParameter()`메소드를   
  이용해서 설정하며, 인덱스는 0-base이다.

* 이름 기반 파라미터를 사용할 수도 있다. 이름 기반 파라미터는 ":이름"의 형식을 갖는다.
```java
TypedQuery<Player> query = entityManager.createQuery(
    "SELECT p FROM Player p WHERE p.team.id = :teamId AND p.salary > :minSalary", Player.class);
query.setParameter("teamId", "T1");
query.setParameter("minSalary", 1000);
List<Player> players = query.getResultList();
```

* 이름 기반 파라미터를 이용할 경우에는 `setParameter()`의 첫 번째 인자로 인덱스 번호가 아닌 파라미터명을 지정하면 된다.

* `setParameter()`의 값으로 단순 값 뿐만 아니라 Entity를 지정할 수도 있다. 아래 코드는 위 코드와 동일한 기능을 수행한다.
```java
Team team = entityManager.find(Team.class, "T1");
TypedQuery<Player> query = entityManager.createQuery(
    "SELECT p FROM Player p WHERE p.team = :team AND p.salary > :minSalary", Player.class);

query.setParameter("team", team);  // Entity를 값으로 주면 식별자를 이용하여 비교한다.
query.setParameter("minSalary", 1000);
List<Player> players = query.getResultList();
```

* 위 코드는 "team" 파라미터에 `Team` Entity를 지정했다. 이렇게 Entity를 이용하면 연관에 대한 직접 비교를 할 수 있다. 연관은   
  테이블 수준에서 조인 컬럼을 이용해 구현하므로, Entity를 query 파라미터로 전달하면 SQL 수준에서는 __식별자를 이용해서 비교__ 한다.

* `Calendar`와 `Date`의 경우는 아래의 `setParameter()`를 이용해서 값을 할당할 수 있다.
```java
setParameter(int position, Calendar value, TemporalType temporalType);
setParameter(int position, Date value, TemporalType temporalType);
setParameter(String name, Calendar value, TemporalType temporalType);
setParameter(String name, Date value, TemporalType temporalType);
```

* SQL의 비교 연산자는 JPQL에서 모두 동일하게 사용 가능하다.

<h3>컬렉션 비교</h3>

* 컬렉션에 대한 비교도 가능하다. 특정 Entity나 값이 컬렉션에 속해있는지 검사하고 싶다면 member of 연산자나 not member of 연산자를   
  사용하면 된다. `Team` Entity가 컬렉션을 사용해서 `Player` Entity와 1:N 연관을 갖는다고 할 때, 아래와 같이 member of 연산자를   
  이용해서 특정 `Player`를 컬렉션에 포함하고 있는 `Team`을 구할 수 있다.
```java
Player player = entityManater.find(Player.class, "p1");
TypedQuery<Team> query = entityManager.createQuery(
  "SELECT t FROM Team t WHERE :player MEMBER OF t.players ORDER BY t.name", Team.class);
query.setParameter("player", player);
List<Team> teams = query.getResultList();
```

* 단순 값 컬렉션에 대해서도 member of 연산자를 사용해서 컬렉션에 특정 값을 포함하고 있는 Entity의 목록을 구할 수 있다.   
  `User` Entity의 keywords속성이 `Set<String>`인 경우, 아래와 같은 JPQL을 이용해서 keywords에 "서울"을 포함한 `User`를 구할 수 있다.
```java
TypedQuery<User> query = entityManager.createQuery(
  "SELECT u FROM User u WHERE :keyword MEMBER OF u.keywords ORDER BY u.name", User.class);
query.setParameter("keyword", "서울");
List<User> users = query.getResultList();
```

* is empty나 is not empty 연산자를 사용하면 Entity 컬렉션에 대해 컬렉션이 비어있는지를 비교할 수 있다. 아래 코드는 players 컬렉션이   
  비어있는, 즉 컬렉션에 데이터가 없는 `Team`을 찾는 JPQL 예시이다.
```sql
SELECT t FROM Team t WHERE t.players IS EMPTY ORDER BY t.name;
```

<h3>exists, all, any</h3>

* 특정 값이 존재하는지를 검사하고 싶을 때에는 exists, all, any 중 하나를 사용하면 된다. 먼저 exists는 sub query의 결과가   
  존재하면 조회한다. 아래 JPQL을 보자.
```sql
SELECT h FROM Hotel h
  WHERE EXISTS(SELECT r FROM Review r WHERE r.hotel = h)
  ORDER BY h.name;
```
* 위 JPQL의 exists에서 사용하는 sub query는 hotel 속성이 from절에서 지정한 h와 같은 `Review`를 구한다. 즉, 리뷰가 존재하는   
  모든 `Hotel`들을 조회한다. not exists를 사용하면 `Review`가 존재하지 않는 `Hotel`을 선택한다.

* all은 sub query 결과가 조건을 모두 충족하는지를 검사한다. 예를 들어, 아래 JPQL은 특정 `Team`과 연관된 모든 `Player`의   
  salary값이 500보다 큰 `Team`을 구한다. 즉, 소속 `Player`의 salary가 모두 500보다 큰 `Team`을 구한다.
```sql
SELECT t FROM Team t
  WHERE 500 < ALL (SELECT p.salary FROM Player p WHERE p.team = t)
```

* any는 sub query 결과가 조건을 충족하는 대상 중 하나 이상 충족하는지 검색한다. 위 JPQL문에서 ALL 대신 ANY를 사용하면   
  `Team`과 관련된 `Player` 중 하나라도 salary값이 500보다 크면, 해당 `Team`을 선택한다.
<hr/>

<h2>페이징 처리</h2>

* `Query`와 `TypedQuery`를 사용하면 간단하게 페이징 처리를 할 수 있다. 이 인터페이스는 지정한 범위의 값을 구할 수 있는 두 개의   
  메소드를 제공한다.
  * `setFirstResult(int startPosition)` : 조회할 첫 번째 결과의 위치를 지정한다.
  * `setMaxResults(int maxResult)` : 조회할 최대 개수를 지정한다.

* 첫 번째 결과 위치(startPosition)은 0부터 시작한다. 아래 예시는 조회 결과에서 정렬 순서를 기준으로 11번째부터 5개를 조회한다.
```java
TypedQuery<Review> query = entityManager.createQuery(
  "SELECT r FROM Review r WHERE r.hotel.id = :hotelId ORDER BY r.id DESC", Review.class);
query.setParameter("hotelId", "H-001");
query.setFirstResult(10);
query.setMaxResults(5);

List<Review> reviews = query.getResultList();
```

* 위 두개 메소드를 이용하면 JPA는 LIMIT절이 들어간 query문을 수행하게 된다.
<hr/>

<h2>지정 속성 조회</h2>

<h3>배열로 조회하기</h3>

* 전체 Entity가 아니라 특정 속성만 조회할 수 있다. 아래 예시를 보자.
```java
TypedQuery<Object[]> query = entityManager.createQuery(
  "SELECT p.id, p.name, p.salary FROM Player p", Object[].class);

List<Object[]> rows = query.getResultList();

for(Object[] row : rows) {
  String id = row[0].toString();
  String name = row[1].toString();
  int salary = Integer.parseInt(row[2].toString());
}
```

* 위 보드에서 JPQL의 SELECT절은 Entity의 개별 속성을 3개 선택하고 있다. __SELECT절에 선택한 대상이 두 개 이상일 때 결과 타입은__   
  __`Object[]` 배열이 된다__. 따라서 `getResultList()`의 반환타입도 `List<Object[]>`가 되는 것이다.

<h3>특정 객체로 조회하기</h3>

* 식별자와 이름만 조회하는 기능이 있다고 할 때, 아래와 같은 클래스에 데이터를 담을 수 있을 것이다.
```java
@AllArgsConstructor
@Getters
public class IdName {
  private String id;
  private String name;
}
```

* 위 클래스는 생성자를 이용해서 필요한 데이터를 전달받고 있다. 이 생성자를 이용하면 JPQL에서 클래스에 바로 데이터를 담을 수 있다.
```java
TypedQuery<IdName> query = entityManager.createQuery(
  "SELECT new jpastart.common.IdName(p.id, p.name) FROM Player p", IdName.class);
List<IdName> idNames = query.getResultList();
```

* SELECT절을 보면 마치 생성자를 이용해서 객체를 생성하는 것과 같다. SELECT절에 new와 함께 완전한 클래스명을 사용하면 해당 클래스의   
  생성자를 이용해서 결과 객체를 생성한다. 위 코드의 JPQL을 실행하면 `IdName` 클래스의 생성자를 이용해서 결과 객체를 생성한다.
<hr/>

<h2>한 개 행 조회</h2>

* 지금까지 코드는 `getResultList()` 메소드를 이용했다. 만약 결과가 정확하게 한 행인 경우에는 `getSingleResult()` 메소드를   
  사용할 수 있다. 이 메소드 사용 시 주의점은 __반드시 결과가 1개이어야 한다__ 는 점이다. 아래 예외 상황을 기억하자.
  * 결과가 없는 경우 : `javax.persistence.NoResultException`
  * 결과가 두 개 이상인 경우 : `javax.persistence.NonUniqueResultException`
<hr/>

<h2>Join</h2>

* JPQL에서는 다음의 세 가지 방식으로 조인을 수행할 수 있다.
  * 자동(Implicit) join
  * 명시적 join
  * WHERE절에서의 join

* 자동 join은 연관된 Entity의 속성에 접근할 때 발생한다. 아래 JPQL을 보자.
```sql
SELECT p FROM Player p WHERE p.team.name = :teamName;
```
* 위 JPQL은 `Player`와 연관된 `Team`의 name 속성을 사용해서 조건을 비교한다. `Player`와 `Team`은 서로 다른 테이블에 매핑되어 있는데,   
  이 경우 hibarnate는 아래와 같이 두 테이블을 join한 query를 수행한다.
```sql
SELECT p.player_id FROM Player p CROSS JOIN Team t WHERE p.team_id = t.id AND t.name = ?
```

* 아래와 같이 join절을 이용해서 JPQL에서 명시적으로 join을 수행할 수도 있다.
```sql
SELECT p FROM Player p JOIN p.team t WHERE t.name = :teamName;
```
* 위 JPQL은 `Player`를 연관된 `Team`과 join 한다. 실제 실행하는 query는 아래와 같이 inner join을 사용해서 두 테이블을 조인한다.
```sql
SELECT p.player_id, ... FROM Player p INNER JOIN Team t ON p.team_id = t.id WHERE t.name = ?
```

* 아래 코드처럼 외부 join을 사용할 수도 있다.
```java
TypedQuery<Object[]> query = entityManager.createQuery(
  "SELECT p, t FROM Player p LEFT JON p.team ORDER BY p.name", Object[].class);
List<Object[]> rows = query.getResultList();
for(Object[] row : rows) {
  Player p = (Player)row[0];
  Team t = (Team)row[1];
}
```

* 위 코드는 외부 join을 사용해서 `Player`와 `Team`을 join한다. 외부 join을 사용하므로 `Team`과 연관되지 않은 `Player`도 함께 조회된다.   
* join절에는 ON을 이용해서 조건을 지정할 수 있다.
```sql
SELECT p FROM Player p JOIN p.team ON t = :team ORDER BY p.name;
```

* join을 하는 세 번째 방법은 where절에서 join하는 것이다. 이 경우, 연관된 Entity가 아니어도 두 Entity의 속성을 비교해서 join을   
  수행할 수 있다.
```java
TypedQuery<Object[]> query = entityManager.createQuery(
  "SELECT u, s FROM User u, UserBestSight s WHERE u.email = s.email ORDER BY u.name", Object[].class);
```
<hr/>

<h2>집합 함수</h2>

* JPQL은 `max()`, `sum()`와 같은 집합 관련 함수를 지원한다. 아래는 JPA 규약에 정의된 집합 규약 함수 목록이다.

<table>
  <tr>
    <td>함수명</td>
    <td>리턴 타입</td>
    <td>설명</td>
  </tr>
  <tr>
    <td>count</td>
    <td>Long</td>
    <td>개수를 구한다.</td>
  </tr>
  <tr>
    <td>max, min</td>
    <td>해당 속성의 타입</td>
    <td>최대값/최소값을 구한다.</td>
  </tr>
  <tr>
    <td>avg</td>
    <td>Double</td>
    <td>평균을 구한다.</td>
  </tr>
  <tr>
    <td>sum</td>
    <td>속성 타입에 따른다.(정수 타입이면 Long, 실수 타입이면 Double 등)</td>
    <td>합을 구한다.</td>
  </tr>
</table>

* 위 함수들의 사용법은 SQL과 유사하다.
```java
TypedQuery<Object[]> query = entityManager.createQuery(
  "SELECT count(p), avg(p.salary), max(p.salary), min(p.salary) FROM Player p", Object[].class);
Object[] aggValues = query.getSingleResult();
Long count = (Long)aggValues[0];
Double avgSal = (Double)aggValues[1];
int maxSal = (Integer)aggValues[2];
int minSal = (Integer)aggValues[3];
```

* `max()`, `min()`, `avg()`, `sum()`은 해당 값이 존재하지 않는 경우 null을 반환한다.
<hr/>

<h2>GROUP BY와 HAVING</h2>

* 집함 함수와 함께 쓰이는 것으로 group by절이 있다. SQL의 group by와 동일하게 JPQL의 group by는 지정한 속성을 기준으로 그룹을 나눈다.
```java
TypedQuery<Object[]> query = entityManager.createQuery(
  "SELECT p.team.id, count(p), avg(p.salary), max(p.salary), min(p.salary) FROM Player p GROUP BY p.tea.id", Object[].class);
List<Object[]> rows = query.getResultList();
for(Object[] aggValues : rows) {
  Long count = (Long)aggValues[0];
  Double avgSal = (Double)aggValues[1];
  int maxSal = (Integer)aggValues[2];
  int minSal = (Integer)aggValues[3];
}
```

* join 대상으로 그룹을 나눌 수도 있다.
```sql
SELECT t, COUNT(p), AVG(p.salary) FROM Player p LEFT JOIN p.team t GROUP BY t;
```

* group by에 having을 사용해서 조건을 지정할 수도 있다. 아래는 having을 이용해서 소속 선수가 1명 보다 많은 `Team`의 선수 수와   
  평균 연봉을 구하는 JPQL문이다.
```sql
SELECT t, count(p), avg(p.salary) FROM Team t LEFT JOIN t.players p GROUP BY t HAVING count(p) > 1;
```
<hr/>