<h1>테스트 코드의 구성</h1>

<h2>기능에서의 상황</h2>

* 기능은 주어진 상황에 따라 다르게 동작한다. 예를 들어 아래 기능을 보자.
  * 파일에서 숫자를 읽어와 숫자의 합을 구한다.
  * 한 줄마다 한 개의 숫자를 포함한다.

* 위 기능을 `MathUtils.sum()` 메소드로 구현한다고 가정하자. 아래처럼 `sum()` 메소드에 파일을 인자로 전달할 것이다.   
  `sum()` 메소드는 인자로 전달받는 파일에서 한 줄씩 읽어와 숫자로 변환한 뒤에 합한 값을 결과로 제공하면 된다.
```java
File dataFile = new File("data.txt");
long sum = MathUtils.sum(dataFile);
```

* 하지만 위 기능을 구현하려면 고려할 것이 있다. 먼저 파일이 없는 상황을 처리해야 한다. 데이터를 읽을 파일이 없다면   
  인자가 잘못되었다는 예외를 발생시키거나 문제 상황을 알려줄 수 있는 값을 반환해야 한다. 비슷하게 데이터 중에 숫자가 아닌   
  데이터가 존재하는 경우에도 알맞은 결과를 생성해야 한다.

* 이처럼 주어진 상황에 따라 기능의 실행 결과는 달라진다. 이는 테스트 코드 구조에도 영향을 주게 된다.
<hr/>

<h2>테스트 코드의 구성 요소 : 상황, 실행, 결과 확인</h2>

* 기능은 상황에 따라 결과가 달라진다. 테스트 코드는 기능을 실행하고 그 결과를 확인하므로 상황, 실행, 결과 확인의   
  세 가지 요소로 테스트를 구성할 수 있다. 어떤 상황이 주어지고, 그 상황에서 기능을 실행하고, 실행한 결과를 확인하는   
  세 가지가 테스트 코드의 기본 골격을 이루게 된다.

* 상황, 실행, 결가 확인은 Given, When, Then에 각각 해당한다.

* JUnit에서 상황을 설정하는 방법은 테스트할 대상에 따라 달라진다. 숫자 야구 게임을 예로 들어보자.   
  숫자 야구 게임을 구현한 `BaseballGame` 클래스는 객체를 생성할 때 정답 숫자를 지정한다.   
  이 경우 각 테스트 메소드마다 객체를 생성해서 확인을 설정할 수 있다.
```java
@Test
void exactMatch() {

    // Answer is 456, Given
    BaseballGame game = new BaseballGame("456");

    // When
    Score score = game.guess("456");

    // Then
    assertEquals(3, score.strikes());
    assertEquals(0, score.balls());
}

@Test
void noMatch() {

    // Answer is 123, Given
    BaseballGame game = new BaseballGame("123");

    // When
    Score score = game.guess("456");

    // Then
    assertEquals(0, score.strikes());
    assertEquals(0, score.balls());
}
```

* 또다른 방법은 `@BeforeEach`를 적용한 메소드에서 상황을 설정하는 것이다. 이때는 주로 상황 설정과 관련된 대상을 필드로 보관한다.
```java
private BaseballGame game;

@BeforeEach
void givenGame() {
    game = new BaseballGame("456");
}

@Test
void exactMatch() {
    Score score = game.guess("456");
    assertEquals(3, score.strikes());
    assertEquals(0, score.balls());
}
```

* 상황이 아예 없는 경우도 존재한다. 암호 강도 측정 예시의 경우 결과에 영향을 주는 상황이 존재하지 않으므로   
  테스트는 아래와 같이 기능을 실행하고 결과를 확인하는 코드만 포함하고 있다.
```java
@Test
void meetsAllCriteria_Then_Strong() {
    PasswordStrengthMeter meter = new PasswordStrengthMeter();
    PasswordStrength result = meter.meter("ab12!@AB");
    assertEquals(PasswordStrength.STRONG, result);
}
```

* 실행 결과를 확인하는 쉬운 방법은 리턴 값을 사용하는 것이다. 하지만 실행 결과가 항상 리턴값으로 존재하는 것은 아니다.   
  실행 결과로 예외를 발생시키는 것이 정상인 경우도 있다. 예를 들어 숫자 야구 게임 생성 기능의 테스트 코드는 정답 숫자에   
  동일한 숫자가 존재하면 게임 생성에 실패해야 한다. 이 경우 게임 생성 실패 결과를 표시하기 위해 `BaseballGame` 생성자가   
  `IllegalArgumentException`을 발생시키도록 구현할 수 있다.
```java
@Test
void generateGame_With_DuplicateNumber_Then_Fail() {
    assertThrows(IllegalArgumentException.class,
        () -> new BaseballGame("110")
    );
}
```
<hr/>

