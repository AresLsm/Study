# 제네릭 타입 파라미터

- 제네릭을 사용하면 **타입 파라미터(type parameter)** 를 받는 타입을 정의할 수 있다. 제네릭 타입의 인스턴스를 만들려면  
  타입 파라미터를 구체적인 **타입 인자(type argument)** 로 치환해야 한다. 예를 들어 `List`라는 타입이 있다면, 그 안에  
  들어가는 원소의 타입을 안다면 쓸모 있을 것이다. 타입 파라미터를 사용하면 _"이 변수는 리스트이다"_ 라고 말하는 대신,  
  _"이 변수는 문자열을 담는 리스트다"_ 라고 말할 수 있다. 코틀린에서 문자열을 담는 리스트를 표현하는 구문은 Java와  
  마찬가지로 `List<String>`이다. 클래스에 타입 파라미터가 여럿 있을 수도 있다. 예를 들어, `Map` 클래스는 key와  
  value 타입을 타입 파라미터로 받으므로 `Map<K, V>`가 된다. 이러한 제네릭 클래스에 `Map<String, Person>` 처럼  
  구체적인 타입을 타입 인자로 넘기면 타입을 인스턴스화할 수 있다.  
  여기까지는 모든 내용이 Java와 동일해 보인다.

- 코틀린 컴파일러는 보통 타입과 마찬가지로 타입 인자도 추론할 수 있다.

```kt
val authors = listOf("Dmitry", "Svetlana")
```

- `listOf()`에 전달된 두 값이 문자열이기에 컴파일러는 여기서 생기는 리스트가 `List<String>`임을 추론한다. 반면, 빈 리스트를  
  만들어야 한다면 타입 인자를 추론할 근거가 없기 때문에 직접 타입 인자를 명시해야 한다. 리스트를 만들 때 변수 타입을 지정해도 되고  
  변수를 만드는 함수의 타입 인자를 지정해도 된다.

```kt
val readers: MutableList<String> = mutableListOf()

val readers2 = mutableListOf<String>()
```

- 위 두 선언은 동일하다.

> - Java에는 1.5부터 제네릭이 지원되었기 때문에 이전 버전과의 호환성을 유지하기 위해 Raw Type을 허용한다.  
>    자세한 내용은 <a href="https://github.com/sang-w0o/Study/blob/master/Programming%20Paradigm/Effective%20Java/4.%20%EC%A0%9C%EB%84%A4%EB%A6%AD/Item%2026.%20Raw%20%ED%83%80%EC%9E%85%EC%9D%80%20%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80%20%EB%A7%88%EB%9D%BC.md">여기</a> 에서 볼 수 있다.  
>   반면, 코틀린은 처음부터 제네릭을 도입했기 때문에 raw type을 지원하지 않는다. 따라서 제네릭 타입의 타입 인자를 항상 정의해서  
>   코틀린 컴파일러가 제네릭 타입 인자를 추론할 수 있도록 해야 한다.

<hr/>
