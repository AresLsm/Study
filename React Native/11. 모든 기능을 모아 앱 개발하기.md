<h1>앱 개발해보기</h1>

* React Native에는 iOS와 안드로이드에서 모두 사용한 크로스 플랫폼 API를 많이 제공하는데, 그 중 아래를 알아보자.
  * Fetch API
  * Modal
  * ActivityIndicator
  * Flatlist
  * Picker
  * React-Navigation

* 우선 `App.js`에서 필요한 컴포넌트를 가져오자.
```js
import React, {Component} from 'react';
import {StyleSheet, Text, FlatList, TouchableHighlight} from 'react-native';

import {createAppContainer} from 'react-navigation';
import {createStackNavigator} from 'react-navigation-stack';
```
* `FlatList`는 app에서 데이터 배열을 이용해서 목록을 렌더링하는 컴포넌트이며, `createStackNavigator`는 react-navigation의   
  Navigator이며 각 화면 사이를 이동하는 쉬운 방법을 제공한다.

* 다음으로는 컴포넌트에 검정 배경을 적용하는 스타일 코드를 반복해서 사용하지 않기 위해 `Container` 컴포넌트를 만들어서 View의   
  Wrapper Container로 사용하자. 이 컴포넌트는 스타일링을 위해서만 사용된다.

```js
// Container.js

import React from 'react';
import {StyleSheet, View} from 'react-native';

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: 'black'
    }
});

const Container = ({children}) => (
    <View style={styles.container}>
        {children}
    </View>
);

export default Container;
```

* `Container`를 `App.js`에 가져온 다음에, 링크에 사용할 항목들을 배열로 만든다. 배열의 항목을 `FlatList` 컴포넌트에 전달해서   
  링크 목록을 만들게 된다. 다음 배열은 객체를 포함하며, 각 객체는 title라는 Key를 갖는다. 링크의 제목을 표시할 때 title Key가   
  필요하기 때문이다.
```js
const links = [
    {title: People},
    {title: Films},
    {title: StarShips},
    {title: Vehicles},
    {title: Species},
    {title: Planets}
]
```

<h3>내비게이션 컴포넌트를 만들고 라우트 등록하기</h3>

* `App.js` 파일의 하단에 메인 내비게이션 컴포넌트를 만들고 `AppRegistry`에 전달한다. `createStackNavigator`와 `createAppContainer`를   
  이용해서 내비게이션 컴포넌트를 만들고 app에서 사용할 라우트를 등록한다.
* `createStackNavigator`를 초기화하고, 내비게이터를 `AppRegistry`에 전달하자, `createStackNavigator`는 크로스 플랫폼 컴포넌트로   
  app에서 화면 간 전환이 가능하도록 한다. 각각 새 화면은 스택의 위쪽에 위치하게 된다.

* 아래는 작성이 완료된 `App.js`이다.
```js
import React, {Component} from 'react';
import {StyleSheet, Text, FlatList, TouchableHighlight} from 'react-native';

import {createAppContainer} from 'react-navigation';
import {createStackNavigator} from 'react-navigation-stack';

import People from './People';

import Container from './Container';

const links = [
  { title: 'People' },
  { title: 'Films' },
  { title: 'StarShips' },
  { title: 'Vehicles' },
  { title: 'Species' },
  { title: 'Planets' }
];

class StarWars extends Component {
    
    static navigationOptions = {
        headerTitle: <Text style={{fontSize: 34, color: 'rgb(255,232,31)'}}>StarWars</Text>,
        headerStyle: {backgroundColor: 'black', height: 110}
    }
    
    navigate = (link) => {
        const {navigate} = this.props.navigation;
        navigate(link);
    }
    
    renderItem = ({item, index}) => {
        return(
            <TouchableHighlight onPress={() => this.navigate(item.title)}
                style={[styles.item, {borderTopWidth: index === 0 ? 1 : null}]} >
                <Text style={styles.text}>{item.title}</Text>
            </TouchableHighlight>               
        )
    }
    
    render() {
        return(
            <Container>
                <FlatList data={links} keyExtractor={(item) => item.title}
                          renderItem={this.renderItem}/>
            </Container>
        );
    }
}

const App = createStackNavigator({
    Home: {screen: StarWars},
    People:{screen: People}
});

const styles = StyleSheet.create({
    item: {
        padding: 20,
        justifyContent: 'center',
        borderColor: 'rgba(255,232,31,.2)',
        borderBottomWidth: 1
    },
    text: {
        color: '#ffe81f',
        fontSize: 18
    }
});

export default App;
```

* react-navigation의 `createStackNavigator`를 이용하므로 각 라우트에 라우트 설정을 전달할 수 있다. 기본 헤더 설정과 스타일을   
  변경하기 위해 static한 `navigationOptions`객체를 생성하고, 이 객체에 제목을 포함한 `headerTitle` 컴포넌트와 스타일링 정보를   
  포함한 `headerStyle`객체를 전달한다. `headerTitle`은 로고로 사용할 텍스트이며 `headerStyle`은 배경색을 검정으로 지정하고,   
  텍스트가 잘 표현될 수 있도록 헤더의 높이를 지정한다.

* `navigate()` 메소드는 link를 인수로 전달받는다. `StackNavigation`이 렌더링하는 모든 컴포넌트는 props로 `navigation`객체를   
  전달받는다. 이 props를 이용해서 구조 분해 할당하여 전달된 링크로 이동한다. 여기서 이 링크는 links 배열의 title 속성이며,   
  `createStackNavigator`에 전달되는 키와 연결되어 있다.

* `FlatList`는 `renderItem()` 메소드를 전달받는다. 이 메소드는 data 속성으로 전달된 데이터 배열을 루프로 처리해서 배열에 포함된   
  각 항목의 item과 항목의 index를 포함한 객체를 반환한다. item은 모든 속성을 포함한 실제 목록에 표현될 항목이고 index는   
  각 항목의 인덱스이다. `renderItem()`의 반환된 객체를 인수로 각 항목을 `navigate()`의 인수로 전달해서 제목으로 표시힌다.   
  또한 index를 이용해서 목록의 첫 번째 항목에는 borderTop 스타일을 적용한다.

* `render()`는 `Container`를 반환한다. `Container`는 `FlatList`를 감싸고 data에 links와 renderItem 메소드, 그리고   
  `keyExtractor()` 메소드를 전달한다. 배열에 key로 이름 붙여진 항목이 없다면 `FlatList`에 어떤 항목을 키로 사용할지 지정해   
  주어야 하며 그렇지 않으면 오류가 발생한다.
<hr/>