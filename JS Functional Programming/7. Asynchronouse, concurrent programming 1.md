# 비동기: 동시성 프로그래밍 1

<h2>callback, Promise</h2>

- JavaScript에서 비동기 동시성 프로그래밍을 하는 방법으로는 크게 두 가지가 있다.  
  첫 번째는 callback을 사용하는 것이며, 두 번째는 `Promise`를 기반으로 하여  
  메소드 체이닝을 하는 것이다.

- 먼저 callback 방식이다.

```js
function add10(a, callbackFn) {
  setTimeout(() => callbackFn(a + 10), 100);
}

add10(5, (res) => {
  console.log(res);
}); // 15

add10(5, (res) => {
  add10(res, (res) => {
    add10(res, (res) => {
      console.log(res);
    });
  });
});
```

- 다음으로 promise 기반의 메소드 체이닝 방식을 보자.

```js
function add20(a) {
  return new Promise((resolve) => setTimeout(() => resolve(a + 20), 100))();
}

add20(5).then((res) => console.log(res));

add20(5)
  .then(add20)
  .then(add20)
  .then(add20)
  .then(add20)
  .then((res) => console.log(res));
```

- 벌써 callback 방식에 비해 promise기반의 메소드 체이닝 방식이 눈에 띄게 편리하고, 가독성이 좋다.  
  이때, promise 기반의 방식이 callback에 비해 근본적으로 가지는 차이점은 `.then()`을 사용하여  
  결과를 꺼내본다는 것이 아니라 **비동기 상황을 일급 값으로 다룬다는 중요한 차이점이 있다.**

- promise는 `Promise`라는 클래스를 통해서 만들어진 인스턴스를 반환하는데, 그 인스턴스는 _대기_, _성공_,  
  _실패_ 를 다루는 일급 값으로 이루어져 있다.

- 위 코드에서 `add10()` callback 함수를 보면 비동기적인 상황을 다루는 것이 코드로만 표현되고 있는데,  
  `add20()`같은 경우에는 비동기 상황에 대한 값을 만들어서 리턴을 하고 있다는 것이 매우 중요한 차이점이다.

```js
const a = add10(5, (res) => {
  add10(res, (res) => {
    add10(res, (res) => {
      console.log(res);
    });
  });
});

const b = add20(5)
  .then(add20)
  .then(add20)
  .then((res) => console.log(res));
```

- a는 `undefined`, b는 `Promise`라는 값이 나온다. 이 점이 그 중요한 차이점이다.

- 아래 코드와 주석은 콘솔에 입력했을 때의 결과값이다.

```js
add10(5, (_) => _);
// undefined

add20(5, (_) => _);
// Promise {<pending>}

var c = add20(5, (_) => _);
console.log(c); // Promise {<pending>}

var d = c.then((a) => a - 5);
console.log(d); // Promise {<resolved>: 20}

d.then(console.log()); // 20
```

- 이렇게 Promise는 비동기를 값으로 만들어주고, 값으로 만들어 준다는 것은 일급임을 의미한다.

<hr/>

<h2>값으로서의 Promise 활용</h2>

- Promise가 비동기 상황을 값으로 다루어 일급의 성질을 가지는 것을 활용해서 다양한 것들을 할 수 있는데,  
  이 값을 함수에게 전달할 수도 있고, 값이 Promise인지 아닌지도 확인할 수 있다.

```js
const go1 = (a, fn) => fn(a);
const add5 = (a) => a + 5;
console.log(go1(10, add5)); // 15
```

- 위 코드의 `go1()`의 조건은 a가 동기적으로 바로 값을 알 수 있어야 하는 변수이며, fn 도 동기적으로 바로 값을  
  만들어내는 함수여야 한다는 것이다. 곧 비동기 상황이 일어난 값이 아닌 값이 들어와야 실행된다는 것이다.

- `go1()`이 인자로 비동기적인 값이 들어와도 잘 작동하게끔 만들어보자.

```js
const delay100 = (a) =>
  new Promise((resolve) => setTimeout(() => resolve(a), 100));

const go1 = (a, fn) => (a instanceof Promise ? a.then(fn) : fn(a));
const add5 = (a) => a + 5;

const r = go1(10, add5);
console.log(r); // 15

const r2 = go1(delay100(10), add5);
r2.then(console.log); // 15

const n1 = 10;
console.log(go1(go1(n1, add5), console.log)); // 15

const n2 = delay100(10);
console.log(go1(go1(n2, add5), console.log)); // 15
```
