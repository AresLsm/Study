# MSA에서의 트랜잭션 관리

- 엔터프라이즈 애플리케이션은 거의 모든 요청을 하나의 DB 트랜잭션으로 처리한다.  
  개발자는 보통 트랜잭션 관리를 간소화한 프레임워크, 라이브러리를 사용하고  
  그중에는 트랜잭션을 명시적으로 시작, 커밋, 롤백할 수 있는 프로그램형 API를  
  제공하는 제품도 있다. Spring Framework는 선언형 메커니즘을 제공한다.  
  즉, 메소드 선언부에 `@Transactional` 어노테이션만 붙이면 해당 메소드를  
  하나의 트랜잭션으로 자동 실행하므로 개발자가 간편하게 트랜잭셔널 비즈니스  
  로직을 작성할 수 있다.

- 단일 DB에 접근하는 모놀리틱 애플리케이션의 트랜잭션 관리는 어렵지 않다.  
  하지만 다중 DB, 다중 메시지 브로커를 사용하는 모놀리틱 애플리케이션이나,  
  자체 DB를 가진 여러 서비스로 구성된 MSA는 트랜잭션 관리가 어렵기 때문에  
  좀 더 정교한 메커니즘이 필요하다.

- Saga에 대해 살펴보기 전에, 먼저 MSA에서 트랜잭션 관리가 어려운 이유를 알아보자.

<h2>분산 트랜잭션의 필요성</h2>

- `createOrder()`는 주문 가능한 소비자인지 확인하고, 주문 내역을 확인하고,  
  소비자의 신용카드를 승인하고, DB에 주문을 생성하는 작업으로 이뤄진다.  
  모놀리틱 애플리케이션에서 이런 작업을 구현하기에는 그렇게 어렵지 않다.  
  주문 검증에 필요한 데이터를 그냥 가져오면 되기 때문이다.  
  Spring을 사용할 경우, `createOrder()` 메소드에 `@Transactional`만  
  붙여주면 ACID 트랜잭션이 자동으로 걸려, 데이터 일관성이 보장된다.

- 반면, 데이터가 여러 서비스에 흩어져 있는 MSA는 복잡하다.  
  `createOrder()`는 소비자 서비스, 주문 서비스, 주방 서비스, 회계 서비스 등  
  여러 서비스에 있는 데이터에 접근해야 한다.

- 서비스마다 DB가 따로 있기 때문에 여러 DB에 걸쳐 데이터 일관성을 유지할 수 있는  
  수단을 강구해야 한다.

<hr/>

<h2>분산 트랜잭션의 문제점</h2>

- 예전에는 분산 트랜잭션을 이용해서 여러 서비스, DB, 메시지 브로커에 걸쳐 데이터  
  일관성을 유지했다. X/Open DTP(Distributed Transaction Processing) 모델(X/Open XA)은  
  분산 트랜잭션 관리의 사실상 표준이다. XA는 2단계 커밋(2PC)을 이용하여 전체 트랜잭션 참여자가  
  반드시 커밋 아니면 롤백을 하도록 보장한다. XA 호환 기술 스택은 XA 호환 DB, 메시지 브로커,  
  DB 드라이버, 메시징 API, XA 전역 트랜잭션 ID를 전파하는 프로세스 간 메커니즘으로 구성된다.  
  SQL DB는 대부분 XA와 호환되며, 메시지 브로커의 일부 제품도 호환된다. 예를 들어, Java EE  
  애플리케이션은 JTA 기술을 사용하여 분산 트랜잭션을 수행할 수 있다.

- 분산 트랜잭션은 간단해 보이지만, 문제점도 많다. 일단 NoSQL DB(MongoDB, Cassandra)와  
  현대 메시지 브로커(RabbitMQ, Apache Kafka)는 분산 트랜잭션을 지원하지 않으므로  
  분산 트랜잭션이 필수라면 최근 기술은 상당수 포기할 수 밖에 없다.

- 동기 IPC 형태이기에 가용성이 떨어지는 문제도 있다. 분산 트랜잭션은 참여한 서비스가 모두  
  가동 중이어야 커밋할 수 있다. 더 많은 서비스가 참여할 수록 가용성은 더 떨어진다.  
  서비스는 일관성(Consistency), 가용성(Availability), 분할 허용성(Partition Tolerance) 중  
  두 가지 속성만 가질 수 있다. 요즘 아키텍트들은 일관성보다 가용성을 더 우선시 하는 편이다.

- 개발자 관점에서 보면, 분산 트랜잭션은 로컬 트랜잭션과 프로그래밍 모델이 동일하므로 매력적이지만,  
  위에서 본 문제점들 때문에 현대 애플리케이션에는 잘 맞지 않는다. 분산 트랜잭션을 사용하지 않고  
  메시지를 DB 트랜잭션의 일부로 전송하는 방법이 낫다. MSA에서 데이터 일관성을 유지하려면,  
  느슨하게 결합된 비동기 서비스 개념을 토대로 뭔가 다른 메커니즘이 필요하다.  
  이것이 바로 Saga 이다.

<hr/>
