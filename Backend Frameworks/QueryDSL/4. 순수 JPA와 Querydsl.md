# 순수 JPA와 Querydsl

## 순수 Jpa Repository와 Querydsl

- 우선 순수 JPA만 사용하여 레포지토리를 만들면, 대략 아래처럼 된다.

```kt
@Repository
class MemberJpaRepository(
    private val entityManager: EntityManager
) {

    private val queryFactory: JPAQueryFactory = JPAQueryFactory(entityManager)

    fun save(member: Member) {
        entityManager.persist(member)
    }

    fun findById(id: Long): Optional<Member> {
        val member = entityManager.find(Member::class.java, id)
        return Optional.ofNullable(member)
    }

    fun findAll(): List<Member> {
        return entityManager.createQuery("SELECT m FROM Member m", Member::class.java)
            .resultList
    }

    fun findByUsername(username: String): List<Member> {
        return entityManager.createQuery("SELECT m FROM Member m WHERE m.username = :username", Member::class.java)
            .setParameter("username", username)
            .resultList
    }
}
```

- 위 `MemberJpaRepository`의 코드를 테스트하는 코드는 아래와 같다.

```kt
@SpringBootTest
@Transactional
class MemberJpaRepositoryTest {

    @Autowired
    private lateinit var entityManager: EntityManager

    @Autowired
    private lateinit var memberJpaRepository: MemberJpaRepository

    @Test
    fun basicTest() {
        val member = Member("member1", 10)
        memberJpaRepository.save(member)
        val foundMember = memberJpaRepository.findById(member.id!!).get()
        assertEquals(member, foundMember)

        val memberList = memberJpaRepository.findAll()
        assertThat(memberList).containsExactly(member)

        val memberList2 = memberJpaRepository.findByUsername("member1")
        assertThat(memberList2).containsExactly(member)
    }
}
```

- 기존의 `MemberJpaRepository`의 메소드 중 `findAll()`과 `findbyUsername()`을 querydsl로 바꿔보자.

```kt
@Repository
class MemberJpaRepository(
    private val entityManager: EntityManager
) {

    //..

    fun findAll(): List<Member> {
        return query
            .selectFrom(member)
            .fetch()
    }

    fun findByUsername(username: String): List<Member> {
        return query
            .selectFrom(member)
            .where(member.username.eq(username))
            .fetch()
    }
}
```

- 이렇게 기존의 `EntityManager#createQuery()`로 문자열을 이용해 JPQL을 작성한 것과 비교했을 때,  
  Querydsl을 사용하면 메소드 체이닝으로 쿼리를 작성할 수 있어서 훨씬 안전하다.  
  쿼리문이 잘못되어 런타임에 오류를 잡을 일도 없다. 또한 명시적인 파라미터 바인딩(`setParameter()`)도  
  안해줘도 된다.

- 또한 다수의 레포지토리가 생겼을 때 `JPAQueryFactory`를 편리하게 사용하기 위해 필요할 때마다 매번  
  새로운 인스턴스를 생성해주는 대신 Spring Bean으로 등록할 수도 있다.

```kt
@SpringBootApplication
class QuerydslExampleApplication {
    @Bean
    fun jpaQueryFactory(entityManager: EntityManager) = JPAQueryFactory(entityManager)
}

fun main(args: Array<String>) {
    runApplication<QuerydslExampleApplication>(*args)
}
```

- 이렇게 하면 `@Autowired`, setter, 혹은 생성자 의존성 주입으로 `JPAQueryFactory`를  
  원하는 곳에서 주입받아 사용할 수 있다.

```kt
@Repository
class MemberJpaRepository(
    private val entityManager: EntityManager,
    private val query: JPAQueryFactory
) {

    fun save(member: Member) {
        entityManager.persist(member)
    }

    fun findById(id: Long): Optional<Member> {
        val member = entityManager.find(Member::class.java, id)
        return Optional.ofNullable(member)
    }

    fun findAll(): List<Member> {
        return query
            .selectFrom(member)
            .fetch()
    }

    fun findByUsername(username: String): List<Member> {
        return query
            .selectFrom(member)
            .where(member.username.eq(username))
            .fetch()
    }
}
```

<hr/>
