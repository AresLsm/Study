# 포인터

## 빠른 포인터 입문

- 포인터는 간단히 말해 값이 저장된 메모리의 위치 값을 갖는 변수이다.

```go
var x int32 = 10
var y bool = true
```

- 모든 변수는 하나 혹은 그 이상의 연속적인 메모리 공간에 저장되는데, 그것을 **주소**라 한다. 서로 다른 타입의 변수들은 서로 다른 양의 메모리를  
  차지한다. 예를 들어 x는 int32이므로 4바이트가 필요하고, y는 bool이기에 1비트만 필요하다.(주소 지정을 통해 가질 수 있는 최소 공간은 1바이트이다.)

- 포인터는 단순히 다른 변수가 저장된 주소를 내용으로 갖는 변수이다.

```go
var x int32 = 10
var y bool = true
pointerX := &x
pointerY := &y
var pointerZ *string
```

- 서로 다른 타입은 서로 다른 수의 메모리를 차지하지만, 모든 포인터는 어떤 타입을 가리키던 간에 항상 같은 크기를 가지는데, 그 수는 데이터가 저장된  
  메모리의 위치를 가질 만큼이다. 예를 들어 위 코드에서 x가 1번지~4번지를(4byte) 차지하고, y가 5번지(1byte)를 차지한다고 해보자.  
  그리고 pointerX기 메모리의 6번지에 저장되었다고 하면 값으로는 x의 주소인 1을 갖는다. 비슷하게 y를 가리키는 pointer가 10번지에 저장되었다 하면  
  값으로는 y의 주소인 5를 갖는다. 마지막으로 pointerZ는 어딘가에 저장되긴 하지만, 아무것도 가리키지 않기에 0의 값을 가진다.

- 포인터의 zero value는 nil이다. nil은 slice, map, 함수를 위한 zero value이기도 하다. 추가로 channel, interface가 있는데 이들 모두  
  포인터로 구현되어 있다. nil은 특정 값의 부재를 표현하는 타입이 지정되지 않은 식별자이다. C언어의 NULL과 다르게, nil은 0의 다른 이름이 아니다.  
  그래서 nil을 숫자로 바꾸거나 숫자를 nil로 바꿀 수 없다.

> 이전에 보았듯이 nil은 Universe Block에 정의되어 있다. 즉, shadowing될 수 있다는 뜻이다.  
> 따라서 절대 함수나 변수명을 nil로 지정하지 말자.

- Go의 포인터 구문은 일부 C와 C++에서 차영했다. Go는 GC를 갖기에 메모리 관리에 대한 고통이 거의 사라졌다. 게다가 포인터 산술을 포함한 C와 C++에서  
  포인터를 갖고 할 수 있는 기교 중 일부는 Go에서는 허용되지 않는다.

- `&`는 주소 연산자로, 변수 앞에 `&`를 붙이면 해당 변수의 값이 저장된 메모리 위치의 주소를 반환하게 된다.

```go
x := "hello"
pointerToX := &x
```

- `*`는 간접 연산자로, 포인터 타입의 변수 앞에 붙이면 가리키는 값을 반환하게 된다. 이를 **역참조(dereferencing)** 라 한다.

```go
x := 10
pointerToX := &x
fmt.Println(pointerToX) // x의 메모리 주소
fmt.Println(*pointerToX) // 10
z := 5 + *pointerToX
fmt.Println(z) // 15
```

- 포인터를 역참조하기 전에 꼭 pointer가 nil이 아닌지 확인해야 한다. 만약 nil을 갖는 포인터를 역참조하면, 프로그램은 panic을 일으킨다.

```go
var x *int
fmt.Println(x == nil) // true
fmt.Println(*x) // Panic
```

- **포인터 타입**은 포인터가 어떤 타입을 가리키는지 나타낸다. 타입 이름 앞에 `*`를 사용해 작성한다.

```go
x := 10
var pointerX *int
pointerToX := &x
```

- 내장 함수 `new()`는 포인터 변수를 생성하는데, 제공된 타입의 zero value를 가리키는 포인터를 반환한다.

```go
var x = new(int)
fmt.Println(x == nil) // false
fmt.Println(*x) // 0
```

- `new()`는 드물게 사용된다. 구조체를 위해 포인터 인스턴스를 만들려면 구조체 리터럴 앞에 `&`를 사용한다. 기본 타입 리터럴이나 상수 앞에는  
  메모리 주소를 갖지 않기에 `&`를 사용할 수 없다. 이들은 단지 컴파일 과정에 존재하기 때문이다. 기본 타입을 위한 포인터가 필요하면, 변수를  
  선언하고 해당 변수를 가리키게끔 하도록 하자.

```go
x := &Foo{}
var y sring
z := &y
```

- 상수의 주소를 가질 수 없기에 때로는 불편함을 야기하기도 한다. 하나의 구조체 내에 기본 타입을 가리키는 포인터가 있다면, 리터럴을 해당 항목에  
  직접 할당할 수 있다.

```go
type person struct {
	FirstName string
	MiddleName *string
	LastName string
}

p := person{
	FirstName: "Pat",
	MiddleName: "Perry", // Compile Error
	LastName: "Peterson",
}
```

- 위 코드는 p변수 중 MiddleName에 값을 할당하는 과정에서 컴파일 에러가 발생한다. `MiddleName: &"Perry"`로도 에러는 해결되지 않는다.

- 이 문제를 회피하기 위한 두 가지 방법이 있는데, 첫 번째는 변수에 상수의 값을 들고 있게끔 하는 것이다.  
  두 번째는 helper 함수를 작성해 불리언, 숫자, 문자열 타입을 파라미터로 받아 해당 타입의 포인터를 반환하도록 하는 방법이다.

```go
func stringp(string s) *string {
	return &s
}
```

- 위 함수로 문제가 된 구조체를 다시 작성해보자.

```go
p := person{
	FirstName: "Pat",
	MiddleName: stringp("Perry"),
	LastName: "Peterson",
}
```

- 위 방식이 왜 동자할까? 상수를 함수로 전달했을 때, 상수는 파라미터로 복사된다. 그것은 변수이기 때문에 메모리에서 주소를 갖는다.  
  즉 `stringp()`는 변수의 메모리 주소를 반환하게 되는 것이다.

---

## 포인터를 두려워하지 말자

- 포인터는 Java, Javscript, Python, Ruby 등의 언어에 익숙하다면 위협적일 수 있다. 하지만 포인터는 실제 클래스의 동작과 유사하다.  
  이런 언어의 모든 클래스 인스턴스는 포인터로 구현이 된다. 클래스 인스턴스를 메소드로 넘길 때, 복사된 값은 인스턴스의 포인터이다.

- Go에서 포인터 변수나 파라미터를 사용할 때, 똑같은 수행을 보인다. Go와 이런 언어들 간의 차이는 원시 값과 구조체 모두를 위해 값으로 사용할지,  
  포인터로 사용할지에 대한 **선택**을 제공한다는 것이다. 대부분의 경우에는 값으로 사용하자. 값으로 사용하는 것은 데이터가 언제, 어떻게 수정되는지  
  이해하기 쉬워진다. 값으로 사용하는 또다른 이득은 GC가 해야하는 일의 양을 줄여준다.

---

## 포인터는 변경 가능한 파라미터를 가리킨다.

- 이전에 봤듯이 Go 상수는 컴파일 과정에서 계산될 수 있는 리터럴 표현을 위한 이름을 제공한다. 언어에는 다른 종류의 갑을 불변으로 선언하는 메커니즘은 없다.  
  최신 소프트웨어 엔지니어링은 불변성을 받아들인다. 불변 타입은 버그로부터 조금 더 안전하고, 더 이해하기 쉬우며 변경에 더 적합하기 때문이다.  
  반대로 가변성은 프로그램이 무엇을 하는지 더 이해하기 힘들게 만들며 협업하기 어렵게 될 수 있다.

- Go에서 불변 상수를 선언할 수 없다는 것은 문제가 될 수 있지만, 파라미터를 값이나 포인터로 선택할 수 있도록 하는 기능이 그런 문제를 해결할 수 있다.  
  소프트웨어 구성 과정 자료는 _"가변의 객체를 사용하는 것은 메소드 내에서 지역적으로 사용하거나 단 하나의 참조만 있게 사용한다면 나쁘지 않다."_ 라고  
  설명을 계속한다. 어떤 변수나 파라미터를 불변으로 선언하는 것보다, Go 개발자들은 가변인 파라미터를 가리키는 포인터를 사용한다.

- Go는 call by value를 사용하는 언어이기에, 함수로 전달된 값은 복사된다. 기본타입, 구조체, 배열과 같은 비 포인터 타입들은 호출된 함수에서  
  원본을 수정할 수 없다는 의미이다. 호출된 함수는 원본의 복사본을 갖기에 원본의 불변성을 보장한다.

- 하지만 포인터가 함수로 전달되면 함수는 포인터의 복사를 얻게 된다. 해당 포인터는 원본 데이터를 가리키고 있는데, 이는 호출된 함수에서 원본 데이터를  
  수정할 수 있다는 의미이다.

- 이에 관련된 몇 가지 예시가 있다.

- 첫 번째 예시는 nil 포인터를 함수로 전달했을 때, 해당 값을 nil이 아닌 값으로 만들 수 없다는 것이다. **포인터에 이미 할당된 값이 있는 경우에만 값을**  
  **재할당할 수 있다.** 메모리 위치가 call by value를 통해 함수로 넘어가기 때문에 정수 파라미터의 값을 변경할 수 있는 것 이상으로 메모리 주소를  
  변경할 수 없다.

```go
func failedUpdate(g *int) {
	x := 10
	g = &x
}

func main() {
	var f *int // f: nil
	failedUpdate(f)
	fmt.Println(f) // nil
}
```

- 위 코드에서 `main()`에서 f는 nil을 갖고 시작한다. `failedUpdate()`를 호출하면 f의 값인 nil을 복사하고, 복사된 값을 파라미터 g에 넣는다.  
  이는 곧 g 또한 nil로 설정된다는 의미이다. `failedUpdate()` 내에서 새로운 변수 x를 선언하고, 값으로 10을 할당한다. 그 다음 `failedUpdate()`의  
  g가 x를 가리키도록 변경한다. 이는 `main()`의 f를 변경하지는 않으며, `failedUpdate()`를 끝내고 `main()`으로 돌아와도 f는 여전히 nil을 가진다.

- 복사되는 포인터의 두 번째 예시는 함수를 종료해도 포인터 파라미터에 할당된 값이 그대로 유지되도록 하기 위해서는 포인터를 역참조 해 값을 설정해야 한다는  
  것이다. 포인터를 변경하면, 복사본을 변경하는 것이지 원본을 변경하는 것이 아니다. 역참조는 원본과 복사본이 가리키는 메모리 위치에 새로운 값을 넣어준다.  
  이것이 어떻게 동작하는지 간단한 프로그램으로 알아보자.

```go
func failedUpdate(px *int) {
	x2 := 20
	px = &x2
}

func update(px *int) {
	*px = 20
}

func main() {
	x := 10
	fmt.Println(&x)
	fmt.Println(10) // 10
	update(&x)
	fmt.Println(x) // 20
}
```

- 위 예시 코드에서는 `main()`에서 x에 10을 넣는 것으로 시작한다. `failedUpdate()`가 호출될 때, x의 주소를 복사해 px 파라미터에 넣는다.  
  다음으로 `failedUpdate()`에서 x2를 선언하고 20을 할당한다. 그리고 나서 `failedUpdate()`에서 px는 x2의 주소를 가리키도록 한다.  
  `main()`으로 돌아왔을 때, x의 값은 변하지 않는다. `update()`가 호출될 때, x의 주소를 복사해 px에 다시 넣는다. 하지만 이번에는  
  `update()`에서 px가 가리키는 `main()`의 x 값을 변경한다. `main()`으로 돌아왔을 때, x는 변경되어 있다.

---
