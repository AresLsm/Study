# 컬렉션과 배열

## null 가능성과 컬렉션

- 타입 인자의 nullability는 타입 시스템의 일관성을 지키기 위해 필수적으로 고려해야할 사항이다.  
  컬렉션 안에 null 값을 넣을 수 있는지 여부는 어떤 변수의 값이 null이 될 수 있는지의 여부와  
  마찬가지로 중요하다. 변수 타입 뒤에 `?`를 붙이면 그 변수에 null을 저장할 수 있다는 뜻인  
  것처럼 타입 인자로 쓰인 타입에도 같은 표시를 사용할 수 있다.

```kt
fun readNumbers(reader: BufferedReader): List<Int?> {
    val result = ArrayList<Int?>()
    for (line in reader.lineSequence()) {
	try {
	    val number = line.toInt()
	    result.add(number)
	} catch (e: NumberFormatException) {
	    result.add(null)
	}
    }
    return result
}
```

- `List<Int?>`는 `Int?` 타입의 값을 저장할 수 있다. 다른 말로 하면, 그 리스트에는 null이나  
  `Int`를 저장할 수 있다. 현재 line을 파싱할 수 있으면 result에 정수를 넣고, 그렇지 않으면  
  null을 넣는다. 코틀린 1.1부터는 파싱에 실패하면 null을 반환하는 `String.toIntOrNull()`을  
  사용해 위 코드를 더 줄일 수 있다.

- 어떤 변수 타입의 nullability와 타입 파라미터로 쓰이는 타입의 nullability 사이의 차이를 알아보자.  
  `List<Int?>`의 경우, 리스트 자체는 항상 null이 아니다. 하지만 리스트에 들어있는 각 원소는 null이  
  될 수도 있다. `List<Int>?`의 경우에는 리스트를 가리키는 변수에 null이 들어갈 수 있지만, 리스트  
  안에는 null이 아닌 값만 들어간다.

- 경우에 따라 nullable한 값으로 이뤄진 null이 될 수 있는 리스트를 정의해야 할 수도 있다.  
  코틀린에서는 이를 `List<Int?>?`로 표현한다. 이런 리스트를 처리할 때는 변수에 대해 null 검사를  
  수행한 다음, 그 리스트에 속한 모든 원소에 대해 다시 null 검사를 수행해야 한다.

- nullable한 값으로 이뤄진 리스트를 다루는 예를 살펴보자. 정상적인 숫자를 따로 모으고, 그렇지 않은 숫자(null)의  
  개수를 세는 함수를 작성해보자.

```kt
fun addValidNumbers(numbers: List<Int?>) {
    val sumOfValidNumbers = 0
    val invalidNumbers = 0
    for(number in numbers) {
	if (number != null) {
	    sumOfValidNumbers += number
	} else {
	    invalidNumbers++
	}
    }
}
```

- 특별한 내용은 없다. 리스트의 원소에 접근하면 `Int?` 타입의 값을 얻는다. 따라서 그 값에 대해 산술 연산을  
  하기 전에 null 여부를 검사해야 한다.

- nullable한 값으로 이뤄진 컬렉션에서 null을 걸러내는 경우가 자주 있어서, 코틀린 표준 라이브러리는  
  `filterNotNull()`이라는 함수를 제공한다. 이 함수를 사용해 위 코드를 수정해보자.

```kt
fun addValidNumbers(numbers: List<Int?>) {
    val validNumbers = numbers.filterNotNull()
}
```

- 물론 걸러내는 연산도 컬렉션의 타입에 영향을 끼친다. 위 코드에서는 `filterNotNull()`이 컬렉션 내에  
  null이 들어있지 않음을 보장해주므로 validNumbers는 `List<Int>` 타입이다.

<hr/>

## 읽기 전용과 변경 가능한 컬렉션

- 코틀린 컬렉션과 Java 컬렉션을 나누는 가장 중요한 특성 하나는 코틀린에서는 컬렉션 안의 데이터에 접근하는 인터페이스와  
  컬렉션 내의 데이터를 변경하는 인터페이스를 분리했다는 점이다. 이런 구분은 코틀린 컬렉션을 다룰 때 사용하는 가장  
  기초적인 인터페이스인 `kotlin.collections.Collection`부터 시작한다. 이 `Collection` 인터페이스를 사용하면  
  컬렉션 내의 원소들을 순회하고, 컬렉션의 크기를 얻고, 어떤 값이 컬렉션 안에 있는지 검사하고, 컬렉션에서 데이터를 읽는  
  여러 다른 연산을 수행할 수 있다. 하지만 `Collection`에는 원소를 추가하거나 제거하는 메소드가 없다.

- 컬렉션의 데이터를 수정하려면 `kotlin.collections.MutableCollection` 인터페이스를 사용해야 한다.  
  `MutableCollection`은 일반 인터페이스인 `kotlin.collections.Collection`을 확장해서 원소를 추가하거나,  
  삭제하거나, 컬렉션 내의 모든 원소를 지우는 등의 메소드를 더 지원한다.

- 코드에서 가능하면 항상 읽기 전용 인터페이스를 사용하는 것을 일반적인 규칙으로 삼자. 코드가 컬렉션을 변경할 필요가  
  있을 때만 변경 가능한 버전을 사용하자.

- val과 var의 구별과 마찬가지로, 컬렉션의 읽기 전용 인터페이스와 변경 가능 인터페이스를 구별한 이유는 프로그램에서  
  데이터에 어떤 일이 벌어지는지를 더 쉽게 이해하기 위함이다. 어떤 함수가 `MutableCollection`이 아닌 `Collection`  
  타입의 인자를 받는다면, 그 함수는 컬렉션을 변경하지 않고 읽기만 한다. 반면, 어떤 함수가 `MutableCollection`을  
  인자로 받는다면 그 함수가 컬렉션의 데이터를 바꾸리라 가정할 수 있다. 어떤 컴포넌트의 내부 상태에 컬렉션이 포함된다면  
  그 컬렉션을 `MutableCollection`을 인자로 받는 함수에 전달할 때는 어쩌면 원본의 변경을 막기 위해 컬렉션을  
  복사해야 할 수도 있다. (방어적 복사, Defensive Copy)

- 예를 들어, 아래 `copyElements()`가 source는 변경하지 않지만 target은 변경하리라는 사실을 분명히 알 수 있다.

```kt
fun <T> copyElements(source: Collection<T>, target: MutableCollection<T>) {
    //..
}
```

- target에 해당하는 인자로는 읽기 전용 컬렉션을 넘길 수 없다. 실제 그 컬렉션이 변경 가능한 컬렉션인지의 여부와  
  관계 없이 선언된 타입이 읽기 전용이라면 target에 넘기면 컴파일 오류가 난다.

- 컬렉션 인터페이스를 사용할 때 항상 염두에 둬야할 핵심은 **읽기 전용 컬렉션이라고 해서 꼭 변경 불가능한 컬렉션일**  
  **필요는 없다는 점**이다. 읽기 전용 인터페이스 타입인 변수를 사용할 때, 그 인터페이스는 실제로는 어떤 컬렉션  
  인스턴스를 가리키는 수많은 참조 중 하나일 수 있다.

- 이렇게 어떤 동일한 컬렉션 객체를 가리키는 읽기 전용 컬렉션 타입의 참조와 변경 가능한 컬렉션 타입의 참조가 있는 경우,  
  이 컬렉션을 참조하는 다른 코드를 호출하거나 병렬 실행한다면 컬렉션을 사용하는 도중에 다른 컬렉션이 그 컬렉션의 내용을  
  변경하는 상황이 생길 수 있고, 이런 상황에서는 `ConcurrentModificationException`이나 다른 오류가 발생할 수 있다.  
  따라서 읽기 전용 컬렉션이 항상 Thread-Safe 하지 않다는 점을 명심해야 한다. 다중 스레드 환경에서 데이터를 다루는 경우,  
  그 데이터를 적절히 동기화하거나 동시 접근을 허용하는 데이터 구조를 활용해야 한다.

<hr/>

## 코틀린 컬렉션과 Java

- 모든 코틀린 컬렉션은 그에 상응하는 Java 컬렉션 인터페이스의 인스턴스이다. 따라서 코틀린과 Java를 오갈 때  
  아무런 변화도 필요 없다. 또한 wrapper 클래스를 만들거나 데이터를 복사할 필요도 없다. 하지만 코틀린은  
  모든 Java 컬렉션 인터페이스마다 읽기 전용 인터페이스와 변경 가능한 인터페이스라는 두 가지 표현(representation)을  
  제공한다.

- 코틀린의 읽기 전용과 변경 가능 인터페이스의 기본 구조는 `java.util` 패키지에 있는 Java 컬렉션 인터페이스의  
  구조를 그대로 옮겨 놓았다. 추가로 변경 가능한 각 인터페이스는 자신과 대응하는 읽기 전용 인터페이스를 확장(상속)한다.  
  변경 가능한 인터페이스는 `java.util` 패키지에 있는 인터페이스와 직접적으로 연관되지만, 읽기 전용 인터페이스에는  
  컬렉션을 변경할 수 있는 모든 요소가 빠져있다.

- Java 표준 클래스를 코틀린에서 어떻게 취급하기 위해 `java.util.ArrayList`와 `java.util.HashSet`을  
  생각해보자. 코틀린은 이들이 마치 각각 코틀린의 `MutableList`와 `MutableSet` 인터페이스를 상속한 것처럼  
  취급한다. 이러한 방식을 통해 코틀린은 Java 호환성을 제공하는 한편, 읽기 전용 인터페이스와 변경 가능  
  인터페이스를 분리한다.

- 컬렉션과 마찬가지로 `Map` 클래스(`Map`은 `Collection`이나 `Iterable`을 확장하지 않는다.)도 코틀린에서 `Map`과  
  `MutableMap`이라는 두 가지 버전으로 나뉜다.

- 아래 표는 여러 다른 컬렉션을 만들 때 사용하는 함수이다.

| 컬렉션 타입 | 읽기 전용 타입 | 변경 가능 타입                                                    |
| ----------- | -------------- | ----------------------------------------------------------------- |
| `List`      | `listOf()`     | `mutableListOf()`, `arrayListOf()`                                |
| `Set`       | `setOf()`      | `mutableSetOf()`, `hashSetOf()`, `sortedSetOf()`                  |
| `Map`       | `mapOf()`      | `mutableMapOf()`, `hashMapOf()`, `linkedMapOf()`, `sortedMapOf()` |

- Java 메소드를 호출하되, 컬렉션을 인자로 넘겨야 한다면 따로 반환하거나 복사하는 등의 추가 작업 없이 직접 컬렉션을  
  넘기면 된다. 예를 들어, `java.util.Collection`을 인자로 받는 메소드에는 아무런 `Collection`이나  
  `MutableCollection` 값을 인자로 넘길 수 있다.

- 이러한 성질로 인해 컬렉션의 변경 가능성과 관련해 중요한 문제가 생긴다. Java는 읽기 전용 컬렉션과 변경 가능 컬렉션을  
  구분하지 않으므로, 코틀린에서 읽기 전용 `Collection`으로 선언된 객체라도, Java 코드에서는 그 컬렉션 객체의 내용을  
  변경할 수 있다. 코틀린 컴파일러는 Java 코드가 컬렉션에 대해 어떤 일을 하는지 완전히 분석할 수 없다.  
  따라서 이런 상황을 막을 수 없다.

- 컬렉션을 Java로 넘기는 코틀린 프로그램을 작성한다면, 호출하려는 Java 코드가 컬렉션을 변경할지 여부에 따라  
  올바른 파라미터 타입을 사용할 책임은 온전히 개발자에게 있다.

- 이런 함정은 null이 아닌 원소로 이뤄진 컬렉션 타입에서도 발생한다. null이 아닌 원소로 이뤄진 컬렉션을 Java 메소드로  
  넘겼는데 Java 메소드가 null을 컬렉션에 넣을 수도 있다. 코틀린에서 이를 금지할 방법도 없고, 성능을 포기하지 않고는  
  컬렉션에 null값이 들어왔는지 감지할 방법도 없다. 따라서 컬렉션을 Java 코드에 넘길 때는 특별히 주의를 기울여야 하며,  
  코틀린 쪽 타입이 적절히 Java 쪽에서 컬렉션에게 가할 수 있는 변경의 내용을 반영(nullability나 불변성)하게 해야 한다.

<hr/>
