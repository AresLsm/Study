# 비동기: 동시성 프로그래밍 2

<h2>지연 평가 + Promise - L.map, map, take</h2>

- 비동기 상황에도 대응할 수 있도록 `map()`을 수정해보자.

```js
go(
  [1, 2, 3],
  L.map((a) => a + 10),
  take(2),
  console.log()
);

go(
  [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)],
  L.map((a) => a + 10),
  take(2),
  console.log()
);
```

- 지금대로라면 Promise가 있을 때 정상적인 연산이 되지 않는다.  
  기존에 있던 `L.map()`의 코드를 보자.

```js
L.map = curry(function* (fn, iterable) {
  for (const a of iterable) {
    yield fn(a);
  }
});
```

- `L.map()`는 들어온 iterable을 순회하고, 순회할 때 마다 각 원소를 `fn` 함수에 적용한다.  
  여기서 이전에 구현했던 Promise에 대응 가능한 `go1()`을 적용해보자.

```js
const go1 = (a, fn) => (a instanceof Promise ? a.then(fn) : fn(a));

L.map = curry(function* (fn, iterable) {
  for (const a of iterable) {
    yield go1(a, fn);
  }
});
```

- 지금 상태로, 위의 `go()` 함수 실행 결과는 Promise 2개로 이루어진 배열이다.  
  따라서 `take()`를 수정하여 Promise인 경우를 처리할 수 있도록 해주자.

```js
// 기존의 take
const take = curry((limit, iterable) => {
  let res = [];
  iterable = iterable[Symbol.iterator]();
  let current;
  while (!(current = iterable.next()).done) {
    const a = current.value;
    res.push(a);
    if (res.length === limit) {
      return res;
    }
  }
  return res;
});

// 수정한 take
const take = curry((limit, iterable) => {
  let res = [];
  iterable = iterable[Symbol.iterator]();
  return (function recur() {
    let current;
    while (!(current = iterable.next()).done) {
      const a = res.value;
      if (a instanceof Promise)
        return a.then((a) => {
          res.push(a);
          return res.length === limit ? res : recur();
        });
      res.push(a);
      if (res.length === limit) {
        return res;
      }
    }
    return res;
  })();
});
```

- 위 처럼 `take()`가 원소를 추가할 때 추가할 원소가 Promise인지 검사하여  
  Promise라면 `then()`을 호출하여 비동기를 처리해 주었다. 만약 추가할 원소(a)가  
  Promise라면 `then()`의 결과를 반환하는데, 먼저 배열에 넣은 다음, limit만큼  
  배열이 차지 않았다면 제어가 다시 while 문으로 돌아가야 하기 때문에 `recur()`라는  
  유명함수를 만들어서 재귀적으로 호출할 수 있게 했다.

- `map()` 또한 내부적으로 `L.map()`을 사용하기에 위 코드를 `map()`으로 바꾸더라도 정상 동작하게 된다.

<hr/>

<h2>Kleisli Composition - L.filter, filter, nop, take</h2>

- `filter()`에서 지연성과 비동기 동시성(Promise)를 함께 지원하려면 Kleisli Composition을 활용해야 한다.

```js
go(
  [1, 2, 3, 4],
  L.filter((a) => a % 2),
  take(2),
  console.log()
); // [1, 3]
```

- 위 코드에서 만약 주어진 인자가 Promise라고 해보자.

```js
go(
  [1, 2, 3, 4],
  L.map((a) => Promise.resolve(a * a)),
  L.filter((a) => a % 2),
  take(2),
  console.log()
);
```

- 현재로서는 위 코드가 제대로 동작하지 않는다.  
  그 이유는 `filter()`에 넘어오는 값이 Promise인 채로 넘어오기 때문이다.  
  이를 해결해보자.

```js
const nop = Symbol("nop");

L.filter = curry(function* (fn, iterable) {
  for (const a of iterable) {
    const b = go1(a, fn);
    if (b instanceof Promise)
      yield b.then((b) => (b ? a : Promise.reject(nop)));
    else yield a;
  }
});

// take까지 수정하여 nop이 발생하면 함수 합성을 취소한다.
const take = curry((limit, iterable) => {
  let res = [];
  iterable = iterable[Symbol.iterator]();
  return (function recur() {
    let current;
    while (!(current = iterable.next()).done) {
      const a = current.value;
      if (a instanceof Promise)
        return a
          .then((a) => ((res.push(a), res).length === 1 ? res : recur()))
          .catch((e) => (e === nop ? recur() : Promise.reject(e)));
      res.push(a);
      if (res.length === limit) return res;
    }
    return res;
  })();
});

go(
  [1, 2, 3, 4],
  L.map((a) => Promise.resolve(a * a)),
  L.filter((a) => a % 2),
  take(2),
  console.log()
);
```

- `yield b.then(b => b ? a : Promise.reject(nop))`처럼 작성한 이유는 만약 b의 Promise를 풀었을 때
  a를 넘겨줘야 하고, 그 외의 경우에는 아무런 것도 하지 않아야 하기 때문이다.
  `Promise.reject()`를 해주면 `Promise.reject()`가 일어난 이후의 코드는 에러가 발생하며 실행되지 않는다.
  이러한 면에서 Kleisli Composition을 지킬 수 있다는 것이다.

- `Promise.reject()`에 nop을 굳이 만들어서 전달한 이유는 이 코드가 실행된 이후의 모든 함수 합성을 취소하겠다
  라는 구분자로써 전달한 것이다. (그냥 특정 값을 담은 것일 뿐)  
  실제로 수정한 `take()`에서 에러를 catch하면 다음 원소에 대해 순회하기 위해 `recur()`를 다시 호출하고  
  nop이 아니라면 진짜 에러이기에 에러를 다시 던져준다.

- 여기서 한가지 더 알아야할 Promise의 중요한 규칙은, 중간에 `Promise.reject()`가 일어나면 뒤에  
  아무리 많이 `.then()`이 chaining되어 있어도 `.catch()`만 실행된다는 것이다.

- `filter()` 또한 내부에서 `L.filter()`를 사용하므로 이제 `filter()`까지 비동기에 대한 동시성을 지원하게 된다.

<hr/>

<h2>reduce()의 nop 지원</h2>

- `reduce()`에도 `take()`에서 처럼 nop을 지원하여 지연성과 promise를 모두 지원하도록 해보자.

```js
// 기존 reduce
const reduce = curry((fn, start, iterable) => {
  if (!iterable) {
    iterable = start[Symbol.iterator]();
    start = iterable.next().value;
  } else {
    iterable = iterable[Symbol.iterator]();
  }
  return go1(start, function recur(start) {
    let current;
    while (!(current = iterable.next()).done) {
      const a = current.value;
      start = fn(start, a);
      if (start instanceof Promise) return start.then(recur);
    }
    return acc;
  });
});

// 변경된 reduce

const reduceF = (start, a, fn) =>
  a instanceof Promise
    ? a.then((a) =>
        fn(start, a, (e) => (e === nop ? start : Promise.reject(e)))
      )
    : fn(start, a);

const reduce = curry((fn, start, iterable) => {
  if (!iterable) {
    iterable = start[Symbol.iterator]();
    start = iterable.next().value;
  } else {
    iterable = iterable[Symbol.iterator]();
  }
  return go1(start, function recur(acc) {
    let current;
    while (!(current = iterable.next()).done) {
      start = reduceF(acc, current.value, fn);
      if (start instanceof Promise) return start.then(recur);
    }
    return start;
  });
});
```

- 결국 기존에 비해 달라질 핵심적인 부분은 while문 내의 current의 value를 가져온 후  
  함수에 인자로 전달하는 부분이다. 이를 `reduceF`라는 함수로 뺐다.

- 조금 더 추상화를 시켜 리팩토링을 해보자.  
  우선 `next()`를 호출하는 부분에서 조금 더 안전하게 비동기를 처리하게 해보자.

```js
const head = (iterable) => go1(take(1, iterable), ([h]) => h);

const reduce = curry((fn, start, iterable) => {
  if (!iterable)
    return reduce(fn, head((iterable = start[Symbol.iterator]())), iterable);
  iterable = iterable[Symbol.iterator]();
  return go1(start, function recur(acc) {
    let current;
    while (!(current = iterable.next()).done) {
      start = reduceF(acc, current.value, fn);
      if (start instanceof Promise) return start.then(recur);
    }
    return start;
  });
});
```

<hr/>
