<h1>Factory Pattern</h1>

* `new` 키워드를 사용하는 것은 구상 클래스의 인스턴스를 생성하는 것이다. 구상 클래스를 바탕으로 코딩을 하면 나중에 코드를 수정해야할 가능성이   
  높아지고, 유연성이 떨어지게 된다. 또한 일련의 구상 클래스들이 있을 때는 어쩔 수 없이 아래와 같은 코드를 만들어야 할 경우도 있다.
```java
// 인터페이스 : Duck

Duck duck;
if(picnic) {
    duck = new MallardDuck();
} else if(hunting) {
    duck = new DecoyDuck();
} else if(inBachTub) {
    duck = new RubberDuck();
}
```

* 위와 같이 만들어지는 구상 클래스의 인스턴스 형식은 실행시에 주어진 조건에 따라 결정된다. 이러한 코드는 추후에 변경 또는 확장할 때 코드를   
  다시 확인하고 추가 또는 제거해야 함을 의미한다.

* `new` 자체에 문제가 있는 것은 아니고, 가장 문제를 일으키는 것이 바로 __변화__ 이다. 인터페이스에 맞춰서 코딩을 하면, 다형성 덕분에 어떠한   
  클래스든 특정 인터페이스만 구현하면 사용할 수 있다. 반대로 코드에서 구상 클래스를 많이 사용하면 새로운 구상 클래스가 추가될 때마다 코드를   
  수정해야 하기 때문에 많은 문제가 발생할 수 있다. 즉, 변화에 대해 닫혀있는 코드가 되는 것이다.
<hr/>

<h2>예시 시나리오</h2>

* 누군가가 피자 가게를 운영하고 있고, 피자는 종류가 다양하다. 이 때, 주문에 따라 올바른 피자를 고르고 피자를 만들기 위한 프로그램이 필요하다.
<hr/>

<h2>기본 코드</h2>

* 우선, 처음으로 주어진 기본 코드는 아래와 같다.
```java
Pizza orderPizza() {
    Pizza pizza = new Pizza();

    pizza.prepare();
    pizza.bake();
    pizza.cut();
    pizza.box();
    return pizza;
}
```

* 피자가 한 종류만 있는 것이 아니므로, 올바른 피자 종류를 고르고 만들기 위해 코드를 추가하자.
```java
Pizza orderPizza(String type) {
    Pizza pizza;

    if(type.equals("cheese")) {
        pizza = new CheesePizza();
    } else if(type.equals("greek")) {
        pizza = new GreekPizza();
    } else if(type.equals("pepperoni")) {
        pizza = new PepproniPizza();
    }
    return pizza;
}
```

* 위와 같은 코드가 있는 상황에서 새로운 피자 종류를 추가해야 하고, 기존 피자 중 하나를 삭제해야 한다면 `if`와 `else if`문이 바뀌게 된다.   
  즉, 위의 `orderPizza()` 메소드에서 가장 문제가 되는 부분은 바로 __인스턴스를 만들 구상 클래스를 선택하는 부분__ 이 된다. 

* 이제 어떤 부분이 바뀌고 어떤 부분이 바뀌지 않는지를 파악했으니 __캡슐화__ 를 진행할 차례이다.
<hr/>

<h2>객체 생성 부분의 캡슐화 + 간단한 팩토리</h2>

* 이제 객체를 생성하는 부분을 `orderPizza()` 메소드에서 뽑아내야 한다는 것은 명확하다.
* 새로 만들 객체에는 `Factory`라는 이름을 붙이자. __객체 생성을 처리하는 클래스를 `Factory`라 한다.__ 가장 먼저 `SimplePizzaFactory`를 만들고   
  나면 `orderPizza()`는 새로 만든 객체의 클라이언트가 된다. 즉, 새로 만든 객체를 호출하는 것이다. 간단히 말해, 피자가 필요할 때 마다 피자 공장에   
  피자를 만들어달라고 부탁한다고 생각하면 된다.
```java
public class SimplePizzaFactory {
    
    public Pizza createPizza(String type) {
        if(type.equals("cheese")) {
            return new CheesePizza();
        } else if(type.equals("pepperoni")) {
            return new PepproniPizza();
        } else if(type.equals("clam")) {
           return new ClamPizza();
        } else if(type.equals("veggie")) { 
            return new VeggiePizza();
        }
    }
}
```

* 위와 같이 `SimplePizzaFactory`를 따로 생성하여 생기는 장점은 이 클래스를 사용하는 클라이언트가 매우 많은 경우를 생각하면 된다.   
  위의 예시에는 `orderPizza()` 메소드만 나와 있지만, 피자 객체를 받아 가격이든, 설명이든, 다양한 주문 처리 등에 대한 클래스에서도 이 팩토리를   
  사용할 수 있다. 따라서 피자를 생성하는 작업을 한 클래스에 캡슐화시켜 놓으면 구현을 변경해야 하는 경우에 코드를 찾아 고칠 필요 없이 위의   
  팩토리 클래스 하나만을 고치면 된다.

* 이제 팩토리 클래스가 만들어졌으니, `PizzaStore` 클래스를 수정해보자. `PizzaStore`는 `SimplePizzaFactory`의 클라이언트가 되는 것이다.
```java
public class PizzaStore {

    private SimplePizzaFactory factory;

    public PizzaStore(SimplePizzaFactory factory) {
        this.factory = factory;
    }

    public Pizza orderPizza(String type) {
        
        Pizza pizza = factory.createPizza(type);
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        return pizza;
    }
}
```

* 위와 같은 구조를 `Simple Factory(간단한 팩토리)` 라 하는데, 이는 디자인 패턴이라고 할 수는 없다. 클래스 구조를 생성하면, `PizzaStore`는   
  `SimplePizzaFactory`의 클라이언트이며, 클라이언트는 팩토리를 이용해서 `Pizza` 인스턴스를 받게 된다. 이때, `SimplePizzaFactory#createPizza()`는   
  종종 static으로 선언되기도 한다. 이렇게 정적 메소드로 정의하는 방법은 `Static Factory`라 하는데, 정적 메소드를 사용하면 객체를 생성하기 위한   
  메소드를 실행시키기 위해 객체의 인스턴스를 만들지 않아도 된다. 하지만 서브클래스를 만들어서 객체 생성 메소드의 행동을 변경 시킬 수 없다는 단점이 있다.
<hr/>

<h2>예시 시나리오2</h2>

* 위와 같은 시나리오에서, 이제 `PizzaStore`가 각 지역별로 프랜차이즈를 두게 되었다고 생각하자. 또한 지역별로 입맛이 다르기에, 각각의 스타일을   
  가진 피자를 만들어야 한다.

* 피자를 만드는 과정이 모두 동일하다면, `SimplePizzaFactory`를 빼고 `NYPizzaFactory`, `ChicagoPizzaFactory`처럼 팩토리 클래스를 알맞은   
  PizzStore에서 사용하도록 하면 문제가 없다. 하지만, 피자를 만드는 과정 등 여러가지가 지역별 분점에 따라 다르다면 피자 가게와 피자 제작 과정 전체를    하나로 묶어주는 프레임워크를 만들어야 한다.

* 피자를 만드는 활동 자체는 전부 `PizzaStore` 클래스에 국한시키면서도 분점마다 고유의 스타일을 살릴 수 있도록 하는 방법이 있다.
```java
// 클래스가 추상 클래스로 바뀌었다.
public abstract class PizzaStore {

    public Pizza orderPizza(String type) {
        Pizza pizza = createPizza(type);

        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();

        return pizza;
    }

    // 팩토리 객체 대신 이 메소드를 사용한다.
    protected abstract Pizza createPizza(String type);
}
```

* 다음으로는 각 분점을 위한 `PizzaStore`의 서브 클래스가 필요하다. 피자의 스타일은 각 서브클래스에서 결정한다.

* `PizzaStore#orderPizza()` 메소드에 이미 주문 시스템이 잘 갖춰져 있다. 이 주문 시스템 자체는 모든 분점에서 동일하게 진행되어야 한다.
* 각 분점마다 달라질 수 있는 것은 피자의 스타일 뿐이다. 이렇게 분점마다 달라지는 것들은 `createPizza()` 메소드에 집어넣고, 이 메소드에서   
  해당 스타일의 피자를 만드는 것을 모두 책임지도록 할 것이다. 즉, `PizzaStore`의 서브클래스에서 `createPizza()`를 구현하도록 하는 것이다.

* `PizzaStore`의 분점 중 하나인 `NYPizzaStore`를 보도록 하자.
```java
public class NYPizzaStore extends PizzaStore {

    @Override
    public Pizza createPizza(String type) {
        if(type.equals("cheese")) {
            return new NYStyleCheesePizza();
        } else if(type.equals("veggie")) {
            return new NYStyleVeggiePizza();
        } else if(type.equals("clam")) {
            return new NYStyleClamPizza();
        } else if(type.equals("pepperoni")) {
            return new NYStylePepproniPizza();
        } else return null;
    }
}
```

* 슈퍼클래스(`PizzaStore`)의 `orderPizza()` 메소드에서는 어떤 종류의 피자가 만들어지는지 전혀 알 수 없다.
<hr/>

<h2>팩토리 메소드</h2>

* 팩토리 메소드는 객체의 생성을 처리하며, 팩토리 메소드를 이용하면 객체를 생성하는 작업을 서브클래스에 캡슐화할 수 있다. 이렇게 하면 슈퍼클래스에   
  있는 클라이언트 코드와 서브클래스에 있는 객체 생성 코드를 분리시킬 수 있다.
```java
abstract Product factoryMethod(String type);
```

  * 팩토리 메소드는 추상 메소드로 선언하여 서브클래스에서 객체 생성을 책임지도록 한다.
  * 팩토리 메소드는 특정 제품(`Product`)을 반환하며, 그 객체는 보통 슈퍼클래스에서 정의한 메소드 내에서 쓰이게 된다.
  * 팩토리 메소드는 클라이언트에서 실제로 생성되는 구상 객체가 무엇인지 알 수 없게 만드는 역할도 한다.
  * 팩토리 메소드를 만들 때 매개변수를 써서 만들어낼 객체의 종류를 선택할 수도 있다.
<hr/>

<h2>예시 시나리오에 이어서..</h2>

* 피자들의 슈퍼클래스에 해당하는 `Pizza` 클래스는 아래와 같다.
```java
public abstract class Pizza {

    String name;
    String dough;
    String sauce;
    ArrayList<String> toppings = new ArrayList();

    void prepare() {
        // prepare code
    }

    void bake() {
        // bake code
    }

    void cut() {
        // cut code
    }

    void box() {
        // box code
    }
}
```

* 각 피자들의 구상 클래스들은 모두 `Pizza` 클래스를 상속받으며, 알맞게 `prepare()`, name 등에 해당하는 피자의 스타일을 지정할 수 있다.
<hr/>

<h2>Factory Method Pattern</h2>

* 정의 : `Factory Method Pattern`에서는 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서   
  결정하게 만든다. 이 패턴을 이용하면 결국 클래스의 인스턴스를 만드는 일을 서브클래스에 맡기게 되는 것이다.
  * 서브 클래스에서 어떤 클래스의 인스턴스를 만들지를 __결정한다__ 라는 표현을 쓰는 이유는, 이 패턴을 사용할 때 서브클래스에서 실행중에 어떤 클래스의   
    인스턴스를 만들지를 결정하기 때문이 아니라, __Creator Class 자체가 실제 만들어질 인스턴스(제품)에 대한 사전 지식이 전혀 없이 만들어지기 때문__ 이다.


* 모든 팩토리 패턴에서는 __객체 생성을 캡슐화__ 한다. `Factory Method Pattern(팩토리 메소드 패턴)`에서는 서브클래스에서 어떤 클래스를 만들지를   
  결정하게 함으로써 객체 생성을 캡슐화한다.

* `Creator 클래스`는 추상 클래스와 구상 클래스로 이루어지는데, 추상 클래스에서는 나중에 서브클래스에서 제품(객체)을 생산하기 위해 구현할 팩토리   
  메소드(추상 메소드)를 정의한다. 제품을 생산하는 클래스는 `Concrete Creator`라 하며, 추상 클래스를 상속받는다.

* `Product 클래스`는 모든 제품의 슈퍼클래스와, 그 슈퍼클래스를 상속받는 실제 구현 클래스들이다.