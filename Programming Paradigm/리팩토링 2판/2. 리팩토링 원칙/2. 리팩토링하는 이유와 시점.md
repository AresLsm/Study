# 리팩토링의 이유와 시점

<h2>리팩토링하는 이유</h2>

- 리팩토링이 소프트웨어의 모든 문제점을 해결하는 만병통치약은 절대 아니다.  
  하지만 코드를 건강한 상태로 유지하는 데 도와주는 약임은 분명하다.  
  리팩토링은 다양한 용도로 활용할 수 있고, 또 반드시 그래야 하는 도구이다.

<h3>리팩토링하면 소프트웨어 설계가 좋아진다</h3>

- 리팩토링하지 않으면 소프트웨어의 내부 설계(아키텍쳐)가 훼손되기 쉽다. 아키텍쳐를 충분히 이해하지 못한 채 단기 목표만을  
  위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다. 그러면 코드만 봐서는 설계를 파악하기 어려워진다. 코드 구조가 무너지기  
  시작하면 악효과가 누적된다. 코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어려워지고, 설계가 부패되는 속도는  
  더욱 빨라진다. 반면 규칙적인 리팩토링은 코드의 구조를 지탱해준다.

- 같은 일을 하더라도 설계가 나쁘면 코드가 길어지기 십상이다. 사실상 같은 일을 하는 코드가 여러 곳에 나타날 수 있기 때문이다.  
  그래서 중복 코드 제거는 설계 개선 작업의 중요한 한 축을 차지한다. 코드량을 줄인다고 시스템이 빨라지는 것은 아니다.  
  프로그램의 용량이 속도에 영향을 주는 경우는 별로 없다. 하지만 코드량이 줄면 수정하는 데 드는 노력은 크게 달라진다.  
  코드가 길 수록 실수 없이 수정하기 어려워진다. 이해해야할 코드량도 늘어난다. 비슷한 일을 하는 코드가 산재해 있다면 한 부분만  
  살짝 바꿔서는 시스템이 예상대로 동작하지 않을 수 있다. 반면 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을  
  보장할 수 있으며, 이는 바람직한 설계의 핵심이다.

<h3>리팩토링하면 소프트웨어를 이해하기 쉬워진다</h3>

- 프로그래밍은 여러 면에서 컴퓨터에게 시킬 일을 표현하는 행위이다. 컴퓨터에게 시키려는 일과 이를 표현하는 코드의 차이를  
  최대한 줄이는 것은 매우 중요하다. 프로그래밍은 결국 개발자가 원하는 바를 명확히 표현하는 것이다.  
  그런데 내 소스를 컴퓨터만 사용하는 것이 아니고, 예를 들어 몇 달이 지나 누군가가 내 코드를 수정하고자 읽게될 수 있다.  
  사실 프로그래밍에서는 사람이 가장 중요하지만 소홀하기 쉽다. 다른 프로그래머가 내 코드를 제대로 이해했다면 한 시간에 끝낼  
  수정을 일주일이나 걸리게 될 수도 있다.

- 문제는 프로그램을 동작시키는 데만 신경쓰면 나중에 내 코드를 다룰 개발자를 배려하지 못한다는 데 있다.  
  코드를 이해하기 쉽게 만들려면 일하는 리듬에 변화를 줘야 한다. 리팩토링은 코드가 더 잘 읽히게 도와준다.  
  잘 작동하지만 이상적인 구조는 아닌 코드가 있다면, 잠깐 시간을 내서 리팩토링하자. 그러면 코드의 목적이 더 잘 드러나게, 다시말해  
  내 의도를 더 명확하게 전달하도록 개선할 수 있다.

- 단지 다른 사람을 배려하기 위해서가 아니다. 사실 그 다른 사람이 바로 나 자신일 때가 많다.  
  그래서 더더욱 리팩토링이 중요하다.

<h3>리팩토링하면 버그를 쉽게 찾을 수 있다</h3>

- 코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다.  
  리팩토링을 하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다.  
  프로그램의 구조를 명확하게 다듬으면 그냥 *이럴 것이다*라고 가정하던 점들이 분명히 드러나는데,  
  버그를 지나치려야 지나칠 수 없을 정도까지 명확해진다.

<h3>리팩토링하면 프로그래밍 속도를 높일 수 있다</h3>

- 지금까지 본 장점들을 한 마디로 정리하면, 리팩토링하면 코드 개발 속도를 높일 수 있다는 말과 같다.  
  사람들은 리팩토링에 대해 알게 되면 품질을 높일 수 있다는 점에는 대개 수긍한다.  
  내부 설계와 가독성이 개선되고 버그가 줄어든다는 점은 모두 품질 향상에 직결된다.

- 오랜 시간이 지난 프로젝트는 새로운 기능을 추가할 때 초기에 비해 시간이 훨씬 오래 걸리는 경향이 있다.  
  즉, 새로운 기능을 추가할수록 기존 코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 늘어난다는 것이다.  
  게다가 기능을 추가하고 나면 버그가 발생하는 일이 잦고, 이를 해결하는 시간은 한층 더 걸린다.  
  이러한 부담은 기능 추가 속도를 계속 떨어뜨리면서, 차라리 처음부터 새로 개발하는 편이 낫겠다고 생각하는 지경에 이른다.

- 시간이 x축, 기능의 누적이 y축인 그래프가 있을 때 나쁜 설계는 루트 그래프를 띄며,  
  좋은 설계는 x=y 형식의 그래프를 띈다.  
  이렇게 차이나는 원인은 소프트웨어의 내부 품질에 있다.  
  내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다.  
  모듈화가 잘 되어있으면 전체 코드베이스 중 작은 부분만 이해하면 된다.  
  코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉽다.  
  내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.

<hr/>

<>
