## 조건문 분해하기

```js
// 리팩토링 적용 전
if (!date.isBefore(plan.summerStart) && !date.isAfter(plan.summerEnd)) {
  charge = quantity * plan.summerRate;
}

// 리팩토링 적용 후
if (summer()) {
  charge = summerCharge();
} else {
  charge = regularCharge();
}
```

### 배경

- 복잡한 조건부 로직은 프로그램을 복잡하게 만드는 가장 흔한 원흉에 속한다. 다양한 조건, 그에 따라  
  동작도 다양한 코드를 작성하면 순식간에 꽤 긴 함수가 탄생한다. 긴 함수는 그 자체로 읽기가 어렵지만,  
  조건문은 그 어려움을 한층 가중시킨다. 조건을 검사하고 그 결과에 따른 동작을 표현하는 코드는 무슨  
  일이 일어나는지는 이야기해주지만, _'왜'_ 일어나는지는 제대로 말해주지 않을 때가 많은 것이 문제다.

- 거대한 코드 블록이 주어지면, 코드를 부위별로 분해한 다음 해체된 코드 덩어리들을 각 덩어리의 의도를  
  살린 이름의 함수 호출로 바꿔주자. 그러면 전체적인 의도가 더 확실히 드러난다. 이렇게 해주면 해당 조건이  
  무엇인지를 강조하고, 그래서 무엇을 분기했는지가 명백해진다. 분기한 이유 역시 더 명확해진다.

- 이 리팩토링은 자신의 코드에 **함수 추출하기**를 적용하는 한 사례라 할 수 있다.

### 절차

- (1) 조건식과 그 조건식에 딸린 조건절 각각을 **함수로 추출** 한다.

### 예시

- 여름철이라면 할인율이 달라지는 어떤 서비스의 요금을 계산한다 해보자.

```js
if (!date.isBefor(plan.summerStart) && !date.isAfter(plan.summerEnd)) {
  charge = quantity * plan.summerRate;
} else {
  charge = quantity * plan.regularRate + plan.regularServiceCharge;
}
```

- 우선 _(1) 조건 부분(조건식)을 별도 함수로 추출하자._

```js
if (summer()) {
  charge = quantity * plan.summerRate;
} else {
  charge = quantity * plan.regularRate + plan.regularServiceCharge;
}

function summer() {
  return !date.isBefore(plan.summerStart) && !date.isAfter(plan.summerEnd);
}
```

- 그런 다음 조건을 만족했을 때의 로직도 또 다른 함수로 추출한다.  
  조건을 만족하지 않았을 때의 로직도 함수로 추출해주자. 사이에 테스트를 해야 한다.

```js
if (summer()) {
  charge = summerCharge();
} else {
  charge = regularCharge();
}

function summer() {
  return !date.isBefore(plan.summerStart) && !date.isAfter(plan.summerEnd);
}

function summerCharge() {
  return quantity * plan.summerRate;
}

function regularCharge() {
  return quantity * plan.regularRate + plan.regularServiceCharge;
}
```

- 취향에 따라 삼항 연산자로 바꿀 수도 있다.

```js
charge = summer() ? summerCharge() : regularCharge();
```

<hr/>

## 조건식 통합하기

```js
// 리팩토링 적용 전
if(employee.seniority < 2) return 0;
if(employee.monthsDisabled > 12) return 0;
if(employee.isPartTime) return 0;

// 리팩토링 적용 후
if(isNotEligibleForDisability()) return 0;

function isNotEligibleForDisability() {
  return (employee.seniority < 2) || (employee.monthsDisabled > 12) || (employee.isPartTime);
```

### 배경

- 비교하는 조건은 다르지만 그 결과로 수행하는 동작은 똑같은 코드들이 더러 있는데, 어짜피 같은 일을 할 거라면 조건 검사도  
  하나로 통합하는게 낫다. 이럴 때 _and_ 연산자나 _or_ 연산자를 사용하면 여러 개의 비교 로직을 하나로 합칠 수 있다.

- 조건부 코드를 통합하는 게 중요한 이유는 두 가지다.  
  첫째, 여러 조각으로 나뉜 조건들을 하나로 통합함으로써 하려는 일이 더 명확해진다. 나눠서 순서대로 비교해도 결과는  
  똑같지만, 읽는 사람은 독립된 검사들이 우연히 함께 나열된 것으로 오해할 수 있다.  
  둘째, 이 작업은 **함수 추출하기**까지 이어질 가능성이 높다. 복잡한 조건식을 함수로 추출하면 코드의 의도가  
  훨씬 분명하게 드러나는 경우가 많다. 함수 추출하기는 _'무엇'_ 을 하는지를 기술하던 코드를  
  _'왜'_ 하는지를 말해주는 코드로 바꿔주는 효과적인 도구임을 기억하자.

### 절차

- (1) 해당 조건식들 모두에 부수 효과가 없는지 확인한다.  
  부수효과가 있는 조건식들에는 **질의 함수와 변경 함수 분리하기**를 적용한다.
- (2) 조건문 두 개를 선택해서 두 조건문의 조건식들을 논리 연산자로 결합한다.  
  순차적으로 이뤄지는 조건문은 or로, 중첩된 조건문은 and로 결합한다.
- (3) 테스트한다.
- (4) 조건이 하나만 남을 때까지 `(2)` ~ `(3)`을 반복한다.
- (5) 하나로 합쳐진 조건식을 **함수로 추출**할지 고려해본다.

### 예시: or 사용하기

- 아래와 같은 코드를 발견했다 해보자.

```js
function disabilityAmount(employee) {
  if (employee.seniority < 2) {
    return 0;
  }
  if (employee.monthsDisabled > 12) {
    return 0;
  }
  if (employee.isPartTime) {
    return 0;
  }
  // 장애 수당 계산
}
```

- 똑같은 결과로 이어지는 조건 검사가 순차적으로 진행되고 있다.  
  _(2) 결과로 행하는 동작이 같으므로 이를 하나의 식으로 결합해보자._  
  순차적인 경우이므로 or 연산자를 이용하면 된다.

```js
function disabilityAmount(employee) {
  if (employee.seniority < 2 || employee.monthsDisabled > 12) {
    return 0;
  }
  if (employee.isPartTime) {
    return 0;
  }
  // 장애 수당 계산
}
```

- _(3) 테스트_ 한 후 _(4) 그 다음 조건에도 적용_ 한다.

```js
function disabilityAmount(employee) {
  if (
    employee.seniority < 2 ||
    employee.monthsDisabled > 12 ||
    employee.isPartTime
  ) {
    return 0;
  }
  // 장애 수당 계산
}
```

- 이제 _(5) 모든 조건을 통합했다면 최종 조건식을 함수로 추출할_ 수 있다.

```js
function disabilityAmount(employee) {
  if (isNotEligibleForDisability()) return 0;
  // 장애 수당 계산

  function isNotEligibleForDisability() {
    return (
      employee.seniority < 2 ||
      employee.monthsDisabled > 12 ||
      employee.isPartTime
    );
  }
}
```

### 예시: and 사용하기

- 앞의 예시에서는 조건식들을 or 연산자로 결합하는 모습을 봤는데, if문이 중첩되어 나오면 and를 사용해야 한다.

```js
if (employee.onVacation) {
  if (employee.seniority > 10) {
    return 1;
  }
}
```

- 이 조건들을 and 연산자로 결합해보자.

```js
if (employee.onVacation && employee.seniority > 10) return 1;
else return 0.5;
```

<hr/>

## 중첩 조건문을 보호 구문으로 바꾸기

```js
// 리팩토링 적용 전
function getPayAmount() {
  let result;
  if (isDead) result = deadAmount();
  else {
    if (isSeperated) result = seperatedAmount();
    else {
      if (isRetired) result = retiredAmount();
      else result = normalPayAmount();
    }
  }
  return result;
}

// 리팩토링 적용 후

function getPayAmount() {
  if (isDead) return deadAmount();
  if (isSeperated) return seperatedAmount();
  if (isRetired) return retiredAmount();
  return normalPayAmount();
}
```

### 배경

- 조건문은 주로 두 가지 형태로 쓰인다. 참인 경로와 거짓인 경로 모두 정상 동작으로 이어지는 형태와,  
  한쪽만 정상인 형태다.

- 두 형태는 의도하는 바가 서로 다르므로 그 의도가 코드에 드러나야 한다. 만약 두 경로 모두 정상  
  동작이라면 if와 else절을 사용한다. 한쪽만 정상이라면 비정상 조건을 if에서 검사한 다음,  
  조건이 참이면(비정상이면) 함수에서 빠져나오게 하자. 이때, 두 번째 검사 형태를 흔히  
  **보호 구문(Gurade Clause)** 이라 한다.

- 중첩 조건문을 보호 구문으로 바꾸기 리패토링의 핵심은 의도를 부각하는 데 있다. 저자는 if-then-else  
  구조를 사용할 때 if절과 else절에 똑같은 무게를 두어, 코드를 읽는이에게 양 갈래가 똑같이  
  중요하다는 뜻을 전달한다. 이와 달리, 보호 구문은 _"이건 이 함수의 핵심이 아니다. 이 일이 일어나면_  
  _무언가 조취를 취한 후 함수에서 빠져나온다."_ 라고 이야기한다.

- 함수의 진입점과 반환점이 하나라고 배운 사람들이 있다. 진입점이 하나라는 점은 최신 프로그래밍 언어에서는  
  강제된다. 그런데 반환점이 하나여야 된다는 규칙은 유용하지 않다. 코드에서는 **명확함**이 핵심이다.  
  반환점이 하나일 때 함수의 로직이 더 명백하다면 그렇게 하자. 그렇지 않다면 하지 말자.

### 절차

- (1) 교체해야 할 조건 중 가장 바깥 것을 선택해 보호 구문으로 바꾼다.
- (2) 테스트한다.
- (3) `(1)` ~ `(2)` 과정을 필요한 만큼 반복한다.
- (4) 모든 보호 구문이 같은 결과를 반환한다면 보호 구문들의 조건식을 통합한다.

### 예시

- 직원 급여를 계산하는 코드를 보자. 현직 직원만 급여를 받아야 하므로 이 함수는 두 가지 조건을 검사한다.

```js
function payAmount(employee) {
  let result;
  if (employee.isSeperated) {
    result = { amount: 0, reasonCode: "SEP" };
  } else {
    if (employee.isRetired) {
      result = { amount: 0, reasonCode: "RET" };
    } else {
      // 급여 계산 로직
      lorem.ipsum(dolor.setAmet);
      consectuter(adipiscing).elit();
      sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua);
      ut.enim.ad(minim.veniam);
      result = someFinalComputation();
    }
  }
  return result;
}
```

- 위 코드는 실제로 벌어지는 중요한 일들이 중첩된 조건들에 가려 잘 보이지 않는다. 이 코드가 진짜 의도한  
  작업은 모든 조건이 거짓일 때만 실행되기 때문이다. 이 상황에서는 보호 구문을 사용하면 코드의 의도가  
  더 잘 드러난다.

- 우선 _(1) 최상위 조건부터 보호 구문으로 바꿔보자._

```js
function payAmount(employee) {
  let result;
  if (employee.isSeperated) return { amount: 0, reasonCode: "SEP" };
  if (employee.isRetired) {
    result = { amount: 0, reasonCode: "RET" };
  } else {
    // 급여 계산 로직
    lorem.ipsum(dolor.setAmet);
    consectuter(adipiscing).elit();
    sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua);
    ut.enim.ad(minim.veniam);
    result = someFinalComputation();
  }
  return result;
}
```

- _(2) 변경 후 테스트_ 하고 _(3) 다음 조건으로 넘어가자._

```js
function payAmount(employee) {
  let result;
  if (employee.isSeperated) return { amount: 0, reasonCode: "SEP" };
  if (employee.isRetired) return { amount: 0, reasonCode: "RET" };
  // 급여 계산 로직
  lorem.ipsum(dolor.setAmet);
  consectuter(adipiscing).elit();
  sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua);
  ut.enim.ad(minim.veniam);
  result = someFinalComputation();
  return result;
}
```

- 여기까지 왔다면 result 변수는 아무런 역할도 하지 않으므로 제거해도 좋다.

```js
function payAmount(employee) {
  if (employee.isSeperated) return { amount: 0, reasonCode: "SEP" };
  if (employee.isRetired) return { amount: 0, reasonCode: "RET" };
  // 급여 계산 로직
  lorem.ipsum(dolor.setAmet);
  consectuter(adipiscing).elit();
  sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua);
  ut.enim.ad(minim.veniam);
  return someFinalComputation();
}
```

### 예시: 조건 반대로 만들기

- 아래 코드를 보자.

```js
function adjustedCapital(instrument) {
  let result = 0;
  if (instrument.capital > 0) {
    if (instrument.interestRate > 0 && instrument.duration > 0) {
      result =
        (instrument.income / instrument.duration) * instrument.adjustmentFactor;
    }
  }
  return result;
}
```

- 역시 한 번에 하나씩 수정해보자. 다만 이번에는 보호 구문을 추가하면서 조건을 역으로 바꿀 것이다.

> 기존 보호 구문은 비정상 조건을 if에서 검사한 다음, 조건이 참이면(비정상이면) 함수에서 빠져나오게 했다.

```js
function adjustedCapital(instrument) {
  let result = 0;
  if (instrument.capital <= 0) return result;
  if (instrument.interestRate > 0 && instrument.duration > 0) {
    result =
      (instrument.income / instrument.duration) * instrument.adjustmentFactor;
  }
  return result;
}
```

- 다음 조건을 살짝 더 복잡하므로 두 단계로 나눠 진행해보자.  
  먼저 간단히 not 연산자(`!`)를 추가한다.

```js
function adjustedCapital(instrument) {
  let result = 0;
  if(instrument.capital <= 0) return result;
  if(!(instrument.interestRate > 0 && instrument.duration > 0)) return result;
  result = (instrument.income / instrument.duration) * instrument.adjustmentFactor;
  return result;
```

- 이처럼 조건식 안에 not 연산자가 있으면 보기에 어려우니 아래처럼 간소화해보자.

```js
function adjustedCapital(instrument) {
  let result = 0;
  if (instrument.capital <= 0) return result;
  if (instrument.interestRate <= 0 || instrument.duration <= 0) return result;
  result =
    (instrument.income / instrument.duration) * instrument.adjustmentFactor;
  return result;
}
```

- 두 if 문 모두 같은 결과를 내는 조건을 포함하니, 조건식을 통합하자.

```js
function adjustedCapital(instrument) {
  let result = 0;
  if (
    instrument.capital <= 0 ||
    instrument.interestRate <= 0 ||
    instrument.duration <= 0
  )
    return result;
  result =
    (instrument.income / instrument.duration) * instrument.adjustmentFactor;
  return result;
}
```

- 여기서 result는 두 가지의 역할을 한다.(값이 두 번 할당된다는 것은 두 가지의 역할을 한다는 뜻이다.)  
  처음 설정한 값 0은 보호 구문이 발동했을 때 반환할 값이다. 두 번째로 설정한 값은 계산의 최종 결과다.  
  이 변수를 제거하면 변수 하나가 두 가지 용도로 쓰이는 상황이 사라진다.

```js
function adjustedCapital(instrument) {
  if (
    instrument.capital <= 0 ||
    instrument.interestRate <= 0 ||
    instrument.duration <= 0
  )
    return 0;
  return (
    (instrument.income / instrument.duration) * instrument.adjustmentFactor
  );
}
```

<hr/>
