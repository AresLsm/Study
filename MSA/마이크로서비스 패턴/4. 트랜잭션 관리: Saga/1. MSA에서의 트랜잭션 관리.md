# MSA에서의 트랜잭션 관리

- 엔터프라이즈 애플리케이션은 거의 모든 요청을 하나의 DB 트랜잭션으로 처리한다.  
  개발자는 보통 트랜잭션 관리를 간소화한 프레임워크, 라이브러리를 사용하고  
  그중에는 트랜잭션을 명시적으로 시작, 커밋, 롤백할 수 있는 프로그램형 API를  
  제공하는 제품도 있다. Spring Framework는 선언형 메커니즘을 제공한다.  
  즉, 메소드 선언부에 `@Transactional` 어노테이션만 붙이면 해당 메소드를  
  하나의 트랜잭션으로 자동 실행하므로 개발자가 간편하게 트랜잭셔널 비즈니스  
  로직을 작성할 수 있다.

- 단일 DB에 접근하는 모놀리틱 애플리케이션의 트랜잭션 관리는 어렵지 않다.  
  하지만 다중 DB, 다중 메시지 브로커를 사용하는 모놀리틱 애플리케이션이나,  
  자체 DB를 가진 여러 서비스로 구성된 MSA는 트랜잭션 관리가 어렵기 때문에  
  좀 더 정교한 메커니즘이 필요하다.

- Saga에 대해 살펴보기 전에, 먼저 MSA에서 트랜잭션 관리가 어려운 이유를 알아보자.

<h2>분산 트랜잭션의 필요성</h2>

- `createOrder()`는 주문 가능한 소비자인지 확인하고, 주문 내역을 확인하고,  
  소비자의 신용카드를 승인하고, DB에 주문을 생성하는 작업으로 이뤄진다.  
  모놀리틱 애플리케이션에서 이런 작업을 구현하기에는 그렇게 어렵지 않다.  
  주문 검증에 필요한 데이터를 그냥 가져오면 되기 때문이다.  
  Spring을 사용할 경우, `createOrder()` 메소드에 `@Transactional`만  
  붙여주면 ACID 트랜잭션이 자동으로 걸려, 데이터 일관성이 보장된다.

- 반면, 데이터가 여러 서비스에 흩어져 있는 MSA는 복잡하다.  
  `createOrder()`는 소비자 서비스, 주문 서비스, 주방 서비스, 회계 서비스 등  
  여러 서비스에 있는 데이터에 접근해야 한다.

- 서비스마다 DB가 따로 있기 때문에 여러 DB에 걸쳐 데이터 일관성을 유지할 수 있는  
  수단을 강구해야 한다.

<hr/>

<h2>분산 트랜잭션의 문제점</h2>

- 예전에는 분산 트랜잭션을 이용해서 여러 서비스, DB, 메시지 브로커에 걸쳐 데이터  
  일관성을 유지했다. X/Open DTP(Distributed Transaction Processing) 모델(X/Open XA)은  
  분산 트랜잭션 관리의 사실상 표준이다. XA는 2단계 커밋(2PC)을 이용하여 전체 트랜잭션 참여자가  
  반드시 커밋 아니면 롤백을 하도록 보장한다. XA 호환 기술 스택은 XA 호환 DB, 메시지 브로커,  
  DB 드라이버, 메시징 API, XA 전역 트랜잭션 ID를 전파하는 프로세스 간 메커니즘으로 구성된다.  
  SQL DB는 대부분 XA와 호환되며, 메시지 브로커의 일부 제품도 호환된다. 예를 들어, Java EE  
  애플리케이션은 JTA 기술을 사용하여 분산 트랜잭션을 수행할 수 있다.

- 분산 트랜잭션은 간단해 보이지만, 문제점도 많다. 일단 NoSQL DB(MongoDB, Cassandra)와  
  현대 메시지 브로커(RabbitMQ, Apache Kafka)는 분산 트랜잭션을 지원하지 않으므로  
  분산 트랜잭션이 필수라면 최근 기술은 상당수 포기할 수 밖에 없다.

- 동기 IPC 형태이기에 가용성이 떨어지는 문제도 있다. 분산 트랜잭션은 참여한 서비스가 모두  
  가동 중이어야 커밋할 수 있다. 더 많은 서비스가 참여할 수록 가용성은 더 떨어진다.  
  서비스는 일관성(Consistency), 가용성(Availability), 분할 허용성(Partition Tolerance) 중  
  두 가지 속성만 가질 수 있다. 요즘 아키텍트들은 일관성보다 가용성을 더 우선시 하는 편이다.

- 개발자 관점에서 보면, 분산 트랜잭션은 로컬 트랜잭션과 프로그래밍 모델이 동일하므로 매력적이지만,  
  위에서 본 문제점들 때문에 현대 애플리케이션에는 잘 맞지 않는다. 분산 트랜잭션을 사용하지 않고  
  메시지를 DB 트랜잭션의 일부로 전송하는 방법이 낫다. MSA에서 데이터 일관성을 유지하려면,  
  느슨하게 결합된 비동기 서비스 개념을 토대로 뭔가 다른 메커니즘이 필요하다.  
  이것이 바로 Saga 이다.

<hr/>

<h2>데이터 일관성 유지: Saga 패턴</h2>

- Saga는 MSA에서 분산 트랜잭션 없이 데이터 일관성을 유지하는 메커니즘이다.  
  여러 서비스의 데이터를 업데이트하는 시스템 커맨드마다 Saga를 하나씩 정의한다.  
  Saga는 일련의 로컬 트랜잭션이다. 각 로컬 트랜잭션은 앞서 언급한 ACID 트랜잭션  
  프레임워크, 라이브러리를 이용하여 서비스별 데이터를 업데이트한다.

> Saga Pattern: Saga는 비동기 메시징을 이용하여 편성한 일련의 로컬 트랜잭션이다.  
> 서비스 간 데이터 일관성은 Saga로 유지한다.

- 시스템 작업은 Saga의 첫 번째 단계를 실행한다. 어느 로컬 트랜잭션이 완료되면 이어서 그 다음  
  로컬 트랜잭션이 실행된다. 비동기 메시징으로 단계를 편성하는 방법은 후에 보겠지만,  
  비동기 메시징은 하나 이상의 Saga 참여자가 일시 불능인 상태인 경우에도 Saga의 전체 단계를  
  확실히 실행시킬 수 있는 중요한 장점이 있다.

- Saga와 ACID 트랜잭션은 두 가지 중요한 차이점이 있다.

  - ACID 트랜잭션에 있는 I(Isolation, 격리성)는 Saga에는 없다.
  - Saga는 로컬 트랜잭션마다 변경분을 커밋하므로 보상 트랜잭션을 걸어 롤백해야 한다.

<h3>예제: 주문 생성 Saga</h3>

- 주문 생성 saga(Create Order Saga)를 예시로 들어보자.  
  주문 서비스의 `createOrder()` 작업은 이 saga로 구현한다.  
  이 saga의 첫 번째 로컬 트랜잭션은 *주문 생성*이라는 외부 요청에 의해 시작된다.  
  나머지 5개의 로컬 트랜잭션은 각자 자신의 선행 트랜잭션이 완료되면 트리거된다.

- 주문 생성 saga는 6개의 로컬 트랜잭션으로 구성된다.

  - (1) 주문 서비스(Txn:1): 주문을 `APPROVAL_PENDING` 상태로 변경
  - (2) 소비자 서비스(Txn:2): 주문 가능한 소비자인지 확인
  - (3) 주방 서비스(Txn:3): 주문 내역을 확인하고, 티켓을 `CREATE_PENDING` 상태로 변경
  - (4) 회계 서비스(Txn:4): 소비자 신용카드 승인
  - (5) 주방 서비스(Txn:5): 티켓 상태를 `AWAITING_ACCEPTANCE`로 변경
  - (6) 주문 서비스(Txn:6): 주문 상태를 `APPROVED`로 변경

- 서비스는 로컬 트랜잭션이 완료되면 메시지를 발행하여 다음 Saga 단계를 트리거한다.  
  메시지를 통해 Saga 참여자를 느슨하게 결합하고, Saga가 반드시 완료되도록 보장하는 것이다.  
  메시지 수신자가 일시 불능 상태라면, 메시지 브로커는 다시 메시지를 전달할 수 있을 때까지  
  메시지를 버퍼링한다.

- 언뜻 보기에 직관적인 것 같지만, 몇 가지 풀어야할 문제가 있다.  
  도중에 에러가 발생한다면 변경분을 어떻게 롤백시킬 수 있을까?

<h3>Saga는 보상 트랜잭션으로 변경분을 롤백한다.</h3>

- ACID 트랜잭션은 비즈니스 로직 실행 도중 규칙에 위배되면 쉽게 롤백이 가능하다.  
  DB에서 `ROLLBACK` 하면 그 시점까지 변경된 내용은 모두 undo 된다.  
  하지만 Saga는 단계마다 로컬 DB에 변경분을 commit하므로 자동 롤백은 불가능하다.  
  가령, 앞서 본 주문 생성 saga에서 4단계에서 신용카드 승인이 실패하면, 1~3단계에서  
  적용된 변경분을 명시적으로 undo 해야 한다.  
  즉, **보상 트랜잭션(Compensating Transaction)** 을 미리 작성해야 한다.

- (N+1)번째 Saga 트랜잭션이 실패하면, 이전 N개의 트랜잭션을 모두 undo 해야 한다.  
  개념적으로 단계 T(i)에서는 T(i)의 작용(effect)을 undo하는 보상 트랜잭션 C(i)가  
  대응되며, 처음 N개 단계의 작용을 undo 하려면 Saga는 각 C(i)를 역순으로 실행하면 된다.  
  T(1)~T(n) 순서로 트랜잭션이 실행되다가 T(n+1)에서 실패할 경우, T(1)~T(n)을  
  undo하기 위해 C(n)~C(1)을 순서대로 실행한다.

- Saga는 트랜잭션이 진행하는 반대 방향(n~1)으로 보상 트랜잭션을 실행한다.  
  C(i)와 T(i)는 순서화 원리가 동일하므로, C(i)가 끝나면 C(i-1)의 실행이 트리거된다.

- 주문 생성 saga가 실패하는 이유는 여러 가지일 것이다.

  - 소비자 정보가 올바르지 않거나 주문을 할 수 없는 소비자인 경우
  - 음식점 정보가 올바르지 않거나 주문 접수가 불가한 음식점인 경우
  - 소비자의 신용카드 승인이 거절된 경우

- 로컬 트랜잭션이 실패하면, Saga는 주문, 티켓을 무효화하는 보상 트랜잭션을 가동한다.  
  아래 표를 보자.

| 단계 | 서비스        | 트랜잭션                  | 보상 트랜잭션    |
| ---- | ------------- | ------------------------- | ---------------- |
| 1    | 주문 서비스   | `createOrder()`           | `rejectOrder()`  |
| 2    | 소비자 서비스 | `verifyConsumerDetails()` | -                |
| 3    | 주방 서비스   | `createTicket()`          | `rejectTicket()` |
| 4    | 회계 서비스   | `authorizeCreditCard()`   | -                |
| 5    | 주방 서비스   | `approveTicket()`         | -                |
| 6    | 주문 서비스   | `approveOrder()`          | -                |

- 위 표에서 볼 수 있듯이, **모든 단계에서 보상 트랜잭션이 필요한 것은 아니다.**  
  `verifyConsumerDetails()`와 같은 read-only 단계나, 항상 성공하는 단계 다음에 이어지는  
  `authorizeCreditCard()`같은 단계는 보상 트랜잭션이 필요 없다.

- 주문 생성 saga의 1\~3 단계는 실패할 가능성이 있는 단계 다음에 있으므로 보상 트랜잭션,  
  4번째 단계는 절대로 실패하지 않는 단계 다음에 있으므로 pivot 트랜잭션, 5\~6 단계는  
  항상 성공하기 때문이 재시도 가능(retriable) 트랜잭션이라 한다.

- 위 표를 보고, 소비자의 신용카드 승인이 거절된다면 아래 순서로 Saga 및 보상 트랜잭션이 실행될 것이다.

  - (1) 주문 서비스: 주문을 `APPROVAL_PENDING` 상태로 변경
  - (2) 소비자 서비스: 소비자가 주문을 할 수 있는지 확인
  - (3) 주방 서비스: 주문 내역 확인 후 티켓을 `CREATE_PENDING`으로 생성
  - (4) 회계 서비스: 소비자의 신용카드 승인 요청이 거부됨(여기서부터 보상 트랜잭션 시작)
  - (5) 주방 서비스: 티켓을 `CREATE_REJECTED` 상태로 변경 (`rejectTicket()`에 의해)
  - (6) 주문 서비스: 주문 상태를 `REJECTED`로 변경 (`rejectOrder()`에 의해)

- 위에서 5, 6번째 단계는 주방 서비스, 주문 서비스가 수행한 업데이트를 undo하는  
  보상 트랜잭션이다. 일반 트랜잭션과 보상 트랜잭션의 순서화는 바로 다음에 볼 _Saga 편성_ 로직이  
  하는 일이다.

<hr/>
