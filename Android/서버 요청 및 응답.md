서버 요청 및 응답
======

<h2>Networking</h2>

* 네트워킹은 인터넷에 연결되어 있는 원격지의 서버 또는 원격지의 단말과 통신해서 데이터를 주고받는 동작을 의미한다.   
<hr/>

<h3>네트워크 연결 방식의 이해</h3>

* 원격지의 서버에 연결하는 가장 단순한 방식은 Client, Server가 1대1로 연결하는 `2-tier C/S(Client/Server)` 방식이다.   
  Client는 Server에 Request를 보내고, 이에 대해 Server는 Client에 Response를 보낸다. `2-tier C/S` 연결 방식은 가장 많이   
  사용하는 네트워킹 방식이며 대부분 Client가 Server에 연결되어 데이터를 요청하고 응답받는 단순한 개념으로 이해할 수 있다.   
  웹 페이지를 볼 때 사용하는 HTTP Protocol, 파일 전송을 위한 FTP Protocol, 그리고 메일을 주고 받는 POP3 Protocol 등의   
  연결방식은 모두 이 방식과 같은 방법으로 Server로 간편하게 접속하여 처리하는 것이다.

* `3-tier` 연결 방식은 `Client <==> 응용 Server <==> Data Server` 로 구성된 방식으로, Server를 좀 더 유연하게 구성할 수 있게 해준다.   
  또 응용 server와 Data server로 Server를 구성하면, DB를 분리할 수 있어 중간에 Business Logic을 처리하는 응용 server가 좀 더   
  다양한 역할을 할 수 있게된다는 장점이 생긴다

* 단말 간의 통신이 일반화되면서 Client와 Server의 관계는 `Peer-to-Peer` 통신으로 불리는 `P2P` Model로도 변형되어   
  사용되기도 한다. `P2P` model은 Server를 두지 않고 단말끼리 Server와 Client의 역할을 한다. 이 연결 방식은 정보 검색이나   
  파일 송수신으로 정보를 공유하는데 많이 사용된다.
<hr/>

<h2>Socket 사용</h2>

* `Socket`은 `TCP/IP` 방식으로 많이 사용하는데, 이 방식은 IP 주소로 목적지 host를 찾아내고 port로 통신 접속점을 찾아낸다.
<hr/>

<h3>HTTP Protocol + Socket</h3>

* HTTP Protocol은 Socket을 통해 WebServer에 연결한 후에 요청을 전송하고 응답을 받은 다음 연결을 끊는다. 이런 특성을   
  `Stateless(비연결성)`이라 하는데, 이러한 특성 때문에 실시간으로 데이터를 처리하는 app은 응답 속도를 높이기 위해 연결성이   
  있는 Socket연결을 선호했다. 하지만 현재는 인터넷 속도가 빨라져 HTTP Protocol을 사용하는 web이 일반적이 되었고, 결국 속도가   
  그렇게 느리지 않으면서도 국체 표준을 따를 수 있다는 장점을 가진 WebServer로 많은 server가 만들어지게 되었다.

* 안드로이드는 표준 Java에서 사용하는 `java.net` 패키지를 그대로 사용할 수 있다. 하지만 android는 Socket연결 등을 시도하거나   
  응답을 받아 처리할 때 Thread를 사용해야 한다. 이는 강제사항으로 Thread를 사용하지 않으면 networking 기능 자체가 동작하지 않는다.

* 아래와 같이 `activity_main.xml`이 구성되어 있다고 하자.
```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="1dp"
        android:layout_weight="1"
        android:background="@android:color/holo_blue_bright"
        android:orientation="vertical">

        <EditText
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="Data to send"
            android:id="@+id/editText"
            android:textSize="20sp" />

        <Button
            android:id="@+id/button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="SEND"
            android:textSize="20sp" />

        <ScrollView
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical">
                <TextView
                    android:id="@+id/textView"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:textSize="20sp"/>
            </LinearLayout>
        </ScrollView>
    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="1dp"
        android:layout_weight="1"
        android:background="@android:color/holo_orange_light"
        android:orientation="vertical">

        <Button
            android:id="@+id/button2"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Start server"
            android:textSize="20sp" />

        <ScrollView
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical">

                <TextView
                    android:id="@+id/textView2"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:textSize="20sp" />
            </LinearLayout>
        </ScrollView>
    </LinearLayout>
</LinearLayout>
```

* 다음으로는 `MainActivity.java`를 작성하자.
```java
public class MainActivity extends AppCompatActivity {

    EditText editText;
    TextView textView;
    TextView textView2;

    Handler handler = new Handler();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        editText = findViewById(R.id.editText);
        textView = findViewById(R.id.textView);
        textView2 = findViewById(R.id.textView2);

        Button button = findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            // button 클릭 시 새로운 Thread를 익명 Runnable 구현 객체를 생성하여 바로 start()를 호출하여
            // 실행시킨다. run() 메소드 내에서는 send() 메소드를 호출한다.
            @Override
            public void onClick(View view) {
                final String data = editText.getText().toString();
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        send(data);
                    }
                }).start();
            }
        });

        Button button2 = findViewById(R.id.button2);
        button2.setOnClickListener(new View.OnClickListener() {
            // button2 클릭 시 새로운 Thread를 익명 Runnable 구현 객체를 생성하여 바로 start()를 호출하여
            // 실행시킨다. run() 메소드 내에서는 startServer() 메소드를 호출한다.
            @Override
            public void onClick(View view) {
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        startServer();
                    }
                }).start();
            }
        });
    }

    // 화면 상단의 textView에 결과를 출력하는 메소드
    // 새로 만들어진 thread에서 이 메소드들을 호출할 것이므로 UI 객체에 접근할 수 있는
    // MainThread를 처리하는 handler를 사용한다.
    private void printClientLog(final String data) {
        Log.d("MainActivity", data);
        handler.post(new Runnable() {
            @Override
            public void run() {
                textView.append(data + '\n');
            }
        });
    }

    // 화면 하단의 textView2에 결과를 출력하는 메소드
    // 새로 만들어진 thread에서 이 메소드들을 호출할 것이므로 UI 객체에 접근할 수 있는
    // MainThread를 처리하는 handler를 사용한다.
    public void printServerLog(final String data) {
        Log.d("MainActivity", data);
        handler.post(new Runnable() {
            @Override
            public void run() {
                textView2.append(data + '\n');
            }
        });
    }

    // Client에서 Server로 데이터를 전송하는 메소드
    // 5001번 포트를 사용하도록 한다.
    public void send(String data) {
        try {
            int portNumber = 5001;
            Socket socket = new Socket("localhost", portNumber);
            printClientLog("Socket connected.");
            ObjectOutputStream outputStream = new ObjectOutputStream(socket.getOutputStream());
            outputStream.writeObject(data);
            outputStream.flush();
            printClientLog("Data sent.");
        } catch(Exception e) {
            e.printStackTrace();
        }
    }

    // Client가 접속할 Server를 구성하는 메소드
    public void startServer() {
        try {
            int portNumber = 5001;
            ServerSocket server = new ServerSocket(portNumber);
            printServerLog("Server started : " + portNumber);

            while(true) {
                Socket socket = server.accept();
                InetAddress clientHost = socket.getLocalAddress();
                int clientPort = socket.getPort();
                printServerLog("Client connected : " + clientHost + " : " + clientPort);

                ObjectInputStream inputStream = new ObjectInputStream(socket.getInputStream());
                Object obj = inputStream.readObject();
                printServerLog("Data received : " + obj);

                ObjectOutputStream outputStream = new ObjectOutputStream(socket.getOutputStream());
                outputStream.writeObject(obj + " from server.");
                outputStream.flush();
                printServerLog("Data sent.");

                socket.close();
            }
        } catch(Exception e) {
            e.printStackTrace();
        }
    }
}
```
* 마지막으로 인터넷에 접속할 권한이 필요하므로 `AndroidManifest.xml`의 `<manifest>` 태그 내에 아래 구문을 추가해준다.
```xml
<uses-permission android:name="android.permission.INTERNET" />
```
<hr/>

<h2>Web으로 요청하기</h2>

* `Stateless`인 HTTP Protocol은 페이지 정보를 요청할 때마다 Socket을 새로 연결하고 응답을 받은 다음, Socket의 연결을   
  끊는 것이 일반적이다. 그리고 그 Socket 연결상에서 HTTP Protocol에 맞는 요청을 보내고 응답을 받아 처리한다.
<hr/>

<h3>HTTP로 Web Server 접속하기</h3>

* HTTP로 Webserver에 접속하느 것도 Socket과 마찬가지로 표준 Java의 방식을 그대로 사용할 수 있다. Java에서 HTTP Client를   
  만드는 가장 간단한 방법은 `URL` 객체를 만들고 이 객체의 `openConnection()` 메소드를 호출하여 `HttpURLConnection`객체를 만드는 것이다.
```java
public URLConnection openConnection();
```

* `URL`객체에 들어있는 문자열이 "http://"를 포함하면 HTTP 연결을 위한 객체를 만들게 되므로 `openConnection()` 메소드가   
  반환하는 `URLConnection` 객체를 `HttpURLConnection`객체로 형변환하여 사용할 수 있다. `HttpURLConnection` 객체로   
  연결할 경우에는 GET, POST와 같은 요청 방식과 함께 요청을 위한 파라미터를 설정할 수 있다.
```java
public void setRequestMethod(String method);
public void setRequestProperty(String field, String newValue);
```

* 요청 방식을 지정하는 메소드는 `setRequestMethod()`로 , GET, POST 문자열을 파라미터로 전달한다. `setRequestProperty()` 메소드는   
  요청 시 header에 들어가는 field값을 지정할 수 있도록 한다. GET 방식을 사용해서 웹페이지의 주소를 입력하면, 해당 페이지의 내용을   
  가져오는 app을 만들어보자.

* 아래는 `activity_main.xml` 이다.
```xml

```