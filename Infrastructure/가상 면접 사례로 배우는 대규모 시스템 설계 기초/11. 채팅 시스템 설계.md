# 채팅 시스템 설계

- 이번에는 채팅 시스템을 설계해보자.

## 문제 이해 및 설계 범위 확정

- 현재 시장에 나와있는 채팅 앱들을 보면 1:1 채팅에 집중하는 앱들이 있는가 하면 그룹 채팅에 중점을 둔 업무용 앱이나, 게임 채팅을 위해 대규모  
  그룹의 소통과 응답지연(latency)이 낮은 음성 채팅에 집중하는 앱 등이 있다.

- 따라서 채팅 시스템을 설계하기 전에, 요구 사항들을 명확히 해놔야 한다.

- 이번에 설계할 채팅 시스템의 요구사항은 아래와 같다.

  - 1:1, 그룹 채팅 모두 지원
  - 모바일 앱, 웹 앱 모두 지원
  - DAU: 5000만명
  - 그룹 채팅은 최대 100명까지 참가 가능
  - 1:1채팅, 그룹 채팅, 사용자 접속상태 표시를 지원해야 한다.
  - 텍스트 메시지만 주고 받을 수 있다.
    - 메시지 길이 제한: 100,000자 이하
  - 채팅 이력은 영원히 보관되어야 한다.
  - 이후 end-to-end encryption(종단 간 암호화)를 지원할 수 있어야 한다.

- 아래는 한 번 더 정리한 설계할 시스템의 주요 기능이다.

  - latency가 낮은 1:1 채팅 기능
  - 최대 100명까지 참여 가능한 그룹 채팅 기능
  - 사용자의 접속 상태 표시 기능
  - 다양한 단말 지원
    - 하나의 계정으로 여러 단말에 동시 접속 지원
  - 푸시 알림

---

## 개략적 설계안 제시 및 동의 구하기

- 이 시스템을 설계하기 위해서는 클라이언트와 서버의 통신 방법에 대한 기본적 지식은 갖추고 있어야만 한다.  
  채팅 시스템의 경우, 클라이언트는 모바일 앱이거나 웹 애플리케이션이다. 클라이언트들은 서로 직접 통신하지 않는다.  
  대신, 각 클라이언트는 위에 나열한 모든 기능을 지원하는 채팅 서비스와 통신한다.  
  기본 기능에 집중해, 채팅 서비스의 기능을 다시 생각해보자.

  - 클라이언트들로부터 메시지 수신
  - 메시지 수신자(recipient) 결정 및 전달
  - 수신자가 접속(online) 상태가 아닌 경우에는 접속할 때까지 해당 메시지 보관

- 아래 그림은 클라이언트(메시지 송신 클라이언트와 수신 클라이언트)와 채팅 서비스 사이의 관계를 나타낸 것이다.

![picture 34](/images/SDI_CS_1.png)

- 채팅을 시작하려는 클라이언트는 네트워크 통신 프로토콜을 사용해 서비스에 접속한다.  
  따라서 채팅 서비스의 경우, 어떤 통신 프로토콜을 사용할 것인가도 매우 중요한 문제다.

- 대부분의 클라이언트/서버 애플리케이션에서 요청을 보내는 것은 클라이언트인데, 채팅 시스템의 경우에도 마찬가지다.  
  sender(메시지 송신 클라이언트)가 이 역할을 한다. 위 그림에서 sender는 receiver(수신 클라이언트)에게 전달할 메시지를  
  채팅 서비스에게 보낼 때, 오랜 세월 검증된 HTTP Protocol을 사용한다. HTTP는 현재 웹에서 가장 널리 사용되는 프로토콜이다.  
  위 그림에서 클라이언트는 채팅 서비스에 HTTP Protocol로 연결한 다음, 메시지를 보내 receiver에게 해당 메시지를 전달하라고 알린다.  
  채팅 서비스와의 접속에는 keep-alive header를 사용하면 효율적인데, 클라이언트와 서버 사이의 연결을 끊지 않고 계속 유지할 수 있기 때문이다.  
  TCP 접속 과정에서 발생하는 handshake 횟수를 줄일 수 있음은 물론이다. HTTP는 메시지 전송 용도로는 괜찮은 선택이며, Facebook 같은  
  많은 대중적 채팅 프로그램이 초기에 HTTP를 사용했다.

- 하지만 메시지 수신 시나리오는 이보다 복잡하다. HTTP는 클라이언트가 연결을 만드는 프로토콜이자, 서버에서 클라이언트로 임의 시점에 메시지를  
  보내는 데는 쉽게 쓰일 수 없다. 서버가 연결을 만드는 것처럼 동작할 수 있도록 하기 위해 많은 기법들이 제안되어 있는데,  
  polling, long polling, WebSocket 등이 그런 기술이다. 이들 각각에 대해 조금 더 자세히 살펴보자.

### Polling

- Polling은 클라이언트가 주기적으로 서버에게 새로운 메시지가 있는지를 물어보는 방법이다.  
  Polling 비용은 polling을 자주하면 할수록 올라간다.  
  답해줄 새로운 메시지가 없는 경우에는 서버 자원이 불필요하게 낭비된다는 문제도 있다.  
  아래는 polling을 대략적으로 그린 그림이다.

![picture 35](/images/SDI_CS_2.png)

### Long Polling

- Polling은 여러 가지로 비효율적일 수 있어서 나온 기법이 Long Polling이다.

![picture 36](/images/SDI_CS_3.png)

- Long polling의 경우 클라이언트는 새로운 메시지가 반환되거나 timeout 될 때까지 연결을 유지한다.  
  클라이언트는 새로운 메시지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내 모든 절차를 다시 시작한다.  
  이 방법에는 아래와 같은 단점들이 있다.

  - 메시지를 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수도 있다.  
    HTTP 서버들은 보통 stateless 서버이다. Load balancing을 위해 round-robin 알고리즘을 사용하는 경우,  
    메시지를 받은 서버는 해당 메시지를 수신할 클라이언트와의 long polling 연결을 갖고 있지 않은 서버일 수도 있는 것이다.

  - 서버 입장에서는 클라이언트가 연결을 해제했는지 아닌지 알 수 있는 좋은 방법이 없다.

  - 여전히 비효율적이다. 메시지를 많이 받지 않는 클라이언트도 timeout이 일어날 때마다 주기적으로 서버에 다시 접속할 것이다.

### Websocket

- WebSocket은 서버가 클라이언트에게 asynchronous(비동기) 메시지를 보낼 때 가장 널리 사용하는 기술이다.

![picture 37](/images/SDI_CS_4.png)

- WebSocket 연결은 클라이언트가 시작한다. 한번 맺어진 연결은 항구적이며 양방향이다. 이 연결은 처음에는 HTTP 연결이지만, 특정 handshake 절차를  
  거쳐 WebSocket Connection으로 업그레이드 된다. 일단 이 항구적인 연결이 만들어지고 나면, 서버는 클라이언트에게 비동기적으로 메시지를  
  전송할 수 있다. WebSocket은 일반적으로 방화벽이 있는 환경에서도 잘 동작한다. 80, 443처럼 HTTP 혹은 HTTPS Protocol이 사용하는  
  기본 포트 번호를 그대로 사용하기 때문이다.

- 앞서 HTTP Protocol이 메시지를 보내려는 클라이언트에게는 썩 괜찮은 프로토콜임을 보았다.  
  하지만 WebSocket은 이에 더해 양뱡향 메시지 전송까지 가능하게 하므로, WebSocket 대신 HTTP를 굳이 고집할 필요는 없다.  
  아래 그림은 어떻게 WebSocket이 메시지 전송이나 수신에 쓰일 수 있는지 간략하게 나타낸 그림이다.

![picture 38](/images/SDI_CS_5.png)

### 개략적 설계안

- 이제 클라이언트와 서버 사이의 주 통신 프로토콜로 WebSocket을 사용하기로 결정했다.  
  하지만 다른 부분에서는 굳이 WebSocket을 사용할 필요가 없다. 사실 대부분의 기능(회원가입, 로그인, 사용자 프로필 등)들은 일반적인  
  HTTP 상에서 구현해도 된다.

- 이제부터는 전체 시스템의 개략적인 설계안을 살펴보자.  
  아래 그림처럼, 이번 채팅 시스템은 크게 세 가지 부분으로 나눠볼 수 있다.

![picture 39](/images/SDI_CS_6.png)

#### Stateless Service

- 이 설계안에서 Stateless(무상태) 서비스는 로그인, 회원가입, 사용자 프로필 표시 등을 처리하는 전통적인 요청/응답 서비스이다.  
  무상태 서비스가 제공하는 기능은 많은 웹사이트와 같이 앱이 보편적으로 제공하는 기능이다.

- 무상태 서비스는 load balancer 뒤에 위치한다. Load balancer가 하는 일은 요청을 그 경로에 맞는 서비스로 정확하게 전달하는 것이다.  
  Load balancer 뒤에 있는 monolithic 서비스일 수도 있고, micro 서비스일 수도 있다. 이 서비스들 가운데 상당수가 시장에 완제품으로  
  나와있기에, 직접 구현하지 않아도 쉽게 사서 쓸 수 있다. 이들 가운데 나중에 살펴볼 것은 **Service Discovery** 이다.  
  이 서비스는 클라이언트가 접속할 채팅 서버의 DNS hostname을 클라이언트에게 알려주는 역할을 한다.

#### Stateful Service

- 이 설계안에서 유일하게 상태 유지가 필요한 서비스는 채팅 서비스다. 각 클라이언트가 채팅 서버와 독립적인 네트워크 연결을 유지해야 하기 때문이다.  
  클라이언트는 보통 서버가 살아 있는 한 다른 서버로 연결을 변경하지 않는다. 위에서 언급한 Service Discovery 서비스는 채팅 서비스와  
  긴밀히 협력해 특정 서버에 부하가 몰리지 않도록 한다.

#### Third party 연동

- 채팅 앱에서 가장 중요한 제3자 서비스는 Push Notification이다. 새로운 메시지를 받았다면, 설사 앱이 실행중이지 않더라도  
  알림을 받을 수 있어야 하기 때문이다.

##### 규모 확장성

- 트래픽 규모가 얼마 되지 않을 때는 위에서 설명한 모든 기능을 단 한 대의 서버로 구현할 수 있다.  
  지금 설계중인 시스템의 경우처럼 대량의 트래픽을 처리해야 하는 경우에도 이론적으로는 모든 사용자 연결을 최신 클라우드 서버 한대로 처리할 수  
  있기는 하다. 이때 따져봐야 할 것은 **서버 한 대로 얼마나 많은 접속을 동시에 허용할 수 있느냐** 이다. 이번에 다루는 시스템의 경우에는  
  동시 접속자가 1M 명이라고 가정할 것인데, 접속당 10K의 메모리가 필요하다고 본다면(매우 개략적인 수치) 10GB의 메모리만 있으면 모든  
  연결을 다 처리할 수 있을 것이다.

- 하지만 모든 것을 서버 한 대에 담은 설계안은 절대 좋지 못하다. 누구도 그 정도 규모의 트래픽을 서버 한 대로 처리하려하지 않을 것이기 때문이다.  
  여기에는 여러 이유가 있는데, SPOF도 그 중 하나다.

> 서버만 한 대 갖는 설계안에서 출발해 점차 다듬어 나가는 것은 괜찮다. 단, 면접관에게 _"이것은 그저 시작일 뿐"_ 이라는 것만 정확히  
> 전달해 놓으면 된다.

- 지금까지 본 것들을 정리하면, 아래와 같은 개략적 설계안이 만들어진다.

![picture 40](/images/SDI_CS_7.png)

- 위 그림에서 유의할 점은 실시간으로 메시지를 주고받기 위해 클라이언트가 웹 서버와 WebSocket 연결을 끊지 않고 유지한다는 것이다.  
  각 컴포넌트의 역할과 기능을 살펴보자.

  - 채팅 서버: 클라이언트 사이에 메시지를 중계하는 역할을 담당한다.
  - 접속 상태 서버(presence server): 사용자의 접속 여부를 관리한다.
  - API 서버: 로그인, 회원가입, 프로필 변경 등 그 외 나머지 전부를 처리한다.
  - 알림 서버: Push 알림을 보낸다.
  - Key-value Store: 채팅 이력(history)을 보관한다.  
    시스템에 접속한 사용자는 이전 채팅 이력을 전부 보게될 것이다.

##### 저장소

- 이제 서버도 준비되었고 제3자 서비스 연동도 모두 끝났다고 해보자. 이 기술 스택 깊은 곳에 데이터 계층이 있다.  
  데이터 계층을 올바르게 만드는 데는 노력이 필요하다. 중요한 것 가운데 하나는 어떤 데이터베이스를 쓸 것인가 이다.  
  RBDMS를 쓸 것인가, 아니면 NoSQL을 쓸 것인가? 이 질문에 대한 올바른 답을 하기 위해 중요하게 따져야할 것은  
  데이터의 유형과 읽기/쓰기 연산의 패턴이다.

- 채팅 시스템이 다루는 데이터는 보통 두 가지다. 첫 번째는 사용자 프로필, 설정, 친구 목록처럼 일반적인 데이터다.  
  이런 데이터는 안정성을 보장하는 RDBMS에 보관한다. 다중화(replication)와 sharding은 이런 데이터의 가용성과 규모 확장성을  
  보증하기 위해 보편적으로 사용하는 기술이다.

- 두 번째 유형의 데이터는 채팅 시스템에 고유한 데이터로, 바로 채팅 이력이다.  
  이 데이터를 어떻게 보관할지 결정하려면 읽기/쓰기 연산의 패턴을 이해해야 한다.

  - 채팅 이력 데이터의 양은 엄청나다. Facebook은 매일 대략 600억 개의 메시지를 처리한다.
  - 이 데이터 가운데 빈번하게 사용되는 것은 주로 최근에 주고받은 메시지이다.  
    대부분의 사용자는 오래된 메시지는 들여다보지 않는다.
  - 사용자는 대체로 최근에 주고받은 메시지 데이터만 보게 되는 것이 사실이나, 특정 메시지로 jump하거나 특정 사용자가 mention된 메시지를  
    보거나하여 무작위적인 데이터에 접근하게 되는 일도 있다. 데이터 계층은 이런 기능도 지원해야 한다.
  - 1:1 채팅 앱의 경우, 읽기 쓰기 비율은 대략 1:1 정도다.

- 위 모두를 지원할 데이터베이스를 고르는 것은 아주 중요한 일이다.  
  이 설계안의 경우에는 key-value store를 추천할 것인데, 이유는 아래와 같다.

  - Key-value store는 horizontal scaling이 쉽다.
  - Key-value store는 latency가 낮다.
  - RDBMS는 데이터 가운데 long tail에 해당하는 부분을 잘 처리하지 못하는 경향이 있다.  
    index가 커지면 데이터에 대한 무작위적 접근(random access)을 처리하는 비용이 늘어난다.
  - 이미 많은 안정적인 채팅 시스템이 key-value store를 채택하고 있다. Facebook 메신저나 Discord가 그 사례다.  
    Facebook 메신저는 HBase를, Discord는 Cassandra를 사용하고 있다.

#### 데이터 모델

- Key-value store를 데이터 계층 기술로 사용하기로 했으니, 메시지 데이터를 어떻게 보관할 것인지 자세히 살펴보자.

##### 1:1 채팅을 위한 메시지 테이블

![picture 41](/images/SDI_CS_8.png)

- 위 그림은 1:1 채팅을 지원하기 위한 메시지 테이블의 사례다. 이 테이블의 primary key는 `message_id`로, 메시지 순서를 쉽게 정할 수 있도록  
  하는 역할도 담당한다. `created_at`을 사용해 메시지 순서를 정할 수는 없는데, 서로 다른 두 메시지가 동시에 만들어질 수도 있기 때문이다.

##### 그룹 채팅을 위한 메시지 테이블

![picture 42](/images/SDI_CS_9.png)

- 위 그림은 그룹 채팅을 위한 메시지 테이블의 사례다. `(channel_id, message_id)`의 composite key를 primary key로 사용한다.  
  여기서 channel은 채팅 그룹과 같은 뜻이다. `channel_id`는 partition key로도 사용할 것인데, 그룹 채팅에 적용될 모든 질의는  
  특정 channel을 대상으로 할 것이기 때문이다.

##### Message ID

- `message_id`를 만드는 기법은 자세히 논의해 볼 만한 가치가 있는 흥미로운 주제이다.  
  `message_id`는 메시지들의 순서도 표현할 수 있어야 한다. 그러기 위해서는 아래와 같은 속성들을 만족해야 할 것이다.

  - `message_id` 값은 unique 해야 한다.
  - ID 값은 정렬 가능해야 하며 시간 순서와 일치해야 한다. 즉, 새로운 ID는 이전 ID보다 큰 값이어야 한다.

- 위 두 조건을 어떻게 만족시킬 수 있을까? RDBMS라면 auto_increment가 대안이 될 수 있겠지만, NoSQL은 보통 해당 기능을 제공하지 않는다.

- 두 번째 방법은 Snowflake와 같은 전역젹 64-bit sequence number 생성기를 사용하는 것이다.

- 마지막 방법으로는 local sequence number generator를 이용하는 것이다.  
  여기서 _local_ 이라 함은, ID의 uniqueness는 같은 그룹 내에서만 보증하면 충분하다는 것이다.  
  이 방법이 사용 가능한 이유는 메시지 사이의 순서는 같은 channel, 혹은 같은 1:1 채팅방에서만 유지되면 충분하기 때문이다.  
  이 방법은 전역젹 ID 생성기에 비해 구현하기 쉬운 접근법이다.

---
