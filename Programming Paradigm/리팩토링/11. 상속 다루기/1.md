## 메소드 올리기

- 반대 리팩토링: **메소드 내리기**

```js
// 리팩토링 적용 전
class Employee {
  //..
}

class SalesPerson extends Employee {
  get name() {
    /*...*/
  }
}

class Engineer extends Employee {
  get name() {
    /*...*/
  }
}

// 리팩토링 적용 후

class Employee {
  get name() {
    /*...*/
  }
}

class SalesPerson extends Employee {
  //..
}

class Engineer extends Employee {
  //..
}
```

### 배경

- 중복 코드 제거는 중요하다. 중복된 두 메소드가 당장은 문제없이 동작할지라도 미래에는 벌레가  
  꼬이는 음식물 쓰레기로 전락할 수 있다. 무언가 중복되었다는 것은 한쪽의 변경이 다른 쪽에는  
  반영되지 않을 수 있다는 위험을 항상 수반한다. 그런데 일반적으로는 중복을 찾기가 그리 쉽지  
  않다는게 문제다.

- 메소드 올리기를 적용하기 가장 쉬운 상황은 메소드들의 본문 코드가 똑같을 때다. 이럴 땐 그냥  
  복사해 붙여넣기만 하면 끝이다. 물론 세상이 언제나 이처럼 만만하지는 않다. 리팩토링이 제대로  
  되었는지를 검증하려면 테스트가 여전히 잘 동작하는지 확인하면 되지만, 테스트를 얼마나 잘  
  만들었느냐에 크게 의존하는 방법이다. 그래서 차이점을 찾는 방법이 효과가 좋다. 테스트에서 놓친  
  동작까지 알게 해주는 경우가 자주 있기 때문이다.

- 메소드 올리기 리팩토링을 적용하려면 선행 단계를 거쳐야 할 때가 많다. 예를 들어 서로 다른 두 클래스의  
  두 메소드를 각각 매개변수화하면 궁극적으로 같은 메소드가 되기도 한다. 이런 경우에 가장 작은 단계를  
  거쳐 리팩토링하려면 각각의 **함수를 매개변수화**한 다음 메소드를 상속 계층의 위로 올리면 된다.

- 반면, 메소드 올리기를 적용하기에 가장 이상하고 복잡한 상황은 해당 메소드의 본문에서 참조하는 필드들이  
  서브클래스에만 있는 경우다. 이런 경우라면 **필드를 먼저 슈퍼클래스로 올린** 후에 메소드를 올려야 한다.

- 두 메소드의 전체 흐름은 비슷하지만 세부 내용이 다르다면 **템플릿 메소드 만들기**를 고려해보자.

### 절차

- (1) 똑같이 동작하는 메소드인지 면밀히 살펴본다.  
  실질적으로 하는 일은 같지만 코드가 다르다면 본문 코드가 똑같아질 때까지 리팩토링한다.

- (2) 메소드 안에서 호출하는 다른 메소드와 참조하는 필드들을 슈퍼클래스에서도 호출하고 참조할 수  
  있는지 확인한다.

- (3) 메소드 시그니처가 다르다면 **함수 선언 바꾸기**로 슈퍼클래스에서 사용하고 싶은 형태로 통일한다.

- (4) 슈퍼클래스에 새로운 메소드를 생성하고, 대상 메소드의 코드를 복사해넣는다.

- (5) 정적 검사 수행

- (6) 서브클래스 중 하나의 메소드를 제거한다.

- (7) 테스트한다.

- (8) 모든 서브클래스의 메소드가 없어질 때까지 다른 서브클래스의 메소드를 하나씩 제거한다.

### 예시

- 두 서브클래스에서 같은 일을 수행하는 메소드를 찾았다.

```js
class Employee extends Party {
  //..
  get annualCost() {
    return this.monthlyCost * 12;
  }
}

class Department extends Party {
  //..
  get totalAnnualCost() {
    return this.monthlyCost * 12;
  }
}
```

- 확인해보니 _(2) 두 메소드에서 참조하는 `monthlyCost()` 속성은 슈퍼크래스에는 정의되어 있지 않지만,_  
  _두 서브클래스 모두에 존재_ 한다. 지금은 동적 언어인 JS를 사용해서 괜찮지만, 정적 언어였다면  
  슈퍼클래스인 `Party`에 추상 메소드를 정의해야 한다.

- _(3) 두 메소드명이 다르므로 **함수 선언 바꾸기**로 이름을 통일_ 한다.

```js
class Department extends Party {
  //..
  get annualCost() {
    return this.monthlyCost * 12;
  }
}
```

- 이제 _(4) 서브클래스 중 하나의 메소드를 복사해 슈퍼클래스에 붙여넣는다._

```js
class Party {
  //..
  get annualCost() {
    return this.monthlyCost * 12;
  }
}
```

- 정적 언어였다면 이 시점에서 컴파일해 모든 참조가 올바른지 확인해야 한다. JS에서는  
  해당하지 않으니 _(6) `Employee`에서 `annualCost()`를 제거_ 하고,  
  _(7) 테스트_ 하고, _(8) `Department`에서도 제거_ 한다.

> 이상으로 이번 리팩토링은 끝났지만, `annualCost()` 내에서 `monthlyCost`를 호출하는데  
>  `Party`에서는 `monthlyCost()`가 보이지 않는다. 이 상태로도 잘 동작하는 이유는 JS가  
>  동적 언어이기 때문이다. 하지만 나중에 다른 서브클래스가 더해질 수 있으니 `Party`의 서브클래스가  
>  `monthlyCost()`를 구현해야 한다는 사실을 알려주는 게 좋을 것이다. 이럴 때는 아래처럼  
>  _함정 메소드(trap method)_ 를 만들어주면 유용하다.
>
> ```js
> class Party {
>   //..
>   get monthlyCost() {
>     throw new SubclassResponsibilityError();
>   }
> }
> ```

<hr/>

## 필드 올리기

- 반대 리팩토링: **필드 내리기**

```java
// 리팩토링 적용 전
class Employee { /* ... */ }

class SalesPerson extends Employee {
    private String name;
}

class Engineer extends Employee {
    private String name;
}
```

### 배경

- 서브클래스들이 독립적으로 개발되었거나 뒤늦게 하나의 계층구조로 리팩토링된 경우라면, 일부  
  기능이 중복되어 있을 때가 종종 있다. 이런 필드들은 이름이 비슷한게 보통이지만, 항상  
  그런 것은 아니다. 그래서 어떤 일이 벌어지는지를 알아내려면 필드들이 어떻게 이용되는지  
  분석해야 한다. 분석 결과 필드들이 비슷한 방식으로 쓰인다고 판단되면 슈퍼클래스로 끌어올리자.

- 이렇게 하면 두 가지 중복을 줄일 수 있다. 첫째, 데이터 중복 선언을 없앨 수 있다.  
  둘째, 해당 필드를 사용하는 동작을 서브클래스에서 슈퍼클래스로 옮길 수 있다.

- 동적 언어 중에는 필드를 클래스 정의에 포함시키지 않는 경우가 많다. 그 대신에 필드에 가장 처음  
  값이 대입될 때 등장한다. 이런 경우라면 필드를 올리기 전에 반드시 생성자 본문부터 올려야 한다.

### 절차

- (1) 후보 필드들을 사용하는 곳 모두가 그 필드들을 똑같은 방식으로 사용하는지 면밀히 살핀다.

- (2) 필드들의 이름이 각기 다른다면 똑같은 이름으로 바꾼다.(**필드이름 바꾸기**)

- (3) 슈퍼클래스에 새로운 필드를 생성한다. 서브클래스에서 이 필드에 접근할 수 있어야 한다.

- (4) 서브클래스의 필드들을 제거한다.

- (5) 테스트한다.

<hr/>

## 생성자 본문 올리기

```js
// 리팩토링 적용 전
class Party {
  /* ... */
}

class Employee extends Party {
  constructor(name, id, monthlyCost) {
    super();
    this._name = name;
    this._id = id;
    this._monthlyCost = monthlyCost;
  }
}

// 리팩토링 적용 후
class Party {
  constructor(name) {
    this._name = name;
  }
}

class Employee extends Party {
  constructor(name, id, monthlyCost) {
    super(name);
    this._id = id;
    this._monthlyCost = monthlyCost;
  }
}
```

### 배경

- 생성자는 다루기 까다롭다. 일반 메소드와는 많이 달라, 생성자에서 하는 일에 제약을 둘 때 많다.

- 서브클래스에서 기능이 같은 메소드들을 발견하면 **함수 추출하기**와 **메소드 올리기**를 차례로 적용해  
  말끔히 슈퍼클래스로 옮길 수 있다. 그런데 그 메소드가 생성자라면 스텝이 꼬인다. 생성자는 할 수 있는  
  일과 호출 순서에 제약이 있기에 조금 다른 식으로 접근해야 한다.

### 절차

- (1) 슈퍼클래스에 생성자가 없다면 하나 정의한다. 서브클래스의 생성자들에서 이 생성자가 호출되는지 확인한다.

- (2) **문장 슬라이드하기**로 공통 문장 모두를 `super()` 호출 직후로 옮긴다.

- (3) 공통 코드를 슈퍼클래스에 추가하고 서브클래스들에서는 제거한다. 생성자 매개변수 중 공통 코드에서  
  참조하는 값들을 모두 `super()`로 건넨다.

- (4) 테스트한다.

- (5) 생성자 시작 부분으로 옮길 수 없는 공통 코드에는 **함수 추출하기**와 **메소드 올리기**를 차례로 적용한다.

### 예시

- 아래 코드에서 시작해보자.

```js
class Party {}

class Employee extends Party {
  constructor(name, id, monthlyCost) {
    super();
    this._id = id;
    this._name = name;
    this._monthlyCost = monthlyCost;
  }
  //..
}

class Department extends Party {
  constructor(name, staff) {
    super();
    this._name = name;
    this._staff = staff;
  }
  //..
}
```

- 여기서 공통 코드는 `this._name = name;` 이라는 name 대입 부분이다.  
  _(2) `Employee`에서 대입문을 슬라이드해 `super()`호출 바로 아래로 옮기자._

```js
class Employee extends Party {
  constructor(name, id, monthlyCost) {
    super();
    this._name = name;
    this._id = id;
    this._monthlyCost = monthlyCost;
  }
  //..
}
```

- 테스트가 성공하면 _(3) 이 공통 클래스를 슈퍼클래스로 옮기자. 이 코드가 생성자의 인수인_  
  _name을 참조하므로 이 인수를 슈퍼클래스 생성자에 매개변수로 건넨다._

```js
class Party {
	constructor(name) {
		this._name = name;
	}
	}
}

class Employee extends Party {
  constructor(name, id, monthlyCost) {
    super(name);
    this._id = id;
    this._monthlyCost = monthlyCost;
  }
  //..
}

class Department extends Party {
  constructor(name, staff) {
    super(name);
    this._staff = staff;
  }
  //..
}
```

- _(4) 테스트를 돌려 모두 통과_ 하면 이 리팩토링은 끝이다.

### 예시: 공통 코드가 나중에 올 때

- 생성자는 대부분 `super()`를 호출해 공통 작업을 먼저 처리한 다음, 각 서브클래스에 필요한 추가 작업을  
  처리하는 식으로 동작한다. 그런데 이따금 공통 작업이 뒤에 오는 경우도 있다.

```js
class Employee {
  constructor(name) {
    /*...*/
  }
  get isPrivileged() {
    /*...*/
  }
  assignCar() {
    /*...*/
  }
}

class Manager extends Employee {
  constructor(name, grade) {
    super(name);
    this._grade = grade;
    if (this.isPrivileged) this.assignCar();
  }

  get isPrivileged() {
    return this._grade > 4;
  }
}
```

- `Manager`의 생성자 부분이 저렇게 될 수밖에 없는 이유는 `isPrivileged()`는  
  grade 필드에 값이 대입된 후에야 호출될 수 있고, 서브클래스만이 이 필드에 값을 대입할 수  
  있기 때문이다.

- 이런 경우라면 먼저 _(5) 공통 코드를 함수로 추출하자._

```js
class Manager extends Employee {
  constructor(name, grade) {
    super(name);
    this._grade = grade;
    this.finishConstruction();
  }

  finishConstruction() {
    if (this.isPrivileged) this.assignCar();
  }

  get isPrivileged() {
    return this._grade > 4;
  }
}
```

- 그런 다음 추출한 메소드를 슈퍼클래스로 옮긴다.

```js
class Employee {
  //..
  finishConstruction() {
    if (this.isPrivileged) this.assignCar();
  }
}
```

<hr/>
