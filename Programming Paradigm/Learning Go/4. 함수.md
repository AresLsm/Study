# 함수

## 함수 선언과 호출

- Go는 메소드도 가지며, 함수도 가진다. 제어 구조와 마찬가지로 Go는 함수 기능에 고유한 변형을 몇 가지 추가한다.

- 함수 선언은 네 부분으로 나뉜다. 키워드 func, 함수명, 파라미터, 타입이다.  
  Go는 정적 타입 언어(statically typed language)라 파라미터에 반드시 타입을 명시해야만 한다.

```go
fun main() {
	result := div(5, 2)
	fmt.Println(result)
}
```

### 이름이 지정된 파라미터와 선택적 파라미터 대응

- 이름이 지정된 파라미터와 선택적 파라미터는 Go가 제공하지 않는 기능이다. 이후에 볼 한 가지 예외적인 상황을 제외하고, 함수를 위한 파라미터는  
  호출 시 모두 넘겨져야 한다. 이름이 지정된 파라미터나 선택적 파라미터 처럼 사용하고 싶다면, 파라미터로 사용될 것과 동일하게 구조체로 만들어  
  함수에 넘겨줘야 한다.

```go
type MyFuncOpts struct {
	FirstName string
	LastName string
	Age int
}

func MyFunc(opts MyFuncOpts) error {
	// ..
}

func main() {
	MyFunc(MyFuncOpts {
		LastName: "Patel",
		Age: 50,
	})
	MyFunc(MyFuncOpts {
		FirstName: "John",
		LastName: "Doe",
		Age: 50,
	})
}
```

- 실제로 이름이 지정된 파라미터와 선택적 파라미터를 갖지 않더라도 제한은 아니다. 함수는 파라미터가 몇 개 이상을 가져서는 안되며, 이름이 지정돤  
  파라미터와 선택적 파라미터는 함수에 입력이 많을 때 주료 유용하다. 이런 상황이라면 작성된 함수가 너무 복잡할 수 있다.

### 가변 입력 파라미터와 slice

- `fmt.Println()` 같은 함수는 임의 개수의 입력 파라미터를 갖는다. 다른 언어처럼 Go는 **가변 파라미터(variadic parameter)** 를  
  지원한다. 가변 파라미터는 **반드시** 입력 파라미터 리스트에 있는 마지막 파라미터에 있어야 한다. 타입 **전에** `...`를 붙인다.  
  함수 내에서 생성된 변수는 지정된 타입의 slice이다. 즉, 가변 파라미터는 함수 내에서 다른 slice와 마찬가지로 사용이 가능하다.

```go
func addTo(base int, vals ...int) []int {
	out := make([]int, 0, len(vals))
	for _, v := range vals {
		out = append(out, base + v)
	}
	return out
}

func main() {
	fmt.Println(addTo(3))
	fmt.Println(addTo(3, 2))
	fmt.Println(addTo(3, 2, 5))
	a := []int{1, 2, 3}
	fmt.Println(addTo(3, a...))
	fmt.Println(addTo(3, []int{1, 2, 3, 4}...))
}
```

### 다중 반환값

- Go와 다른 언어들 사이의 첫 번째 차이점은 Go는 다중 반환값을 허용한다는 것이다.

```go
func divAndRemainder(numerator int, denominator int) (int, int, error) {
	if denominator == 0 {
		return 0, 0, errors.New("cannot devide by zero")
	}
	return numerator / denominator, numerator % denominator, nil
}
```

- 다중 반환 값을 지원하기 위해 몇 가지 변경 사항이 있다. Go 함수가 여러 값을 반환할 때, 반환값의 타입들을 괄호내에 `,`로 구분해 나열한다.  
  또한 함수가 여러 값을 반환한다면, 반드시 해당 값들을 쉼표로 구분해 반환해야 한다. 반환되는 값들을 괄호로 감싸면 컴파일 에러가 발생한다.

```go
func main() {
	result, remainder, err := divAndRemainder(5, 2)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	fmt.Println(result, remainder)
}
```

### 다중 반환값은 다중값

- 다중 반환값을 갖는 함수를 호출할 때, 해당 함수로부터 반환되는 각각의 값은 변수로 할당되어야 한다.  
  반환되는 여러 값을 하나의 변수로 할당하려 한다면, 컴파일 에러가 발생한다.

### 반환값 무시

- 함수 호출 시, 모든 반환 값이 의미를 갖지 않을 수 있다. 이럴 때는 반환값을 무시할 수 있는데, 무시할 반환값이 할당될 변수명을  
  `_`로 지정하면 된다.

- Go는 암묵적으로 함수에서 반환되는 값들을 **모두** 무시할 수 있다. 예를 들어 `fmt.Println()`의 경우에도 2개의 반환값이 있지만,  
  관용적으로 해당 값들을 무시한다. 거의 모든 다른 경우에는 사용하지 않을 반환값에 대해서는 `_`를 사용해 명시적으로 무시하도록 하자.

### 이름이 지정된 반환값

- Go에서는 다중 반환값 함수에서 반환값에 대해 이름을 지정할 수 있다.

```go
func divAndRemainder(numerator int, denominator int) (result int, remainder int, err error) {
	if denominator == 0 {
		err = errors.New("cannot devide by zero")
		return
	}
	result, reaminder = numerator / denominator, numerator % denominator
	return result, remainder, err
}
```

- 반환값에 대해 이름을 지정하는 것은 함수 내에서 반환값을 담기 위해 사용되는 변수를 미리 선언하는 것과 같다.  
  참고해야 할 중요한 사항은 이름이 지정된 반환값은 해당 함수 내에서만 접근 가능하다는 것이다.  
  함수 외부에서는 해당 이름의 변수가 적용되지 않는다.

- 이름이 지정된 반환값은 어떤 부분에 대해서는 코드를 명확하게 해주는 반면, 잠재적인 corner case를 가진다.  
  첫 번째로는 변수 shadowing 문제다. 다른 모든 변수와 마찬가지로 이름이 지정된 반환값이 shadowing될 수 있다.

### 빈 반환

- 이름이 지정된 반환값을 사용했다면, Go에서 하나의 심각한 오류인 blank return(빈 반환)을 조심해야 한다.  
  이름이 지정된 반환값이 있다면, 반환될 값을 명시하지 않고 return만 사용해야 한다. 해당 반환값은 이름이 지정된 변수에  
  마지막으로 할당된 값으로 처리된다.

```go
func divAndRemainder(numerator int, denominator int) (result int, remainder int, err error) {
	if denominator == 0 {
		err = errors.New("cannot devide by zero")
		return
	}
	result, reaminder = numerator / denominator, numerator % denominator
	return
}
```

- 빈 반환을 사용하면서 해당 함수에 몇 가지 변경을 했다. 유효하지 않은 입력이 있을 때 즉시 함수가 return되어 종료된다.  
  이때 result와 remainder에는 할당된 값이 없기에 해당 변수의 zero value를 반환한다. 이름이 지정된 반환 값에 대해  
  zero value를 반환하는 경우에 어떤 의미기 있는지를 생각해야 한다. 또한 함수의 마지막에는 여전히 return을 넣어야 한다.

- 빈 반환은 어느 정도 typing의 수고가 없어지기에 편리해 보이지만, 대부분의 Go 개발자들은 데이터 흐름을 이해하기 어려워지게  
  만들기 때문에 빈 반환을 좋은 선택지로 보지 않는다. 좋은 소프트웨어는 명확하고 가독성이 좋아 어떤 일이 일어나는지를 분명히  
  파악되게 할 수 있어야 한다. 빈 반환을 사용하면 코드를 읽는 사람은 반환 파라미터에 할당된 마지막 값을 추적하고, 어떤 값이  
  정확히 반환되는지 확인하기 위해 이전 코드를 다시 봐야할 수도 있다.

---
