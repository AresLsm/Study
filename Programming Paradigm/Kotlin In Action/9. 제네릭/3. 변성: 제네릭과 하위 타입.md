# 변성: 제네릭과 하위 타입

- **변성(variance)** 개념은 `List<String>`과 `List<Any>`와 같이 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤  
  연관 관계가 있는지 설명하는 개념이다.

## 변성이 있는 이유: 인자를 함수에 넘기기

- `List<Any>` 타입의 파라미터를 받는 함수에 `List<String>`을 넘기면 안전할까? `String`은 `Any`를 확장하므로, `Any` 타입 값을  
  파라미터로 받는 함수에 `String` 값을 넘겨도 당연히 안전하다. 하지만 `Any`와 `String`이 `List` 인터페이스의 타입 인자로 들어가는 경우,  
  그렇게 자신 있게 안전성을 말할 수 없다.

- 예를 들어, 리스트의 내용을 출력하는 함수를 생각해보자.

```kt
fun printContents(list: List<Any>) {
	println(list.joinToString())
}

printContents(listOf("a", "b", "c")) // a, b, c
```

- 이 경우에는 문자열 리스트도 잘 동작한다. 이 함수는 각 원소를 `Any`로 취급하며, 모든 문자열은 `Any` 타입이기도 하므로 완전히 안전하다.

- 이제 리스트를 변경하는 다른 함수를 살펴보자.

```kt
fun addAnswer(list: MutableList<Any>) {
	list.add(42)
}
```

- 이 함수에 문자열 리스트를 넘기면 어떻게 될까?

```kt
val strings = mutableListOf("abc", "bac")
addAnswer(strings) // line 2
println(strings.maxBy { it.length }) // line 3
```

- 위 코드의 line 2가 컴파일된다면, line 3가 수행될 때 `ClassCastException`이 발생할 것이다.  
  따라서 컴파일러는 애초에 line 2에서 컴파일 오류를 발생시켜, `MutableList<Any>`가 필요한 곳에 `MutableList<String>`을  
  넘기면 안된다는 사실을 알려준다. 코틀린 컴파일러는 이런 함수 호출을 금지한다.

- 다시 원래 질문으로 돌아가 `List<Any>` 타입의 파라미터를 받는 함수에 `List<String>`을 넘기면 안전하지 생각해보자.  
  어떤 함수가 리스트의 원소를 추가하거나 변경한다면, 타입 불일치가 생길 수 있기에 `List<Any>` 대신 `List<String>`을  
  넘길 수 없다. 하지만 원소의 추가나 변경이 없는 경우에는 `List<String>`을 `List<Any>` 대신 넘겨도 안전하다.  
  코틀린에서는 리스트의 변경 가능성에 따라 적절한 인터페이스를 선택한다면 안전하지 못한 함수 호출을 막을 수 있다.  
  함수가 읽기 전용 리스트를 받는다면 더 구체적인 타입의 원소를 갖는 리스트를 그 함수에 넘길 수 있다.  
  하지만 리스트가 변경 가능하다면 그럴 수 없다.

---

## 클래스, 타입, 하위 타입

- 우선 타입과 클래스의 차이에 대해 보자.

- 가장 단순한 경우를 생각해보자. 제네릭 클래스가 아닌 클래스에서는 클래스명을 바로 타입으로 쓸 수 있다. 예를 들어 `var x: String`이라 쓰면,  
  `String` 클래스의 인스턴스를 저장하는 변수를 정의할 수 있다. 하지만 `var x: String?` 처럼 클래스명을 nullable한 타입에도 쓸 수  
  있다는 점을 기억하자. 이는 모든 코틀린 클래스가 적어도 두 개 이상의 타입을 구성할 수 있음을 의미한다.

- 제네릭 클래스에서는 상황이 더 복잡하다. 올바른 타입을 얻으려면 제네릭 타입의 타입 파라미터를 구체적인 타입 인자로 바꿔줘야 한다.  
  예를 들어 `List`는 클래스이지만, 타입은 아니다. 하지만 타입 인자를 치환한 `List<Int>`, `List<String?>`, `List<List<String>>` 등은  
  모두 제대로 된 타입이다. 각각의 제네릭 클래스는 무수히 많은 타입을 만들어낼 수 있다.

- 타입 사이의 관계를 논하기 위해서는 **하위 타입(subtype)** 의 개념을 잘 알아야 한다.  
  어떤 타입 `A`의 값이 필요한 모든 장소에 어떤 타입 `B`의 값을 넣어도 아무런 문제가 없다면, 타입 `B`는 타입 `A`의 하위 타입이다.  
  예를 들어 `Int`는 `Number`의 하위 타입이지만, `String`의 하위 타입은 아니다. 이 정의는 모든 타입이 자기 자신의 하위 타입이라는 뜻이기도 하다.

- 반면 **상위 타입(supertype)** 은 하위 타입의 반대다. `A` 타입이 `B` 타입의 하위 타입이라면, `B`는 `A`의 상위 타입이다.

- 한 타입이 다른 타입의 하위 타입인지가 왜 중요할까?  
  컴파일러는 변수 대입이나 함수 인자 전달 시 하위 타입 검사를 매번 수행한다.

```kt
fun test(i: Int) {
	val n: Number = i // Int가 Number의 하위 타입이기에 컴파일 된다.

	fun f(s: String) { /* ... */ }
	f(i) // Int가 String의 하위 타입이 아니기에 컴파일 에러가 발생한다.
}
```

- 어떤 값의 타입이 변수 타입의 하위 타입인 경우에만 값을 변수에 대입하도록 허용한다.

- 간단한 경우, 하위 타입은 **하위 클래스(subclass)** 와 근본적으로 같다. 예를 들어 `Int` 클래스는 `Number`의 하위 클래스이므로  
  `Int`는 `Number`의 하위 타입이다. `String`은 `CharSequence`의 하위 타입인 것처럼, 어떤 인터페이스를 구현하는 클래스의  
  타입은 인터페이스 타입의 하위 타입이다.

- nullable하지 않은 타입은 nullable한 타입의 하위 타입이다. (ex. `Int`는 `Int?`의 하위 타입이다.)  
  하지만 두 타입 모두 같은 클래스에 해당한다. 항상 nullable하지 않은 타입의 값을 nullable한 타입의 변수에 저장할 수 있지만,  
  거꾸로 nullable한 타입의 값을 nullable하지 않은 타입의 변수에 저장할 수는 없다.

```kt
val s: String = "abc"
val t: String? = s
```

- 제네릭 타입에 대해 이야기할 때 특히 하위 클래스와 하위 타입의 차이가 중요해진다.  
  위에서 본 _"`List<String>` 타입의 값을 `List<Any>`를 파라미터로 받는 함수에 전달해도 안전한가?"_ 라는 질문을 하위 타입 관계를  
  써서 다시 쓰면 _"`List<String>`은 `List<Any>`의 하위 타입인가?"_ 라는 질문이 된다.  
  위에서 `MutableList<String>`을 `MutableList<Any>`의 하위 타입으로 다루면 왜 안되는지 살펴봤다.  
  즉 이 둘은 하위, 상위타입 관계가 아니다.

- 제네릭 타입을 인스턴스화할 때 타입 인자로 서로 다른 타입이 들어가서 인스턴스 타입 사이의 하위 타입 관계가 성립하지 않으면,  
  그 제네릭을 **무공변(invariant)** 이라 한다. `MutableList`를 예로 들면 `A`와 `B`가 서로 다르기만 하면 `MutableList<A>`는  
  항상 `MutableList<B>`의 하위 타입이 아니다.

> Java에서는 모든 클래스가 무공변이다.

- 위에서 이미 하위 타입 규칙이 다른 클래스를 살펴봤다. 코틀린의 `List` 인터페이스는 읽기 전용 컬렉션을 표현한다.  
  `A`가 `B`의 하위 타입이면 `List<A>`는 `List<B>`의 하위 타입이다.  
  이런 클래스나 인터페이스를 **공변적(covariant)** 이라 한다.

---

## 공변성: 하위 타입 관계를 유지

- `Producer<T>`를 예시로 공변성 클래스를 알아보자. `A`가 `B`의 하위 타입일 때 `Producer<A>`가 `Producer<B>`의 하위 타입이면  
  `Producer`는 공변적이다. 이를 하위 타입 관계가 유지된다고 말한다.

- 코틀린에서 제네릭 클래스가 타입 파라미터에 대해 공변적임을 표시하려면 타입 파라미터명 앞에 out을 붙여야 한다.

```kt
interface Producer<out T> {
	fun produce(): T
}
```

- 클래스의 타입 파라미터를 공변적으로 만들면, 함수 정의에 사용한 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도 그 클래스의  
  인스턴스를 함수 인자나 반환값으로 사용할 수 있다. 예를 들어 `Herd` 클래스로 표현되는 동물 무리의 사육을 담당하는 함수가 있다 해보자.  
  `Herd`의 타입 파라미터는 그 떼가 어느 동물의 무리인지 알려준다.

```kt
open class Animal {
	fun feed() { /* ... */ }
}

class Herd<T: Animal> {
	val size: Int get() = /* ... */
	operator fun get(i: Int): T { /* ... */ }
}

fun feedAll(animals: Herd<Animal>) {
	for (i in 0 until animals.size) {
		animals[i].feed()
	}
}
```

- 사용자 코드가 `Cat` 무리를 만들어 관리한다 해보자.

```kt
class Cat: Animal() {
	fun cleanLitter() {/* ... */}
}

fun takeCareOfCats(cats: Herd<Cat>) {
	for (i in 0 until cats.size) {
		cats[i].cleanLitter()
		feedAll(cats) // Error: inferred type is Herd<Cat>, but Herd<Animal> was expected
	}
}
```

- `feedAll(cats)`에서 컴파일 오류가 발생하는 이유는 `Herd`의 `T` 타입 파라미터에 대해 아무런 변성도 지정하지 않았기 때문에,  
  `Herd<Cat>`은 `Herd<Animal>`의 하위 클래스가 아니라고 취급되기 때문이다. 명시적으로 타입 캐스팅을 사용하면 이 문제를  
  해결할 수 있지만, 그런 식으로 처리하면 코드가 장황해지고 실수를 하기 쉽다. 게다가 타입 불일치를 해결하기 위해 강제 캐스팅을  
  하는 것은 결코 올바른 방법이 아니다.

- `Herd`는 `List`와 비슷한 API를 제공하며 동물을 그 클래스에 추가하거나 무리 안의 동물을 다른 동물로 바꿀 수는 없다.  
  따라서 아래처럼 `Herd`를 공변적인 클래스로 만들고, 호출 코드를 적절히 바꿀 수 있다.

```kt
class Herd<out T: Animal> {
	//..
}

fun takeCareOfCats(cats: Herd<Cat>) {
	for (i in 0 until cats.size) {
		cats[i].cleanLitter()
	}
	feedAll(cats) // OK
}
```

- 모든 클래스를 공변적으로 만들 수는 없다. 공변적으로 만들면 안전하지 못한 클래스도 있다.  
  타입 파라미터를 공변적으로 지정하면, 클래스 내부에서 그 파라미터를 사용하는 방법을 제한한다.  
  타입 안전성을 보장하기 위해 공변적 파라미터는 항상 out 위치에만 있어야 한다.  
  이는 클래스가 `T` 타입의 값을 생산할 수는 있지만, `T` 타입의 값을 소비할 수는 없다는 뜻이다.

- 클래스 멤버를 선언할 때 타입 파라미터를 사용할 수 있는 지점은 모두 in과 out 위치로 나뉜다.  
  `T`라는 타입 파라미터를 선언하고 `T`를 사용하는 클래스가 멤버로 있는 클래스를 생각해보자.  
  `T`가 함수의 반환 타입에 쓰인다면 `T`는 out 위치에 있다. 그 함수는 `T` 타입의 값을 _생산(produce)_ 한다.  
  `T`가 함수의 파라미터 타입에 쓰인다면 `T`는 in 위치에 있다. 그런 함수는 `T` 타입의 값을 _소비(consume)_ 한다.

```kt
interface Transformer<T> {
	fun transform(t: T): T
	//   in 위치 --^      ^-- out 위치
}
```

- 클래스 타입 파라미터 `T` 앞에 out 키워드를 붙이면, 클래스 안에서 `T`를 사용하는 메소드가 out 위치에서만 `T`를  
  사용하도록 허용하고, in 위치에서는 `T`를 사용하지 못하게 막는다. out 키워드는 `T`의 사용법을 제한하며,  
  `T`로 인해 생기는 하위 타입 관계의 타입 안전성을 보장한다.

- `Herd`를 다시 생각해보자. `Herd`에서 타입 파라미터 `T`를 사용하는 곳은 오직 `get()`의 반환 타입 뿐이다.

```kt
class Herd<out T: Animal> {
	val size: Int = get // ..
	operator fun get(i: Int): T {/*..*/}
}
```

- 위에서 `T`가 쓰인 곳은 out 위치다. 따라서 이 클래스를 공변적으로 선언해도 안전하다. `Cat`이 `Animal`의 하위 타입이기에  
  `Herd<Animal>`의 `get()`을 호출하는 모든 코드는 `get()`이 `Cat`을 반환해도 아무런 문제 없이 동작한다.

- 다시 한 번 보자. 타입 파라미터 `T`에 붙은 out 키워드는 아래 두 가지를 함께 의미한다.

  - **공변성** : 하위 타입 관계가 유지된다. (`Producer<Cat>`은 `Producer<Animal>`의 하위 타입)
  - **사용 제한** : `T`를 out 위치에만 사용할 수 있다.

- 이제 `List<T>` 인터페이스를 보자. 코틀린 `List`는 읽기 전용이다. 따라서 그 안에는 `T` 타입의 원소를 반환하는 `get()`은 있지만  
  리스트에 `T` 타입의 값을 추가하거나, 리스트에 있는 기존 값을 변경하는 메소드는 없다. 따라서 `List`는 `T`에 대해 공변적이다.

```kt
interface List<out T>: Collection<T> {
	operator fun get(index: Int): T
	//..
}
```

- 타입 파라미터를 함수의 파라미터 타입이나 반환 타입에만 쓸 수 있는 것은 아니다.  
  타입 파라미터를 다른 타입의 타입 인자로 사용할 수도 있다.  
  예를 들어 `List` 인터페이스에는 `List<T>`를 반환하는 `subList()` 메소드가 있다.

```kt
interface List<out T>: Collection<T> {
	fun subList(fromIndex: Int, toIndex: Int): List<T>
	//..
}
```

- 이 경우 `subList()`에 쓰인 `T`는 out 위치에 있다.

> 어떤 위치가 out인지 in인지를 판정하는 명확한 알고리즘은 코틀린 언어 문서를 보자.

- `MutableList<T>`를 타입 파라미터 `T`에 대해 공변적인 클래스로 선언할 수는 없다는 점에 유의하자.  
  `MutableList<T>`에는 `T`를 인자로 받아, 그 타입의 값을 반환하는 메소드가 있다. (`T`가 in, out에 동시에 쓰인다.)

```kt
interface MutableList<T>: List<T>, MutableCollection<T> {
	override fun add(element: T): Boolean
}
```

> `T`가 in 위치에 쓰이기에 `MutableList`는 `T`에 대해 공변적일 수 없다.

- 컴파일러는 타입 파라미터가 쓰이는 위치를 제한한다. 클래스가 공변적으로 선언된 경우, _"Type parameter T is declared as 'out' but_  
  _occurs in 'in' position"_ 이라는 오류를 보고한다.

- 생성자 파라미터는 in이나 out 어느쪽도 아님에 유의하자. 타입 파라미터가 out이라 해도, 그 타입을 여전히 생성자 파라미터의 선언에 사용할 수 있다.

```kt
class Herd<out T: Animal>(vararg animals: T) { /*...*/ }
```

- 변성은 코드에서 위험할 여지가 있는 메소드를 호출할 수 없게 만듦으로써 제네릭 타입의 인스턴스 역할을 하는 클래스 인스턴스를 잘못 사용하는 일이  
  없게 방지하는 역할을 한다.

> 생성자는 인스턴스를 생성한 뒤, 나중에 호출할 수 있는 메소드가 아니기에 생성자는 위험할 여지가 없다.

- 하지만 val이나 var 키워드를 생성자 파라미터에 적는다면, getter나 setter를 정의하는 것과 같다.  
  따라서 val은 out 위치, var은 out과 in 위치 모두에 해당한다.

```kt
class Herd<T: Animal>(var leadAnimal: T, vararg animals: T) { /*...*/ }
```

- 위 코드에서 `T` 타입인 leadAnimal 프로퍼티가 in 위치에 있기에 `T`를 out으로 표시할 수 없다.

- 또한 이런 in, out 위치 규칙은 오직 외부에서 볼 수 있는(public, protected, internal) 클래스 API에만 적용할 수 있다.  
  private 메소드의 파라미터는 in도 아니고 out도 아닌 위치다. 변성 규칙은 클래스 외부의 사용자가 클래스를 잘못 사용하는 일을  
  막기 위함이므로 클래스 내부 구현에는 적용되지 않는다.

---
