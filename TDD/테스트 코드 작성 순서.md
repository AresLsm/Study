<h1>테스트 코드 작성 순서</h1>

<h2>테스트 코드 작성 순서</h2>

* 이전에 암호 강도 측정 기능을 TDD로 구현했다. 기능 구현 시 테스트 코드를 작성한 순서는 아래와 같았다.
   1. 모든 규칙을 충족하는 암호 강도는 STRONG
   2. 길이만 8글자 미만이고 나머지 규칙은 충족하는 암호의 강도는 NORMAL
   3. 숫자를 포함하지 않고 나머지 규칙은 충족하는 암호의 강도는 NORMAL
   4. 값이 없는 암호의 강도는 INVALID
   5. 대문자를 포함하지 않고 나머지 규칙은 충족하는 경우
   6. 길이가 8글자 이상인 규칙만 충족하는 경우
   7. 숫자 포함 규칙만 충족하는 경우
   8. 대문자 포함 규칙만 충족하는 경우
   9. 아무런 규칙도 충족하지 않는 경우

* 위의 순서는 아래 규칙에 따라 나왔다.
  * 쉬운 경우에서 어려운 경우의 순서대로 진행
  * 예외적인 경우에서 정상인 경우로 진행

<h3>초반에 복잡한 테스트부터 시작하면 안되는 이유</h3>

* 만약 초반부터 다양한 조합을 검사하는 복잡한 상황을 테스트로 추가하면 해당 테스트를 통과시키기 위해 한 번에 구현해야할 코드가 많아진다.   
  예를 들어 아래 순서대로 테스트를 진행했다고 해보자.
  1. 대문자 포함 규칙만 충족하는 경우
  2. 모든 규칙을 충족하는 경우
  3. 숫자를 포함하지 않고 나머지 규칙은 충족하는 경우

* 위 순서대로 TDD를 진행해보자. 먼저 1번째 순서이다.
```java
@Test
void meetsOnlyUpperCriteria_Then_Weak() {
    PasswordStrengthMeter meter = new PasswordStrengthMeter();
    PasswordStrength result = meter.meter("abCDef");
    assertEquals(PasswordStrength.WEAK, result);
}
```

* 위 테스트를 통과 시키는 방법은 단지 `PasswordStrengthMeter#meter()`가 `PasswordStrength.WEAK`를 반환하도록 하면 된다.

* 다음으로 2번째 순서의 테스트를 해보자.
```java
@Test
void meetsAllCriteria_Then_Strong() {
    PasswordStrengthMeter meter = new PasswordStrengthMeter();
    PasswordStrength result = meter.meter("abcDef12");
    assertEquals(PasswordStrength.STRONG, result);
}
```

* 위 테스트를 통과시키려면 가장 단순한 방법은 입력 값이 "abcDef12"면 STRONG을 반환하도록 하면 된다. 테스트 코드를 더 작성해보자.
```java
@Test
void meetsAllCriteria_Then_Strong() {
    PasswordStrengthMeter meter = new PasswordStrengthMeter();
    PasswordStrength result = meter.meter("abcDef12");
    assertEquals(PasswordStrength.STRONG, result);
    PasswordStrength result2 = meter.meter("aZcDef12");
    assertEquals(PasswordStrength.STRONG, result);
}
```

* 위 테스트를 통과시키는 가장 단순한 방법은 위와 마찬가지로 입력값이 "aZcDef12"일 때에도 STRONG을 반환하도록 하면 된다. 하지만 검증 예를 추가할   
  때 마다 if 절을 늘릴 수는 없다. 좀 더 범용적인 구현이 필요하다. 이때, `범용적`이라는 구현을 하려면 구현에 대한 순서도 모호하고, 구현이 막힐 수 있다.

* 한 번에 완벽한 코드를 만들면 좋지만, 보통 많은 코드를 만들다 보면 개발자도 모르게 버그를 만들게 되고, 나중에 디버깅에는 그에 비례하여 많은 시간이   
  소요된다.

<h3>구현하기 쉬운 테스트부터 시작하기</h3>

* 가장 구현하기 쉬운 경우부터 시작하면 테스트를 빠르게 통과시킬 수 있다. 보통은 수 분에서 십여 분 이내에 구현을 완료해서 테스트를 통과시킬 수 있을 만큼   
  쉬운 경우를 선택한다.

<h3>예외 상황을 먼저 테스트해야 하는 경우</h3>

* 다양한 예외 상황은 if-else 블록을 동반할 때가 많다. 예외 상황을 전혀 고려하지 않은 코드에 예외 상황을 반영하려면 코드의 구조를 뒤집거나 코드 중간에   
  예외 상황을 처리하기 위해 조건문을 추가하는 일이 벌어진다. 이는 코드의 복잡성을 높이며 버그 발생 가능성을 높인다.

* 초반에 예외 상황을 테스트하면 위와 같은 가능성이 줄어든다. 예외 상황에 따른 if-else 구조가 미리 만들어지기 때문에 많은 코드를 완성한 뒤에 예외   
  상황을 반영할 때보다 코드 구조가 덜 바뀐다.

* TDD를 하는 동안 예외 상황을 찾고 테스트에 반영하면 예외 상황을 처리하지 않아 발생하는 버그도 줄여준다. 암호 등급 측정 예시의 경우, 암호 값이 없는   
  상황에 대한 테스트를 추가했다. 이 테스트를 추가하지 않으면 시스템 운영 중에 NPE가 발생할 수 있다. 이렇게 예외 상황을 찾고 테스트하면 이런 문제가   
  발생하는 것을 사전에 막을 수 있다.

<h3>완급 조절</h3>

* 처음 TDD로 구현할 때 어려운 것 중 하나는 한 번에 얼마만큼의 코드를 작성할 것인가이다. TDD를 처음 접할 때에는 아래 단계에 따라 TDD를 익히자.
  1. 정해진 값을 반환.
  2. 값 비교를 이용해서 정해진 값 반환.
  3. 다양한 테스트를 추가하면서 구현을 일반화한다.

* 예를 들어 암호 강도 측정 기능에서 길이가 8글자 미만이지만 나머지 규칙은 모두 충족하는 예시를 위 단계를 거쳐 구현해보자.
```java
@Test
void meetsOtherCriteria_except_for_length_Then_Normal() {
    PasswordStrengthMeter meter = new PasswordStrengthMeter();
    PasswordStrength result = meter.meter("ab12!@A");
    assertEquals(PasswordStrength.NORMAL, result);
}
```

* 처음에는 딱 이 테스트를 통과할 만큼만의 코드를 작성하자.
```java
public class PasswordStrengthMeter() {

    public PasswordStrength meter(String s) {
        if("ab12!@A".equals(s)) {
            return PasswordStrength.NORMAL;
        }
        return PasswordStrength.STRONG;
    }
}
```

* 위 메소드에서는 상수를 직접 비교하여 테스트를 통과시켰다. 다음으로 동일한 조건을 검증하기 위한 테스트 코드를 추가하자.
```java
@Test
void meetsAllCriteria_except_for_lengthThen_Normal() {
    PasswordStrengthMeter meter = new PasswordStrengthMeter();
    PasswordStrength result = meter.meter("ab12!@A");
    assertEquals(PasswordStrength.NORMAL, result);
    PasswordStrength result2 = meter.meter("Ab12!c");
    assertEquals(PasswordStrength.NORMAL, result);
}
```

* 새로 추가한 테스트 코드를 통과시키려면 아래와 같이 값 비교를 추가하면 된다.
```java
public class PasswordStrengthMeter() {

    public PasswordStrength meter(String s) {
        if("ab12!@A".equals(s) || "Ab12!c".equals(S)) {
            return PasswordStrength.NORMAL;
        }
        return PasswordStrength.STRONG;
    }
}
```

* 이번에도 상수 비교를 이용해서 테스트를 통과시켰다. 다음 차례는 상수를 제거하고 일반화하는 것이다.
```java
public class PasswordStrengthMeter() {

    public PasswordStrength meter(String s) {
        if(s.length() < 8) {
            return PasswordStrength.NORMAL;
        }
        return PasswordStrength.STRONG;
    }
}
```

<h3>지속적인 리팩토링</h3>

* 테스트를 통과한 뒤에는 리팩토링을 진행한다. 매번 리팩토링을 진행해야 하는 것은 아니지만 적당한 후보가 보이면 리팩토링을 진행한다. 대표적인 리팩토링의   
  대상은 코드 중복 부분이다. 코드가 길어지거나 중복되면 메소드 추출과 같은 기법을 사용해서 메소드명으로 코드의 의미를 표현할 수 있다.

* TDD를 진행하는 과정에서 지속적으로 리팩토링을 진행하면 코드의 가독성이 높아진다. 이는 이후에 분석의 용이함, 코드 변경의 어려움 감소 등의 효과를 주어   
  향후 유지보수에 도움이 된다.
<hr/>

