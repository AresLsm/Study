# Asynchronous Programming Techniques

- 개발자들은 개발을 하면서 Application이 블로킹되는 현상을 막기 위해 다양한 노력을 했다.  
  어떠한 유형의 애플리케이션을 개발하더라도 사용자가 오래동안 기다리게 하면 안되고, 애플리케이션이 탄력적으로  
  확장/축소할 수 있게끔 해야 했다.

- 아래는 이러한 문제를 해결하기 위해 나온 것들이다.

  - Threading
  - Callbacks
  - Future, Promise, others
  - Reactive Extensions
  - Coroutines

<h2>Threading</h2>

- Threading은 애플리케이션 블로킹 현상을 피하기 위해 가장 잘 알려진 방법이다.

```kt
fun postItem(item: Item) {
    val token = preparePost()
    val post = submitPost(token, item)
    processPost(post)
}

fun preparePost(): Token {
    // Request를 만들고 Main Thread를 block한다.
    return token
}
```

- 위 코드에서 `preparePost()` 메소드가 상당히 오래 걸리는 프로세스라면 사용자의 인터페이스도 그만큼 블로킹될 것이다.  
   여기서 우리가 할 수 있는 방법 중 하나는 다른 thread에서 이 작업을 하도록 하는 것이다. 이렇게 한다면 UI가 같이 blocking되는  
   현상은 피할 수 있다. 이는 가장 흔한 기술이지만, 아래의 단점들을 가진다.
  - Thread는 가벼운 리소스가 아니다. Thread를 다루려면 Context-Switching이 발생하는데, 매우 큰 연산 비용이 소모되는 작업이다.
  - Thread는 무한정 사용할 수 있는 것이 아니다. 기반 OS에 따라 사용할 수 있는 Thread의 최대 개수가 한정되며,  
    Server Side Application의 경우 이는 매우 큰 문제를 발생시킬 수 있다.
  - Thread는 항상 사용할 수 없다. JavaScript의 경우에는 Thread 자체를 제공하지 않는다.
  - Thread를 다루는 것은 결코 쉽지 않다. Thread를 디버깅하고, 경합 현상을 피해야 하는 것은 multi-thread programming에서  
   우리가 항상 겪는 문제이다.
  <hr/>

* 참고 문서: <a href="https://kotlinlang.org/docs/async-programming.html">Link</a>
