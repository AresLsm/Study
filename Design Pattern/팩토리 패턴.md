<h1>Factory Pattern</h1>

* `new` 키워드를 사용하는 것은 구상 클래스의 인스턴스를 생성하는 것이다. 구상 클래스를 바탕으로 코딩을 하면 나중에 코드를 수정해야할 가능성이   
  높아지고, 유연성이 떨어지게 된다. 또한 일련의 구상 클래스들이 있을 때는 어쩔 수 없이 아래와 같은 코드를 만들어야 할 경우도 있다.
```java
// 인터페이스 : Duck

Duck duck;
if(picnic) {
    duck = new MallardDuck();
} else if(hunting) {
    duck = new DecoyDuck();
} else if(inBachTub) {
    duck = new RubberDuck();
}
```

* 위와 같이 만들어지는 구상 클래스의 인스턴스 형식은 실행시에 주어진 조건에 따라 결정된다. 이러한 코드는 추후에 변경 또는 확장할 때 코드를   
  다시 확인하고 추가 또는 제거해야 함을 의미한다.

* `new` 자체에 문제가 있는 것은 아니고, 가장 문제를 일으키는 것이 바로 __변화__ 이다. 인터페이스에 맞춰서 코딩을 하면, 다형성 덕분에 어떠한   
  클래스든 특정 인터페이스만 구현하면 사용할 수 있다. 반대로 코드에서 구상 클래스를 많이 사용하면 새로운 구상 클래스가 추가될 때마다 코드를   
  수정해야 하기 때문에 많은 문제가 발생할 수 있다. 즉, 변화에 대해 닫혀있는 코드가 되는 것이다.
<hr/>

<h2>예시 시나리오</h2>

* 누군가가 피자 가게를 운영하고 있고, 피자는 종류가 다양하다. 이 때, 주문에 따라 올바른 피자를 고르고 피자를 만들기 위한 프로그램이 필요하다.
<hr/>

<h2>기본 코드</h2>

* 우선, 처음으로 주어진 기본 코드는 아래와 같다.
```java
Pizza orderPizza() {
    Pizza pizza = new Pizza();

    pizza.prepare();
    pizza.bake();
    pizza.cut();
    pizza.box();
    return pizza;
}
```

* 피자가 한 종류만 있는 것이 아니므로, 올바른 피자 종류를 고르고 만들기 위해 코드를 추가하자.
```java
Pizza orderPizza(String type) {
    Pizza pizza;

    if(type.equals("cheese")) {
        pizza = new CheesePizza();
    } else if(type.equals("greek")) {
        pizza = new GreekPizza();
    } else if(type.equals("pepperoni")) {
        pizza = new PepproniPizza();
    }
    return pizza;
}
```

* 위와 같은 코드가 있는 상황에서 새로운 피자 종류를 추가해야 하고, 기존 피자 중 하나를 삭제해야 한다면 `if`와 `else if`문이 바뀌게 된다.   
  즉, 위의 `orderPizza()` 메소드에서 가장 문제가 되는 부분은 바로 __인스턴스를 만들 구상 클래스를 선택하는 부분__ 이 된다. 

* 이제 어떤 부분이 바뀌고 어떤 부분이 바뀌지 않는지를 파악했으니 __캡슐화__ 를 진행할 차례이다.
<hr/>

<h2>객체 생성 부분의 캡슐화</h2>

* 이제 객체를 생성하는 부분을 `orderPizza()` 메소드에서 뽑아내야 한다는 것은 명확하다.
* 새로 만들 객체에는 `Factory`라는 이름을 붙이자. __객체 생성을 처리하는 클래스를 `Factory`라 한다.__ 가장 먼저 `SimplePizzaFactory`를 만들고   
  나면 `orderPizza()`는 새로 만든 객체의 클라이언트가 된다. 즉, 새로 만든 객체를 호출하는 것이다. 간단히 말해, 피자가 필요할 때 마다 피자 공장에   
  피자를 만들어달라고 부탁한다고 생각하면 된다.
```java
public class SimplePizzaFactory {
    
    public Pizza createPizza(String type) {
        if(type.equals("cheese")) {
            return new CheesePizza();
        } else if(type.equals("pepperoni")) {
            return new PepproniPizza();
        } else if(type.equals("clam")) {
           return new ClamPizza();
        } else if(type.equals("veggie")) { 
            return new VeggiePizza();
        }
    }
}
```

* 위와 같이 `SimplePizzaFactory`를 따로 생성하여 생기는 장점은 이 클래스를 사용하는 클라이언트가 매우 많은 경우를 생각하면 된다.   
  위의 예시에는 `orderPizza()` 메소드만 나와 있지만, 피자 객체를 받아 가격이든, 설명이든, 다양한 주문 처리 등에 대한 클래스에서도 이 팩토리를   
  사용할 수 있다. 따라서 피자를 생성하는 작업을 한 클래스에 캡슐화시켜 놓으면 구현을 변경해야 하는 경우에 코드를 찾아 고칠 필요 없이 위의   
  팩토리 클래스 하나만을 고치면 된다.

* 이제 팩토리 클래스가 만들어졌으니, `PizzaStore` 클래스를 수정해보자. `PizzaStore`는 `SimplePizzaFactory`의 클라이언트가 되는 것이다.
```java
public class PizzaStore {

    private SimplePizzaFactory factory;

    public PizzaStore(SimplePizzaFactory factory) {
        this.factory = factory;
    }

    public Pizza orderPizza(String type) {
        
        Pizza pizza = factory.createPizza(type);
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        return pizza;
    }
}
```

* 위와 같은 구조를 `Simple Factory(간단한 팩토리)` 라 하는데, 이는 디자인 패턴이라고 할 수는 없다. 클래스 구조를 생성하면, `PizzaStore`는   
  `SimplePizzaFactory`의 클라이언트이며, 클라이언트는 팩토리를 이용해서 `Pizza` 인스턴스를 받게 된다. 이때, `SimplePizzaFactory#createPizza()`는   
  종종 static으로 선언되기도 한다. 이렇게 정적 메소드로 정의하는 방법은 `Static Factory`라 하는데, 정적 메소드를 사용하면 객체를 생성하기 위한   
  메소드를 실행시키기 위해 객체의 인스턴스를 만들지 않아도 된다. 하지만 서브클래스를 만들어서 객체 생성 메소드의 행동을 변경 시킬 수 없다는 단점이 있다.
<hr/>