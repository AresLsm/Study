# 어노테이션 선언과 적용

- Java 프레임워크도 어노테이션을 많이 사용한다. 코틀린 어노테이션도 개념은 마찬가지다. 메타데이터를 선언에 추가하면 어노테이션을 처리하는  
  도구가 컴파일 시점이나 실행 시점에 적절한 처리를 해준다.

## 어노테이션 적용

- 코틀린에서는 Java와 같은 방법으로 어노테이션을 사용할 수 있다. 어노테이션을 적용하려면 적용하려는 대상 앞에 어노테이션을 붙이면 된다.  
  함수나 클래스 등 여러 다른 코드 구성 요소에 대해 붙일 수 있다.

```kt
class MyTest {
	@Test fun testTrue() {
		assertTrue(true)
	}
}
```

- 더 흥미로운 예제로 `@Deprecated` 어노테이션을 살펴보자. Java와 코틀린에서 이 어노테이션의 의미는 똑같다.  
  하지만 코틀린에서는 replaceWith 파라미터로 예전 버전을 대신할 수 있는 패턴을 제시할 수 있고, API 사용자는 그 패턴을 보고  
  지원이 종료될 API 기능을 더 쉽게 새 버전으로 포팅할 수 있다.

```kt
@Deprecated("Use remoteAt(index) instead.", ReplaceWith("remoteAt(index)"))
fun remove(index: Int) { /* ... */ }
```

- 어노테이션에 인자를 넘길 때는 일반 함수와 마찬가지로 괄호 안에 인자를 넣는다. 이런 `remove()` 선언이 있다면, IntelliJ는  
  `remove()`에 대해 경고를 표시해 줄 뿐 아니라 자동으로 그 코드를 새로운 API 버전에 맞는 코드로 바꿔주는 quick fix도 제시해준다.

- 어노테이션의 인자로는 원시 타입의 값, enum, 클래스 참조, 다른 어노테이션 클래스, 그리고 지금까지 말한 요소들로 이뤄진 배열이 들어갈 수 있다.  
  어노테이션 인자를 지정하는 문법은 Java와 약간 다르다.

  - 클래스를 어노테이션 인자로 지정할 때는 `@MyAnnotation(MyClass::class)` 처럼 `::class`를 클래스명 뒤에 넣어야 한다.
  - 다른 어노테이션을 인자로 지정할 때는 인자로 들어가는 어노테이션 앞에 `@`를 넣지 않아야 한다. 예를 들어, 방금 본 `ReplaceWith`는  
    어노테이션이다. 하지만 `@Deprecated` 어노테이션의 인자로 들어가므로 `ReplaceWith` 앞에 `@`를 사용하지 않는다.
  - 배열을 인자로 지정하려면 `@RequestMapping(path = arrayOf("/foo", "/bar"))` 처럼 `arrayOf()` 함수를 사용한다.  
    Java에서 선언한 어노테이션 클래스를 사용한다면 value라는 이름의 파라미터가 필요에 따라 자동으로 가변 길이 인자로 변환된다.  
    따라서 그런 경우에는 `@JavaAnnotationWithArrayValue("abc", "foo", "bar")`처럼 `arrayOf()`를 쓰지 않아도 된다.

- 어노테이션 인자를 컴파일 시점에 알 수 있어야 한다. 따라서 임의의 프로퍼티를 인자로 지정할 수는 없다. 프로퍼티를 어노테이션 인자로 사용하려면  
  그 앞에 const 변경자를 붙여야 한다. 컴파일러는 const가 붙은 프로퍼티를 컴파일 시점 상수로 취급한다.

```kt
const val TEST_TIMEOUT = 10L

@Test(timeout = TEST_TIMEOUT) fun testMethod() { /* ... */ }
```

> const가 붙은 프로퍼티는 파일의 맨 위나 object 안에 선언되어야 하며, 원시 타입이나 `String`으로 초기화해야만 한다.

---
