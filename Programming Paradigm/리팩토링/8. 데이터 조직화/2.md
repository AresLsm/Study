## 참조를 값으로 바꾸기

- 반대 리팩토링: **값을 참조로 바꾸기**

```js
// 리팩토링 적용 전
class Product {
  applyDiscount(arg) {
    this._price.amount -= arg;
  }
}

// 리팩토링 적용 후
class Product {
  applyDiscount(arg) {
    this._price = new Money(this._price.amount - arg, this._price.currency);
  }
}
```

### 배경

- 객체(데이터 구조)를 다른 객체(데이터 구조)에 중첩하면 내부 객체를 참조 호은 값으로 취급할 수 있다.  
  참조냐 값이냐의 차이는 내부 객체의 속성을 갱신하는 방식에서 가장 극명하게 드러난다.  
  참조로 다루는 경우에는 내부 객체는 그대로 둔 채 그 객체의 속성만 갱신하며, 값으로 다루는 경우에는  
  새로운 속성을 담은 객체로 기존 내부 객체를 통째로 대체한다.

- 필드를 값으로 다룬다면 내부 객체의 클래스를 수정해 값 객체(Value Object)로 만들 수 있다.  
  값 객체는 대체로 자유롭게 활용하기 좋은데, 특히 불변이기 때문이다. 일반적으로 불변 데이터구조는  
  다루기 더 쉽다. 불변 데이터 값은 프로그램 외부로 건네줘도 나중에 그 값이 바뀌어 내부에  
  영향을 줄까 염려하지 않아도 된다. 값을 복제해 이곳저곳에서 사용하더라도 서로 간의 참조를  
  관리하지 않아도 된다. 그래서 값 객체는 분산 시스템과 동시성 시스템에서 특히 유용하다.

- 한편 값 객체의 이런 특성 때문에 이번 리팩토링을 적용하면 안되는 상황도 있다. 예를 들어 특정 객체를  
  여러 객체에서 공유하고자 한다면, 그래서 공유 객체의 값을 변경했을 때 이를 관련 객체 모두에게  
  알려줘야 한다면 공유 객체를 참조로 다뤄야 한다.

### 절차

- (1) 후보 클래스가 불변인지, 혹은 불변이 될 수 있는지 확인한다.

- (2) 각각의 setter를 하나씩 제거한다.

- (3) 이 값 객체의 필드들을 사용하는 동치성(equality) 비교 메소드를 만든다.

### 예시

- 사람(`Person`) 객체가 있고, 이 객체는 아래 코드처럼 생성 시점에는 전화번호가 올바로 설정되지  
  못하게 짜여 있다 해보자.

```js
class Person {
  constructor() {
    this._telephoneNumber = new TelephoneNumber();
  }
  get officeAreaCode() {
    return this._telephoneNumber.areaCode;
  }
  set officeAreaCode(value) {
    this._telephoneNumber.areaCode = value;
  }
  get officeNumber() {
    return this._telephoneNumber.number;
  }
  set officeNumber(value) {
    this._telephoneNumber.number = value;
  }
}

class TelephoneNumber {
  //..

  get areaCode() {
    return this._areaCode;
  }
  set areaCode(value) {
    this._areaCode = value;
  }
  get number() {
    return this._number;
  }
  set number(value) {
    this._number = value;
  }
}
```

- 클래스를 추출하다 보면 종종 이런 상황이 벌어지곤 한다. 추출해서 새로 만들어진 객체(여기서는 `TelephoneNumber`)를  
  갱신하는 메소드들은 여전히 추출 전(`Person`)에 존재할 것이다. 어쨌든 새로운 클래스를 가리키는 참조가 하나뿐이므로  
  참조를 값으로 바꾸기에 좋은 상황이다.

- 가장 먼저 할 일은 _(1) `TelephoneNumber`을 불변으로 만들기_ 이다. _(2) 필드들의 setter만 제거하면 된다._  
  Setter 제거의 첫 단계로, setter로 설정하던 두 필드를 생성자에서 입력받아 설정하도록 한다.

```js
class TelephoneNumber {
  constructor(areaCode, number) {
    this._areaCode = areaCode;
    this._number = number;
  }

  get areaCode() {
    return this._areaCode;
  }
  get number() {
    return this._number;
  }
}
```

- 이제 setter를 호출하는 쪽을 살펴서 전화번호를 매번 다시 대입하도록 바꿔야 한다.

```js
class Person {
  //..

  get officeAreaCode() {
    return this._telephoneNumber.areaCode;
  }
  set officeAreaCode(value) {
    this._telephoneNumber = new TelephoneNumber(arg, this.officeNumber);
  }
  get officeNumber() {
    return this._telephoneNumber.number;
  }
  set officeNumber(value) {
    this._telephoneNumber = new TelephoneNumber(this.officeAreaCode, arg);
  }
}
```

- 이제 `Telephone`은 불변이 되었으니 값 객체로 활용할 수 있게 되었다.  
  값 객체로 인정받으려면 동치성을 값 기반으로 평가해야 한다. 이 시점에서 JS는 살짝 아쉬운데, JS는  
  참조 기반 동치성을 값 기반 동치성으로 대체하는 일과 관련하여 언어나 핵심 라이브러리 차원에서  
  지원해주는게 없다. 아래처럼 메소드를 만들어야 한다.

```js
class TelephoneNumber {
  //..

  equals(other) {
    if (!(other instanceof TelephoneNumber)) {
      return false;
    }
    return this.areaCode === other.areaCode && this.number === other.number;
  }
}
```

- 테스트하는 것도 잊으면 안된다.

- `TelephoneNumber`를 사용하는 곳이 둘 이상이라도 절차는 똑가다. Setter를 제거할 때 해당  
  사용처를 모두 수정하면 된다. 번호가 다른 전화번호들로 비교해보고, 유효하지 않은 번호나 null값과도  
  비교해보면 좋다.

<hr/>
