# Nearby Friends

- 이번 장에서는 가까운 친구들의 목록을 알려주는 _"Nearby friends"_ 기능을 포함한 확장 가능한 백엔드 시스템을 구현해보자.  
  위치 정보에 대한 접근 권한을 허가한 사용자들에 대해서 모바일 클라이언트는 지리적으로 가까운 친구들의 목록을 보여주게 된다.  
  예를 들어 Facebook에서도 이러한 기능을 제공한다.

- 이전에 본 Proximity Service와 상당히 유사하다는 것을 느낄 수 있겠지만, 자세히 생각해보면 이 둘은 꽤나 큰 차이점이 많다.  
  Proximity Service에서 각 장소의 위치 정보는 변하지 않기에 정적인 반면, Nearby Friends에서는 사용자의 위치가 자주 바뀌기 때문에  
  위치 정보가 더욱 동적이다.

## 문제 이해 및 설계 범위 확정

- 이번에 설계할 시스템의 요구사항은 아래와 같다.

  - 5miles 내에 있어야 _"nearby"_ 하다고 취급한다.
  - 사용자들 간의 거리는 일직선 상의 거리로 계산한다.
  - 사용자 수는 1억 명이며, 이 중 10%만이 Nearby Friends 기능을 사용한다.
  - 위치 정보는 머신 러닝 등을 위해 저장되어야 한다.
  - 10분 이상 활동을 하지 않는 사용자는 인접 친구 목록에 뜨지 않는다.
  - 개인 정보 보호 법 등의 법규에 대한 신경은 쓰지 않아도 된다.

- 추가적으로 아래의 요구 사항들이 있다.

  - 사용자는 모바일 애플리케이션 상에서 가까운 친구들의 목록을 볼 수 있어야 한다. 각 친구들에 대해서는 일직선 상의 거리와 마지막으로 거리가  
    갱신된 timestamp를 나타내준다.
  - 가까운 친구들의 목록은 몇 초 마다 갱신되어야 한다.
  - Low latency: 친구들의 위치 정보를 빠르게 갱신하기 위해 지연 시간이 낮아야 한다.
  - Reliability: 시스템은 전체적으로 안정적이어야 하고, 가끔 어쩔 수 없는 데이터의 손실은 허용된다.
  - Eventual Consistency: 위치 정보의 저장소는 강한 일관성(strong consistency)를 필요로 하지 않는다.  
    다른 replica들로부터 위치 정보를 조회해 발생하는 몇 초의 delay는 허용된다.

- 이제 위의 요구사항들에 기반해 필요한 정보들을 수치화해보자.

  - 가까운 친구들은 5 mile 반경 내에 있는 친구들로 정의된다.
  - 사용자의 위치 정보는 매 30초마다 갱신된다. 30초라는 숫자가 나온 이유는 사람의 걷는 속도가 느리기 때문이다.  
    30초 동안 걷는다고 했을 때, 걷기 전의 위치와 30초 후의 위치는 그렇게 큰 차이가 없다.
  - 평균적으로 매일 1000만 명의 사용자가 "Nearby Friends" 기능을 사용한다.
  - 동시 접속자의 수는 DAU의 10%라고 해보자. 따라서 동시 접속자 수는 100만 명이다.
  - 평균적으로 한 사용자는 400명의 친구가 있다. 그리고 이 400명 모두가 "Nearby Friends" 기능을 사용한다 가정한다.
  - 앱은 한 페이지당 20명의 가까운 친구들을 표시하며, 추가적인 요청에 의해 더 많은 가까운 친구들을 불러올 수 있다.
  - QPS를 계산하는 과정은 아래와 같다.
    - DAU: 1000만 명
    - 동시 접속자 수: `1000만 * 10% = 100만`
    - 사용자는 자신의 위치 정보를 30초마다 갱신시킨다.
    - 위치 정보 갱신의 QPS는 `100만 / 30 = 334,000` 이다.

---
