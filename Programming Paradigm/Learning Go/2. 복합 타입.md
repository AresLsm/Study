# 복합 타입

## 배열

- Go도 배열을 갖지만, 직접 배열을 사용하는 경우는 드물다.

- 배열의 모든 요소는 지정된 타입이어야 한다. 배열을 선언하는 방법에는 몇 가지가 있는데, 첫 번째는 아래처럼 배열의 크기와 요소 타입을  
  지정하는 방법이다.

```go
var x [3]int
```

- 위 선언은 3개의 정수 요소를 갖는 배열을 생성한다. 값은 지정하지 않았기에 배열의 모든 위치에는 각각 정수의 zero value인 0이  
  들어간다. 배열에 초기값을 주려면 **배열 리터럴**로 요소 값을 넣을 수 있다.

```go
var x = [3]int{10, 20, 30}
```

- **희소 배열** (대부분의 값이 0으로 설정된 배열)을 만든다면, 배열 리터럴 내에 지정된 index의 값만 설정할 수 있다.

```go
var x = [12]int{1, 5: 4, 6, 10: 100, 15}
```

- 위 선언은 `[1, 0, 0, 0, 0, 5, 6, 0, 0, 0, 100, 15]`의 값을 갖는 배열을 생성한다.

- `==`와 `!=`를 사용해 배열 간의 비교도 가능하다.

```go
var x = [...]int{1, 2, 3}
var y = [3]int{1, 2, 3}
fmt.Println(x == y) // true
```

- Go에서 다차원 배열은 배열의 요소로 다른 배열을 포함하는 배열이다.

```go
var x [2][3]int
```

- 위에서 길이가 2인 정수 배열은 길이가 3인 정수 배열을 요소로 갖는다.  
  마지막으로 아래처럼 괄호를 사용해 값을 읽거나 쓸 수 있다.

```go
x[0] = 10
fmt.Println(x[2])
```

- 배열에서 배열의 끝을 넘어서거나 음수의 index를 사용해 값을 읽거나 쓸 수 없다. 이를 상수나 리터럴 index로 한다면 컴파일 오류가 발생한다.  
  범위를 넘어서는 값을 가진 변수를 통해 배열을 읽거나 쓰기를 시도한다면 컴파일은 되겠지만, 실행 중에 panic이 발생하며 실행이 중단된다.

- 마지막으로 내장 함수인 `len()`으로 배열의 길이를 알 수 있다.

```go
fmt.Println(len(x))
```

- 위에서 말했듯이 Go에서 배열은 거의 사용되지 않는다. 이유는 Go에서 배열의 크기를 배열 타입의 일부로 간주한다는 제한이 있기 때문이다.  
  예를 들어 `[3]int`로 선언된 배열은 `[4]int`와 다른 타입으로 만든다. 이는 곧 배열의 크기를 지정하기 위해 변수를 사용할 수  
  없다는 뜻이다. 왜냐면 타입은 실행 중이 아니라 컴파일 과정에서 반드시 해석되어야 하기 때문이다.

- 또한 동일한 타입을 가진 다른 크기의 배열 간에 타입 변환을 시도할 수도 없다. 크기가 다른 배열을 서로 변환할 수는 없기에  
  어떤 크기의 배열로도 실행 가능한 함수를 작성할 수 없으며, 동일한 변수에 크기가 다른 배열을 할당할 수 없다.

- 이러한 제약들 때문에 정확히 미리 필요한 크기를 아는 경우가 아니라면, 배열을 사용하지 않도록 한다.

---

## slice

TODO: p.69

---

## string, rune, byte

- Go의 문자열이 rune으로 만들어진다고 생각할 수 있지만, 실제로 그렇지 않다.  
  내부적으로 Go는 문자열을 표현하기 위해 일련의 byte를 사용한다. 이 byte는 어느 특정한 문자 인코딩을 가지진 않지만,  
  몇몇의 Go 라이브러리 함수는 문자열이 UTF-8 encoding으로 구성되어 있다고 간주한다.

> Go 언어 스펙에 따르면, Go 소스 코드는 항상 UTF-8로 쓰여진다. 문자열 리터럴에 16진수 escape를 사용하지  
> 않는다면, 문자열 리터럴은 UTF-8로 쓰여진다.

- 배열이나 slice에서 단일 값을 추출하는 것과 같이, 문자열도 index 표현으로 값을 꺼내올 수 있다.

```go
var s string = "Hello there"
var b byte = s[6]
```

- 배열, slice 처럼 문자열 index는 0부터 시작한다.  
  또한 slice 표기법은 문자열에서도 통용된다.

```go
var s string = "Hello there"
var s2 string = s[4:7] // "o t"
var s3 string = s[:5] // "Hello"
var s4 string = s[6:] // "there"
```

- Go에서 문자열에 개별 요소를 꺼내기 위해 index 표기법을 사용하고, 하위 문자열을 만들기 위해 slice 표기법을 사용하도록 하는 것은  
  매우 편리하지만, 매우 조심스럽게 다뤄야 한다. 문자열은 변경이 불가하기 때문에, slice의 slice에서 발생한 수정 문제와 같은 것은  
  없다. 하지만 다른 문제가 있다. **문자열은 일련의 byte로 구성되는데, UTF-8 코드는 1에서 4byte로 어디든 위치할 수 있기 때문이다.**  
  예를 들어, 영어가 아닌 다른 나라의 언어나 이모티콘을 처리하려 할 때, 여러 byte에 걸쳐 UTF-8의 코드를 사용해 코드를 수행해야 한다.

```go
var s string = "Hello 🥳"
var s2 string = s[4:7]
var s3 string = s[:5]
var s4 string = s[6:]
```

- s의 마지막에는 이모티콘이 있는데, 위 코드를 수행하면 원하는 대로 결과가 나오지 않게 된다.  
  이모티콘의 첫 번째 byte만 복사해 유효하지 않은 코드가 되었기 때문이다.

- Go는 내장 함수 `len()`에 문자열을 넘겨 해당 문자열의 길이를 알아낼 수 있다.  
  문자열 index와 slice 표현식이 위치를 byte 단위로 계산한다는 것을 생각하면, `len()`을 통해 반환된 길이는 코드 단위가 아니라  
  byte 단위라는 것을 알 수 있다.

```go
var s string = "Hello 🥳"
fmt.Println(len(s)) // 10
```

- rune, string, byte 사이의 복잡한 관계 때문에 Go는 이런 타입들 간에 변환할 수 있는 기능을 제공한다.  
  아래처럼 단일 rune 또는 byte는 string으로 변환이 가능하다.

```go
var a rune = 'x'
var s string = string(a)
var b byte = 'y'
var s2 string = string(b)
```

> 타입 변환으로 정수를 문자열로 변경하지 말자. 아래 코드를 보자.
>
> ```go
> var x int = 65
> var y = string(x)
> fmt.Println(y) // A
> ```

- string은 byte slice나 rune slice로 변환이 가능하다.

```go
var s string = "Hello 🥳"
var bs []byte = []byte(s)
var rs []rune = []rune(s)
```

- Go에서 대부분의 데이터는 일련의 byte로 읽거나 쓸 수 있어서, 대부분의 일반 string은 byte slice로 타입 변환이 가능하다.  
  rune slice로의 변환은 드문 경우이다.

- 문자열을 slice와 index 표현법으로 사용하기 보다는, 표준 라이브러리인 `strings`나 `unicode/utf8` 패키지에 있는  
  함수를 사용해 하위 문자열이나 코드 포인트를 추출해 사용하자.

---

## map

- slice는 순차 데이터를 접근할 때 유용하게 사용할 수 있다. 대부분의 언어와 마찬가지로, Go는 하나의 값을 다른 것과 연결하고  
  관리하기 위한 내장 데이터 타입을 지원한다. map 타입은 `map[keyType]valueType` 형태로 선언된다. map을 선언할 수 있는  
  몇 가지 방법에 대해 살펴보자. 첫 번째로는 var 키워드를 사용해 map 변수를 생성하고, zero value를 할당할 수 있다.

```go
var nilMap map[string]int
```

- 위처럼 선언하면 nilMap은 문자열 타입의 key와 정수를 value로 갖는 map으로 선언된다. 이때, map의 zero value는  
  nil이 된다. nil map은 길이가 0이다. nil map의 value를 읽으려 하면 map의 value type의 zero value가 반환된다.  
  하지만 nil map에 값을 쓰려 한다면 panic이 발생할 것이다.

- `:=` 연산자를 사용해 map 변수를 선언하고, map 리터럴을 할당할 수 있다.

```go
totalWins := map[string]int{}
```

- 이렇게 하면 비어 있는 map 리터럴을 사용하게 된다. 위 선언은 nil map과는 다르다. 길이는 0이지만, 비어 있는 map 리터럴이  
  할당된 map을 읽고 쓸 수 있다. 비어 있지 않은 map 리터럴은 아래와 같다.

```go
teams := map[string]string {
	"Orcas": []string{"Fred", "Ralph", "Bijou"},
	"Lions": []string{"Sarah", "Peter", "Billie"},
	"Kittens": []string{"Waldo", "Raul", "Ze"},
}
```

- map 리터럴은 중괄호 내에 key가 쓰인 뒤에 콜론이 따라오고, 그 다음에는 대응되는 값이 위치한다. 위 예시 코드에서는 key에 대응되는  
  value로 문자열 slice를 사용했다. map에서 value의 타입으로 어떤 것이든 가능하다.

- 만약 key-value 쌍이 얼마나 들어갈 지는 알고 있지만, 정확히 어떤 값이 들어갈지 모른다면 `make()`를 사용해 기본 크기를  
  지정해 map을 생성할 수 있다.

```go
ages := make(map[int]string, 10)
```

- `make()`로 생성된 map은 길이가 0이고, 초기에 지정한 크기 이상으로 커질 수 있다.

- map은 여러 가지 방법적인 면에서 아래와 같은 부분이 있다.

  - map은 key-value 쌍이 추가되면 자동으로 커진다.
  - map에 넣을 key-value 쌍의 데이터가 어느정도 되는지 파악이 된다면, `make()`를 통해 특정한 크기로 초기화해 생성할 수 있다.
  - `len()`에 map을 넘기면 key-value 쌍이 해당 map에 몇 개가 있는지를 반환한다.
  - map의 zero value는 nil이다.
  - map은 비교 가능하지 않다. nil과 같은지는 비교 가능하지만, 두 개의 map에 key와 대응되는 value가 동일하게 들어있는지를  
    비교하기 위해 `==`를 사용하거나, 혹은 같지 않은지를 비교하기 위해 `!=`를 사용할 수는 없다.

- map의 key는 모든 비교 가능한 타입이 될 수 있다. 이는 map의 key로써 slice나 map이 될 수 없다는 것을 의미한다.

- map이나 slice를 어느 시점에 써야 하는지 살펴보자. slice는 데이터 리스트를 만들 때 사용하는데, 특히 순차적인 데이터를 다룰 때  
  사용하도록 하자. map은 엄격하게 증가하는 순서가 아닌 값들을 구성하는 데이터가 있을 때 사용하면 유용하다.

> map을 사용할 때 요소의 순서는 상관이 없지만, slice를 사용하는 경우에는 요소의 순서가 중요하게 고려된다.
>
> Go에서 내장된 map은 hashmap이다.
> hashmap은 key 기반으로 대응되는 value를 빠르게 찾을 수 있다. 내부적으로, hashmap은 배열로 구현되어 있다.  
> key와 value를 추가할 때, key는 hash algorithm을 통해 숫자로 변환된다. 이런 숫자들은 각 key를 대변하는 유일한 값이다.  
> hash algorithm은 서로 다른 key를 동일한 숫자로 바꿀 수도 있다. 이 숫자는 배열의 index로 사용된다. 배열의 요소는 bucket이라  
> 불리는데, key-value 쌍의 데이터가 bucket에 저장된다. Bucket에 이미 동일한 key가 존재한다면, 대응되는 이전 값은 새로운 값으로 교체된다.
>
> 각 bucket 또한 배열인데, 한 개 이상의 값을 담을 수 있다. 두 개의 key가 동일한 bucket에 할당되었을 때, 이를 collision(충돌)이라 하며  
> 두 개의 key-value 쌍을 해당 bucket에 저장한다.
>
> hashmap에서 값을 읽을 때도 동일하게 동작한다. key를 가지고 hash algorithm을 수행해 숫자로 변환한 뒤, 관련된 bucket을 찾고  
> bucket 내의 모든 key-value 쌍을 순회하며 해당 key를 갖는 요소를 찾아낸다.
>
> 찾아냈다면, key에 대응되는 value를 반환한다.
>
> 너무 많은 collision을 가지는 것은 좋지 않다. 왜냐면 이런 collision이 많아진다면 hashmap을 통해 value를 얻는 작업이 동일한  
> bucket내에 원하는 요소를 찾아내기 위해 순회하기 때문에 느려지기 때문이다. 명석한 hash algorithm은 collision을 최소화하기 위한  
> 설계가 들어있다. 요소들이 충분히 추가되었다면, hashmap은 크기가 조정되어 bucket의 load를 재조정하고 더 많은 entry를 받아들일 수 있도록 한다.

### map 읽고 쓰기

- map을 선언해 쓰고 읽는 간단한 프로그램을 살펴보자.

```go
totalWins := map[string]int{}
totalWins["Orcas"] = 1
totalWins["Lions"] = 2
fmt.Println(totalWins["Orcas"]) // 1
fmt.Println(totalWins["Kittens"]) // 0
totalWins["Kittens"]++
fmt.Println(totalWins["Kittens"]) // 1
totalWins["Lions"] = 3
fmt.Println(totalWins["Lions"]) // 3
```

- 특정 map key에 대해 value를 할당하기 위해 `[]`에 Key를 넣고, `=`를 사용해 value를 할당한다. 그리고 `[]`에 key를 넣어  
  map에 해당 key에 할당된 value를 읽을 수 있다. map key에 value를 할당하기 위해 `:=` 연산자는 사용할 수 없다는 것을 기억하자.

### comma ok idiom

- map은 key에 대응되는 value가 없어도 기본 zero value를 반환한다. 이는 위에서 본 counter 같은 것을 구현할 때 편리하다.  
  하지만 때론 map에 key가 있는지 확인해야 하는 경우도 있다. Go는 _comma ok idiom_ 으로 map에 key가 없어 zero value를  
  반환하는 경우와 key에 해당하는 value로 0을 반환한 것인지를 구분해 알려줄 수 있다.

```go
m := map[string]int{
	"hello": 5,
	"world": 0,
}

v, ok := m["hello"]
fmt.Println(v, ok) // 5 true

v, ok = m["world"]
fmt.Println(v, ok) // 0 true

v, ok = m["goodbye"]
fmt.Println(v, ok) // 0 false
```

- map을 읽어 해당 결과를 단일 변수에 할당하는 것보다 comma ok idiom을 사용해 읽기 결과를 두 개의 변수에 할당한다.  
  첫 번째 변수는 key에 해당하는 value를 저장하고, 두 번째 반환된 값은 해당 key가 map에 있는지 여부를 저장한 boolean 값이다.

- 일반적으로 ok라고 변수명을 사용한다. ok가 true라면 해당 key는 map에 있다는 뜻이고, ok가 false라면 해당 key는 map에 없다는 뜻이다.

### map에서 key-value 쌍 제거

- key, value 쌍은 내장 함수 `delete()`를 이용해 map에서 삭제할 수 있다.

```go
m := map[string]int{
	"hello": 5,
	"world": 0,
}

delete(m, "hello")
```

- `delete()`는 map과 key를 인자로 받아 해당하는 key-value 쌍을 map에서 제거한다. key가 map에 존재하지 않거나 map이 nil인 경우는  
  어떤 일도 일어나지 않는다. `delete()`는 반환값이 없다.

### map을 set으로 이용

- 많은 개발 언어들은 표준 라이브러리에서 set을 지원한다. set은 중복되는 값이 없음을 보장하지만, 어떤 특정 순서로 값들이 들어간다는  
  것은 보장해주지 않는다. 한 요소가 set에 있는지 확인하는 것은 얼마나 많은 요소들이 set에 들어 있냐와 무관하게 빠르다.

- Go는 set을 지원하지는 않지만, map을 이용해 set처럼 사용할 수 있다. set에 넣고자 하는 타입은 map의 key로 하고,  
  value로는 boolean type을 지정한다.

```go
intSet := map[int]bool{}
vals := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
for _, v := range vals {
	intSet[v] = true
}

fmt.Println(intSet) // map[1:true 2:true 3:true 4:true 5:true 6:true 7:true 8:true 9:true 10:true]
fmt.Println(intSet[5]) // true
fmt.Println(intSet[500]) // false
if intSet[100] {
	fmt.Println("100 is in the set")
}
```

- 정수 set을 만들고 싶다면 key를 정수로 하고 value를 boolean으로 갖는 map을 만들면 된다.

> map으로 set을 구현할 때 value type으로 boolean이 아니라 `struct{}`를 지정할 수도 있다.  
> `struct{}`는 0byte를 차지하지만, boolean은 1byte를 차지한다.  
> 하지만 이렇게 구현하면 의도가 불명확한 할당으로 코드의 모양새가 나빠지고, value가 set에 있는지를 확인하기 위해  
> comma ok idiom을 사용해야만 한다.

---

## struct

---
