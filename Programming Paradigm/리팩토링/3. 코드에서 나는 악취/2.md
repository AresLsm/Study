# 코드에서 나는 악취(2)

<h2>기능 편애</h2>

- 프로그램을 모듈화할 때는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은  
  최대한 늘리고, 영역 사이에서 이뤄지는 상호작용은 최소한으로 줄이는 데 주력한다.  
  기능 편애는 흔히 어떤 함수가 **자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와**  
  **상호작용 할 일이 더 많을 때** 풍기는 냄새이다. 실행 과정에서 외부 객체의 setter 메소드  
  대여섯개를 호출하도록 작성된 함수는 정말 많다. 다행이 해결하기는 쉽다. 이 함수가 데이터와  
  가까이 있고 싶어 한다는 의중이 뚜렷이 드러나므로 소원대로 **함수 옮기기**를 사용하여  
  데이터 근처로 옮겨주면 된다. 때로는 함수의 일부에서만 기능을 편애할 수 있다. 이럴 때는 그 부분만  
  독립 함수로 **함수 추출하기**를 이용해 빼낸 다음 **함수 옮기기**로 원하는 모듈로 보내주자.

- 물론 어디로 옮겨야 하는지가 명확하게 드러나지 않을 때도 있다.  
  예를 들어 함수가 사용하는 모듈이 다양하다면 어느 모듈로 옮겨야 할까?  
  이럴 때 저자는 **가장 많은 데이터를 포함한 모듈로** 옮긴다.  
  **함수 추출하기**로 함수를 여러 조각으로 나눈 후 각각을 적합한 모듈로 옮기면 더 쉽게  
  해결되는 경우도 많다.

- 한편 앞의 두 문단에서 설명한 규칙을 거스르는 복잡한 패턴도 있다.  
  예를 들어 _전략 패턴_, *방문자 패턴*이 있을 것이다. 이들은 모두 뒤엉킨 변경 냄새를 없앨 때  
  활용하는 패턴들로, 가장 기본이 되는 원칙은 **함께 변경할 대상을 한데 모으는 것**이다.  
  데이터와 이를 활용하는 동작은 함께 변경해야 할 때가 많지만, 예외가 있다.  
  그럴 때는 같은 데이터를 다루는 코드를 한 곳에서 변경할 수 있도록 옮기자.  
  전략 패턴과 방문자 패턴을 적용하면 오버라이드해야 할 소량의 동작 코드를 각각의 클래스로  
  격리해주므로 수정하기가 쉬워진다.

<hr/>

<h2>데이터 뭉치</h2>

- 데이터 항목들은 서로 어울려 노는 것을 좋아한다. 그래서 데이터 항목 서너 개가 여러 곳에서  
  항상 함께 뭉쳐 다니는 모습을 흔히 목격할 수 있다. 클래스 두어 개의 필드에서, 혹은  
  여러 메소드의 시그니처에서 함께 발견되기도 한다. 이렇게 몰려다니는 데이터 뭉치는  
  보금자리를 따로 마련해줘야 마땅하다.

- 가장 먼저 필드 형태의 데이터 뭉치를 찾아서 **클래스 추출하기**로 하나의 객체로 묶는다.  
  다음은 메소드 시그니처에 있는 데이터 뭉치 차례다. 먼저 **매개변수 객체 만들기**나  
  **객체 통째로 넘기기**를 적용해서 매개변수 수를 줄여본다. 그 즉시 메소드 호출 코드는 간결해진다.  
  데이터 뭉치가 앞에서 새로 만든 객체의 일부만 사용하더라도 걱정할 필요 없다. 새로운 객체로 뽑아낸  
  필드가 두 개 이상이기만 해도 확실히 예전보다 나아지기 때문이다.

- 데이터 뭉치인지를 판별하려면 *값 하나를 삭제*해보자. 그랬을 때 나머지 데이터만으로는 의미가 없다면  
  객체로 환생하길 갈망하는 데이터 뭉치라는 뜻이다.

- 방금 설명에서 간단한 레코드 구조가 아닌 **클래스**로 만들기를 권했다는 점을 주의하자.  
  클래스를 이용하면 좋은 향기를 흩뿌릴 기회가 생긴다. 기능 편애를 없애는 과정에서 새로운 클래스를  
  만들었다면, 이어서 그 클래스로 옮기면 좋을 동작은 없는지 살펴보자. 이러한 연계 과정은 종종 상당한  
  중복을 없애고 향후 개발을 가속화하는 유용한 클래스를 탄생시키는 결과로도 이어지기도 한다.  
  데이터 뭉치가 생산성에 기여하는 정식 멤버로 등극하는 순간이다.

<hr/>
