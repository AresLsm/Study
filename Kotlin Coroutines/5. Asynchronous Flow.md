# Asynchronous Flow

- Suspending function은 비동기적으로 하나의 값을 반환한다.  
  하지만 만약 비동기적으로 계산돤 여러 개의 값을 반환하고 싶다면 어떻게 해야 할까? 이때 Kotlin Flow를 사용할 수 있다.

## Representing Multiple Values

- 여러 개의 값들은 코틀린에서 컬렉션으로 표현할 수 있다. 예를 들어 아래의 `simple()` 함수는 3개의 숫자를 담은 `List`를 반환하고,  
  반환받은 `List`의 원소를 각각 `main()`에서 출력한다.

```kt
fun simple(): List<Int> = listOf(1, 2, 3)

fun main() {
	simple().forEach { println(it) }
}
```

### Sequences

- 아래 처럼 하나의 값을 계산하는 데 100ms가 소요된다고 해보자. 이때, 이 값들을 `Sequence`로 표현할 수 있다.

```kt
fun simple(): Sequence<Int> = sequence {
	for (i in 1..3) {
		Thread.sleep(100)
		yield(i) // yield next value
	}
}

fun main() {
	simple().forEach { println(it) }
}
```

- 위 코드는 100ms씩 각 숫자를 출력한다.

### Suspending Functions

- 위에서 본 코드는 코드를 실행하는 main thread를 block한다는 단점이 있다. 만약 계산되는 값들이 비동기적으로 계산된다면, `simple()`을 suspending  
  function으로 표시해 blocking을 하지 않고 비동기적으로 처리할 수 있다.

```kt
suspend fun simple(): List<Int> {
	delay(1000)
	return listOf(1, 2, 3)
}

func main() = runBlocking<Unit> {
	simple().forEach { println(it) }
}
```

- 위 코드는 1초 후 모든 원소들을 출력한다.

### Flows

- 위에서 본 `simple()`은 반환형이 `List<Int>`인데, 이는 곧 모든 값들을 한 번에 반환해야 함을 의미한다.  
  비동기적으로 계산되는 값들의 _stream_ 을 나타내기 위해서는 `Flow<Int>` 타입을 사용할 수 있다.

```kt
fun simple(): Flow<Int> = flow {
	for (i in 1..3) {
		delay(100)
		emit(i) // emit next value
	}
}

func main() = runBlocking<Unit> {
	launch {
		for (k in 1..3) {
			println("I'm not blocked $k")
			delay(100)
		}
	}
	simple().collect { println(it) }
}

/*
I'm not blocked 1
1
I'm not blocked 2
2
I'm not blocked 3
3
*/
```

- 위 코드는 각 숫자를 출력하기 전 main thread를 blocking하지 않고 100ms 씩 기다린다.  
  "I'm not blocked"가 100ms 씩 출력되는 것으로 이를 알 수 있다.

- `Flow`를 사용한 이 코드에서 다른 코드의 차이점을 보자.

  - 우선 `Flow`를 사용하기 위한 builder function은 `flow { .. }`이다.
  - `flow { .. }` 안의 코드는 suspendable하다.
  - `simple()` 함수는 더 이상 suspend 키워드가 적용되어 있지 않다.
  - 값들은 `emit()`을 통해 flow로부터 _emit_ 된다.
  - 값들은 `collect()`를 통해 flow로부터 _collect_ 된다.

> `flow { .. }` 내의 `delay()`를 `Thread.sleep()`으로 바꾸면 main thread가 block된다.

---

## Flows are cold

- `Flows`는 `Sequence`와 비슷하게 _cold_ 한데, 즉 `flow { .. }` builder 내의 코드는 flow가 _collect_ 되기 전까지 실행되지 않는다.

```kt
fun simple(): Flow<Int> = flow {
    println("Flow started")
    for (i in 1..3) {
        delay(100)
        emit(i)
    }
}

fun main() = runBlocking<Unit> {
    println("calling simple()..")
    val flow = simple()
    println("calling simple().collect()..")
    flow.collect { println(it) }
    println("calling collect() again..")
    flow.collect { println(it) }
}

/*
calling simple()..
calling simple().collect()..
Flow started
1
2
3
calling collect() again..
Flow started
1
2
3
*/
```

- 여기서 왜 `simple()`이 suspend 키워드가 없어도 되는지 알 수 있다. `simple()`은 재빠르게 return하고 아무런 것도 기다리지 않는다.  
  flow는 _collect_ 될 때마다 시작된다. 위 코드에서 `collect()`가 호출되었을 때 "Flow started"가 출력된 것을 볼 수 있다.

---

## Flow cancellation basics

- `Flow`는 일반적인 coroutine의 cancellation과 비슷하게 동작한다. 마찬가지로 flow _collection_ 은 flow가 `delay()`와 같은  
  cancellable suspending function에 의해 suspend 되었을 때 cancel될 수 있다.

- 아래 예시 코드는 `withTimeoutOrNull { .. }` 블록 내에서 어떻게 flow가 cancel 되는지 보여준다.

```kt
fun simple(): Flow<Int> = flow {
    for (i in 1..3) {
        delay(100)
        println("Emitting $i")
        emit(i)
    }
}

fun main() = runBlocking<Unit> {
    withTimeoutOrNull(250) {
        simple().collect { println(it) }
    }
    println("Done")
}

/*
Emitting 1
1
Emitting 2
2
Done
*/
```

## Flow builders

- 이전에 코드에서 본 `flow { .. }` builder는 기본적인 flow builder이다.  
  Flow의 사용을 위한 다른 builder들도 있는데, 아래와 같다.

  - `flowOf { .. }` builder는 고정된 값들을 반환하는 flow를 정의한다.
  - 다양한 컬렉션과 `Sequence`는 `asFlow()` 함수를 통해 `Flow`로 변환될 수 있다.

```kt
(1..3).asFlow().collect { println(it) }
```

---

## Intermediate flow operators

- `Flow`에는 컬렉션과 `Sequence`에 대해서와 마찬가지로 다양한 연산을 진행할 수 있다. 중간 연산들이 upstream flow에 적용된 후  
  downstream flow를 반환한다. 호출하는 연산 함수들 자체는 suspending function이 아니다. 이 함수들은 `Flow`와 마찬가지로  
  _cold_ 한데, 즉 필요할 때까지 연산을 수행하지 않는다는 것이다.

- 기본적인 중간 연산들은 `map()`, `filter()`와 같이 친숙한 이름을 갖고 있다.  
  `Sequence`와의 중요한 차이점 중 하나는 `Filter.map{ .. }` 블록 내에서는 suspending function을 호출할 수 있다는 점이다.

- 예를 들어 수신되는 요청들의 flow는 아무리 연산이 오래 걸리는 suspending function으로 값을 구하더라도 `map()`으로  
  결과값을 받아올 수 있다. 아래 코드를 보자.

```kt
suspend fun performRequest(request: Int): String {
	delay(1000)
	return "response $request"
}

fun main() = runBlocking<Unit> {
	(1..3).asFlow()
		.map { request -> performRequest(request) }
		.collect { response -> println(response) }
}

/*
response 1
response 2
response 3
*/
```

- 위 코드는 1초씩 하나의 결과를 출력한다.

### Transform Operator

- Flow transformation operator들 중, 가장 일반적인 것은 `transform()`이다. 이 함수를 사용해 `map()`, `filter()`등과 같은  
  간단한 변환 연산을 흉내낼 수도 있고, 더 복잡한 연산도 수행할 수 있다. `transform()`을 사용하면 값들에 대해 여러 가지의 연산을 수행할 수 있다.

- 예를 들어, 아래 코드에서는 `transform()`을 사용해 오래 걸리는 작업(`performRequest()`)을 하기 전에 하나의 문자열을 emit 한다.

```kt
(1..3).asFlow()
	.transform { request ->
		emit("Making request $request")
		emit(performRequest(request))
	}
	.collect { response -> println(response) }

/*
Making request 1
response 1
Making request 2
response 2
Making request 3
response 3
*/
```

### Size-limiting operators

- `take()`와 같이 size를 제한하는 intermediate operator들은 지정된 size 제한만큼 결과를 얻어내면 flow의 연산을 중지한다.  
  Coroutine의 cancellation은 항상 예외를 던지는 것으로 이뤄지기에, `try { .. } finally { .. }` 등과 같이 리소스를 관리하는  
  블록이나 함수들도 cancellation에 대해 정상적으로 작동한다.

```kt
fun numbers(): Flow<Int> = flow {
	try {
		emit(1)
		emit(2)
		println("This line will not execute")
	} finally {
		println("Finally in numbers")
	}
}

fun main() = runBlocking<Unit> {
	number()
		.take(2)
		.collect { value -> println(value) }
}

/*
1
2
Finally in numbers
*/
```

---

## Terminal flow operators

- `Flow`에 대한 terminal operator들은 `Flow`에 대해 컬렉션을 만들어내는 suspending function이다.  
  `collect()` 연산자는 이 중 가장 기본적인 것이지만, 더 많은 다른 terminal operator들도 있다.

  - `toList()`, `toSet()` 등과 같이 다양한 컬렉션으로 변환할 수 있다.
  - `first()`로 첫 번째 값을 가져오거나, `single()`을 통해 flow가 하나의 값만 emit하는지 확인할 수 있다.
  - `reduce()`와 `fold()`를 사용해 `Flow`를 하나의 값으로 reducing할 수 있다.

```kt
val sum = (1..5).asFlow()
	.map { it * it }
	.reduce { a, b -> a + b }
println(sum)  // 55
```

---
