# 구조화된 API 구축: DSL에서 수신 객체 지정 DSL 사용

## 수신 객체 지정 람다와 확장 함수 타입

- 이전에 `buildString()`, `with()`, `apply()` 표준 라이브러리 함수를 보면서 수신 객체 지정 람다에 대해 간략히 보았다.  
  이제 `buildString()` 함수를 통해 코틀린이 수신 객체 지정 람다를 어떻게 구현하는지 살펴보자.  
  `buildString()`을 사용하면 한 `StringBuilder` 객체에 여러 내용을 추가할 수 있다.

- 우선 먼저 일반 람다를 받는 `buildString()` 함수를 정의해보자.

```kt
fun buildString(builderAction: (StringBuilder) -> Unit): String {
	val sb = StringBuilder()
	builderAction(sb)
	return sb.toString()
}


// client
val s = buildString {
	it.append("Hello, ")
	it.append("World!")
}
```

- 위 코드는 이해하기 쉽다. 하지만 사용하기에는 람다 본문에서 매번 it을 사용해 `StringBuilder` 인스턴스를 참조해야 하기에 편하지는 않다.  
  람다의 목적은 `StringBuilder`를 텍스트로 채우는 것이므로 `it.append()` 처럼 메소드명 앞에 `it.`을 일일이 넣지 않고, 메소드명으로만  
  호출하기를 바란다.

- 이런 일을 가능하게끔 하려면 **수신 객체 지정 람다(lambda with a receiver)** 로 바꿔야 한다.  
  람다의 인자 중 하나에게 수신 객체라는 상태를 부여하면, 이름과 마침표를 명시하지 않아도 그 인자의 멤버를 바로 사용할 수 있다.

```kt
fun buildString(builderAction: StringBuilder.() -> Unit): String {
	val sb = StringBuilder()
	builderAction(sb)
	return sb.toString()
}


// client
val s = buildString {
	append("Hello, ")
	append("World!")
}
```

- 이전에 본 `buildString()`의 구현과 위에서 본 구현의 차이점을 보자.  
  이제는 `buildString()`에게 수신 객체 지정 람다를 인자로 넘기기 때문에 람다 내에서 it을 사용하지 않아도 된다.  
  `it.append()` 대신 `append()`를 사용한다.

- 다음으로 `buildString()` 함수의 선언이 어떻게 달라졌는지 보자. 위 코드에서는 파라미터 타입을 선언할 때 일반 함수 타입 대신  
  **확장 함수 타입(extension function type)** 을 사용했다. 확장 함수 타입 선언은 람다의 파라미터 목록에 있던 수신 객체 타입을  
  파라미터 목록을 여는 괄호 앞으로 빼내면서 중간에 `.`를 붙인 것이다. 이전에는 `(StringBuilder) -> Unit`이었지만, 위에서는  
  `StringBuilder.() -> Unit`으로 바뀌었다. 여기서 앞에 오는 타입인 `StringBuilder`를 수신 객체 타입이라 부르며, 람다에 전달되는  
  그런 타입의 객체를 수신 객체라고 부른다.

- 왜 확장 함수 타입일까? 외부 타입의 멤버를 아무런 수식자 없이 사용한다는 말을 들으면 확장 함수라는 단어가 떠오를 것이다.  
  확장 함수의 본문에서는 확장 대상 클래스에 정의된 메소드를 마치 그 클래스 내부에서 호출하듯이 사용할 수 있었다.  
  확장 함수나 수신 객체 지정 람다에서는 모두 함수(람다)를 호출할 때 수신 객체를 지정해야만 하고, 함수(람다) 본문 안에서는 그  
  수신 객체를 특별한 수식자 없이 사용할 수 있었다. 일반 람다를 사용할 때는 `StringBuilder`의 인스턴스를 `builderAction(sb)` 구문을  
  사용해 전달하지만, 수신 객체 지정 람다를 사용할 때는 `sb.builderAction()`으로 전달한다. 다시 말해 `sb.builderAction()`에서  
  `builderAction`은 `StringBuilder` 클래스 안에 정의가 있는 함수가 아니며, `StringBuilder` 인스턴스인 sb는 확장 함수를  
  호출할 때와 동일한 구문으로 호출할 수 있는 함수 타입의 인자일 뿐이다.

- 아래 코드처럼 확장 함수 타입의 변수를 정의할 수도 있다. 정의한 확장 함수 타입 변수를 마치 확장 함수처럼 호출하거나 수신 객체 지정 람다를  
  요구하는 함수에게 인자로 넘길 수 있다.

```kt
val appendExcl: StringBuilder.() -> Unit = { this.append("!") }

val stringBuilder = StringBuilder("HI")
stringBuilder.appendExcl()
println(stringBuilder) // HI!
```

- 소스코드 상에서 수신 객체 지정 람다가 일반 람다와 똑같아 보인다는 점을 유의하자. 람다에 수신 객체가 있는지 알아보려면 그 람다가 전달되는 함수를  
  살펴봐야 한다. 함수 시그니처를 보면 람다에 수신 객체가 있는지와 람다가 어떤 타입의 수신 객체를 요구하는지를 알 수 있다.  
  예를 들어 `buildString()`의 선언을 보면 그 함수가 `StringBuilder.() -> Unit` 타입의 람다를 파라미터로 받는다는 사실을 알 수 있으므로,  
  람다의 본문에서 `StringBuilder`의 멤버를 특별한 수식자 없이 사용할 수 있다는 것을 알 수 있다.

- 표준 라이브러리의 `buildString()` 구현은 위 코드보다 더 짧다. `builderAction()`을 명시적으로 호출하는 대신, 이를 `apply()` 함수에게  
  인자로 넘긴다. 이렇게 하면 아래처럼 `buildString()`을 단 한줄로 구현할 수 있다.

```kt
fun buildString(builderAction: StringBuilder.() -> Unit): String = StringBuilder().apply(builderAction).toString()
```

- `apply()`는 인자로 받은 람다나 함수를 호출하면서 자신의 수신 객체를 람다나 함수의 묵시적 수신 객체로 사용한다.

```kt
inline fun <T> T.apply(block: T.() -> Unit): T {
	block()
	return this
}

inline fun <T, R> with(receiver: T, block: T.() -> R): R {
	receiver.block()
}
```

- 기본적으로 `apply()`와 `with()`는 모두 자신이 제공받은 수신 객체로 확장 함수 타입의 람다를 호출한다.  
  `apply()`는 수신 객체 타입에 대한 확장 함수로 선언됐기에 수신 객체의 메소드처럼 불리며, 수신 객체를 묵시적 인자(this)로 받는다.  
  반면 `with()`는 수신 객체를 첫 번째 파라미터로 받는다. 또한 `apply()`는 수신 객체를 다시 반환하지만, `with()`는 람다를 호출해  
  얻은 결과를 반환한다.

```kt
val map = mutableMapOf(1 to "one")
map.apply { this[2] = "two" }
with(map) { this[3] = "three" }
println(map) // {1=one, 2=two, 3=three}
```

---

## 수신 객체 지정 람다를 HTML builder 안에서 사용

- HTML을 만들기 위한 코틀린 DSL을 보통은 HTML Builder라 한다. HTML Builder는 더 넓은 범위의 type-safe builder의 대표적인 예시다.  
  Builder를 사용하면 객체의 계층 구조를 선언적으로 정의할 수 있다.

- 코틀린도 마찬가지의 개념을 채택하지만, 코틀린 builder는 타입 안전성을 보장한다. 따라서 코틀린 builder는 사용하기 편리하면서 안전하므로  
  어떤 면에서는 Groovy의 builder보다 더 매력적이다. 코틀린 HTML Builder가 어떻게 동작하는지 자세히 보자.

```kt
fun createSimpleTable() = createHTML().
	table {
		tr {
			td { +"cell" }
		}
	}
```

- 위 코드는 일반 코틀린 코드이지, 특별한 템플릿 언어 같은 것이 아니다. `table()`, `tr()`, `td()` 등은 모두 평범함 함수다.  
  각 함수는 고차 함수로 수신 객체 지정 람다를 인자로 받는다.

- 여기서 관심 가질만한 것은 각 수신 객체 지정 람다가 이름 결정 규칙을 바꾼다는 것이다. `table()` 함수에 넘겨진 람다에서는  
  `tr()` 함수를 사용해 `<tr>` HTML tag를 만들 수 있다. 하지만 그 람다 밖에서는 `tr()`이라는 함수를 찾을 수 없다.  
  마찬가지로 `td()` 함수도 `tr()` 내에서만 접근 가능한 함수다.

- 각 블록의 네이밍 규칙은 각 람다의 수신 객체에 의해 결정된다. `table()`에 전달된 수신 객체는 `TABLE`이라는 특별한 타입이며,  
  그 안에 `tr()` 메소드의 정의가 있다. 마찬가지로 `tr()`은 `TR` 객체에 대한 확장 함수 타입의 람다를 받는다.

```kt
open class Tag

class TABLE : Tag {
	fun tr(init: TR.() -> Unit)
}

class TR: Tag {
	fun td(init: TD.() -> Unit)
}

class TD : Tag
```

- `TABLE`, `TR`, `TD` 모두 HTML 생성 코드에 나타나면 안되는 유틸리티 클래스이다. 그래서 이름을 모두 대문자로 만들어서 일반 클래스와 구분한다.  
  이들은 모두 `Tag`를 확장한다. 각 클래스에는 자신의 내부에 들어갈 수 있는 태그를 생성하는 메소드가 들어있다.  
  예를 들어 `TABLE` 클래스 내에는 `tr()` 메소드가 있다.

- `tr()`와 `td()`의 init 파라미터의 타입을 살펴보자. 이들의 타입인 `TR.() -> Unit`과 `TD.() -> Unit`은 모두 확장 함수 타입이다.  
  이런 확장 함수 타입은 각 메소드에 전달할 람다의 수신 객체 타입을 순서대로 `TR`과 `TD`로 지정한다.

- 여기서 어떤 일이 벌어지는지 더 분명히 보기 위해 모든 수신 객체를 명시하면서 위의 코드를 다시 짜보자.

```kt
fun createSimpleTable() = createHTML().
	table {
		(this@table).tr {
			(this@tr).td {
				+"cell"
			}
		}
	}
```

- Builder에 수신 객체 지정 람다가 아닌 다른 일반 람다를 사용하면, HTML 생성 코드 구문이 알아볼 수 없을 정도로 난잡해질 것이다.  
  태그 생성 메소드를 호출할 때 it을 붙이거나 it이라는 이름이 싫다면 람다 내에서 적절히 파라미터명을 정의해야 한다.  
  수신 객체를 묵시적으로 정하고 this 참조를 쓰지 않아도 되면 builder 문법이 간단해지고 전체적인 구문이 원래의 HTML 구문과 비슷해진다.

- 위 코드처럼 수신 객체 지정 람다가 다른 수신 객체 지정 람다 안에 들어가면 내부 람다에서 외부 람다에 정의된 수신 객체를 사용할 수 있다.  
  예를 들어 `td()` 함수의 인자인 람다 안에서는 세 가지 수신 객체(`this@table`, `this@tr`, `this@td`)를 사용할 수 있다.

> 코틀린 1.1부터는 `@DslMarker` 어노테이션을 사용해 중첩된 람다 안에서 외부 람다의 수신 객체를 접근하지 못하게 제한할 수 있다.

- 이제 원하는 HTML을 HTML Builder가 어떻게 생성하는지 살펴보자.

- 아주 간략한 버전의 HTML Builder library를 구현해보자. `TABLE`, `TR`, `TD` 선언을 확장해 결과 HTML을 생성하는 기능을 추가할 것이다.  
  이런 간략한 버전의 출발점인 최상위 `table()` 함수는 `<table>` 태그가 최상위에 있는 HTML 조각을 만들어낸다.

```kt
fun createTable() = table {
	tr {
		td {

		}
	}
}

println(createTable()) // <table><tr><td></td></tr></table>
```

- `table()`은 `TABLE`의 새로운 인스턴스를 만들고 그 인스턴스를 초기화고 반환한다.

```kt
fun table(init: TABLE.() -> Unit) = TABLE().apply(init)
```

- `createTable()`에서 `table()`에 전달된 람다에는 `tr()` 함수의 호출이 들어있다. 이 `table()` 호출에서 모든 부분을 명시하면  
  `table(init = {this.tr { }})`이다. `tr()` 함수는 마치 `TABLE().tr { ... }`라고 쓴 것처럼 `TABLE` 인스턴스를  
  수신 객체로 호출한다.

- 이 간단한 예시에서 `<table>`은 최상위 태그이며, 다른 모든 태그들은 `<table>` 안에 들어간다. 각 태그에는 자식들에 대한 참조를  
  저장하는 리스트가 들어있다. 따라서 `tr()` 함수는 `TR` 인스턴스를 새로 만들고 바깥 클래스의 자식 리스트에 그 새로 만든 `TR` 인스턴스를  
  추가해야만 한다.

```kt
fun tr(init: TR.() -> Unit) {
	val tr = TR()
	tr.init()
	children.add(tr)
}
```

- 이런 식으로 주어진 태그를 초기화(init)하고 바깥쪽 태그의 자식으로 추가하는 로직을 거의 모든 태그가 공유한다.  
  따라서 이런 기능을 상위 클래스인 `Tag`로 뽑아내서 `doInit()`이라는 멤버로 만들 수 있다. `doInit()`은 자식 태그들에 대한 참조를  
  저장하는 일과 인자로 전달받은 람다를 호출하는 일을 책임진다. 여러 태그는 그냥 `doInit()`을 호출하면 된다.  
  예를 들어 `tr()`은 `TR` 클래스의 인스턴스를 새로 하나 만들어서 `doInit(TR(), init)`과 같은 방식으로 인스턴스와 초기화 람다를  
  `doInit()`에게 넘긴다.

```kt
open class Tag(val name: String) {
	private val children = mutableListOf<Tag>()
	protected fun <T: Tag> doInit(child: T, init: T.() -> Unit) {
		child.init()
		children.add(child)
	}

	override fun toString() = "<$name>${children.joinToString("")}</$name>"
}

fun table(init: TABLE.() -> Unit) = TABLE().apply(init)

class TABLE: Tag("table") {
	fun tr(init: TR.() -> Unit) = doInit(TR(), init)
}

class TR : Tag("tr") {
	fun td(init: TD.() -> Unit) = doInit(TD(), init)
}

class TD : Tag("td")

fun createTable() = table {
	tr {
		td {

		}
	}
}

println(createTable()) // <table><tr><td></td></tr></table>
```

- 태그 생성 함수가 자신이 새로 생성한 태그를 부모 태그가 가진 자식 목록에 추가한다는 점에 유의하자.  
  따라서 아래처럼 태그를 동적으로 만들 수도 있다.

```kt
fun createAnotherTable() = table {
	for(i in 1..2) {
		tr {
			td {

			}
		}
	}
}


println(createAnotherTable()) // <table><tr><td></td></tr><tr><td></td></tr></table>
```

---
