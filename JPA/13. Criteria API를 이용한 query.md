<h1>Criteria API를 이용한 query</h1>

<h2>Criteria API</h2>

* JPQL이 문자열을 이용하여 작성하는 query라면, Criteria API는 Java 코드를 이용해서 작성하는 query 이다. 아래 코드는 `CriteriaQuery`를   
  이용하여 query를 작성한 예시이다.
```java
CriteriaBuilder builder = entityManager.getCriteriaBuilder();
CriteriaQuery<User> query = builder.createQuery(User.class);

Root<User> root = query.from(User.class);
query.select(root);
query.where(builder.equal(root.get("name"), "이름"));

TypedQuery<User> typedQuery = entityManager.createQuery(query);
List<User> users = typedQuery.getResultList();
```

* 위 코드는 `SELECT u FROM User u WHERE u.name = '이름'`에 해당하는 query를 생성하는 criteria 코드이다.
* Criteria를 이용해서 query를 작성하는 것은 복잡하지만, 다양한 조건을 조합하기 쉽고, java code를 사용하기에 타입에 안전한 query를   
  만들 수 있다는 장점 때문에 사용한다.
<hr/>

<h2>Criteria 기본 코드</h2>

* Criteria 코드의 기본 구조는 아래와 같다.
```java
// (1) EntityManager에서 CriteriaBuilder 객체 구하기
CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();

// (2) CriteriaQuery 객체 생성, 결과 타입으로 User 사용
CriteriaQuery<User> criteriaQuery = criteriaBuilder.createQuery(User.class);

// (3) SQL문 : "FROM User u"
Root<User> root = criteriaQuery.from(User.class);

// (4) SQL문 : "SELECT u FROM User u"
criteriaQuery.select(root);

// (5) CriteriaQuery로부터 Query 생성
TypedQuery<User> query = entityManager.createQuery(criteriaQuery);
```

* Criteria를 사용할 때는 먼저 `EntityManager#getCriteriaBuilder()`로 `CriteriaBuilder`객체를 구한다. 이 객체는 `CriteriaQuery`를   
  생성할 때 사용된다.

* `CriteriaBuilder#createQuery()` 메소드로 `CriteriaQuery`객체를 생성한다. 이 메소드의 인자로는 조회 결과 타입을 지정한다.

* `javax.persistence.criteria.CriteriaQuery`는 `from()`, `select()`, `where()` 등 query를 구성하기 위한 메소드를 제공한다.   
  이들은 각각 JPQL의 FROM, SELECT, WHERE절에 대응한다.

* `from()` 메소드는 JPQL의 FROM절에 대응하는 메소드로, 검색 대상이 되는 entity의 타입을 인자로 받는다.   
  `javax.persistence.criteria.Root`는 `from()`으로 선택한 Entity 대상이다. 위 코드에서 root는 `User` Entity를 의미하는 `Root`가 된다.

* `CriteriaQuery#select()` 메소드는 SELECT결과로 선택할 대상을 지정한다. `from()`에서 지정한 Entity를 SELECT의 결과로 사용하려면   
  `from()`으로 구한 `Root`객체를 `select()`메소드에 전달한다.

* 원하는 대로 `CriteriaQuery`를 구성했다면, `EntityManager#createQuery(CriteriaQuery)`메소드를 이용해서 `TypedQuery`객체를 생성하고   
  실행하면 된다.
<hr/>

<h2>검색 조건 지정</h2>

* Criteria로 검색 조건을 지정하는 코드의 기본 구조는 아래와 같다.
```java
CriteriaBuilder builder = entityManager.getCriteriaBuilder();

CriteriaQuery<User> criteriaQuery = builder.createQuery(User.class);
Root<User> root = criteriaQuery.from(User.class);
criteriaQuery.select(root);

Predicate namePredicate = builder.equal(root.get("name"), "이름");
criteriaQuery.where(namePredicate);

TypedQuery<User> query = entityManager.createQuery(criteriaQuery);
```

* `CriteriaBuilder`는 `Predicate` 객체를 생성하는 메소드를 제공한다. `CriteriaBuilder#equal()`메소드는 값이 같은지를 비교하는   
  `Predicate` 객체를 생성한다. `equal()` 메소드의 첫 번째 파라미터는 비교할 대상이며, 두 번째 파라미터는 비교할 값이다.

* 위 코드는 SQL문에 `WHERE root.name = "이름"` 조건을 추가한다.

* 생성된 `Predicate`객체를 `CriteriaQuery#where()`에 전달하면 query에 조건을 적용한다.
<hr/>

<h2>속성 경로 구하기</h2>

* 앞서 예로 든 코드를 다시 보자.
```java
Root<User> root = criteriaQuery.from(User.class);
criteriaQuery.select(root);
Predicate namePredicate = builder.equal(root.get("name"), "이름");
```

* 위 코드에서 `root.get("name")`은 `User` Entity의 name 속성에 해당하는 `Path` 객체를 구한다. `Root#get()`메소드는 아래와 같다.
```java
<Y> Path<Y> get(String attributeName);
```

* `javax.persistence.criteria.Path` 인터페이스는 Entity나 Value, Collection등의 속성의 경로를 표현한다.
```java
public interface Path<X> extends Expression<X> {..}
```
  * 타입 파라미터 `X`는 `Path`가 나타내는 대상 속성의 타입이다. `User` Entity의 name 속성은 `String`이므로 아래와 같이 속성 타입을   
    지정해서 `Path`를 구할 수 있다.
  ```java
  Path<String> name = root.get("name");
  ```

* 아래 코드에서 `root.get("name")`은 `Path<Object>` 타입이 된다.
```java
Predicate namePredicate = builder.equal(root.get("name"), "이름");
```
  * `Path<String>`이 아닌 `Path<Object>`가 되는 이유는 `CriteriaBuilder#equal()`메소드는 `Path<?>` 타입을 인자로 받기에 타입을   
    추론할 수 없기 때문이다. 위 코드에서 `Path<Object>` 대신 `Path<String>`을 생성하려면 아래와 같이 타입 파라미터를 알맞게 지정한다.
  ```java
  Predicate namePredicate = builder.equal(root.<String>get("name"), "이름");
  ```

* `Root#get()`으로 `Path`를 구할 때 보통은 타입 파라미터를 알맞게 지정하지 않아도 동작에 문제는 없다. 타입 파라미터를 일일이 지정하면   
  코드가 복잡해지므로 `Root#get(String)` 메소드를 실행할 때 필요한 경우에만 타입 파라미터를 지정하면 된다.

* 이름 대신에 정적 메타모델을 사용해서 속성을 지정할 수도 있다. 정적 메타모델은 Entity의 속성에 대한 메타 정보를 담고 있는 클래스로서   
  아래와 같이 생겼다.
```java
@StaticMetamodel(User.class)
public class User_ {

    public static SingularAttribute<User, String> email;
    public static SingularAttribute<User, String> name;
}
```

* `User_` 클래스를 보면 `@StaticMetamodel`의 값으로 `User`클래스를 주었는데, 이는 `User_` 클래스가 `User` Entity에 대한 메타 정보를   
  담고 있는 정적 메타모델이라고 설정한다. name 필드는 정적 필드이고. 타입으로는 `SingularAttribute<User, String>`을 사용한다.   
  이는 name 필드가 `User` Entity의 `String` 타입 속성인 name에 대응함을 의미한다.

* 이 정적 메타모델을 사용하면 속성 경로를 구할 때 문자열 대신 정적 메타모델의 필드를 사용할 수 있다.
```java
Predicate namePredicate = builder.equal(root.get(User_.name), "이름");
```

* `User_.name`은 이미 속성이 `String` 타입이라는 정보를 담고 있기 때문에, `Root#get()`은 `Path<String>`을 반환한다.

* 정적 메타모델을 사용하면 타입이나 이름 오류 없이 알맞은 `Path` 타입을 구할 수 있기에 컴파일 시점에 안전한 코드를 작성할 수 있다는   
  장점이 있다.

<h3>중첩 속성 경로 구하기</h3>

* 아래 매핑 설정을 보자.
```java
@Entity
@Table(name = "user_best_sight")
public class UserBestSight {

    @OneToOne
    @PrimaryKeyColumn
    private User user;
}
```

* `UserBestSight`는 `User`와 1:1 연관을 맺는다. 연관된 `User` Entity의 name 속성을 검색 조건으로 사용해서 `UserBestSight`를 검색하고   
  싶다면, 중첩해서 속성을 구하면 된다. 아래는 속성 경로를 중첩해서 사용한 예시이다.
```java
Root<UserBestSight> root = criteriaQuery.from(UserBestSight.class);
Predicate namePredicate = builder.equal(root.get("user").get("name"), "이름")ㅣ
criteriaQuery.where(namePredicate);
```

* `root.get()` 메소드는 `Path`객체를 반환하는데, 이 `Path`객체는 경로를 구할 수 있는 `get()` 메소드를 제공한다. 실제로 `Root`   
  인터페이스는 `Path` 인터페이스를 상속하고 있으며, `Root#get()`은 `Path`에 정의되어 있는 메소드이다.

* 위 코드에서 `root.get("user")`는 user 속성으로 연관된 `User` Entity에 대한 `Path`객체를 반환하므로,   
  `root.get("user").get("name")`코드는 `User` Entity의 name 속성에 해당하는 `Path` 객체를 반환한다. 따라서 이 코드는 아래의 JPQL   
  query를 수행한다.
```sql
SELECT ub FROM UserBestSight ub WHERE ub.user.name = '이름';
```

* 중첩 속성은 연관된 Entity 뿐만 아니라 Value 객체에도 동일하게 적용할 수 있다.
<hr/>

<h2>CriteriaQuery와 CriteriaBuilder의 구분</h2>

* `CriteriaQuery`와 `CriteriaBuilder`를 각각 언제 사용하는지 구분하는 방법은 아래와 같다.
  * `CriteriaQuery` : SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY 등의 query의 절 생성
  * `CriteriaBuilder` : 각 절의 구성 요소 생성

* 추가적인 예시로, 정렬 순서를 표현하는 `Order` 구성 요소를 생성할 때에도 `CriteriaBuilder`를 사용한다.
```java
Order teamOrder = criteriaBuilder.asc(player.get("team").get("id"));
Order nameOrder = criteriaBuilder.desc(player.get("name"));

criteriaQuery.orderBy(teamOrder, nameOrder);
```
<hr/>

<h2>Expression과 하위 타입</h2>

* Criteria API의 상속 구조는 다음과 같다.(숫자가 낮을 수록 상위, 모두 Interface이다.)
  * (1) : `Selection`
  * (2) : `Expression`
  * (3-1) : `Path`, (3-2) : `Predicate`
  * (4-1) : `From`
  * (5-1-1) : `Root`, (5-1-2) : `Join`

* 각 타입은 아래와 같다.
  * `Root` : FROM 절의 대상을 표현한다.
  * `Join` : JOIN 대상을 표현한다.
  * `From` : `Root`와 `Join`의 공통 기능을 정의한다. JOIN과 관련된 기능을 정의한다.
  * `Path` : 경로를 표현한다. 속성이나 Entity 등을 표현하며 경로를 구할 수 있는 기능을 제공한다.
  * `Predicate` : `Expression<Boolean>`으로서 비교 연산자를 포함한다. 주로 검색 조건을 지정할 때 사용된다.
  * `Expression` : 값을 표현한다. 경로(`Path`)나 선택 대상(`Root`, `Join`)은, 조건(`Predicate`)는 자신만의 타입이 있지만,   
    집합 함수, 문자열 함수와 같은 함수는 `Expression`을 사용해서 표현한다.
  * `Selection` : SELECT 대상을 표현한다.

* `CriteriaQuery`나 `CriteriaBuilder`의 많은 메소드가 `Expression` 타입의 파라미터를 갖는데, `Path`, `Root`, `Join`, `Predicate`   
  등이 모두 `Expression`의 하위 타입에 속한다. 따라서 `Expression`이 올 수 있는 곳에는 이들 타입을 알맞게 사용할 수 있다. 예를 들어,   
  두 값이 같은지를 비교하는 `Predicate`를 생성할 때 사용하는 `CriteriaBuilder#equal()` 메소드의 첫 번째 파라미터는 `Expression`인데,   
  다음과 같이 `Root#get()`으로 구한 `Path`를 `Expression` 타입 파라미터에 전달할 수 있다.
```java
Predicate namePredicate = criteriaBuilder.equal(root.get("name"), "홍길동");
```
<hr/>