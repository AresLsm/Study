# Channels

- Deffered된 값들은 coroutine 사이에서 하나의 값을 주고받을 수 있는 편리한 방법을 제공한다.  
  **Channel**은 값들의 stream을 coroutine 사이에서 주고받을 수 있게 해준다.

## Channel basics

- `Channel`은 개념적으로 `BlockingQueue`와 매우 유사하다. 이 둘의 가장 중요한 차이점 중 하나는 `BlockingQueue`는 `put()` 연산을  
  blocking하는 반면 `Channel`은 `send()`라는 suspending operation이 있다. 또한 `BlockingQueue`처럼 `take()` 연산을  
  blocking하는 대신 `Channel`은 `receive()`라는 suspending operation이 있다.

```kt
fun main() = runBlocking {
	val channel = Channel<Int>()
	launch {
		for(x in 1..5) channel.send(x * x)
	}
	repeat(5) { println(channel.receive()) }
	println("Done")
}

/*
1
4
9
16
25
Done
*/
```

---

## Closing and iteration over channels

- Queue와 달리 `Channel`은 더 이상 새로운 값이 오지 않는 다는 것을 표현하기 위해 _close_ 될 수 있다.  
  값을 빼가는(receive) 쪽에서 일반적인 for loop을 사용해 channel에서 원소들을 하나씩 꺼내올 수 있다.

- 개념적으로 `close()`는 channel에 channel을 close하기 위한 특별한 token을 보내는 것과 유사하다.  
  순회는 close token이 receive되는 순간 종료된다. 따라서 channel이 close되기 전에 있던 모든 원소들이 모두 receive 됨이 보장된다.

```kt
fun main() = runBlocking {
	val channel = Channel<Int>()
	launch {
		for(x in 1..5) channel.send(x * x)
		channel.close()
	}
	for (y in channel) println(y)
	println("Done")
}

/*
1
4
9
16
25
Done
*/
```

---

## Building channel producers

- Coroutine이 일련의 원소들을 생성(produce)하는 패턴은 매우 흔하다. 이는 동시성을 활용하는 코드의 _producer-consumer pattern_ 의  
  일부이다. 이러한 패턴에서 produce하는 작업을 channel을 파라미터로 받는 함수를 만들어 추상화할 수 있지만, 결과는 함수로부터 반환되어야  
  한다는 일반적인 프로그래밍 관점에서 벗어나게 된다.

- `produce()`라는 coroutine builder를 사용하면 값들을 channel에 쉽게 produce할 수 있게 하고, consumer 쪽에서는  
  `consumeEach()`를 사용해 channel의 값들을 하나씩 꺼내와 각각에 대한 작업을 할 수 있다.

```kt
fun CoroutineScope.produceSquares(): ReceiveChannel<Int> = produce {
	for (x in 1..5) send(x * x)
}

fun main() = runBlocking {
	val squares = produceSquares()
	squares.consumeEach { println(it) }
	println("Done!")
}

/*
1
4
9
16
25
Done!
*/
```

---
