<h1>테스트 코드와 유지보수</h1>

<h2>테스트 코드와 유지 보수</h2>

* 빠른 서비스 출시를 위해 CI(Continuous Integration, 지속적 통합)와 CD(Continuous Deplyoument, 지속적 배포)를 도입하는 곳이   
  증가하고 있다. 지속적으로 코드를 통합하고 출시 가능한 상태로 만들고 배포하려면 새로 추가한 코드가 기존 기능을 망가뜨리지 않는지   
  확인할 수 있어야 하며 이런 이유로 자동화 테스트는 CI/CD의 필수 요건 중 하나이다. TDD를 하는 과정에서 작성한 테스트 코드는   
  CI/CD에서 자동화 테스트로 사용되어 버그가 배포되는 것을 막아주고 이는 소프트웨어 품질이 저하되는 것을 방지한다.

* 테스트 코드는 그 자체로 코드이기 때문에 제품 코드와 동일하게 유지보수의 대상이 된다.   
  테스트 코드를 유지보수하는데 시간이 많이 들기 시작하면 점점 테스트 코드를 손보지 않아 실패하는 테스트가 많아지게 된다.   
  깨지는 테스트를 방치하는 상황이 길어지면 다음과 같은 문제가 발생할 수 있다.
  * 실패한 테스트가 새로 발생해도 무감각해진다. 테스트 실패 여부와 관계없이 빌드하고 배포하기 시작한다.
  * 빌드를 통과시키기 위해 실패한 테스트를 주석 처리하고 실패한 테스트는 고치지 않는다.

* 이런 상황이 발생하면 테스트 코드는 가치를 잃기 시작한다. 테스트 코드는 코드를 변경했을 때 기존 기능이 올바르게 작동하는지를   
  확인하는 회귀 테스트(Regression Test)를 자동화하는 수단으로 사용되는데, 깨진 테스트를 방치하기 시작하면 테스트가 검증하는   
  범위가 줄어든다. 이는 코드에 버그가 발생했을 때 이를 놓칠 가능성이 커지는 것을 의미한다.

* 실패한 테스트를 통과시키기 위해 많은 노력이 필요하면 점점 테스트 코드에서 멀어지고 TDD에서도 멀어진다. 테스트 코드를   
  만들지 않으면, 테스트가 가능하지 않은 코드를 만들게 되고, 이는 다시 테스트 코드 작성을 어렵게 만든다.   
  테스트 코드가 줄어들면 수동으로 테스트해야 하는 범위가 증가한다. 수동 테스트는 자동화된 테스트에 비해 오랜 시간이 걸리고   
  다룰 수 있는 범위도 제한되므로 기존 코드에 문제가 있어도 놓칠 가능성이 커지게 된다.

* 이런 악순환이 발생하지 않으려면 테스트 코드 자체의 유지보수성이 좋아야 한다. 테스트 코드를 유지보수하기 좋아야 지속적으로   
  테스트를 작성하게 되고, 결과적으로 소프트웨어의 품질이 떨어지는 것도 막을 수 있다.

* 유지보수하기 좋은 코드를 만들기 위해 필요한 좋은 패턴과 원칙이 존재하는 것처럼 좋은 테스트 코드를 만들려면 주의해야하는   
  몇 가지 사항이 있다.
<hr/>

<h2>1. 변수나 필드를 사용해서 기댓값 표현하지 않기</h2>

* 아래 코드는 단언의 기대하는 값을 변수를 이용해서 구성하고 있다.
```java
@Test
void dateFormat() {
    LocalDate date = LocalDate.of(2020, 1, 1);
    String dateStr = formatDate(date);
    assertEquals(date.getYear() + "년 " + date.getMonthValue() + "월 " + date.getDayOfMonth() + "일", dateStr);
}
```

* 위 코드는 date 변수를 단언에서 사용하고 있다. 이 단언은 논리적으로는 맞지만, 문자열 연결이 있어 코드가 복잡하다.   
  또한 올바르지 않은 메소드를 실수로 사용했을 경우 테스트가 깨지게 된다.
```java
@Test
void dateFormat() {
    LocalDate date = LocalDate.of(2020, 1, 1);
    String dateStr = formatDate(date);
    assertEquals("2020년 1월 1일", dateStr);
}
```

* 위 코드는 복잡하지 않고 기대하는 값도 명확하게 표현하고 있다. 변수를 사용할 때 처럼 메소드를 잘못 사용할 일도 없다.

* 아래의 코드는 기대하는 값을 기술할 때 로컬 변수와 필드를 사용하고 있다.
```java
private List<Integer> answers = Arrays.asList(1, 2, 3, 4);
private Long respondentId = 100L;

@Test
void saveAnswerSuccesfully() {

    // 답변할 설문이 존재한다.
    Survey survey = SurveyFactory.createApprovedSurvey(1L);
    surveyRepository.save(survey);

    // 설문 답변
    SurveyAnswerRequest surveyAnswer = SurveyAnswerRequest.builder()
        .surveyId(survey.getId())
        .respondentId(respondentId)
        .answers(answers).build();
    
    svc.answerSurvey(surveyAnswer);

    // 저장 결과 확인
    SurveyAnswer savedAnswer = memoryRepository.findBySurveyAndRespondent(survey.getId(), respondentId);
    assertAll(
        () -> assertEquals(respondnetId, savedAnswer.getRespondentId()),
        () -> assertEquals(answers.size(), savedAnswer.getAnswers().size()),
        () -> assertEquals(answers.get(0), savedAnswer.getAnswers().get(0)),
        () -> assertEquals(answers.get(1), savedAnswer.getAnswers().get(1)),
        () -> assertEquals(answers.get(2), savedAnswer.getAnswers().get(2)),
        () -> assertEquals(answers.get(2), savedAnswer.getAnswers().get(3))
    );
}
```

* 만약 테스트에 실패했다면 `assertAll()`의 마지막 실행 함수에서 실패했을 것이다. 만약 NPE가 발생했다면 survey 변수와   
  respondentId의 값도 확인해야 한다.

* 또한 이 테스트 코드를 처음 보는 사람은 각 변수의 의미를 이해하기 위해 코드를 헤집어 봐야 한다.   
  위 테스트 코드는 또한 단언에 변수와 필드를 사용했는데, 아래와 같이 바꿔보자.
```java
@Test
void saveAnswerSuccesfully() {

    // 답변할 설문이 존재한다.
    Survey survey = SurveyFactory.createApprovedSurvey(1L);
    surveyRepository.save(survey);

    // 설문 답변
    SurveyAnswerRequest surveyAnswer = SurveyAnswerRequest.builder()
        .surveyId(1L)
        .respondentId(100L)
        .answers(Arrays.asList(1, 2, 3, 4)).build();
    
    svc.answerSurvey(surveyAnswer);

    // 저장 결과 확인
    SurveyAnswer savedAnswer = memoryRepository.findBySurveyAndRespondent(1L, 100L);
    assertAll(
        () -> assertEquals(100L, savedAnswer.getRespondentId()),
        () -> assertEquals(4, savedAnswer.getAnswers().size()),
        () -> assertEquals(1, savedAnswer.getAnswers().get(0)),
        () -> assertEquals(2, savedAnswer.getAnswers().get(1)),
        () -> assertEquals(3, savedAnswer.getAnswers().get(2)),
        () -> assertEquals(4, savedAnswer.getAnswers().get(3))
    );
}
```

* 위와 같이 비교하면 코드 가독성이 좋아져서 테스트 코드를 더욱 쉽게 파악할 수 있다.   
  또한 객체를 생성할 때 사용한 값이 무엇인지 알아보기 위해 필드와 변수를 참조하지 않아도 된다.   
  마찬가지로 단언할 때 사용한 값이 무엇인지 알기위해 필드와 변수를 오갈 필요도 없다.
<hr/>

<h2>두 개 이상을 검증하지 않기</h2>

* 처음 테스트 코드를 작성하면 한 테스트 메소드에서 가능한 많은 단언을 하려고 시도한다.
```java
@Test
void registerAndSendEmail() {

    userRegister.register("id", "pw", "email");

    // 검증1 : 회원 데이터가 올바르게 저장되었는지 검증
    User savedUser = fakeRepository.findById("id");
    assertEquals("id", savedUser.getId());
    assertEquals("email", savedUser.getEmail());

    // 검증2 : 이메일 발송을 요청했는지 검증
    ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
    BBDMockito.then(mockEmailNotifier).should().sendRegisterEmail(captor.capture());
    assertEquals("email", captor.getValue());
}
```

* 위 테스트 메소드는 두 가지를 검증한다. 만약 첫 번째 검증이 실패하면 테스트는 거기서 멈춘다.   
  즉, 첫 번째 단언이 성공해야 비로소 두 번째 검증을 시도할 기회가 생기는 것이다. 이렇게 하면 테스트 결과를 확인할 때 까지   
  집중도가 떨어진다. 

* 한 테스트 메소드에서 서로 다른 내용을 검증한다면 각 검증 대상을 별도로 분리해서 테스트의 집중도를 높일 수 있다.
<hr/>

<h2>정확하게 일치하는 값으로 모의 객체 생성하지 않기</h2>

* 아래 코드는 모의 객체를 이용해서 "pw"" 문자열은 약한 암호로 처리하라고 지정하고 있다.
```java
@Test
void weakPassword() {

    BDDMockito.given(mockPasswordChecker.checkPasswordWeak("pw")).willReturn(true);

    assertThrows(WeakPasswordException.class,
        () -> userRegister.register("id", "pw", "email")
    );
}
```

* 위 테스트는 작은 변화에도 실패한다. 예를 들어 비밀번호를 "pw" 대신 "pwa"를 사용하면 실패할 것이다.   
  위 코드는 약한 암호인 경우 `UserRegister`가 원하는대로 작동하는지를 확인함이 위함이지, "pw"나 "pwa"가 약한 암호인지를   
  확인하는 테스트 코드가 아니다. 즉, 모의 객체는 "pw"가 아니라 임의의 문자열에 대해 true를 반환해도 이 테스트의 의도에   
  전혀 문제가 되지 않는다. 따라서 위 코드는 아래와 같이 수정할 수 있다.
```java
@Test
void weakPassword() {

    BDDMockito.given(mockPasswordChecker.checkPasswordWeak(Mockito.anyString())).willReturn(true);

    assertThrows(WeakPasswordException.class,
        () -> userRegister.register("id", "pw", "email")
    );
}
```

* 위 코드는 모의 객체가 임의의 String 값에 대해 true를 반환하도록 `Mockito.anyString()`을 인자로 전달했다.   
  따라서 이제는 어떤 문자열을 전달해도 약함 암호인 경우에 대한 테스트를 올바르게 수행할 수 있다.

* 모의 객체를 호출했는지의 여부를 확인하는 경우도 동일하다. 아래 코드처럼 특정 값을 사용해서 호출 여부를 결정할 경우,   
  `register()` 메소드를 호출할 때 전달한 파라미터 값이 조금만 바뀌어도 테스트가 깨지면 된다.
```java
@Test
void checkPassword() {
    userRegister.register("id", "pw", "email");

    BBDMockito.then(mockPasswordChecker).should().checkPasswordWeak("pw");
}
```

* 모의 객체는 가능한 범용적인 값을 사용해서 기술해야 한다. 한정된 값에 일치하도록 모의 객체를 사용하면 약간의 코드 수정만으로도   
  테스트는 실패하게 된다. 이 경우 테스트 코드의 일부 값을 수정하면 모의 객체 관련 코드도 함께 수정하는 번거로움이 생긴다.

* 테스트의 의도를 해치지 않는 범위에서 "pw"와 같은 특정한 값 보다는 `Mockito.anyString()`과 같은 범용적인 값을 사용해야 한다.   
  이렇게 해야 약간의 코드 수정 때문에 테스트가 실패하는 것을 방지할 수 있다. 또한 테스트 코드를 수정할 때 모의 객체 관련 코드를   
  함께 수정해야하는 빈도도 줄어든다.
<hr/>

<h2>과도하게 구현 검증하지 않기</h2>

* 테스트 코드를 작성할 때 주의점은 테스트 대상의 내부 구현을 검증하는 것이다.   
  모의 객체를 처음 사용할 때 특히 이런 유혹에 빠지기 쉽다. 모의 객체를 이용해서 내부 구현을 검증하는 코드를 많이 작성하면   
  테스트 코드의 유지보수에 도움이 되지 않는다.
```java
@Test
void checkPassword() {
    userRegister.register("id", "pw", "email");

    // PasswordChecker#checkPasswordWeak() 메소드 호출 여부 검사
    BBDMockito.then(mockPasswordChecker).should().checkPasswordWeak(Mockito.anyString());

    // UserRepository#findById() 메소드를 호출하지 않는 것을 검사
    BBDMockito.then(mockRepository).should(Mockito.never()).findById(Mockito.anyString());
}
```

* 위 코드는 `UserRegister#register()` 메소드가 `PasswordChecker#checkWeakPassword()`를 호출하는지 검증한다.   
  또한 `UserRepository#findById()`를 호출하지 않는지도 검증한다. `register()` 메소드가 내부적으로 어떤 메소드를 호출하고   
  어떤 메소드를 호출하지 않는지를 확인하는 것은 결국 `register()`의 내부 구현을 검증하는 것이다.

* 내부 구현을 검증하는 것은 나쁜 것은 아니지만, 한 가지 단점이 있다. 그것은 바로 구현을 조금만 변경해도 테스트가 깨질 가능성이   
  커진다는 것이다. 예를 들어 중복 ID가 존재하는지 먼저 확인하고, 그 다음에 비밀번호가 약한지를 검사하도록 `register()`의 구현을   
  변경했다면 위 테스트는 실패하게 된다. 왜냐면 중복ID를 검증하는 과정에서 `findById()`를 호출하기 때문이다.

* 내부 구현은 언제든지 바뀔 수 있기 때문에 테스트 코드는 내부 구현보다 실행 결과를 검증해야 한다. 위 코드의 경우에는 `register()`가   
  `PasswordChecker#checkPasswordWeak()`를 호출하는지보다 약한 암호일 때 `register()`의 결과가 올바른지 검증해야 한다.   
  그렇게 함으로써 내부 구현을 일부 바꿔도 테스트가 실패하지 않게 유지할 수 있다.

* 이미 존재하는 코드에 단위 테스트를 추가하면 어쩔 수 없이 내부 구현을 검증해야 할 때도 있다. 예를 들어 아래의 legacy code가 있다고 하자.
```java
public void changeEmail(String id, String email) {
    int cnt = userDao.countById(id);
    if(cnt == 0) throw new NoUserException();
    userDao.updateEmail(id, email);
}
```

* Legacy Code에서 DAO는 다양한 update, select 메소드를 정의하고 있는 경우가 많기 때문에 메모리를 이용한 가짜 구현으로 대체하기가 쉽지 않다.   
  그래서 legacy code에 대한 테스트 코드를 작성할 때는 모의 객체를 많이 활용한다. 위 코드에 대한 테스트 코드를 보자.
```java
@Test
void changeEmailSuccess() {
    given(mockDao.countById(Mockito.anyString())).willReturn(1);

    emailService.changeEmail("id", "new@new.com");

    then(mockDao).should().updateEmail(Mockito.anyString(), Mockito.matches("new@new.com"));
}
```

* 위 코드는 이메일을 수정했는지 확인하기 위해 모의 객체의 `updateEmail()` 메소드가 호출되었는지를 확인한다.   
  모의 객체를 호출하는지 여부를 확인하는 것은 구현을 검증하는 것이지만 이메일이 변경되었는지 확인할 수 있는 수단은 이뿐이다.

* 기능이 정상적으로 동작하는지 확인할 수단이 구현 검증밖에 없다면 모의 객체를 사용해서 테스트 코드를 작성해야 하지만, 일단 테스트 코드를   
  작성한 뒤에는 점진적으로 코드를 리팩토링해서 구현이 아닌 결과를 검증할 수 있도록 시도해야 한다. 그렇게 함으로써 향후에 사소한   
  구현 변경으로 인해 테스트가 깨지는 것을 방지할 수 있고 또한 코드의 테스트 가능성도 높일 수 있다.
<hr/>

