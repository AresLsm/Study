# TMP

<h2>Session, Cookie의 차이점과 활용</h2>

<h3>Cookie</h3>

- `Cookie`는 최대 4KB의 작은 파일로, 웹 서버가 클라이언트의 컴퓨터에 저장하는 것이다.  
  Cookie가 클라이언트의 컴퓨터에 세팅되면, 이후 모든 요청은 Cookie의 name, value를 반환한다.  
  Cookie는 오로지 생성된 도메인에서만 활용될 수 있다. 예를 들어, `a.example.com`에서 생신 Cookie는  
  `b.example.domain`에서는 읽을 수 없다.

- 많은 웹 사이트는 광고 등의 컨텐츠를 페이지에 함께 포함시킨다.  
  이때, 이 광고를 제공하는 도메인의 Cookie 또한 클라이언트의 컴퓨터에 저장될 수 있는데,  
  이를 Third Party Cookie라 한다. Cookie는 특정 사용자에 한정되게 사용되며, 다른 사용자는  
  다른 사용자의 Cookie를 볼 수 없다.

<h3>Session</h3>

- Session은 서버에 저장되는 전역 변수이다. 각 Session에는 고유 ID가 부여되고, 이 ID를 통해  
  Session에 저장된 값들을 읽어올 수 있다. Session이 생성될 때, 생성된 Session의 고유 ID를  
  가지고 있는 cookie가 클라이언트의 컴퓨터에 저장된다. 만약 클라이언트의 브라우저가 cookie를  
  지원하지 않는다면, Session의 고유 ID는 URL에 나타난다.

- Session은 Cookie에 비해 더 큰 양의 데이터를 저장할 수 있다.

- Session에 저장되어 있는 값들은 브라우저가 닫히면 자동으로 삭제된다.  
  따라서 세션에 있는 값들을 항상 유지하고 싶다면 데이터베이스 같은 저장소를 활용해야 한다.

<h3>Session, Cookie 사용 예제</h3>

- Http는 무상태 프로토콜(Stateless Protocol)이기에 Cookie를 활용하면 클라이언트의 컴퓨터에 작은 파일을  
  저장함으로써 애플리케이션의 상태를 추적할 수 있다. Cookie가 저장되는 위치는 브라우저에 따라 다르다.  
  Cookie는 주로 UX의 최적화를 위해 사용되는데, 사용자는 자신이 선호하는 것들을 클릭하고,  
  그 정보들이 Cookie에 저장됨으로서 개인 맞춤화를 제공할 수 있다.

- Session은 사용자의 고유 ID 등의 중요한 정보를 안전하게 관리하기 위해 사용된다.  
  서버 자체에 저장되니 외부로서의 접근을 막기 용이하다.  
  또한 Session을 이용하면 한 페이지에서 다른 페이지로 정보를 전달할 수 있다.  
  Cookie를 지원하지 않는 브라우저에 대해 Cookie를 대체하기 위해 사용되는 경우도 있다.

<hr/>

<h2>DI는 왜 필요할까?</h2>

- 의존성 주입을 사용하면 해당 클래스에 의존하는 클래스가 주입되는 클래스와 독립적이게 된다.  
  객체지향의 5대 원칙인 SOLID 원칙의 핵심은 코드의 재사용성을 높이는 것인데,  
  DI를 사용하면 객체간의 결합을 느슨하게 할 수 있기에 재사용성을 높일 수 있다.  
  또한 객체들의 책임을 분리할 수 있어서 단일 책임 원칙(SRP)를 따를 수 있게 된다.

- 클래스 A가 클래스 B의 기능을 사용해야 한다고 하자. 이때, B의 인터페이스를 만들어서 A에는  
  B의 인터페이스만 준다면, A와 B는 각각 B의 인스턴스에만 의존성을 가질 뿐, 더 이상의 깊은  
  의존성을 가지지 않는다. 이렇게 하여 느슨한 결합을 갖출 수 있다. A가 B의 인터페이스만  
  가지고 있다면, A가 인스턴스화될 때 B도 인스턴스화를 하여 A가 B를 사용하도록 한다.

- DI의 목적은 클래스간의 직접적인 의존성을 사용하는 부분과 객체를 생성하는 부분을 분리하여  
  없애는 것이다.

- DI에는 크게 4개의 클래스들이 있다.

  - 사용할 Service
  - Service를 사용할 Client
  - Client가 사용하며, Service가 구현하는 Interface
  - 실제 구현된 Service 인스턴스를 client에게 주입하는 Injector

- 만약 위 4개 중 interface를 없애고 구현체를 Client에게 넘긴다면 이는 의존성 역전 원칙을 깨며,  
  client가 service 구현체에 직접적인 의존성을 가지게 된다.

<h2>의존성 역전은 왜 필요할까?</h2>

- 객체 간의 의존성은 **하위 수준의 클래스** 가 **상위 수준의 클래스** 에 의존하도록 해야한다.  
  만약 **상위 수준의 클래스** 가 **하위 수준의 클래스** 에 의존하게 된다면, 상위 수준의 클래스를  
  재사용할 때 하위 수준의 클래스도 필요하기에 재사용하기가 어려워진다. 또한 이러한 상황에서는  
  하위 수준의 클래스가 변경되면, 상위 수준의 클래스 또한 변경된다.

- 이러한 상황에서 **추상화** 를 사용하여 두 클래스 사이에 추상화된 클래스를 두고,  
  상위 수준의 클래스는 추상화된 클래스에 의존하고, 하위 수준의 클래스는 추상화된 클래스를 구현한다고 하자.  
  이렇게 되면 하위 수준의 클래스의 변경으로 인해 상위 수준의 클래스가 영향 받는 것을 방지할 수 있고  
  상위 수준의 클래스를 재사용할 때 하위 수준의 클래스에 얽매이지 않고 다양한 컨텍스트에서 재사용할 수 있다.  
  즉 가장 중요한 것은 **두 클래스 사이의 추상화** 이다.

<h2>서비스 추상화는 왜 할까?</h2>

- DI의 4개 클래스 설명 + 의존성 역전과 중복

<h2>OOP에서의 객체의 책임, 역할, 협력 및 객체 간의 메시지가 무엇일까</h2>

- 책임: 역할의 묶음
- 역할: 해당 객체가 책임지고 수행해야할 행위 (동작)
- 협력: 객체지향 프로그램은 자율적인 객체들의 공동체이며, 이 객체들의 **협력** 을 통해 기능을 구현한다.  
  객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단이 **메시지 전송** 이다.  
  객체는 다른 객체의 상세한 내부 구현에 직접 접근할 수 없기에 오직 메시지 전송을 통해서만  
  자신의 요청을 전달할 수 있다. 메시지를 수신한 객체는 **메소드를 실행** 하여 요청에 응답한다.
- 객체 간의 메시지: 객체 사이의 협력을 위한 유일한 커뮤니케이션 수단

<h2>layered architecture는 왜 필요할까</h2>

<h2>Shell Script의 return vs 다른 언어의 return</h2>

<h2>JPA N + 1 문제 및 해결법</h2>

<h2>HTTP Header vs Body</h2>

- 메타데이터 또는 전체 애플리케이션에서 동일하게 사용될 수 있는 정보를 Header에 넣자.  
  예를 들어, JWT Token같이 전체 애플리케이션에서 사용되는 것이 있고, `Content-Type`과 같은  
  메타 데이터가 있을 것이다.

- 반면, Body는 특정 API에 정보 전달이 필요할 때 사용하자.

<h2>단방향 vs 양방향 데이터 바인딩</h2>

<h2>Promise가 무엇이며 비동기 처리는 어떻게 할까?</h2>

<h2>ES6의 주요 기능</h2>
