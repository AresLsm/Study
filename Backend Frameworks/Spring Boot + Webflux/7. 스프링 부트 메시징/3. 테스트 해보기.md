# 테스트 해보기

## 테스트 컨테이너 사용 테스트

- 이제 테스트 컨테이너를 사용할 준비를 마쳤다.  
  이제 테스트 대상 시스템에 어떤 동작을 테스트할지 먼저 정해보자.  
  지금까지 비동기 메시징 솔루션에 대해 이야기했는데, 웹 컨트롤러에서  
  새로운 `Item`객체의 생성 요청을 받아 RabbitMQ를 통해 메시지로  
  전달하는 과정을 구현해보자. 메시지를 받아서 MongoDB에 저장하는  
  서비스도 함께 구현할 것이다.

- 메시지를 매개체로 사용하는 이 단순한 개념은 여러 방식으로 응용해서 얼마든지 재사용할 수 있다.  
  예를 들어, 웹 컨트롤러 대신 다른 것으로 대체할 수도 있다. 그렇게 해도 메시지는  
  RabbitMQ를 통해 전송된다. 또는 메시지를 전송하는 API를 직접 호출하게 할 수도 있다.

- 일단 처음에 시도하려 했던 것부터 해보자. 동기적인 웹 요청을 받아서 비동기 메시지로 바꾸는  
  웹 컨트롤러를 만들어봊. 이번에는 테스트를 먼저 작성하는 방식으로 진행해보자.

```kt
@SpringBootTest // (1)
@AutoConfigureWebTestClient // (2)
@Testcontainers // (3)
@ContextConfiguration // (4)
class RabbitMQTest {

    companion object {
        @Container
        val container = RabbitMQContainer("rabbitmq:3.7.25-management-alpine") // (5)

        @DynamicPropertySource // (6)
        fun configure(registry: DynamicPropertyRegistry) {
            registry.add("spring.rabbitmq.host", container::getContainerIpAddress)
            registry.add("spring.rabbitmq.port", container::getAmqpPort)
        }
    }

    @Autowired
    private lateinit var webTestClient: WebTestClient

    @Autowired
    private lateinit var repository: ItemRepository
}
```

- 위 코드에 대한 설명은 아래와 같다.

  - (1) `@SpringBootTest`는 자동설정, 환경설정 값 읽기, 내장 웹 컨테이너 등 테스트를 위한  
    애플리케이션 구동에 필요한 모든 것을 활성화한다. 기본적으로 실제 운영환경이 아니라 실제 운영환경을  
    mocking한 환경을 사용한다.

  - (2) `@AutoConfigureWebTestClient`를 적용해서 테스트용으로 사용하는 webClient인  
    `WebTestClient`를 자동설정한다.

  - (3) `@TestContainer`는 JUnit5에서 제공하는 어노테이션으로, 테스트컨테이너를 테스트에  
    사용할 수 있게 해준다.

  - (4) `@ContextConfiguration`은 지정한 클래스를 테스트 실행 전에 먼저 Application Context에  
    로딩해준다.

  - (5) 테스트에 사용할 `RabbitMQContainer`를 생성한다. `RabbitMQContainer`는 테스트에 사용할  
    RabbitMQ 인스턴스를 관리한다.

  - (6) `@DynamicPropertySource`는 Java8의 함수형 인터페이스인 `Supplier`를 사용해서  
    환경 설정 내용을 `Environment`에 동적으로 추가한다. `container::getContainerIpAddress`와  
    `container::getAmqpPort` 메소드 핸들을 사용해서 테스트컨테이너에서 실행한 RabbitMQ 브로커의  
    호스트명과 포트 번호를 가져온다. 이렇게 하면 RabbitMQ 연결 세부 정보를 테스트컨테이너에서 읽어와서  
    Spring AMQP에서 사용할 수 있도록 스프링 부트 환경설정 정보에 저장한다.

- 테스트를 작성하기 전에 먼저 알아야할 것이 있다. 지금까지 Project Reactor를 사용하는  
  테스트에서는 `StepVerifier`를 사용해서 비동기 처리 흐름을 쉽게 테스트할 수 있었고,  
  지연 효과를 흉내낼 수도 있었다. 하지만 RabbitMQ를 사용하는 테스트에서는 `RabbitVerifier`같은  
  것이 없어서 `Thread.sleep()`을 사용해야 한다.

- 그런데 이번에는 테스트를 작성하기 전에 어떤 스프링 프로젝트를 사용해야 되는지 아무런 언급이  
  없었다는 것이 이상하지 않은가? 왜냐하면 아직 테스트 대상조차 없는 상태에서 테스트를 먼저 작성하는  
  test-first 전략을 사용하기 때문이다.

<hr/>

## 테스트 케이스 구성

- 웹 컨트롤러의 초안을 만들기 전에, 웹 컨트롤러가 처리해야할 일을 먼저 나열해보자.

  - (1) 새 `Item` 객체를 생성하기 위해 `Item` 데이터가 담겨있는 HTTP POST 요청을 받는다.
  - (2) `Item` 데이터를 적절한 메시지로 변환한다.
  - (3) `Item` 생성 메시지를 브로커에게 전송한다.

- 메시지를 받는 역할을 하는 브로커가 해야할 일은 아래와 같다.

  - (1) 새 메시지를 받을 준비를 하고 기다린다.
  - (2) 새 메시지가 들어오면 꺼내서,
  - (3) MongoDB에 저장한다.

- 잊지말아야 할 것은 개발자가 직접 하든, 프레임워크에게 위임하든 **구독을 해야 동작**한다는 점이다.  
  이제 실제 테스트 케이스를 작성해보자. 물론 실제 테스트 대상이 구현되지 않은 상태이므로  
  당장은 실패한다.

```kt
@SpringBootTest
@AutoConfigureWebTestClient
@Testcontainers
@ContextConfiguration
class RabbitMQTest {

    // 설정들

    @Test
    @Throws(InterruptedException::class)
    fun verifyMessagingThroughAmqp() {
        webTestClient.post().uri("/items") // (1)
            .bodyValue(Item("Alf alarm clock", "nothing important", 19.99))
            .exchange()
            .expectStatus().isCreated
            .expectBody()

        Thread.sleep(1500L) // (2)

        webTestClient.post().uri("/items") // (3)
            .bodyValue(Item("Smurf TV tray", "nothing important", 29.99))
            .exchange()
            .expectStatus().isCreated
            .expectBody()

        Thread.sleep(2000L) // (4)

        repository.findAll() // (5)
            .`as`(StepVerifier::create)
            .expectNextMatches { item ->
                assertEquals("Alf alarm clock", item.name)
                assertEquals("nothing important", item.description)
                assertEquals(19.99, item.price)
                true
            }
            .expectNextMatches { item ->
                assertEquals("Smurf TV tray", item.name)
                assertEquals("nothing important", item.description)
                assertEquals(29.99, item.price)
                true
            }
            .verifyComplete()
    }
}
```

- 테스트 코드가 하는 일은 각각 아래와 같다.

  - (1) 새 `Item` 데이터를 `/items`에 POST로 요청한다. 요청에 대한 응답으로 HTTP_CREATED_201이  
    반환되는 것을 확인한다.

  - (2) 1500ms 동안 `sleep()` 처리해서 해당 메시지가 브로커를 거쳐 데이터 저장소에 저장될 때까지  
    기다린다. 이렇게 해서 테스트에 사용되는 메시지의 처리 순서를 맞출 수 있다.

  - (3) 두 번째 `Item` 데이터를 보내고, HTTP_CREATED_201이 반환되는 것을 확인한다.

  - (4) 두 번째 메시지가 처리될 수 있도록 2000ms 동안 `sleep()` 한다.

  - (5) `ItemRepository`를 사용해서 MongoDB에 쿼리를 날려서 2개의 `Item`객체가 저장된 것을 확인한다.

- 먼저 알아둘 것은 이 테스트가 **실제 RabbitMQ 브로커를 대상으로 수행된다**는 점이다.  
  아직 `Item` 데이터를 받아서 메시지로 변환하고 브로커에 보내서 MongoDB에 저장하는 로직이  
  구현돼있지 않으므로 테스트를 실행하면 물론 실패한다. 이제부터 이 로직을 구현해서 테스트를  
  통과시켜보자.

- 앞서 스프링의 역사를 살펴볼 때, 스프링은 Java의 복잡도를 낮추는 것을 목표로 한다고 했다.  
  Spring AMQP는 널리 사용되는 메시징 프로토콜인 AMQP를 스프링 방식으로 사용할 수 있게 해준다.

```gradle
//..

dependencies{

    //..
    implementation("org.springframework.boot:spring-boot-starter-amqp")
}
```

- 위 의존성을 추가하고, 이제 POST 요청을 리액티브 방식으로 처리할 수 있는 Spring Webflux  
  REST 컨트롤러를 작성해보자.

```kt
package com.sangwoo.commerce.controller

import com.sangwoo.commerce.domain.Item
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.amqp.core.AmqpTemplate
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RestController
import reactor.core.publisher.Mono
import reactor.core.scheduler.Schedulers
import java.net.URI

@RestController
class SpringAmqpItemController(private val template: AmqpTemplate) { // (1)

    companion object {
        private val log: Logger = LoggerFactory.getLogger(SpringAmqpItemController::class.java)
    }

    @PostMapping("/items")
    fun addNewItemUsingSpringAmqp(@RequestBody item: Mono<Item>): Mono<ResponseEntity<*>> {
        return item
            .subscribeOn(Schedulers.boundedElastic()) // (2)
            .flatMap { content ->
                Mono.fromCallable { // (3)
                    template.convertAndSend("SpringWebflux", "new-items-spring-amqp", content) // (4)
                    ResponseEntity.created(URI.create("/items")).build<Void>() // (5)
                }
            }
    }
}
```

- 위 코드에 대한 설명은 아래와 같다.

  - (1) `spring-boot-starter-amqp`는 Spring AMQP를 classpath에 추가한다. 그래서  
    Spring Boot 자동설정을 통해 `AmqpTemplate`을 테스트에 사용할 수 있다. RabbitMQ를  
    사용하므로 실제 구현체로는 `RabbitTemplate`이 사용된다. 생성자를 통해 `AmqpTemplate`을  
    주입받아서 메시지를 전송할 때 사용한다.

  - (2) `AmqpTemplate`은 블로킹 API를 호출하므로 `subscribeOn()`을 통해  
    **Bounded Elastic Scheduler**에서 관리하는 별도의 스레드에서 실행되게 만든다.

  - (3) 람다식을 사용해서 `AmqpTemplate`의 호출을 `Callable`로 감싸고, `Mono.fromCallable()`을  
    사용해 `Mono`를 생성한다.

  - (4) `AmqpTemplate`의 `convertAndSend()`를 호출하여 `Item` 데이터를  
    new-items-spring-amqp라는 Routing Key와 함께 SpringWebflux exchange로 전송한다.

  - (5) 새로 생성되어 추가된 `Item` 객체에 대한 URI를 location 헤더에 담아 HTTP_201_CREATED  
    상태코드와 함께 반환한다.

- RabbitMQ는 블로킹 API를 호출한다. RabbitMQ는 비동기 메시징 시스템이긴 하지만, 많은  
  RabbitMQ API는 작업 수행 중 현재 스레드를 블록한다. 이 미묘한 차이를 이해하는 것이 중요하다.  
  결국에는 비동기 처리 과정으로 되돌아가더라도 어떤 API가 현재 스레드를 블로킹한다면 블로킹 API다.

- 위 예제 코드에서는 긴 시간동안 블로킹하지 않으므로 큰 문제가 되지 않을 것 같지만,  
  이런 블로킹에 의해 발생하는 지연이 쌓이고 쌓이면, 나중에 무시하지 못할 부담이 될 수 있다.  
  그래서 Project Reactor에서는 이 문제를 해결할 방법을 만들어뒀다.

<hr/>
