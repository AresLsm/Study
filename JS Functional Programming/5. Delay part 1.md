# 지연성 part 1.

<h2>range</h2>

- 숫자 하나를 받고, 그 숫자의 크기만한 배열을 반환하는 `range()` 함수를 만들어보자.

```js
const range = (length) => {
  let i = -1;
  let res = [];
  while (++i < length) {
    res.push(i);
  }
  return res;
};

console.log(range(5)); // [0, 1, 2, 3, 4]
```

- 이제 `range()`로 받은 배열 내의 모든 원소를 더하는 코드를 작성해보자.

```js
const add = (a, b) => a + b;
const list = range(4);
console.log(list); // [0, 1, 2, 3]
console.log(reduce(add, list)); // 6
```

<hr/>

<h2>Lazy range</h2>

- 위의 `range()`와 동일한 작동을 하지만, 조금 다른 방식으로 구현해보자.

```js
const L = {};
L.range = function* (length) {
  let i = -1;
  while (++i < length) {
    yield i;
  }
};

const list = L.range(4);
console.log(list); // L.range {<suspended>}

console.log(reduce(add, list)); // 6
```

- `range()`와 `L.range()`를 호출했을 때의 결과는 동일하다.  
  하지만 이 둘은 차이점이 있는데, list를 찍어보았을 때의 결과가 다르다는 것이다.  
  `L.range()`로 만들어진 list는 iterator를 반환하게 된다.  
  `reduce(add, list)`가 동일한 결과를 나타낸 이유는 `reduce()`가  
  iterable을 받기 때문이다. 즉 `range()`가 반환하는 배열도 iterable이고,  
  `L.range()`가 반환하는 iterator도 iterable이기 때문에 동일한 것이다.

- 좀 더 차이를 근본적으로 알아보자. `range(4)`로 만들어진 list는 `reduce()`에  
  인자로 전달되기 전에 이미 `[0, 1, 2, 3]`의 값을 가지게 된다.  
  반면, `L.range(4)`로 만들어진 list는 `reduce()`에 인자로 전달되기 전에는  
  아직 값이 평가되기 전의 상태이다. 실제로 `L.range()` 함수 몸체의 어디에 로그를 찍어봐도  
  아무런 값도 출력되지 않는다. 실제로 값이 평가되는 시점은 iterator가 내부를 순회할 때 이다.  
  즉, `list.next()`가 호출될 때 값이 1개씩 평가된다는 뜻이다.

- `range()`는 바로 배열을 만들어서 반환하는 반면, `L.range()`는 값이 필요할 때에  
  값을 평가하기 때문에 더 효율적이다. 실제로 이 둘의 효율성이 어떻게 차이가 있는지 보자.

```js
function test(name, time, fn) {
  console.time(name);
  while (time--) fn();
  console.timeEnd(name);
}

test("range", 10, () => reduce(add, range(100000)));
test("L.range", 10, () => reduce(add, L.range(100000)));
```

- 실제로 결과값을 보면 아래와 같다.

```
range: 66.968ms
L.range: 39.169ms
```

<hr/>

<h2>take</h2>

```js
const take = (limit, iterable) => {
  let res = [];
  for (const a of iterable) {
    res.push(a);
    if (res.length === limit) return res;
  }
  return res;
};
```

- 위처럼 `take()`는 2개의 인자를 받고, iterable 인자를 limit 만큼 순회하다가 결과를 반환한다.

```js
console.log(take(5, range(100))); // [0, 1, 2, 3, 4, ...99 ]
console.log(take(5, L.range(100))); // [0, 1, 2, 3, 4, ...99]
```

- `L.lazy()`와 같이 지연성을 가지는 값을 iterator로 만든다면, 다른 함수가 iterable protocol만 따른다면  
  다른 함수에서도 아무런 문제 없이 사용할 수 없다.

- `take(5, range(100))`의 같은 경우, `range(100)`가 값을 이미 평가한 상태에 `take()`의 인자로 전달된다.  
  하지만 `take(5, L.range(100))`의 경우에는 최대 5번의 순회를 할 수 있지만, 순회할 시에 값이 평가되므로  
  훨씬 효율적이다.

<hr/>

<h2>지연 평가</h2>

- 지연 평가의 핵심은 코드를 미리 평가하지 않고, 해당 코드가 평가되어야하는 시점에 가서 평가하는 것이다.
- Generator / Iterator Protocol로 지연 평가를 구현해보자.

<h3>L.map()</h3>

- 기존의 `map()` 메소드를 다시 보자.

```js
const map = = (fn, iterable) => {
  let res = [];
  for(const p of iterable) {
    res.push(fn(p));
  }
  return res;
}
```

- 위 `map()`을 지연성을 가지도록 만들되, Generator / Iterator Protocol을 따르도록 만들어보자.

```js
const L = {};
L.map = function* (fn, iterable) {
  for (const a of iterable) {
    yield fn(a);
  }
};
```

- `L.map()`의 특징은 지연성을 가지기 때문에 값이 미리 평가되어있지 않고, 평가되어야할 시점에 평가가 된다는 점이다.

<h3>L.filter()</h3>

- 마찬가지로 기존의 `filter()` 메소드를 다시 보자.

```js
const filter = (fn, iterable) => {
  let res = [];
  for (const p of iterable) {
    if (fn(p)) res.push(p);
  }
  return res;
};
```

- `L.map()`도 바로 구현해보자.

```js
const L = {};
const L.filter = function* (fn, iterable) {
  for(const a of iterable) {
    if(fn(a)) yield a;
  }
}
```

- 아래는 사용 예시이다.

```js
const it = L.filter((x) => x % 2, [1, 2, 3, 4]);
console.log(it.next()); // { value: 1, done: false }
console.log(it.next()); // { value: 3, done: false }
console.log(it.next()); // { value: undefined, done: true }
```

<hr/>

<h2>range, map, filter, take, reduce 중첩 사용</h2>

- `range()`, `map()`, `filter()`, `take()`, `reduce()`를 다시 한 번 보자.

```js
const curry =
  (fn) =>
  (arg1, ...args) =>
    args.length ? fn(arg1, ...args) : (...args) => fn(arg1, ...args);

const range = (length) => {
  let i = -1;
  let res = [];
  while (++i < length) {
    res.push(i);
  }
  return res;
};

const map = curry((fn, iterable) => {
  let res = [];
  for (const a of iterable) {
    res.push(fn(a));
  }
  return res;
});

const filter = curry((fn, iterable) => {
  let res = [];
  for (const a of iterable) {
    if (fn(a)) res.push(a);
  }
  return res;
});

const take = curry(limit, iterable) => {
  let res = [];
  for(const a of iterable) {
    res.push(a);
    if(res.length === limit) return res;
  }
  return res;
});

const reduce = curry((fn, start, iterable) => {
  if(!iterable) {
    iterable = start[Symbol.iterator]();
    start = iterable.next().value;
  }
  for(const a of iterable) {
    start = fn(start, a);
  }
  return start;
});

const L = {};

const L.range = function* (length) {
  let i = -1;
  while (++i < length) {
    yield i;
  }
}

const L.map = curry(function* (fn, iterable) {
  for(const a of iterable) {
    yield(fn(a));
  }
});

const L.filter = curry(function* (fn, iterable) {
  for(const a of iterable) {
    if(fn(a)) yield(a);
  }
});

```

- 여러 가지 함수를 만들어보자.

```js
const log = console.log;
go(range(10), log); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
go(
  map((n) => n + 10),
  range(10),
  log
); // [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
go(
  map((n) => n + 10),
  filter((n) => n % 2),
  log
); // [11, 13, 15, 17, 19]
go(
  map((n) => n + 10),
  filter((n) => n % 2),
  take(2),
  log
); // [11, 13]
```
