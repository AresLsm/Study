# 구조화된 API 구축: DSL에서 수신 객체 지정 DSL 사용

## 수신 객체 지정 람다와 확장 함수 타입

- 이전에 `buildString()`, `with()`, `apply()` 표준 라이브러리 함수를 보면서 수신 객체 지정 람다에 대해 간략히 보았다.  
  이제 `buildString()` 함수를 통해 코틀린이 수신 객체 지정 람다를 어떻게 구현하는지 살펴보자.  
  `buildString()`을 사용하면 한 `StringBuilder` 객체에 여러 내용을 추가할 수 있다.

- 우선 먼저 일반 람다를 받는 `buildString()` 함수를 정의해보자.

```kt
fun buildString(builderAction: (StringBuilder) -> Unit): String {
	val sb = StringBuilder()
	builderAction(sb)
	return sb.toString()
}


// client
val s = buildString {
	it.append("Hello, ")
	it.append("World!")
}
```

- 위 코드는 이해하기 쉽다. 하지만 사용하기에는 람다 본문에서 매번 it을 사용해 `StringBuilder` 인스턴스를 참조해야 하기에 편하지는 않다.  
  람다의 목적은 `StringBuilder`를 텍스트로 채우는 것이므로 `it.append()` 처럼 메소드명 앞에 `it.`을 일일이 넣지 않고, 메소드명으로만  
  호출하기를 바란다.

- 이런 일을 가능하게끔 하려면 **수신 객체 지정 람다(lambda with a receiver)** 로 바꿔야 한다.  
  람다의 인자 중 하나에게 수신 객체라는 상태를 부여하면, 이름과 마침표를 명시하지 않아도 그 인자의 멤버를 바로 사용할 수 있다.

```kt
fun buildString(builderAction: StringBuilder.() -> Unit): String {
	val sb = StringBuilder()
	builderAction(sb)
	return sb.toString()
}


// client
val s = buildString {
	append("Hello, ")
	append("World!")
}
```

- 이전에 본 `buildString()`의 구현과 위에서 본 구현의 차이점을 보자.  
  이제는 `buildString()`에게 수신 객체 지정 람다를 인자로 넘기기 때문에 람다 내에서 it을 사용하지 않아도 된다.  
  `it.append()` 대신 `append()`를 사용한다.

- 다음으로 `buildString()` 함수의 선언이 어떻게 달라졌는지 보자. 위 코드에서는 파라미터 타입을 선언할 때 일반 함수 타입 대신  
  **확장 함수 타입(extension function type)** 을 사용했다. 확장 함수 타입 선언은 람다의 파라미터 목록에 있던 수신 객체 타입을  
  파라미터 목록을 여는 괄호 앞으로 빼내면서 중간에 `.`를 붙인 것이다. 이전에는 `(StringBuilder) -> Unit`이었지만, 위에서는  
  `StringBuilder.() -> Unit`으로 바뀌었다. 여기서 앞에 오는 타입인 `StringBuilder`를 수신 객체 타입이라 부르며, 람다에 전달되는  
  그런 타입의 객체를 수신 객체라고 부른다.

- 왜 확장 함수 타입일까? 외부 타입의 멤버를 아무런 수식자 없이 사용한다는 말을 들으면 확장 함수라는 단어가 떠오를 것이다.  
  확장 함수의 본문에서는 확장 대상 클래스에 정의된 메소드를 마치 그 클래스 내부에서 호출하듯이 사용할 수 있었다.  
  확장 함수나 수신 객체 지정 람다에서는 모두 함수(람다)를 호출할 때 수신 객체를 지정해야만 하고, 함수(람다) 본문 안에서는 그  
  수신 객체를 특별한 수식자 없이 사용할 수 있었다. 일반 람다를 사용할 때는 `StringBuilder`의 인스턴스를 `builderAction(sb)` 구문을  
  사용해 전달하지만, 수신 객체 지정 람다를 사용할 때는 `sb.builderAction()`으로 전달한다. 다시 말해 `sb.builderAction()`에서  
  `builderAction`은 `StringBuilder` 클래스 안에 정의가 있는 함수가 아니며, `StringBuilder` 인스턴스인 sb는 확장 함수를  
  호출할 때와 동일한 구문으로 호출할 수 있는 함수 타입의 인자일 뿐이다.

- 아래 코드처럼 확장 함수 타입의 변수를 정의할 수도 있다. 정의한 확장 함수 타입 변수를 마치 확장 함수처럼 호출하거나 수신 객체 지정 람다를  
  요구하는 함수에게 인자로 넘길 수 있다.

```kt
val appendExcl: StringBuilder.() -> Unit = { this.append("!") }

val stringBuilder = StringBuilder("HI")
stringBuilder.appendExcl()
println(stringBuilder) // HI!
```

- 소스코드 상에서 수신 객체 지정 람다가 일반 람다와 똑같아 보인다는 점을 유의하자. 람다에 수신 객체가 있는지 알아보려면 그 람다가 전달되는 함수를  
  살펴봐야 한다. 함수 시그니처를 보면 람다에 수신 객체가 있는지와 람다가 어떤 타입의 수신 객체를 요구하는지를 알 수 있다.  
  예를 들어 `buildString()`의 선언을 보면 그 함수가 `StringBuilder.() -> Unit` 타입의 람다를 파라미터로 받는다는 사실을 알 수 있으므로,  
  람다의 본문에서 `StringBuilder`의 멤버를 특별한 수식자 없이 사용할 수 있다는 것을 알 수 있다.

- 표준 라이브러리의 `buildString()` 구현은 위 코드보다 더 짧다. `builderAction()`을 명시적으로 호출하는 대신, 이를 `apply()` 함수에게  
  인자로 넘긴다. 이렇게 하면 아래처럼 `buildString()`을 단 한줄로 구현할 수 있다.

```kt
fun buildString(builderAction: StringBuilder.() -> Unit): String = StringBuilder().apply(builderAction).toString()
```

- `apply()`는 인자로 받은 람다나 함수를 호출하면서 자신의 수신 객체를 람다나 함수의 묵시적 수신 객체로 사용한다.

```kt
inline fun <T> T.apply(block: T.() -> Unit): T {
	block()
	return this
}

inline fun <T, R> with(receiver: T, block: T.() -> R): R {
	receiver.block()
}
```

- 기본적으로 `apply()`와 `with()`는 모두 자신이 제공받은 수신 객체로 확장 함수 타입의 람다를 호출한다.  
  `apply()`는 수신 객체 타입에 대한 확장 함수로 선언됐기에 수신 객체의 메소드처럼 불리며, 수신 객체를 묵시적 인자(this)로 받는다.  
  반면 `with()`는 수신 객체를 첫 번째 파라미터로 받는다. 또한 `apply()`는 수신 객체를 다시 반환하지만, `with()`는 람다를 호출해  
  얻은 결과를 반환한다.

```kt
val map = mutableMapOf(1 to "one")
map.apply { this[2] = "two" }
with(map) { this[3] = "three" }
println(map) // {1=one, 2=two, 3=three}
```

---
