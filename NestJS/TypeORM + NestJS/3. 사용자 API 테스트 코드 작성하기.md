<h1>사용자 API 테스트 코드 작성하기</h1>

<h2>테스트 코드 작성하기</h2>

- 이전에 작성했던 4개의 사용자 API에 대해 Unit Test와 E2E Test 코드를 작성해보자.

- 우선 아래 패키지를 설치해주자.

```
yarn add @nestjs/testing
```

- 또한 CRUD가 잘 되는지를 확인하는 Unit Test에서 실제 데이터베이스로의 I/O를  
  발생시키면 이는 쓸모없는 리소스를 낭비하는 것이므로, 인 메모리 데이터베이스를 사용하도록 하자.  
  인 메모리 데이터베이스를 사용하면 실제 데이터에비스를 사용하긴 하므로 테스트 코드에 대한  
  신뢰도가 높아지는 반면, Mock(모의 작업)을 사용하면 모의로 기능을 구현하기에 신뢰가 조금(?)은  
  떨어질 수 있어도 속도는 인 메모리 데이터베이스를 사용하는 것보단 훨씬 빠를것이다.

- 여기에서는 CRUD에 초점을 맞추었기 때문에 인 메모리 데이터베이스를 사용하도록 하겠다.  
  우선 아래 패키지도 추가적으로 설치해주자.

```
yarn add sqlite3
```

<hr/>

<h2>Unit Test Codes</h2>

- 우선 `UserService`에 대한 단위 테스트 코드는 nest cli를 사용하면 자동으로 생성되는  
  `user.service.spec.ts`에 작성하도록 하자. 이 파일을 보면 기본적으로 작성되어 있는  
  코드들이 있는데, 여기에서 인 메모리 데이터베이스 설정을 하고 Service와 Repository에 대한  
  의존성을 구축하는데에 실패해서.. 아예 다른 테스트 코드에서도 가져다 쓸 수 있는 파일을 생성하도록 했다.

- 원하는 위치에 아래 코드를 작성해보자.

```ts
// src/utils/create-memory-db.ts

import { createConnection, EntitySchema } from "typeorm";

type Entity = Function | string | EntitySchema<any>;

export async function createMemoryDB(entities: Entity[]) {
  return createConnection({
    type: "sqlite",
    database: ":memory:",
    entities,
    logging: false,
    synchronize: true,
  });
}
```

- 위의 `createConnection()` 함수는 typeorm 패키지에서 제공하는 함수인데, 데이터 베이스에 대한  
  커넥션을 수립한 뒤 반환해주는 함수이다. 인자로 전달한 값들을 보면 이전에 `ormconfig.ts`에서  
  본 값들과 동일하다는 것을 알 수 있다. type에 sqlite를 전달하면 sqlite 데이터베이스를 사용하며  
  database에 :memory:를 전달하면 인 메모리 데이터베이스를 사용한다는 것을 지정한다.  
  entities에는 `createMemoryDB()`의 인자로 들어온 배열을 전달하겠다고 했으며,  
  만약 테스트 동안 수행되는 쿼리문들을 보고 싶다면 logging을 true로 지정하면 된다.  
  주의할 점은, 실제 데이터베이스와 달리 이 인 메모리 데이터베이스는 테이블이 만들어져 있지  
  않기 때문에 synchronize를 true로 지정해야 한다는 것이다.

- 이제 `UserService`를 테스트하기 위한 코드를 작성해보자. 기본 틀은 이렇다.

```ts
user.service.spec.ts;

describe("UserService Logic Test", () => {
  let userService: UserService;
  let connection: Connection;
  let userRepository: Repository<User>;

  beforeEach(async () => {
    connection = await createMemoryDB([User]);
    userRepository = await connection.getRepository(User);
    userService = new UserService(userRepository);
  });

  afterEach(async () => {
    await connection.close();
  });

  it("should be defined", () => {
    expect(userService).toBeDefined();
  });
});
```

- 위에서는 `beforeEach()` 내에서 userRepository를 `eonnection#getRepository()`를 사용해서 생성했으며,  
  userService의 생성자에 직접 전달하며 의존성을 직접 주입해주었다. 그리고 `afterEach()`에서  
  `connection.close()`를 호출했다. 테스트 메소드가 끝날 때마다 커넥션을 닫는 이유는 여느 데이터베이스와  
  마찬가지로 Connection Pool에 있다. `Connection#close()`를 호출하여 해당 connection을  
  Connection Pool에 반납하도록 해주었다.

<hr/>

<h2>E2E Test Codes</h2>

- TBC

<hr/>
