# 클래스 계층 정의

## 코틀린 인터페이스

- 인터페이스를 정의하고 구현하는 방법을 살펴보자. 코틀린 인터페이스는 Java8의 인터페이스와 비슷하다.  
  코틀린 인터페이스 안에는 추상 메소드 뿐만 아니라 구현이 있는 메소드도 정의할 수 있다.  
  다만, 인터페이스에는 아무런 상태(필드)도 들어갈 수 없다.

- 코틀린에서 클래스는 class로 정의하지만, 인터페이스는 interface를 사용한다.

```kt
interface Clickable {
    fun click()
}
```

- 위 코드는 `click()`이라는 추상 메소드가 있는 인터페이스를 정의한다. 이 인터페이스를 구현하는 모든  
  비추상 클래스(구체적 클래스)는 `click()`에 대한 구현을 제공해야 한다. 아래는 이 인터페이스를  
  구현하는 방법이다.

```kt
class Button : Clickable {
    override fun click() = println("I was clicked)
}

// client

Button().click()
// I was clicked
```

- Java에서는 extends와 implements 키워드를 사용하지만, 코틀린에서는 클래스명 뒤에 `:`를 붙이고  
  인터페이스와 클래스명을 적는 것으로 클래스 확장과 인터페이스 구현을 모두 처리한다. Java와 마찬가지로  
  클래스는 인터페이스를 원하는 만큼 개수 제한 없이 구현할 수 있지만, 클래스는 오직 하나만 확장할 수 있다.

- Java의 `@Override` 어노테이션과 비슷한 override 변경자는 상위 클래스나 상위 인터페이스에 있는  
  프로퍼티나 메소드를 오버라이드한다는 표시다. 하지만 Java와 달리 코틀린에서는 override 변경자를 꼭  
  사용해야 한다. override 변경자는 실수로 상위 클래스의 메소드를 오버라이드하는 경우를 방지해준다.  
  상위 클래스에 있는 메소드와 시그니처가 같은 메소드를 우연히 하위 클래스에서 선언하는 경우, 컴파일이  
  안되기 때문에 override를 붙이거나 메소드명을 바꿔야만 한다.

- 인터페이스 메소드도 디폴트 구현을 제공할 수 있다. 그런 경우 메소드 앞에 default를 붙여야 하는 Java와  
  달리, 코틀린에서는 메소드를 특별한 키워드로 꾸밀 필요가 없다. 그냥 메소드 본문을 메소드 시그니처 뒤에  
  추가하면 된다. `Clickable`에 디폴트 구현이 포함된 메소드를 하나 추가해보자.

```kt
interface Clickable {
    fun click()
    fun showOff() = println("I'm clickable")
}
```

- 이 인터페이스를 구현하는 클래스는 `click()`에 대한 구현을 제공해야만 하지만, `showOff()`의 경우  
  새로운 동작을 정의할 수도 있고, 그냥 정의를 생략해서 디폴트 구현을 사용할 수도 있다.

- 이제 `showOff()`를 정의하는 다른 인터페이스가 아래와 같은 구현을 포함한다 해보자.

```kt
interface Focusable {
    fun setFocus(b: Boolean) = println("I ${if (b) "got" else "lost"} focus.")
    fun showOff() = println("I'm focusable")
}
```

- 한 클래스에서 이 두 인터페이스를 모두 구현하면 어떻게 될까? 두 인터페이스 모두 디폴트 구현 들어있는  
  `showOff()`가 있다. 어느 쪽 `showOff()`가 선택될까? 답은 어느쪽도 선택되지 않는다는 것이다.  
  클래스가 구현하는 두 상위 인터페이스에 정의된 `showOff()` 구현을 대체할 오버라이딩 메소드를 직접  
  제공하지 않으면 아래와 같은 컴파일러 오류가 발생한다.

```
The class 'Button' must
override public open fun showOff() because it inherits
many implementations of it.
```

- 코틀린 컴파일러는 두 메소드를 아우르는 구현을 하위 클래스에 직접 구현하게 강제한다.

```kt
class Button : Clickable, Focusable {
    override fun click() = println("I was clicked")
    override fun showOff() {
	super<Clickable>.showOff()
	super<Focusable>.showOff()
    }
}
```

- `Button` 클래스는 이제 두 인터페이스를 구현한다. `Button`은 상속한 두 상위 타입의 `showOff()`를  
  호출하는 방식으로 `showOff()`를 구현한다. 상위 타입의 구현을 호출할 때는 Java와 마찬가지로 super를  
  사용한다. 하지만 구체적으로 타입을 지정하는 문법은 다르다. Java에서는 `Clickable.super.showOff()`처럼  
  super 앞에 기반 타입을 적지만, 코틀린에서는 `super<Clickable>.showOff()` 처럼 꺽쇠 괄호 안에  
  기반 타입 이름을 지정한다.

- 상속한 구현 중 단 하나만 호출해도 된다면 아래와 같이 쓸 수도 있다.

```kt
override fun showOff() = super<Clickable>.showOff()
```

<hr/>
