<h1>TDD 시작</h1>

<h2>TDD 이전의 개발</h2>

* TDD는 테스트 추도 개발(Test-Driven Development)을 말한다. TDD 이전의 개발은 아래와 같이 진행되었다.
  1. 만들 기능에 대한 설계를 고민한다. 어떤 클래스와 인터페이스를 도출할지 고민하고, 각 타입에 어떤 메소드를 넣을지 생각한다.
  2. 과정 1을 수행하면서 구현에 대해서도 고민한다. 대략 어떻게 구현하면 될지 생각한 후 코드를 작성한다.
  3. 기능에 대한 구현을 완료한 것 같으면 기능을 테스트한다. 만약 버그가 있다면 과정 2에서 작성한 코드를 디버깅하며 원인을 찾는다.

* 과정2에서 한 번에 작성한 코드가 많은 경우에는 디버깅하는 시간도 길어졌다. 원인을 찾기 위해 많은 양의 코드를 탐색해야 했다. 디버깅을 위한 로그   
  메시지를 추가하고, 개발 도구가 제공하는 디버거를 이용해서 코드를 한 줄씩 따라가며 원인을 찾았다. 오히려 디버깅에 투입되는 시간이 많은 경우도 있다.

* 때로는 코드를 작성하는 개발자와 그 코드를 테스트하는 개발자가 다를 때도 있다.

* 테스트 과정도 쉽지 않은데, 웹 애플리케이션의 경우 기능 하나하나를 테스트하기 위해 WAS를 구동해야 하고, 클래스 파일을 변경하면 WAS도 다시 구동해야   
  하기에 시간이 많이 소요된다. 또한 데이터가 올바른지 확인하기 위해 DB에 접속해 SELECT Query를 수행하고, 아이디 중복과 같은 기능을 테스트하기 위해   
  INSERT Query로 데이터를 미리 넣어놔야 했다.

* ~~TDD는 어렵다..~~
<hr/>

<h2>TDD란?</h2>

* TDD는 테스트부터 시작한다. 구현을 먼저 하고 나중에 테스트하는 것이 아니라 __먼저 테스트를 하고 그 다음에 구현__ 한다. 구현 코드가 없는데 어떻게   
  테스트를 진행할 수 있을까? 여기서 테스트를 한다는 것은 기능이 올바르게 동작하는지를 검증하는 테스트 코드를 작성한다는 것을 의미한다. 기능을   
  검증하는 테스트 코드를 먼저 작성하고, 테스트를 통과시키기 위해 개발을 진행한다.

* 간단한 덧셈 기능을 TDD로 구현해보자.
```java
package chap02;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class CalculatorTest {
    
    @Test
    void plus() {
        int result = Calculator.plus(1, 2);
        assertEquals(3, result);
    }
}
```

* 위 코드를 작성하면, `Calculator` 클래스가 없기에 컴파일 에러가 발생한다. 컴파일 에러를 없애기 전에 코드를 살펴보자.
  * JUnit은 `@Test` 어노테이션을 붙인 `plus()` 메소드를 테스트 메소드로 인식한다. 테스트 메소드는 기능을 검증하는 코드를 담고 있는 메소드이다.
  * `assertEquals()`는 수행한 결과가 기대한 값인지를 검증하는 메소드이다. `assertEquals()` 메소드는 인자로 받은 두 값이 동일한지 비교한다.   
    이때, 첫 번째 인자는 기대한 값이고 두 번째 인자는 실제 값이다. 즉, `assertEquals()` 메소드는 기대한 값과 실제 값이 동일한지 비교한다. 만약   
    두 값이 동일하지 않다면 `AssertionFailedError`가 발생한다.

* 위 코드에서 눈여겨 볼 점은 덧셈 기능을 제공하는 클래스와 메소드를 미리 `Calculator` 클래스와 `plus()` 메소드로 사용했다는 것이다.   

* 아래와 같이 `Calculator` 클래스를 작성해보자.
```java
package chap02;

public class Calculator {
    public static int plus(int a, int b) {
        return 0;
    }
}
```

* 이 후 `CalculatorTest#plus()`를 수행하면 아래와 같은 결과가 뜬다.
```
expected: <3> but was: <0>
Expected :3
Actual   :0
<Click to see difference>
```

* 위 로그는 기대한 값(Expected)은 3인데 실제(Actual) 값은 0이어서 에러가 발생했음을 의미한다. 만약 `Calculator#plus()`가 무조건 3을 반환하도록   
  작성하면 `CalculatorTest#plus(1, 2)`는 테스트 통과를 할 것이다. 만약 이 테스트 메소드에 `assertEquals(5, Calculator.plus(4, 1))`을 추가하면   
  또 다시 테스트를 통과하지 못할 것이다. 이러한 과정에서 아래와 같이 `Calculator`를 작성하는 것이 맞음을 알 수 있다.
```java
package chap02;

public class Calculator {
    public static int plus(int a, int b) {
        return a + b;
    }
}
```

* 위 코드의 경로를 살펴보면 `Calculator.java`는 파일이 `src/test/java`에 위치한다. `Calculator` 클래스를 `src/main/java` 소스 폴더에 만들어도   
  되지만 아직 완성된 기능이 아니기에 `src/test/java`에 작성했다. `src/test/java` 소스 폴더는 배포 대상이 아니므로 `src/test/java` 폴더에 코드를   
  만들면 완성되지 않은 코드가 배포되는 것을 방지하는 효과가 있다.

* 지금까지 간단한 덧셈 기능을 TDD로 구현해 봤다. 이는 TDD의 기본 흐름을 익히기에 좋은 예시이다.
* 앞서 TDD는 __기능을 검증하는 테스트 코드를 먼저__ 작성한다고 했다. 덧셈 예제에서는 덧셈 기능을 검증하는 테스트 코드를 먼저 작성했다. 이 과정에서   
  테스트 대상이 될 클래스명, 메소드명, 파라미터 개수, 반환형을 고민했다. 또한, 새로운 객체를 생성할지 아니면 정적 메소드로 구현할지도 고민해야 한다.   
  이러한 고민 과정은 실제 코드를 설계하는 과정과 유사하다.

* 테스트 코드를 작성한 뒤에는 컴파일 오류를 없애는데 필요한 클래스와 메소드를 작성했다. 그 후 테스트가 실패한 원인을 로그를 통해 확인하고, 코드를   
  수정해서 테스트를 통과했다. 이런 식으로 TDD는 테스트를 먼저 작성하고 테스트에 실패하면 테스트를 통과시킬 만큼 코드를 추가하는 과정을 반복하면서   
  점진적으로 기능을 완성해 나간다.
<hr/>

<h2>TDD 예시 : 암호 검사기</h2>

