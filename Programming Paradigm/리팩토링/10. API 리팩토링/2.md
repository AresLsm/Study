## 생성자를 팩토리 함수로 바꾸기

```js
// 리팩토링 적용 전
leadEngineer = new Employee(document.leadEngineer, "E");

// 리팩토링 적용 후
leadEngineer = createEngineer(document.leadEngineer);
```

### 배경

- 많은 객체지향 언어에서 제공하는 생성자는 객체를 초기화하는 특별한 용도의 함수다.  
  실제로 새로운 객체를 생성할 때면 주로 생성자를 호출한다. 하지만 생성자에는 일반 함수에는 없는  
  이상한 제약이 따라붙기도 한다. 가량 Java 생성자는 반드시 그 생성자를 정의한 클래스의  
  인스턴스를 반환해야 한다. 서브클래스의 인스턴스나 proxy를 반환할 수 없다.  
  생성자를 호출하려면 특별한 연산자(ex. new)를 사용해야 해서 일반 함수가 오길 기대하는  
  자리에는 쓰기 어렵다.

- 팩토리 함수에는 이런 제약이 없다. 팩토리 함수를 구현하는 과정에서 생성자를 호출할 수는 있지만,  
  원한다면 다른 무언가로 대체할 수 있다.

### 절차

- (1) 팩토리 함수를 만든다. 팩토리 함수의 본문에서는 원래의 생성자를 호출한다.
- (2) 생성자를 호출하던 코드를 팩토리 함수 호출로 바꾼다.
- (3) 하나씩 수정할 때마다 테스트한다.
- (4) 생성자의 가시 범위가 최소가 되도록 제한한다.

### 예시

- 직원(`Employee`) 유형을 다루는 간단하지만 이상한 예시를 살펴보자.

```js
class Employee {
  constructor(name, typeCode) {
    this._name = name;
    this._typeCode = typeCode;
  }

  get name() {
    return this._name;
  }

  get type() {
    return Employee.legalTypeCodes[this._typeCode];
  }

  static get legalTypeCodes() {
    return {
      E: "Engineer",
      M: "Manager",
      S: "Salesperson",
    };
  }
}

// client
candidate = new Employee(document.name, document.empType);
const leadEngineer = new Employee(document.leadEngineer, "E");
```

- 첫 번째로 할 일은 _(1) 팩토리 함수 생성_ 이다. 팩토리 본문은 단순히 생성자에  
  위임하는 방식으로 구현한다.

```js
function createEmployee(name, typeCode) {
  return new Employee(name, typeCode);
}
```

- 그런 다음 _(2) 생성자를 호출하던 곳을 모두 찾아 수정한다._  
  한 번에 하나씩, 생성자 대신 팩토리 함수를 사용하게 바꾼다.

```js
candidate = createEmployee(document.name, document.empType);
const leadEngineer = createEmployee(document.leadEngineer, "E");
```

- 조금 더 들어가서, engineer의 typeCode는 "E"이므로 아래처럼 engineer를 위한 팩토리를  
  만들 수도 있다.

```js
function createEngineer(name) {
  return new Employee(name, "E");
}
```

<hr/>

## 함수를 명령으로 바꾸기

```js
// 리팩토링 적용 전
function score(candidate, medicalExam, scoringGuide) {
  let result = 0;
  let healthLevel = 0;
  //..
}

// 리팩토링 적용 후
class Scorer {
  constructor(candidate, medicalExam, scoringGuide) {
    this._candidate = candidate;
    this._medicalExam = medicalExam;
    this._scoringGuide = scoringGuide;
  }

  execute() {
    this._result = 0;
    this._healthLevel = 0;
    //..
  }
}
```

### 배경

- 함수(독립된 함수든 객체에 소속된 메소드든)는 프로그래밍의 기본적인 빌딩 블록 중 하나다.  
  그런데 함수를 그 함수만을 위한 객체 안으로 캡슐화하면 더 유용해지는 상황이 있다.  
  이런 객체를 가리켜 _'명령 객체'_ 혹은 단순히 **명령(command)** 라 한다.  
  명령 객체 대부분은 메소드 하나로 구성되며, 이 메소드를 요청해 실행하는 것이 이 객체의 목적이다.

- 명령은 평범한 함수 메커니즘보다 훨씬 유연하게 함수를 제어하고 표현할 수 있다.  
  명령은 되돌리기(undo) 같은 보조 연산을 제공할 수 있으며, 수명주기를 더 정밀하게 제어하는 데 필요한  
  매개변수를 만들어주는 메소드도 제공할 수 있다. 상속과 hook을 이용해 사용자 맞춤형으로 만들 수도 있다.  
  객체는 지원하지만 일급 함수(first-class function)를 지원하지 않는 프로그래밍 언어를  
  사용할 때는 명령을 이용해 일급 함수의 기능 대부분을 흉내낼 수 있다. 비슷하게, 중첩 함수를 지원하지  
  않는 언어에서도 메소드와 필드를 이용해 복잡한 함수를 잘게 쪼갤 수 있고, 이렇게 쪼갠 메소드들을  
  테스트와 디버깅에 직접 이용할 수 있다.

### 절차

- (1) 대상 함수의 기능을 옮길 빈 클래스를 만든다. 클래스명은 함수명에 기초해 짓는다.
- (2) 방금 생성한 클래스로 함수를 옮긴다.  
  이때 리팩토링이 끝날 때까지는 원래 함수를 전달 함수 역할로 남겨둔다.  
  명령 관련 이름은 사용하는 프로그래밍 언어의 명명규칙을 따른다.  
  규칙이 딱히 없다면 execute, call 같은 흔히 쓰이는 이름을 택하자.
- (3) 함수의 인수들 각각은 명령의 필드로 만들어 생성자를 통해 설정할지 고민해본다.

### 예시

- JS는 허점이 많은 언어다. 하지만 함수를 일급으로 만드는 선택은 아주 훌륭했다.  
  그래서 일급 함수를 지원하지 않는 언어에서라면 필요했을 일반적인 작업에는 굳이 명령을 만들어  
  해결할 이유가 없다. 하지만 명령을 사용하는 편이 나을 때가 없는 것은 아니다.

- 예를 들어 복잡한 함수를 쪼개서 이해하거나 수정하기 쉽게 만들고 싶을 때가 있다.  
  그래서 사실 이 리팩토링의 가치를 잘 보여주려면 길고 복잡한 함수를 봐야 한다.  
  아래는 건강보험 애플리케이션에서 사용하는 점수 계산 함수다.

```js
function score(candidate, medicalExam, scoringGuide) {
  let result = 0;
  let healthLevel = 0;
  let highMedicalRiskFlag = false;

  if (medicalExam.isSmoker) {
    healthLevel += 10;
    highMedicalRiskFlag = true;
  }

  let certificationGrade = "regular";
  if (scoringGuide.stateWithLowCertification(candidate.originState)) {
    certificationGrade = "low";
    result -= 5;
  }

  //..

  result -= Math.max(healthLevel - 5, 0);
  return result;
}
```

- 시작은 _(1) 빈 클래스를 만들고, (2) 이 함수를 그 클래스로 옮기는 일부_ 이다.

```js
function score(candidate, medicalExam, scoringGuide) {
  return new Score().execute(candidate, medicalExam, scoringGuide);
}

class Scorer {
  execute(candidate, medicalExam, scoringGuide) {
    let result = 0;
    let healthLevel = 0;
    let highMedicalRiskFlag = false;

    if (medicalExam.isSmoker) {
      healthLevel += 10;
      highMedicalRiskFlag = true;
    }

    let certificationGrade = "regular";
    if (scoringGuide.stateWithLowCertification(candidate.originState)) {
      certificationGrade = "low";
      result -= 5;
    }

    //..

    result -= Math.max(healthLevel - 5, 0);
    return result;
  }
}
```

- 명령이 받는 인수들을 생성자로 옮겨 `execute()` 메소드는 매개변수를 받지 않게 하면  
  명령의 수명주기나 사용자 정의 기능 등을 지원해야 해서 매개변수가 복잡할 때 매우 편리하다.  
  예를 들어, 이 방식이라면 매개변수 목록이 서로 다른 여러 형태의 명령들을 하나의 실행 대기열(queue)을  
  통해 전달할 수도 있다.

- 매개변수 옮기기는 한 번에 하나씩 수행하자.  
  수행한 결과는 아래와 같다.

```js
function score(candidate, medicalExam, scoringGuide) {
  return new Score().execute(candidate, medicalExam, scoringGuide);
}

class Scorer {
  constructor(candidate, medicalExam, scoringGuide) {
    this._candidate = candidate;
    this._medicalExam = medicalExam;
    this._scoringGuide = scoringGuide;
  }
  execute() {
    let result = 0;
    let healthLevel = 0;
    let highMedicalRiskFlag = false;

    if (this._medicalExam.isSmoker) {
      healthLevel += 10;
      highMedicalRiskFlag = true;
    }

    let certificationGrade = "regular";
    if (
      this._scoringGuide.stateWithLowCertification(this._candidate.originState)
    ) {
      certificationGrade = "low";
      result -= 5;
    }

    //..

    result -= Math.max(healthLevel - 5, 0);
    return result;
  }
}
```

#### 더 가다듬기

- 함수를 명령으로 바꾸는 작업은 여기에서 끝났지만, 이 리팩토링의 본래 목적은 복잡한 함수를  
  잘게 나누는 것이다. 이 목적을 이루기 위한 단계들을 개략적으로 살펴보자.

- 먼저 모든 지역 변수를 필드로 바꿔야 한다.  
  당연히 단계별로 수행해야 하며, 완성된 코드는 아래와 같다.

```js
class Scorer {
  constructor(candidate, medicalExam, scoringGuide) {
    this._candidate = candidate;
    this._medicalExam = medicalExam;
    this._scoringGuide = scoringGuide;
  }
  execute() {
    this._result = 0;
    this._healthLevel = 0;
    this._highMedicalRiskFlag = false;

    if (this._medicalExam.isSmoker) {
      this._healthLevel += 10;
      this._highMedicalRiskFlag = true;
    }

    this._certificationGrade = "regular";
    if (
      this._scoringGuide.stateWithLowCertification(this._candidate.originState)
    ) {
      this._certificationGrade = "low";
      this._result -= 5;
    }

    //..

    this._result -= Math.max(healthLevel - 5, 0);
    return this._result;
  }
}
```

- 이제 함수의 상태가 모두 명령 객체로 옮겨졌다. 따라서 함수가 사용하던 변수나 그 유효범위에  
  구애받지 않고 **함수 추출하기** 같은 리팩토링을 적용할 수 있게 되었다.

```js
class Scorer {
  constructor(candidate, medicalExam, scoringGuide) {
    this._candidate = candidate;
    this._medicalExam = medicalExam;
    this._scoringGuide = scoringGuide;
  }

  scoreSmoking() {
    if (this._medicalExam.isSmoker) {
      this._healthLevel += 10;
      this._highMedicalRiskFlag = true;
    }
  }

  execute() {
    this._result = 0;
    this._healthLevel = 0;
    this._highMedicalRiskFlag = false;

    this.scoreSmoking();
    this._certificationGrade = "regular";
    if (
      this._scoringGuide.stateWithLowCertification(this._candidate.originState)
    ) {
      this._certificationGrade = "low";
      this._result -= 5;
    }

    //..

    this._result -= Math.max(healthLevel - 5, 0);
    return this._result;
  }
}
```

- 이제 명령을 중첩 함수처럼 다룰 수 있다. 사실 JS에서라면 중첩 함수가 명령의 합리적인  
  대안이 될 수 있다.

<hr/>
