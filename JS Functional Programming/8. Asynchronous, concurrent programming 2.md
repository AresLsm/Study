# 비동기: 동시성 프로그래밍 2

<h2>지연 평가 + Promise - L.map, map, take</h2>

- 비동기 상황에도 대응할 수 있도록 `map()`을 수정해보자.

```js
go(
  [1, 2, 3],
  L.map((a) => a + 10),
  take(2),
  console.log()
);

go(
  [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)],
  L.map((a) => a + 10),
  take(2),
  console.log()
);
```

- 지금대로라면 Promise가 있을 때 정상적인 연산이 되지 않는다.  
  기존에 있던 `L.map()`의 코드를 보자.

```js
L.map = curry(function* (fn, iterable) {
  for (const a of iterable) {
    yield fn(a);
  }
});
```

- `L.map()`는 들어온 iterable을 순회하고, 순회할 때 마다 각 원소를 `fn` 함수에 적용한다.  
  여기서 이전에 구현했던 Promise에 대응 가능한 `go1()`을 적용해보자.

```js
const go1 = (a, fn) => (a instanceof Promise ? a.then(fn) : fn(a));

L.map = curry(function* (fn, iterable) {
  for (const a of iterable) {
    yield go1(a, fn);
  }
});
```

- 지금 상태로, 위의 `go()` 함수 실행 결과는 Promise 2개로 이루어진 배열이다.  
  따라서 `take()`를 수정하여 Promise인 경우를 처리할 수 있도록 해주자.

```js
// 기존의 take
const take = curry((limit, iterable) => {
  let res = [];
  iterable = iterable[Symbol.iterator]();
  let current;
  while (!(current = iterable.next()).done) {
    const a = current.value;
    res.push(a);
    if (res.length === limit) {
      return res;
    }
  }
  return res;
});

// 수정한 take
const take = curry((limit, iterable) => {
  let res = [];
  iterable = iterable[Symbol.iterator]();
  return (function recur() {
    let current;
    while (!(current = iterable.next()).done) {
      const a = res.value;
      if (a instanceof Promise)
        return a.then((a) => {
          res.push(a);
          return res.length === limit ? res : recur();
        });
      res.push(a);
      if (res.length === limit) {
        return res;
      }
    }
    return res;
  })();
});
```

- 위 처럼 `take()`가 원소를 추가할 때 추가할 원소가 Promise인지 검사하여  
  Promise라면 `then()`을 호출하여 비동기를 처리해 주었다. 만약 추가할 원소(a)가  
  Promise라면 `then()`의 결과를 반환하는데, 먼저 배열에 넣은 다음, limit만큼  
  배열이 차지 않았다면 제어가 다시 while 문으로 돌아가야 하기 때문에 `recur()`라는  
  유명함수를 만들어서 재귀적으로 호출할 수 있게 했다.

- `map()` 또한 내부적으로 `L.map()`을 사용하기에 위 코드를 `map()`으로 바꾸더라도 정상 동작하게 된다.

<hr/>
