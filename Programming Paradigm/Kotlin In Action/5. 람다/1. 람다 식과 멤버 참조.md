# 람다 식과 멤버 참조

## 람다 소개: 코드 블록을 함수 인자로 넘기기

- _"이벤트가 발생하면 이 핸들러를 실행하자"_ 또는 _"데이터 구조의 모든 원소에 이 연산을 적용하자"_ 와 같은  
  생각을 코드로 표현하기 위해 일련의 동작을 변수에 저장하거나 다른 함수에 넘겨야 하는 경우가 자주 있다.  
  예전에 Java에서는 무명 내부 클래스를 사용해 이런 목적을 달성했다. 무명 내부 클래스를 사용하면 코드를  
  함수에 넘기거나 변수에 저장할 수 있기는 하지만, 상당히 번거롭다.

- 이와 달리 함수형 프로그래밍에서는 함수를 값처럼 다루는 접근 방법을 택함으로써 이 문제를 해결했다.  
  클래스를 선언하고, 그 클래스의 인스턴스를 함수에 넘기는 대신 함수형 언어에서는 함수를 직접  
  다른 함수에 전달할 수 있다. 람다 식을 사용하면 코드가 더욱 간결해진다. 람다 식을 사용하면 함수를  
  선언할 필요가 없고, 코드 블록을 함수의 인자로 전달할 수 있다.

- 예제를 하나 보자. 버튼 클릭에 따른 동작을 정의하고 싶다. 그런 경우 클릭 이벤트를 처리하는 리스너를 추가한다.  
  버튼 클릭 리스너는 `onClick()` 메소드가 들어있는 `OnClickListener`를 구현해야 한다.

```java
button.setOnClickListener(new OnClickListener() {
    @Override public void onClick(View view) {
	//..
    }
});
```

- 위 코드는 Java 방식이다. 무명 내부 클래스를 선언해야 하기 때문에 코드가 번잡스러워졌다. 이와 비슷한 작업을  
  많이 수행해야 하는 경우, 그런 번잡함은 난잡함으로 변해 개발자를 괴롭힌다. 클릭 시 벌어질 동작을 간단히  
  기술할 수 있는 표기법이 있다면 이런 불필요한 코드를 제거할 수 있을 것이다. 코틀린에서는 Java8과 마찬가지로  
  람다를 쓸 수 있다.

```kt
button.setOnClickListener { /* 클릭 시 수행할 동작 */ }
```

- 이 코틀린 코드는 앞서 본 Java 무명 클래스와 같은 역할을 하지만, 훨씬 더 간결하고 읽기 쉽다.  
  이 예제는 람다를 메소드가 하나뿐인 무명 객체 대신 사용할 수 있다는 사실을 보여준다.

<hr/>

## 람다와 컬렉션

- 코드에서 중복을 제거하는 것은 프로그래밍 스타일을 개선하는 중요한 방법 중 하나다.  
  컬렉션을 다룰 때 수행하는 대부분의 작업은 몇 가지 일반적인 패턴에 속한다. 따라서 그런 패턴은  
  라이브러리 내에 있어야 한다. 하지만 람다가 없다면 컬렉션을 편리하게 처리할 수 있는 좋은 라이브러리를  
  제공하기 어렵다. 그런 이유로 Java8 이전에는 Java에서 쓰기 편한 컬렉션 라이브러리가 적었으며, 그에  
  따라 Java 개발자들은 필요한 컬렉션 기능을 직접 작성하곤 했다.

- 사람의 이름과 나이를 저장하는 `Person` 클래스를 사용해보자.

```kt
data class Person(val name: String, val age: Int)
```

- `Person`들로 이뤄진 리스트가 있고, 그중에 가장 나이가 많은 사람을 찾고 싶다. 람다를 사용해본 경험이  
  없는 개발자라면 루프를 써서 직접 검색을 구현했을 것이다.

```kt
fun findTheOldest(people: List<Person>) {
    val maxAge = 0
    var theOldest: Person? = null
    for(person in people) {
	if(person.age > maxAge) {
	    maxAge = person.age
	    theOldest = person
	}
    }
    println(theOldest)
}
```

- 이 루프는 작성하기 쉽지만, 상당히 많은 코드가 들어있기 때문에 작성하다 실수를 저지르기도 쉽다.  
  예를 들어, 비교 연산자를 잘못 사용하면 최대값 대신 최소값을 찾게 된다.

- 코틀린에서는 더 좋은 방법이 있다. 라이브러리 함수를 쓰는 것이다.

```kt
val people = listOf(Person("Alice", 29), Person("Bob", 31))
println(people.maxBy { it.age })
```

- 모든 컬렉션에 대해 `maxBy()` 함수를 호출할 수 있다. `maxBy()`는 가장 큰 원소를 찾기 위해 비교에 사용할  
  값을 돌려주는 함수를 인자로 받는다. `{ it.age }`는 바로 비교에 사용할 값을 돌려주는 함수다. 이 코드는 컬렉션의  
  원소를 인자로 받아서 비교에 사용할 값을 반환한다. 이 예시에서는 컬렉션의 원소가 `Person` 객체였으므로 이 함수가  
  반환하는 값은 `Person` 객체의 age 필드에 저장된 나이 정보다.

- 이런 식으로 단지 함수나 프로퍼티를 반환하는 역할을 수행하는 람다는 멤버 참조로 대치할 수 있다.

```kt
people.maxBy(Person::age)
```

<hr/>
