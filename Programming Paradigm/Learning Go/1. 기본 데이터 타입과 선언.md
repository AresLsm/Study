# 기본 데이터 타입과 선언

## 내장 타입

- Go에는 boolean, integer, float, string 등의 내장 타입을 갖고 있다.  
  이러한 내장 타입들을 살펴보기 전에, 모든 타입에 적용되는 몇 가지 개념을 살펴보자.

### zero value

- Go는 선언되었지만 값이 할당되지 않은 모든 변수에 기본값으로 zero value를 할당한다.

### 리터럴

- Go에서의 리터럴은 숫자, 문자 혹은 문자열을 쓰는 것은 나타낸다.

- 정수(integer) 리터럴은 일련의 숫자로, 일반적으로 10진수를 의미하지만 다른 접두사를 사용해 진법을 변경해 사용할 수도 있다.  
  ex) 0b: 2진수, 0o: 8진수, 0x: 16진수

- 긴 정수 리터럴을 더 가독성이 좋게끔 하기 위해 100,000을 Go에서는 `100_000` 처럼 작성할 수 있다.

- 부동 소수점(floating point) 리터럴은 소수부를 구분하는 소수점이 있다. 또한 문자 e와 양수 혹은 음수(ex. 6.03e23)로 지정된  
  지수를 가질 수 있다.

- Rune 리터럴은 문자를 나타내며, 작은따옴표로 묶어 사용한다. **Go에서는 작은따옴표와 큰따옴표가 혼용될 수 없다.**  
  Rune 리터럴은 단일 유니코드 문자(`'a'`), 8비트 8진 숫자(`'\141'`), 8비트 16진수 숫자(`'\x61'`),  
  16비트 16진수 숫자(`'\u0061'`), 혹은 32비트 유니코드(`'\U00000061'`)를 사용할 수 있다.

- 문자 리터럴을 표시하는 방법에는 두 가지가 있다. 대부분의 경우에는 **interpreted string literal(해석된 문자열 리터럴)** 로  
  큰따옴표를 사용해 만들 수 있다. 이는 허용되는 모든 형식의 rune 리터럴이 0개 이상 포함 가능하다.

- 문자열에서 역슬래시, 큰따옴표 혹은 줄바꿈을 그대로 포함해 출력하고자 한다면 **raw string literal** 을 사용하자.  
  이는 역따옴표(\`)를 사용해 역따옴표 자체를 제외한 모든 리터럴을 포함할 수 있다.

### boolean

- bool 타입은 boolean 변수를 의미하며, zero value는 false이다.

### 숫자 타입

- Go에는 숫자 타입이 꽤 많은데, 세 가지 범주로 분류된 12개의 다른 타입이 있다.

#### 정수 타입

- Go는 1~4 byte 까지 다양한 크기를 가지는 부호 있는 정수와 부호 없는 정수를 모두 제공한다.

| 타입 이름 | 값의 범위                                |
| --------- | ---------------------------------------- |
| int8      | -128~127                                 |
| int16     | -32768~32767                             |
| int32     | -2147483648~2147483647                   |
| int64     | -9223372036854775808~9223372036854775807 |
| uint8     | 0~255                                    |
| uint16    | 0~65535                                  |
| uint32    | 0~4294967295                             |
| uint64    | 0~18446744073709551615                   |

- 모든 정수 타입의 zero value는 0이다.

#### 특정 정수 타입들

- Go는 정수 타입을 위한 몇 개의 특수 이름을 갖는 변수가 있다.  
  `byte` 타입은 `uint8`의 alias이다. `byte`와 `uint8` 간의 할당, 비교 혹은 수학적 연산을 수행할 수 있다.  
  하지만 Go 코드에서는 웬만하면 `byte`를 사용하는 것이 컨벤션이다.

- 다음으로 `int`가 있다. 32bit CPU에서 `int`는 `int32`와 같이 signed 32 bit integer가 된다.  
  대부분의 64bit CPU에서 `int`는 `int64`가 된다. `int`는 플랫폼마다 일관되지 않기 때문에, 타입의 명시적 변환 없이  
  `int`와 `int32` 혹은 `int64` 간에 할당, 비교, 수학적 연산의 수행은 컴파일 오류를 발생시킨다.  
  정수 리터럴은 기본적으로 `int` 타입이다.

- 마지막 특수 타입은 `uint`이다. `int`와 동일한 규칙을 따르는데, 단지 unsigned integer일 뿐이다.

- 정수 타입에는 또 다른 2개의 특수 이름이 있는데, `rune`과 `uintptr`이다.

#### 사용할 정수 타입 선택

- Go는 다른 언어에 비해 지원되는 정수 타입이 더 많은데, 주어진 모든 정수 타입의 선택을 고려한다면 어떤 것을 어떤 시점에  
  적절히 사용할 수 있을지 알 수 있다. 이를 위한 간단한 규칙을 보자.

  - 특정 크기를 갖거나 부호가 지정된 정수를 가진 network protocol이나 binary file format을 갖고 작업한다면,  
    해당되는 정수 타입 사용하자.

  - 모든 정수 타입을 처리하는 라이브러리 함수를 작성한다면, 한 쌍의 함수를 만들어 하나는 파라미터로 `int64` 타입을,  
    다른 하나는 `uint64`를 사용하자.

  > `int64`와 `uint64`를 사용하는 이유는 Go가 generic, function overloading을 지원하지 않는 상태에서  
  >  _관용적인_ 방향으로 선택했기 때문이다. `int64`와 `uint64`를 사용하면 코드를 한 번만 작성하고 호출하는 곳에서  
  >  타입 변환을 해 함수에 전달하고, 반환된 데이터를 다시 변환할 수 있다. 이러한 패턴의 코드 작성은 Go의 표준 라이브러리 중  
  >  strconv에 있는 `FormatInt()`, `FormatUint()`, `ParseInt()`, `ParseUint()`를 보면 알 수 있다.

  - 위의 경우를 제외하고는 `int`를 사용하자.

#### 정수 연산자

- Go 정수는 일반적인 산술 연산자를 모두 지원한다. `+`, `-`, `*`, `/` 그리고 `%`를 사용할 수 있다.  
  만약 나눗셈의 결과를 부동소수점으로 알고 싶다면, 정수를 부동소수점으로 변환해 사용할 필요가 있다.  
  또한 0으로 정수를 나누면 panic이 생길 수 있다.

- bit 조작 연산자도 있는데 `<<`, `>>`를 사용해 bit를 shift하거나 `&`, `|`, `^`, `&^`를 사용해 bit를 조작할 수 있다.

- `*=`, `<<=`, `&^=` 등과 같이 `=`와 함께 사용해 연산과 동시에 변수를 수정할 수 있다.

#### 부동소수 타입

- Go에서는 두 가지 종류의 부동소수점을 지원한다.

| 타입 이름 | 최대 절대값   | 가장 작은 절대값        |
| --------- | ------------- | ----------------------- |
| float32   | 3.402823e+38  | 1.401298e-45            |
| float64   | 1.797693e+308 | 4.9406564584124654e-324 |

- 정수와 같이 부동소수점의 zero value도 0이다.

- 사용할 부동소수점을 선택하는 것은 간단한데, 기존 포맷과 호환이 되는 경우가 아니라면 `float64`를 사용하자.  
  부동소수점 리터럴은 기본적으로 `float64` 타입이기에 `float64`를 사용하는 것이 가장 쉬운 방법이다.  
  또한 `float32`는 소수점 아래 6~7 자리까지만 정밀도를 갖기 때문에, 부동소수점의 정확도 문제를 완화할 수 있다.

- 더 큰 문제는 부동소수점을 사용해야 하는지 자체에 대한 결정이다. 대부분의 경우, 정답은 '아니요' 일 것이다.  
  다른 언어와 마찬가지로 Go의 부동소수점은 엄청난 범위를 갖지만, 해당 범위의 모든 값을 저장할 수 있지 못하고 가장  
  가까운 근사치를 저장한다. 즉, 부정확하기 때문이다.

- 부동소수점에는 `%`를 제외한 모든 수학 연산과 비교 연산자를 사용할 수 있는데, 0이 아닌 부동소수 변수를 0으로 나누면  
  원래 숫자의 부호에 따라 +Inf 또는 -Inf를 반환한다. 또한 0으로 설정된 부동소수점을 0으로 나누면 NaN을 반환한다.

- Go는 부동소수점 변수를 `==`와 `!=`를 사용해 비교하게 하지만, 사용하지 않도록 하자.  
  부동소수점은 태생적으로 부정확한 값을 가지므로, 두 부동소수점의 값을 같다고 생각하고 비교해도 같지 않을 수 있다.  
  대신에 최소 허용 분산을 정의하고, 두 부동소수점 변수 간에 차이가 그보다 작은 값인지를 확인하자.

#### 복소수 타입

- Go에는 복소수 타입도 있다.

### 문자열과 rune

- Go도 다른 언어와 마찬가지로 내장 타입으로 문자열을 지원한다. 문자열의 zero value는 `""` 이다.  
  Go는 unicode를 지원하기에 문자열에 모든 unicode 문자를 넣을 수 있다. 또한 문자열도 `==`와 `!=`를 사용할 수 있다.  
  이에 추가로 `>`, `>=`, `<`, `<=`를 사용해 문자열의 순서도 확인할 수 있고, `+`로 연결할 수도 있다.

- Go에서 문자열은 immutable하다. 즉, 문자열 변수에 값을 재할당 할 수는 있지만 이미 할당되어 있는 값을 바꿀 수는 없다.

- 또한 Go는 단일 코드 포인트를 위한 타입도 있다. 이것이 바로 rune 타입인데, 마치 `byte`가 `uint8`의 alias인 것처럼  
  `rune`은 `int32`의 alias type이다. Rune 리터럴의 기본 타입은 `rune`이고, 문자열의 기본 타입은 문자열이다.

> 문자를 다루는 경우에는 `int32`가 아니라 `rune`을 사용하자. 컴파일러 입장에서는 동일해도, 코드의 의도를 명확하게  
> 하는 타입을 사용하는 것이 좋다.

### 명시적 타입 변환

- 다양한 숫자 타입을 갖는 대부분의 언어는 필요하다면 automatic type promotion(자동 타입 변환)을 지원한다.  
  이는 아주 편하게 보이는 반면, 한 타입을 다른 타입으로 적절하게 변환하는 규칙이 복잡해지고, 예기치 못한 결과를 발생할 수도 있다.  
  **Go는 의도의 명확성과 가독성을 중시하는 언어로서, 변수들 간의 자동 타입 변환을 허용하지 않는다.**  
  변수 타입이 서로 맞지 않으면 명시적으로 타입 변환을 해줘야 한다. 다른 크기를 갖는 정수나 부동소수점 조차도 상호 작용을  
  위해서는 동일한 타입으로 변환해야 한다.

```go
var x int = 10
var y float64 = 30.2

var x float64 = float64(x) + y
var d int = x + int(y)
```

- 타입에 대한 엄격함은 또 다른 의미가 있다. Go 내에서는 모든 타입 변환을 명시적으로 해야하기에, 다른 Go 타입을 boolean으로  
  취급할 수 없다. 다른 많은 언어에서는 0이 아닌 숫자나 non-empty한 문자열은 boolean의 true로 해석되곤 한다.  
  자동 타입 변환과 마찬가지로 true value에 대한 규칙은 언어마다 다르기에 혼란을 야기할 수 있다.  
  따라서 Go에서는 다른 데이터 타입을 boolean으로 변환하고 싶다면, 비교 연산자를 사용해야 한다.

```go
var x int = 0
var s string = "hello"

if x == 0 {
	fmt.Println("x is 0")
}

if s == "" {
	fmt.Println("s is not empty, so this is not printed")
}
```

---

## `var` vs `:=`

- Go에는 변수를 선언하는 다양한 방법이 있는데, 각 선언 스타일로 변수를 어떻게 사용할 것인지를 전달할 수 있다.

```go
var x int = 10
```

- `=`의 오른쪽에 있는 타입이 예상되는 변수 타입인 경우, 타입을 생략할 수 있다.  
  정수 리터럴의 기본 타입은 `int`이기에 아래는 위와 같이 x를 `int`로 선언하는 것이다.

```go
var x = 10
```

- 반대로 변수를 선언하고 해당 변수에 zero value를 할당하고 싶다면 아래처럼 하면 된다.

```go
var x int
```

- 한 번의 var 라인으로 같은 타입의 여러 개 변수를 선언할 수 있다.

```go
var x, y int = 10, 20
```

- 같은 타입의 모든 변수에 zero value를 할당하는 방법도 있다.

```go
var x, y int
```

- 혹은 아래처럼 서로 다른 타입을 선언할 수도 있다.

```go
var x, y = 10, "hello"
```

- var를 사용하는 또다른 방법으로 선언 리스트를 괄호로 묶을 수도 있다.

```go
var (
	x 	int
	y 		= 20
	z 	int = 30
	d, e 		= 40, "hello"
	f, g 	string
)
```

- Go는 짧은 선언도 지원한다. 함수 내에서 `:=`를 사용해 타입 유추를 하는 var 선언을 대체할 수 있다.  
  아래 두 라인의 코드는 정확히 같은 동작을 한다.

```go
var x = 10
x := 10
```

- var과 마찬가지로 `:=` 연산자를 사용해 다양한 변수를 한 번에 선언할 수도 있다.

```go
var x, y = 10, "hello"
x, y := 10, "hello"
```

- `:=` 연산자는 var로는 할 수 없는 한 가지 기능이 있다. 이미 선언된 변수에 값을 할당하는 것이다.

```go
x := 10
x, y := 30, "hello"
```

- `:=`에도 한 가지 제한이 있는데, 패키지 레벨에서 변수를 선언하고자 한다면 `:=`의 사용은 함수 밖에서는 불가하기에  
  반드시 var 키워드를 사용해야만 한다.

- var과 `:=`를 사용하는 기준은 코드의 의도를 가장 명확히 할 수 있는 방향으로 사용하면 된다.  
  함수 내에서의 가장 흔한 선언 방법은 `:=`이고, 함수 밖에서는 선언 리스트를 사용하자.

- 함수 내에서 `:=` 사용을 피해야 하는 상황들이 있다.

  - zero value로 변수를 초기화할 때, `var x int`와 같이 사용하자. 의도한 zero value가 할당될 수 있도록 하기 위함이다.
  - 타입이 지정되지 않은 상수나 리터럴이 변수에 할당될 때, 타입 지정이 가능한 var를 사용하자.  
    타입 변환을 사용해 값의 타입을 지정하고 `:=`를 사용해 `x := byte(20)`과 같이 사용하는 것은 문제 없지만,  
    `var x byte = 20`으로 사용하는 것이 관용적인 코드를 만들 수 있다.
  - `:=` 연산자는 새로운 변수나 이미 존재하는 변수 모두에 값을 할당하기 때문에, 이미 있는 변수에 값을 할당하려고 의도했던 것이  
    새로운 변수를 만들게 되는 경우가 발생한다. 이런 상황에서 명시적으로 var를 사용해 변수를 새로운 선언으로 명확히 한다면,  
    이미 있던 변수나 새로운 변수 모두에 `=`를 사용할 수 있다.

- Package block이라 불리는 범위 내에서 함수 외부에 변수를 선언하는 것은 거의 없다. 값의 변경이 일어나는 패키지 레벨의  
  변수는 좋지 않다. 함수 외부에 변수가 있을 때, 변수의 변경 사항을 추적하기 어려울 수 있어 프로그램의 데이터 흐름을 이해하기  
  어려워진다. 이는 미묘한 버그로 이어질 수 있다. 따라서 패키지 블록에 대해서는 사실상 변경 불가한 변수만 선언해야 한다.

---

## const

- Go에서는 const 키워드를 사용해 값을 변경할 수 없도록 변수를 선언할 수 있다.

```go
const x int64 = 10

const (
	idKey = "id"
	nameKey = "name"
)

const z = 20 * 10

func main() {
	const y = "hello"

	fmt.Println(x, y)

	x = x + 1 // Compile error: cannot assign to x
	y = "bye" // Compile error: cannot assign to y

	fmt.Println(x, y)
}
```

- 보다시피 위에서는 패키지 레벨, 함수 내에 상수(constant)를 선언했다. var처럼 괄호를 이용해 연관된 상수를  
  그룹으로 선언할 수 있다.

- 하지만 Go의 const는 매우 제한적이다. **Go에서 상수는 리터럴에 이름을 부여하는 방법이다.** 컴파일러가 컴파일을 하는 동안에  
  파악할 수 있는 값을 가지고 있을 수 있다. 즉, 아래 리스트의 값을 할당할 수 있다.

  - 숫자 리터럴
  - true, false
  - 문자열
  - rune 문자
  - 내장 함수 `complex`, `real`, `imag`, `len`, `cap`
  - 앞서 선언된 값과 연산자의 구성으로 된 표현

- Go는 실행 중에 계산된 값을 변경할 수 없도록 지정하는 방법을 제공하진 않는다. 예를 들어 변경 불가한 배열, slice, map, struct와  
  같은 것은 없고, struct의 항목을 변경 불가하게 선언하는 방법도 없다. 하지만 함수 내에서 변수가 수정되고 있는지가 명백하므로  
  불변성은 그리 중요하지 않다.

---

## 타입 지정 상수와 타입 미지정 상수

- 상수는 타입이 지정되거나, 지정되지 않을 수 있다. 타입이 지정되지 않은 상수는 리터럴과 똑같이 처리된다.  
  자체 타입은 없지만, 다른 타입으로 추론할 수 없을 때 사용하는 기본 타입을 갖고 있다.  
  타입 지정 상수는 해당 타입의 변수에 직접적으로 할당될 수 있다.

- 상수를 왜 선언했는지에 따라 상수에 타입을 지정하거나, 지정하지 않을 수 있다. 여러 숫자 타입과 함께 사용할 수 있는  
  수학적 상수에 이름을 지정한다면, 상수는 타입을 지정하지 않도록 한다. 일반적으로 상수에 타입을 지정하지 않는 것은  
  조금 더 유연함을 가질 수 있다. 하지만 `iota`를 사용해 열거형을 만드는 것과 같이 타입을 강제하는 몇몇의 경우가 있다.

- 타입 미지정 함수는 아래처럼 선언할 수 있다.

```go
const x = 10
```

- 그리고 아래의 할당 예제는 모두 문법에 맞다.

```go
var y int = x
var z float64 = x
var d byte = x
```

- 타입 지정 상수는 아래처럼 선언할 수 있다.

```go
const typedX int = 10
```

- 이 상수는 이제 `int`에만 직접 할당할 수 있다. 다른 타입에 할당하는 경우에는 컴파일 오류가 발생한다.

---

## 사용하지 않는 변수

- Go언어의 목표 중 하나는 _대규모 팀이 프로그램을 개발하는 과정에서 더 쉽게 협업할 수 있도록 하는 것_ 이다.  
  이를 달성하기 위해 Go는 다른 프로그래밍 언어와는 다른 독특한 규칙들이 있는데, 예를 들어 `go fmt`를 사용해  
  Go 프로그램을 포맷팅하는 것이 있다. 이에 추가해 **모든 선언된 지역 변수들은 반드시 사용되어야 한다**는 규칙이 있다.  
  지역 변수를 선언하고 사용하지 않는다면, 컴파일 에러가 발생할 것이다.

- 컴파일러의 미사용 변수 확인은 그다지 철저하진 않다. 즉, 변수를 한 번이라도 접근했거나 앞으로 접근될 일이 없는 변수에  
  값을 쓴 경우에도 컴파일러는 오류를 내지 않는다.

```go
func main() {
	x := 10
	x = 20
	fmt.Println(x)
	x = 30
}
```

- 컴파일러와 `go vet`은 사용되지 않는 10과 30의 x 변수로의 할당을 잡아내지 못하지만, `golangci-lint`는 잡아낼 수 있다.

- 추가적으로 Go 컴파일러는 접근하지 않는 패키지 레벨에서의 변수 생성도 내버려 둔다. 이는 패키지 레벨 변수를 피애햐 하는  
  또다른 이유가 된다.

- 마지막으로 Go 컴파일러는 const로 사용되지 않는 상수를 만드는 것도 허용한다. Go에서 상수는 컴파일 과정에서 계산될 것이고  
  어떠한 부작용도 만들지 않기 때문이다. 이런 상수는 쉽게 제거할 수 있는데, 사용되지 않는다면 컴파일된 바이너리에 포함하지 않으면 된다.

---

## 변수, 상수명 짓기

---

```

```
