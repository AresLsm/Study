<h1>테스트 가능한 설계</h1>

<h2>테스트가 어려운 코드</h2>

* 모든 코드를 테스트할 수 있는 것은 아니다. 개발을 진행하다 보면 테스트하기 어려운 코드를 만나게 된다.

<h3>하드 코딩된 경로</h3>

* 일부 테스트에는 파일 경로, IP주소, 포트번호가 하드코딩 되어 있는 경우가 있다. 이들은 테스트를 어렵게 만든다.
```java
public class PaySync {
    private PayInfoDao payInfoDao = new PayInfoDao();

    public void sync() throws IOException {

        Path path = Paths.get("D:\\data\\pay\\cp1.csv");
        List<PayInfo> payInfos = Files.line(path)
            .map(line -> {
                String[] data = line.split(",");
                PayInfo payInfo = new PayInfo(
                    data[0], data[1], Integer.parseInt(data[2])
                );
                return payInfo;
            })
            .collect(Collectors.toList());
            payInfos.forEach(pi -> payInfoDao.insert(pi));
    }
}
```

<h3>의존 객체를 직접 생성</h3>

* 위 테스트를 어렵게 만드는 또 다른 요인은 의존 대상(`PayInfoDao`)을 직접 생성하고 있다는 것이다.   
  이 코드를 테스트하려면 `PayInfoDao`가 올바르게 동작하는데 필요한 모든 환경을 구성해야 한다.   
  DB를 준비해야 하고 필요한 테이블도 만들어야 한다.

* 테스트를 실행하면 데이터가 DB에 추가되므로 같은 테스트를 다시 실행하기 전에 기존에 들어간 데이터를 삭제해야 한다.   
  그렇지 않으면 중복 데이터로 인해 데이터 삽입에 실패하게 된다.

<h3>정적 메소드 사용</h3o>

* 정적 메소드를 사용해도 테스트가 어려워질 수 있다. 아래 코드를 보자.
```java
@RequiredArgsConstructor
public class LoginService {
    private String authKey = "somekey";
    private final CustomerRepository repository;

    public LoginResult(String id, String pw) {
        int resp = 0;
        boolean authorized = AuthUtil.authorize(autyKey);
        if(authorized) resp = AuthUtil.authenticate(id, pw);
        else resp = -1;

        if(resp == -1) return LoginResult.badAuthKey();

        if(resp == 1) {
            Customer customer = respository.findOne(id);
            return LoginResult.authenticated(customer);
        } else return LoginResult.fail(resp);
    }   
}
```

* 위 코드는 `AuthUUtil`클래스의 정적 메소드를 사용하고 있다. `AuthUtil` 클래스가 인증 서버와 통신하는 경우 이 코드를 테스트하려면   
  동작하고 있는 인증 서버가 필요하다. `AuthUtil` 클래스가 통신할 인증 서버 정보를 시스템 프로퍼티에서 가져온다면 시스템 프로퍼티도   
  테스트 환경에 알맞게 설정해야 한다. 게다가 다양한 상황을 테스트하려면 인증 서버에 저장되어 있는 유효한 아이디와 암호를 써야 한다.

<h3>실행 시점에 따라 달라지는 결과</h3>

* 아래 코드는 특정 사용자의 포인트를 계산하는 로직을 담고 있다.
```java
@AllArgsConstructor
public class UserPointCalculator {
    private SubsciptionDao subscriptionDao;
    private ProductDao productDao;

    public int calculatePoint(User user) {
        Subscription subscription = subscriptionDao.selectByUser(user.getId());
        if(subscription == null) throw new NoSubscriptionException();
        Product product = productDao.selectById(subscription.getProductId());
        LocalDate now = LocalDate.now();  // 시점에 따라 달라지는 값
        int point = 0;
        if(subscription.isFinished(now)) point += product.getDefaultPoint();
        else point += product.getDefaultPoint() + 10;
        if(subscription.getGrade().equals(Grade.GOLD)) point += 100;
        return point;
    }
}
```

* 위 코드는 같은 테스트 코드라도 `LocalDate.now()`에 따라 실행 결과가 달라진다.
* `Random`을 이용해서 임의 값을 사용하는 코드도 비슷하다. `Random`이 생성한 값에 따라 실행 결과가 달라질 수 있다.

* 이렇게 테스트를 실행하는 시점에 따라 결과가 달라진다면 그 테스트는 신뢰할 수 없게 된다.

<h3>역할이 섞여 있는 코드</h3>

* 위 코드의 또다른 문제는 포인트 계산 로직만 테스트하기 어렵다는 점이다.   
  포인트 계산 결과를 테스트하려면 `SubscriptionDao`와 `ProductDao`에 대한 대역을 구성해야 한다.   
  이 둘의 대역을 알맞게 설정해야만 포인트 계산이 가능하기 때문이다.

<h3>그 외 테스트가 어려운 코드</h3>

* 이 외에 테스트 대상이 다음과 같다면 테스트가 어려울 수 있다.
  * 메소드 중간에 소켓 통신 코드가 포함되어 있다.
  * 콘솔에서 입력을 받거나 결과를 콘솔에 출력한다.
  * 테스트 대상이 사용하는 의존 대상 클래스나 메소드가 final이다. 이 겨우 대역으로의 대체가 어려울 수 있다.
  * 테스트 대상의 소스를 소유하고 있지 않아 수정이 어렵다.
<hr/>

