<h1>어댑터 패턴</h1>

<h2>어댑터</h2>

* 객체지향에서의 어댑터는 실생활에서 쓰이는 어댑터와 동일한 기능을 제공한다.

* 어떤 소프트웨어 시스템이 있는데, 새로운 업체에서 제공한 클래스 라이브러리를 사용해야 한다고 해보자.   
  하지만 새로 채택한 업체에서 사용하는 인터페이스가 기존 업체에서 사용하던 인터페이스와 다르다고 가정해보자.

* 그런데 기존 코드를 바꿔서 문제를 해결할 수는 없다. 업체에서 공급받은 클래스도 변경할 수 없다.   
  그렇다면 __새로 사용하기로한 업체에서 사용하는 인터페이스를 기존에 사용하던 인터페이스에 적응시켜주는 클래스를 만들어야 한다__.

* 즉, 어댑터는 클라이언트로부터 요청을 받아서 새로운 업체에서 제공하는 클래스에서 받아들일 수 있는 형태의 요청으로   
  변환시켜주는 중개인 역할을 한다.
<hr/>

<h2>예시 시나리오</h2>

* 어댑터를 어떻게 사용하는지 살펴보자.
* 먼저 `Duck`라는 인터페이스가 있다.
```java
public interface Duck {
    public void quack();
    public void fly();
}
```

* 그리고 위의 `Duck` 클래스를 구현하는 `MallardDuck`이 있다.
```java
public class MallardDuck implements Duck {
    public void quack() {
        System.out.println("QUACK");
    }

    public void fly() {
        System.out.println("FLY");
    }
}
```

* 위 두 개의 코드가 기존 업체가 가지고 있던 코드이고, 아래의 클래스가 새로운 업체에서 제공한 클래스라 해보자.
```java
public interface Turkey{
    public void gobble();
    public void fly();
}

public class WildTurkey implements Turkey {
    public void gobble() {
        System.out.println("GOBBLE");
    }

    public void fly() {
        System.out.println("FLY");
    }
}
```

* `Duck` 객체가 모자라서 `Turkey` 객체를 대신 사용해야 하는 상황이라고 해보자.   
  `Duck`과 `Turkey`는 다른 인터페이스이므로 `Duck`에 바로 `Turkey` 구현 클래스를 적용할 수는 없다.   
  아래 코드를 살펴보자.
```java
public class TurkeyAdapter implements Duck {

    Turkey turkey;

    public TurkeyAdapter(Turkey turkey) {this.turkey = turkey;}

    public void quack() { 
        turkey.gobble();
    }

    public void fly() {
        for(int i = 0; i < 5; i++) {
            turkey.fly();
        }
    }
}
```

* 위의 `TurkeyAdapter`가 어댑터 클래스이다. 이제 `TurkeyAdapter`를 사용하여 `Turkey`가 `Duck`을 대체할 수 있다.
<hr/>

