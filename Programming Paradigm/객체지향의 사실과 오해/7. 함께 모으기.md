# 함께 모으기

> 코드와 모델을 밀접하게 연관시키는 것은 코드에 의미를 부여하고 모델을 적절하게 한다.

- Martin Fowler는 객체지향 설계 안에 존재하는 세 가지 상호 연관된 과점에 대해 설명한다.  
  세 가지 관점은 각각 개념 관점, 명세 관점, 구현 관점이라고 한다.

- **개념 관점(Conceptual Perspective)** 에서 설계는 도메인 안에 존재하는 개념과 개념들  
  사이의 관계를 표현한다. 도메인이란 사용자들이 관심을 가지고 있는 특정 분야나 주제를 말하며  
  소프트웨어는 도메인에 존재하는 문제를 해결하기 위해 개발된다. 이 관점은 사용자가 도메인을  
  바라보는 관점을 반영한다. 따라서 실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는 것이 핵심이다.

- **명세 관점(Specification Perspective)** 에 이르면 사용자의 영역인 도메인을 벗어나 개발자의  
  영역인 소프트웨어로 초점이 옮겨진다. 명세 관점은 도메인의 개념이 아니라, 실제로 소프트웨어 내에서  
  살아 숨쉬는 객체들의 책임에 초점을 맞추게 된다. 즉, 객체의 인터페이스를 바라보게 된다.  
  명세 관점에서 프로그래머는 객체가 협력을 위해 _무엇_ 을 할 수 있는가에 초점을 맞춘다.  
  인터페이스와 구현을 분리하는 것은 훌륭한 객체지향 설계를 낳는 가장 기본적인 원칙임을 기억하자.  
  안타깝게도 대부분의 객체지향 언어가 인터페이스와 구현을 클래스 안으로 섞어 버리기 때문에 많은  
  설계자들이 인터페이스와 구현의 분리가 얼마나 중요한지를 잊어버리곤 한다. 객체지향 설계 분야의 오래된  
  격언인 _"구현이 아닌 인터페이스에 대해 프로그래밍하라."_ 를 따르는 것은 명세 관점과 구현 관점을  
  명확하게 분리하는 것에서부터 시작된다.

- **구현 관점(Implementation Perspective)** 은 프로그래머인 우리에게 가장 익숙한 관점으로,  
  실제 작업을 수행하는 코드와 연관돼 있다. 구현 관점의 초점은 객체들이 책임을 수행하는 데 필요한  
  동작을 하는 코드를 작성하는 것이다. 따라서 프로그래머는 객체의 책임을 _어떻게_ 수행할 것인가에  
  초점을 맞추며 인터페이스를 구현하는 데 필요한 속성과 메소드를 클래스에 추가한다.

- 위 설명이 마치 개념 관점, 명세 관점, 구현 관점의 순서대로 소프트웨어를 개발한다는 의미처럼  
  느껴질 수 있지만, 이는 사실이 아니다. 개념 관점, 명세 관점, 구현 관점은 동일한 클래스를  
  세 가지 다른 방향에서 바라보는 것을 의미한다. 클래스는 세 가지 관점이라는 안경을 통해  
  설계와 관련된 다양한 측면을 드러낼 수 있다. 클래스가 은유하는 개념은 개념 관점을 반영한다.  
  클래스의 공용 인터페이스는 명세 관점을 반영하며, 클래스의 속성과 메소드는 구현 관점을 반영한다.

- 이는 클래스를 어떻게 설계해야 하느냐에 대한 중요한 힌트를 암시한다. 클래스는 세 가지 관점을 모두  
  수용할 수 있도록 개념, 인터페이스, 구현을 함께 드러내야 한다. 동시에 코드 안에서 세 가지 관점을  
  쉽게 식별할 수 있도록 깔끔하게 분리해야 한다.

- 지금까지 역할, 책임, 협력을 이용해 객체의 인터페이스를 식별한다. 협력에 참여하기 위해 객체가  
  수신해야 하는 메시지를 결정하고, 메시지들이 모여 객체의 인터페이스를 구성한다는 점을 기억하자.  
  따라서 협력 안에서 메시지를 선택하고 메시지를 수신할 객체를 선택하는 것은 객체의 인터페이스,  
  즉 명세 관점에서 객체를 바라보는 것이다.

- 이번에는 명세 관점에 더해 개념 관점과 구현 관점을 함께 다뤄보자. _커피 전문점_ 과 관련된 간단한  
  예제를 보며, 예제를 통해 아래의 두 가지 목표를 달성할 것이다.

  - (1) 도메인 모델에서 시작해 최종 코드까지의 구현 과정을 간략하게나마 보기
  - (2) 구현 클래스를 개념 관점, 명세 관점, 구현 관점에서 바라본다는 것이 의미하는 바를 알아보기

## 커피 전문점 도메인

### 커피 주문

- 예제의 목적은 커피 전문점에서 커피를 주문하는 과정을 객체들의 협력 관계로 구현하는 것이다.

### 커피 전문점이라는 세상

- 개발에 들어가기 전에 먼저 커피 전문점을 구성하는 요소들에 대해 잠시나마 고민해보자.  
  객체지향 패러다임의 가장 중요한 도구는 객체이므로 커피 전문점을 **객체들로 구성된 작은 세상**으로  
  바라봐야 한다.

- 커피 전문점 안에는 메뉴판이 존재하며, 메뉴판에는 아메리카노, 카푸티노, 카라멜 마키아또, 에스프레소의  
  네 가지 메뉴가 적혀있다. 객체지향의 관점에서 **메뉴판은 하나의 객체**다. 메뉴판은 네 개의 메뉴 항목으로  
  구성되어 있는데, 메뉴 항목들 역시 객체로 볼 수 있다. 따라서 **메뉴판은 네 개의 항목 객체들을 포함하는**  
  **객체**라고 볼 수 있다.

- 손님은 메뉴판을 보고 바리스타에게 원하는 커피를 주문한다. 객체의 관점에서 보면 **손님 역시 하나의 객체**다.  
  손님 객체는 메뉴판 객체 안에 적힌 항목 객체들 중에서 자신이 원하는 메뉴 항목 객체를 하나 선택해  
  **바리스타 객체에게 전달**할 것이다.

- 바리스타는 주문을 받은 메뉴에 따라 적절한 커피를 제조한다. 바리스타가 제조할 수 있는 커피의 종류는 네 가지다.  
  **바리스타는 자율적으로 커피를 제조하는 객체**로 볼 수 있으며, 바리스타가 제조하는 커피 역시 메뉴판, 메뉴 항목,  
  바리스타와 구별되는 자신만의 경계를 가지므로 객체로 볼 수 있다.

- 종합해보면 객체지향의 관점에서 커피 전문점 도메인은 **손님 객체, 메뉴 항목 객체, 메뉴판 객체, 바리스타 객체,** 그리고  
  **커피 객체**로 구성된 작은 세상이다.

- 어떤 객체가 존재하는지 살펴봤으므로, 이제는 객체들 간의 관계를 살펴볼 시간이다.

- 손님은 메뉴판에서 주문할 커피를 선택할 수 있어야 한다. 따라서 손님은 어떤 식으로든 메뉴판을 알아야 하며,  
  이는 두 객체 사이에 관계가 존재한다는 것을 암시한다. 손님은 바리스타에게 주문을 해야 하므로 손님과  
  바리스타 사이에도 관계가 존재한다. 바리스타는 커피를 제조하는 사람이므로 당연히 자신이 만든 커피와  
  관계를 맺는다.

  - `손님` <==> `메뉴판`
  - `손님` <==> `바리스타`
  - `바리스타` <==> `커피`

- 인간의 두뇌는 세상을 이해하기 위해 객체를 직접적으로 다룰 수 있을만큼 효율적이지 못하다. 우리가  
  할 수 있는 일은 **동적인 객체를 정적인 타입으로 추상화해서 복잡성을 낮추는 것이다.** 타입은 분류를  
  위해 사용됨을 기억하자. 상태와 무관하게 동일하게 행동할 수 있는 객체들은 동일한 타입으로 분류할 수 있다.

- 손님 객체는 _'손님'_ 타입의 인스턴스로 볼 수 있다. 바리스차 객체는 _'바리스타'_ 타입의 인스턴스이며,  
  아메리카노, 카푸치노 등 커피는 모두 _'커피'_ 타입의 인스턴스이다. 메뉴판 객체는 _'메뉴판'_ 타입의  
  인스턴스이며, 네 개의 메뉴 항목 객체를 포함할 수 있다. 네 개의 메뉴 항목 객체 역시 모두 동일한  
  _'메뉴 항목'_ 타입의 인스턴스로 모델링할 수 있다.

- 커피 전문점을 구성하는 범주로서 손님 타입, 메뉴판 타입, 메뉴 항목 타입, 바리스타 타입, 커피 타입이  
  갖춰졌다. 이제 각 타입 간에 어떤 관계가 존재하는지 살펴보자.

- 하나의 메뉴판 객체는 다수의 메뉴 항목 객체로 구성돼 있다. 메뉴판과 메뉴 항목 객체는 따로 떨어져 존재하지  
  않으며, 하나의 단위로 움직인다. 이런 관점에서 **메뉴 항목 객체가 메뉴판 객체에 포함**돼 있다고 볼 수 있는데,  
  이를 **메뉴판 타입과 메뉴 항목 타입 간의 합성(Composition) 관계로 단순화** 하면 더 보기 수월할 것이다.

- 손님 타입은 메뉴판 타입을 알고 있어야 원하는 커피를 주문할 수 있다. 메뉴판 타입은 손님 타입의 일부가  
  아니므로, 이 관계는 합성 관계까 아니다. 이 경우, 타입들 사이를 단순한 선으로 연결한다. 이처럼  
  **한 타입의 인스턴스가 다른 타입의 인스턴스를 포함하지는 않지만 서로 알고 있어야 하는 경우**를  
  **연관(Association) 관계** 라고 부른다.

- 바리스타 타입은 커피를 제조해야 하므로 커피 타입을 알고 있어야 한다. 메뉴판 타입과 커피 타입 중  
  어떤 것도 바리스타의 일부가 아니므로 이 관계 역시 포함 관계는 아니다.

- 이렇게 타입을 파악하고, 타입 간의 관계를 파악하면 모델을 그릴 수 있다.  
  이렇게 소프트웨어가 대상으로 하는 영역인 도메인을 단순화해서 표현한 모델을 **도메인 모델**이라 한다.

- 커피 전문점이라는 도메인을 단순화해서 이해했으므로 이제 초점을 소프트웨어로 옮길 때다.  
  객체지향의 세계는 협력하는 자율적인 객체들의 공동체라는 점을 기억하자. 다음 단계는  
  **협력을 설계하는 것**이다. 즉, 적절한 객체에게 적절한 책임을 할당하는 것이다.

> 실제로 도메인 모델을 작성하는 단계에서 어떤 관계가 포함이고, 어떤 관계가 연관 관계임은 중요하지 않다.  
> 초점은 **어떤 타입이 도메인을 구성하느냐와 타입들 사이에 어떤 관계가 존재하는지를 파악함으로써**  
> **도메인을 이해하는 것**이다.

<hr/>
