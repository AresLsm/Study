# 기본적인 리팩토링(2)

<h2>매개변수 객체 만들기</h2>

```js
// 리팩토링 적용 전
function amountInvoiced(startDate, endDate) {
  /* ... */
}
function amountReceived(startDate, endDate) {
  /* ... */
}
function amountOverdue(startDate, endDate) {
  /* ... */
}

// 리팩토링 적용 후
function amountInvoiced(dateRange) {
  /* ... */
}
function amountReceived(dateRange) {
  /* ... */
}
function amountOverdue(dateRange) {
  /* ... */
}
```

<h3>배경</h3>

- 데이터 항목 여러 개가 이 함수에서 저 함수로 함께 몰려다니는 경우는 자주  
  볼 수 있다. 이런 경우, 데이터 무리를 발견하면 하나의 데이터 구조로  
  모아주자.

- 데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해진다는  
  이점을 얻는다. 게다가 함수가 이 데이터 구조를 받게 하면 매개변수의  
  수가 줄어든다. 같은 데이터 구조를 사용하는 모든 함수가 원소를  
  참조할 때 항상 똑같은 이름을 사용하기에 일관성도 높여준다.

- 하지만 이 리팩토링의 진정한 힘은 **코드를 더 근본적으로 바꿔준다**는 데 있다.  
  이런 데이터 구조를 새로 발견하면, 이 데이터 구조를 활용하는 형태로 프로그램을  
  재구성할 수 있다. 데이터 구조에 담길 데이터에 공통으로 적용되는 동작을  
  추출해서 함수로 만드는 것이다. 이 과정에서 새로 만든 데이터 구조가 문제 영역을  
  훨씬 간결하게 표현하는 새로운 추상 개념으로 격상되면서, 코드의 개념적인 그림을  
  다시 그릴 수도 있다. 그러면 놀라울 정도로 강력한 효과를 낸다.  
  하지만 이 모든것의 시작은 매개변수 객체 만들기부터다.

<h3>절차</h3>

- (1) 적당한 데이터 구조가 아직 마련되어 있지 않다면 새로 만든다.

- (2) 테스트한다.

- (3) 함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가한다.

- (4) 테스트한다.

- (5) 함수 호출 시 새로운 데이터 구조 인스턴스를 넘기도록 수정한다.  
  하나씩 수정할 때마다 테스트한다.

- (6) 기존 매개변수를 사용하던 코드를 새 데이터 구조의 원소를 사용하도록 바꾼다.

- (7) 다 바꿨다면 기존 매개변수를 제거하고, 테스트한다.

- 이 리팩토링은 새로 생성한 객체로 동작까지 옮기는 더 큰 작업의  
  첫 단계로 수행될 때가 많기 때문에 JS의 객체가 아닌 클래스로  
  데이터 구조를 만들도록 하자.

- 또한 새로 생긴 데이터 구조는 값 객체로 만들 가능성이 높기 때문에  
  getter만 제공하자.(setter는 제공하지 않아도 된다).  
  물론 값 객체가 아니라면 필요한 메소드를 제공해야 한다.

<hr/>

<h2>여러 함수를 클래스로 묶기</h2>

```js
// 리팩토링 적용 전
function base(reading) {
  /* ... */
}
function taxableCharge(reading) {
  /* ... */
}
function calculateBaseCharge(reading) {
  /* ... */
}

// 리팩토링 적용 후
class Reading {
  base() {
    /* ... */
  }
  taxableCharge() {
    /* ... */
  }
  calculateBaseCharge() {
    /* ... */
  }
}
```

<h3>배경</h3>

- 클래스는 대다수의 프로그래밍 언어가 제공하는 기본적인 빌딩 블록이다.  
  클래스는 데이터와 함수를 하나의 공유 환경으로 묶은 후, 다른 프로그램 요소와  
  어우러질 수 있도록 그중 일부를 외부에 제공한다. 클래스는 객체 지향 언어의  
  기본인 동시에 다른 패러다임 언어에도 유용하다.

- 저자는 흔히 함수 호출 시 인자로 전달되는 공통 데이터를 중심으로 긴밀하게 엮여  
  작동하는 함수 무리를 발견하면, 클래스 하나로 묶는다. 클래스로 묶는다면  
  이 함수들이 공유하는 공통 환경을 더 명확하게 표현할 수 있고, 각 함수에 전달되는  
  인수를 줄여서 객체 안에서의 함수 호출을 간결하게 만들 수 있다. 또한 이런 객체를  
  시스템의 다른 부분에 전달하기 위한 참조를 제공할 수 있다.

- 이 리팩토링은 이미 만들어진 함수들을 재구성할 때는 물론, 새로 만든 클래스와  
  관련하여 놓친 연산을 찾아서 새로운 클래스의 메소드로 뽑아내는 데도 좋다.

- 함수를 한데 묶는 또다른 방법으로는 **여러 함수를 변환 함수로 묶기**가 있다.  
  어느 방식으로 진행할지는 프로그램 문맥을 넓게 살펴보고 정해야 한다.  
  클래스로 묶을 때의 두드러진 장점은 클라이언트가 객체의 핵심 데이터를 변경할 수 있고,  
  파생 객체들을 일관되게 관리할 수 있다는 것이다.

- 이런 함수들을 중첩 함수 형태로 묶어도 된다. 저자는 중첩 함수보다 클래스를 선호하는데,  
  중첩 함수는 테스트하기가 까다로울 수 있기 때문이다. 또한 한 울타리로 묶을 함수들 중  
  외부에 공개할 함수가 여러 개일때는 클래스를 사용할 수밖에 없다.

<h3>절차</h3>

- (1) 함수들이 공유하는 공통 데이터 레코드를 캡슐화한다.  
  공통 데이터가 레코드 구조로 묶여 있지 않다면 먼저 **매개변수 객체 만들기**를 적용해  
  데이터를 하나로 묶는 레코드를 만든다.

- (2) 공통 레코드를 사용하는 함수 각각을 새로운 클래스로 옮긴다.  
  공통 레코드의 멤버는 함수 호출문의 인수 목록에서 제거한다.

- (3) 데이터를 조작하는 로직들은 **함수로 추출**해서 새 클래스로 옮긴다.

<hr/>
