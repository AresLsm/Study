<h1>Entity 간의 1:1 연관, 그리고 즉시 및 지연 로딩</h1>

<h2>키를 참조하는 1:1 연관 매핑</h2>

* 구현을 하다보면, 같은 키를 가지고 연관 관계를 이루는 테이블이 자주 등장하게 된다.   
  예를 들어, 회원 카드인 membership_card 테이블은 회원의 주요 키(ex.이메일) 를 외래키로 참조해야 한다.
* JPA를 사용하면 간단한 설정으로 위 두개의 테이블에 대한 Entity 객체 간의 1:1 연관을 처리할 수 있다.
<hr/>

<h2>참조키를 이용한 1:1 단방향 연관</h2>

* membership_card 테이블이 user 테이블의 email 컬럼을 user_email로 참조하고 있다고 가정하자.   
  이를 위한 매핑 설정을 간단한다. 아래 코드를 보자.
```java
@Entity
@Table(name = "membership_card")
public class MembershipCard {
    @Id
    @Column(name = "card_number")
    private String number;

    @OneToOne
    @JoinColumn(name = "user_email")
    private User owner;

    @Temporal(TemporalType.DATE)
    @Column(name = "expiry_date")
    private Date expiryDate;
    private boolean enabled;

    public MembershipCard() {}

    public MembershipCard(String number, User owner, Date expiryDate) {
        this.number = number;
        this.owner = owner;
        this.expiryDate = expiryDate;
    }
}
```

* 위 코드의 owner 필드는 아래의 두 어노테이션을 사용하여 매핑을 설정하고 있다.
  * `@OneToOne` : owner 필드가 User Entity와 1:1 연관을 가짐을 설정한다.
  * `@JoinColumn` : User 객체의 식별자에 해당하는 참조키로 user_email을 설정한다.

* `MemberShipCard` Entity가 `User` Entity를 참조하려면 `User` Entity의 식별자 값을 구해야하는데, 이 식별자를 담고 있는   
  컬럼을 지정할 때 `@JoinColumn` 어노테이션을 사용한다. membership_card 테이블에서 user 테이블에 대한 참조키로 사용하는   
  컬럼이 user_email 이므로 `@JoinColumn` 어노테이션의 값으로 "user_email"을 사용했다.

* `MembershipCard` Entity가 `User` Entity를 참조하므로 `MembershipCard` 객체를 생성할 때 참조할 `User` Entity 객체를   
  아래와 같이 전달할 수 있다.
```java
User owner = entityManager.find(User.class, "email");

Date expiryDate = new /* .. */;

MembershipCard memCard = new MembershipCard("1234", owner, expiryDate);
entityManager.persist(memCard);
```
  * 위 코드에서 식별자가 "1234"인 `MembershipCard` 객체를 생성할 때 `EntityManager`로 구한 owner를 두 번째 인자로   
    전달하고 있다. 생성한 `MembershipCard` 객체는 `EntityManager#persist()`를 이용하여 영속 컨텍스트에 보관한다.

* 위 코드를 수행한 query 로그를 보면, 아래와 같다.
```sql
INSERT INTO membership_card (expiry_date, user_email, card_number, enabled) VALUES (?,?,?,?);
```
  * 즉, `@OneToOne`으로 연관된 객체의 식별자를 `@JoinColumn`으로 설정한 컬럼에 저장하는 것을 알 수 있다.

* 반대로 DB에 저장된 객체를 로딩하면, 저장할때와 반대로 `@JoinColumn`에 지정한 컬럼을 이용하여 `@OneToOne`으로   
  연관된 Entity를 로딩한다. 실제 JPA는 __`@OneToOne`으로 연관된 객체를 위한 데이터도 모두 함께 조회__ 한다.

* 위에서 작성한 `MemberShipCard` 클래스에 아래의 두 가지 메소드를 추가해보자.
```java
public class MembershipCard {

    //..

    // 신규 사용자에게 미리 등록된 카드를 발급하는 메소드
    public void assignTo(User owner) {
        if(this.owner != null) throw new AlreadyAssignedCardException();
        this.owner = owner;
    }

    // 사용자가 등록된 카드에서 사용자를 제거하는 메소드
    public void cancelAssignment() { this.owner = null; }
}
```

  * 아래와 같이 `assignTo()`의 인자로 null을 전달해보자.
  ```java
  MembershipCard memCard = entityManager.find(MembershipCard.class, "1234");
  User user = null;
  memCard.assignTo(null);
  entityManager.persist(user);
  ```
    * 위 코드의 결과, `@JoinColumn`으로 매핑한 user_email 필드에 null이 할당된다.
  * 이번엔 아래와 같이 `cancelAssignment()` 메소드를 호출하여 owner 필드에 null을 할당하고, transaction commit 시에   
    `@JoinColumn`으로 매핑한 user_email 컬럼을 null로 수정해보자. 만약 `@JoinColumn`으로 매핑한 컬럼 값이 null이면,   
    __연관된 객체도 null이 된다__. 즉, membership_card 테이블의 user_email이 null인 데이터를 로딩하면, 이 경우   
    __owner 필드에는 null이 할당된다__.

* __연관에 사용할 Entity 객체는 반드시 영속 상태(Managed 상태)로 존재해야 한다.__
<hr/>

<h2>1:1 연관의 즉시 로딩과 지연 로딩</h2>

* `EntityManager#find()`를 이용하여 `MembershipCard` 객체를 구하면, 아래와 같이 유사한 outer join을 사용하여   
  `MembershipCard` 객체와 함께 연관된 `User` 객체를 한 query로 함께 로딩한다.
```sql
SELECT m.card_number, m.expiry_date, m.user_email, u.email, u.create_date, u.name
    FROM membership_card m LEFT OUTER JOIN user u ON m.user_email = u.email
        WHERE m.card_number = ?
```
  * 이와 같이 __연관된 객체를 함께 로딩하는 것을 `즉시 로딩(Eager Loading)`__ 이라 한다. Hibernate는 즉시 로딩을 구현하기 위해   
    위 코드처럼 JOIN을 이용하여 1:1로 연관된 객체를 함께 로딩한다.
  * 즉시 로딩은 연관된 객체를 함께 불러오는데, 이는 연관된 객체를 함께 사용하지 않으면 곧 필요없는 객체를 로딩함을 의미한다.   
    만약 연관된 객체가 필요하지 않다면, `지연 로딩(Lazy Loading)`을 사용해서 연관된 객체가 필요할 때만 로딩할 수 있다.

* `Lazy Loading`은 __연관 객체를 실제 사용하는 시점에 로딩하는 방식__ 이다. 지연 로딩을 설정하는 방법은 아래와 같이   
  `@OneToOne`어노테이션의 fetch 속성값으로 `FetchType.LAZY`를 지정하면 된다.
```java
@OneToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "user_email")
private User owner;
```

* `@OneToOne` 어노테이션의 fetch 속성은 `FetchType.EAGER`, 즉 즉시 로딩을 기본값으로 갖는다.   
  따라서 fetch 속성을 따로 지정하지 않으면 Entity를 로딩할 때 `@OneToOne`으로 매핑한 연관 객체도 함께 로딩한다.   
  또한 hibernate는 1:1 연관 객체를 즉시로딩하기 위해 위에서 봤던것과 같이 OUTER JOIN을 사용한다.
<hr/>

<h2>참조키를 이용한 1:1 양방향 연관</h2>

* 위의 예제에서는 `MemberShipCard` Entity에서 `User` Entity로의 단방향 1:1 연관에 대해 알아보았는데,   
  아래의 코드 처럼 `User` 클래스 입장에서 카드 정보에 접근할 수 있게 하기 위해 아래와 같이 코드를 추가했다고 하자.
```java
public class User {

    //..

    private MembershipCard card;

    // 특정 카드를 사용자에게 발급할 때 사용할 메소드
    public void issue(MemberShipCard card) {
        card.assignTo(this);
        this.card = card;
    }

    public MembershipCard getCard() { return this.card; }
}
```

* 이제 `User` Entity에서 `MembershipCard`로의 연관을 추가했으므로 특정 사용자에게 카드를 발급하는 코드를   
  아래와 같이 구현할 수 있다.
```java
user.issue(card);
// user.getCard() == card ==> true
// card.getOwner() == user ==> true
```

* 다음으로는 JPA가 양방향 1:1 연관을 처리할 수 있도록 매핑 설정을 추가해보자.
```java
public class User {
    //..

    @OneToOne(mappedBy = "owner")
    private MembershipCard membershipCard;
}

public class MembershipCard {
    //..

    @OneToOne
    @JoinColumn(name = "user_email")
    private User owner;
}
```

* 위의 `User` 클래스에서 `@OneToOne(mappedby = "owner")`는 연관 소유를 `MemberShipCard`의 owner 속성이 가짐을 설정한 것이다.

* DB 테이블에서 두 Entity간의 연관은 참조키를 통해서 이루어진다. 이 예시에서는 membership_card 테이블이 user_email 컬럼을   
  이용해서 user 테이블을 참조하고 있다. 여기서 membership_card 테이블과 user 테이블은 단방향 참조 관계이고,   
  참조를 소유하는 주체는 참조키를 갖고 있는 membership_card 테이블이다. 즉 DB 데이터를 기준으로 `User`에서 `MembershipCard`   
  로의 연관은 존재하지 않는 것이다. 이때, __JPA는 1:1 연관에서 물리적으로 존재하지 않는 연관을 처리하기 위해 mappedBy를 사용__   
  한다. mappedBy는 양방향 관계에서 물리적인 연관을 다른 Entity가 소유한다는 것을 지정한다.   
  위 코드에서 mappedBy 속성은 "owner"인데, 이는 양방향 연관에서 연관을 소유한 쪽이 상대방 Entity의 "owner" 속성임을 의미한다.   
  즉, `User`클래스 입장에서 `@OneToOne`으로 매핑한 card 필드에 대한 연관을 소유한 쪽은 상대방 클래스인 `MembershipCard`   
  Entity이고, 이 Entity의 owner 필드를 통해 연관을 매핑하게 된다.

* 아래 코드의 수행되는 query 결과는 다음과 같다.
```java
User user = entityManager.find(User.class, "email");
```

```sql
# 수행되는 코드
SELECT u.email, u.create_date, u.name, m.card_number, m.enabled, m.expiry_date, m.user_email
    FROM user u LEFT OUTER JOIN membership_card ON u.email = m.user_email
        WHERE u.email=?
```

* 아래처럼 `issue()` 메소드를 이용해서 아직 카드가 없는 `User` Entity를 `MembershipCard` 객체와 연관을 지어보자.
```java
User user = entityManager.find(User.class, "email");
MembershipCard card = entityManager.find(MembershipCard.class, "1234");
user.assign(card);
```
  * 위 코드의 결과, card 객체의 owner 필드에 user 객체를 할당하고, user 객체의 card 필드에는 card를 할당한다.   
    __즉, 두 객체는 양방향으로 1:1 연관을 맺게 된 것이다.__
  * 두 Entity의 1:1 양방향 연관 관계에서 연관 매핑을 소유한 쪽은 `MembershipCard` Entity의 owner 속성이므로   
    위 코드를 commit하면, card의 owner 필드가 변경되므로 membership_card 테이블에 대한 UPDATE query가 수행된다.