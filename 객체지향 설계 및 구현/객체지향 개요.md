<h1>객체 지향 개요</h1>

<h2>소프트웨어 개발 패러다임의 변화</h2>

* 패러다임은 다른 말로 바라보는 시각, 뷰, 또는 관점이라 할 수 있다. 즉, 소프트웨어 개발 패러다임은 소프트웨어 개발에 대한 시각이라 할 수 있다.

<h3>절차지향 패러다임</h3>

* 절차지향 패러다임은 소프트웨어 개발에 있는 기능 중심 혹은 절차 중심의 관점에서 개발하는 방식을 말한다. 소프트웨어 공학에서는 이를 `구조적 개발 방식`   
  이라 한다. 이 방식은 소프트웨어 공학이라는 개념이 등장했을 때 처음 소개된 개발 방식으로서, 1970년대부터 1980년대 초반까지 소프트웨어 개발에 있어서   
  주류를 이루던 패러다임이다. 그러나 이 패러다임은 소프트웨어 개발에 적용해 보았을 때, 소프트웨어 재사용이나 소프트웨어 유지보수에 있어서 많은   
  한계점을 드러냈다. 그 이유는 이 패러다임은 아래와 같이 __기능 또는 함수 중심으로__ 소프트웨어를 개발하기 때문에 데이터들이 국지화(Localization)   
  되어있지 않고, 전역화(Globalization) 되어 있기 때문이다. 따라서 개발 과정이나 개발 이후에 특정 데이터의 변경(ex. 타입 변경)을 가하거나 함수에   
  변경을 가하게 되면 전체 프로그램에 그 영향이 미치기 때문에 프로그램 변경이 매우 어렵게 한다.

```cpp
void main() {

    func1(5);

    //..

    func10();

    //..

    func1(int a);

    //..

    func10();
    func99();
}
```

<h3>객체지향 패러다임</h3>

* 절차지향 패러다임의 문제점은 절차지향으로 개발된 프로그램에는 데이터와 함수들이 서로 연관되어 있지 않고, 데이터와 함수들이 분산되어 있다는 것이다.   
  이렇게 되면 데이터와 함수들이 독립적인 것 처럼 취급되기 때문에 프로그램의 복잡도는 높아지고 프로그램의 모듈성은 매우 떨어지게 된다.   
  이러한 문제점을 해결하기 위해 등장한 패러다임이 객체지향 패러다임이다. 이 방식은 절차지향에서 분산되어 있던 데이터와 함수를 __독립적인 모듈 단위인__   
  __객체 단위로 그룹핑해서 프로그램을 구성__ 하는 패러다임이다. 따라서 하나의 소프트웨어는 객체들의 집합으로 이루어져 있으며, 각각의 객체 속에는   
  관련된 데이터나 함수들이 포함되어 있다.

* 위와 같이 구성됨으로써 기존에 절차지향에서 문제가 되었던 특정 데이터의 변경이나 함수의 변경이 전체 프로그램에 영향을 미치는 것이 아니라 변경할   
  데이터나 함수가 존재하는 객체에만 영향을 미치게 되었다. 이로써 프로그램의 수정이 훨씬 쉬워졌을 뿐만 아니라 소프트웨어 자체가 객체라는 모듈 단위의   
  집합이기 때문에 모듈성 또한 향상된 것이다.
<hr/>

<h2>객체지향 모델링</h2>

<h3>모델링 개념</h3>

* 모델링(Modeling)이란 모델을 만드는 작업으로서, 현실 세계를 단순화시켜 표현하는 기법을 말한다. 모델링은 소프트웨어 분야에 한정된 개념이 아닌 이미   
  여러 다양한 학문 분야 및 산업 분야 등에서 사용되고 있는 개념이다. 소프트웨어에 모델링을 적용해 본다면, 소프트웨어를 모델링한다는 것은 개발할   
  소프트웨어에 대한 모델 혹은 도면을 만드는 작업이라 할 수 있다. 일반적으로 소프트웨어 개발 프로세스는 아래의 6단계로 구분한다.
  * 개발 프로세스 : `계획` --> `분석` --> `설계` --> `구현` --> `시험` --> `유지보수`
* 위의 6단계 중 `분석`과 `설계` 단계를 다른 말로 `모델링 단계`라 하는데, 이 단계를 수행하고 나면 개발할 소프트웨어에 대한 다양한 산출물들이   
  나오게 된다. 이러한 산출물들을 `모델`이라 하며, 모델들에 대한 형태는 다이어그램 형태, 명세서와 같은 Specification이나 Prototpye 등이 될 수   
  있으며, 이는 모델을 만드는 모델링 기법에 따라 다양하다.

<h3>모델링의 중요성</h3>

* 모델링을 하는 목적은 개발할 시스템의 범위나 구조 또는 기능들을 보다 용이하게 이해하기 위함이다. 시스템 개발에 있어서 개발할 시스템 도메인에 대한   
  이해가 무엇보다 중요하기 때문에 모델링은 더욱 중요하게 된다.

<h3>모델링의 목표</h3>

* 위에서 설명한 바와 같이 모델링을 하는 목적은 __개발할 실세계 도메인의 복잡한 내용들은 단순화시킴으로써 도메인에 대해 보다 정확하게 이해하기 위함__ 이다.   
  이러한 목적을 달성하기 위해서는 모델링하는데에 있어서 다음과 같은 원칙들을 가지고 모델링을 해야 한다.

  1. 해당 실세계 도메인을 잘 반영할 수 있는 모델을 선택해라.
    * 모델링은 실세계 현상을 단순화시키는 작업이기 때문에, 개발할 도메인과 잘 연결될 수 있는 모델을 선택하여 모델링을 해야 한다. 예를 들어, 주식   
      거래 시스템과 같은 경우에 있어서는 실시간으로 주가의 변동사항을 잘 표현하는 것이 이 도메인을 잘 반영하는 것이기 때문에 이러한 경우에는   
      상태 모델을 만들어야 좋은 모델이라 할 수 있다.
  2. 여러 다양한 각도에서 표현할 수 있는 모델들을 만들어라.
    * 어떤 시스템을 개발하는 데 있어서 하나의 모델을 가지고 그 시스템의 모든 구조, 행위, 상태, 작업, 흐름 등을 모두 표현하는 것은 불가하다.   
      따라서 시스템을 모델링할 때 하나의 모델이 아닌 시스템의 구조적 측면, 기능적 측면, 동적 측면 등의 다양한 관점에서 관점별로 모델들을 개발해야   
      해당 도메인에 대해 정확하게 파악할 수 있다.
  3. 개발할 시스템에 적합한 모델을 선택해라.
    * 시스템에 따라서 해당 시스템이 직면하게 될 공격의 형태가 다양하고, 또한 이러한 공격에 대한 해결 형태 또한 다양할 수 있다. 따라서 어떠한 모델을   
      선택하느냐에 따라 개발할 시스템이 봉착하게 될 문제점이나 해결방안의 표현이 쉽거나 혹은 어려워질 수 있다.

<h3>모델링 기대 목표</h3>

* 모델링을 함으로써 얻을 수 있는 기대효과는 다음과 같다.
  1. 개발할 시스템을 가시화시킬 수 있다.
    * 하드웨어와 달리 소프트웨어는 눈에 보이지 않기에 고객이 자신이 요구한 사항대로 개발이 이루어지는지, 혹은 개발될 시스템의 형태가 어떠한 모습인지   
      전혀 알 수 없다. 따라서 모델링을 통해 생성된 다양한 모델들을 통해 개발될 시스템의 형태를 보여줄 수 있게 된다.
  2. 개발할 시스템에 대해 명세화시킬 수 있다.
    * 소프트웨어에 있어서도 건축물에 대해서와 유사하게 소프트웨어의 구조에 대한 명세화, 기능에 대한 명세화, 워크 플로우에 대한 명세화, 상태 명세화   
      등등 다양한 명세화를 모델링을 통해 할 수 있다. 이러한 명세화를 통해 개발 시스템의 범위를 보다 정확히 이해할 수 있다.
  3. 개발할 시스템 구축에 대한 기초를 마련할 수 있다.

<h3>객체지향 모델링 언어</h3>

* 모델링 기법 역시 처음에는 절차지향에 기반을 둔 구조적 모델링 기법이 사용되었다. 그러나 이 구조적 모델링 기법은 개발되는 산출물들 간의 연계성이   
  제대로 반영되지 않을 뿐만 아니라, 모델링 단계를 통해 개발된 모델들이 구현단계에 필요한 입력물의 기능을 거의 반영하지 못했다.

* 이러한 구조적 모델링 기법이 갖는 한계점을 극복하기 위해 새롭게 등장한 모델링 패러다임이 __객체 지향 모델링 기법__ 이다. 충분한 결의를 통해   
  개발된 것이 바로 `UML(Unified Modeling Language)`이다.
<hr/>

<h2>객체지향 언어</h2>

<h3>클래스</h3>

* Java 언어에서는 객체 지향 개념의 클래스를 `class`라는 키워드를 통해서 클래스를 구현할 수 있도록 제공하고 있다. 또한 이 클래스를 구성하는 속성,   
  클래스의 행위 또는 기능을 멤버 함수 형태로 제공한다. 그리고 각각의 변수나 함수들에 대해서 정보은닉의 장치로 `private`, `protected`, `public`   
  등의 접근 권한자(Access Specifier)라는 장치를 통해 제공하고 있다.

<h3>객체</h3>

* Java에서는 클래스로부터 객체를 생성하기 위해 `new` 연산자와 객체 생성함수 또는 생성자(Constructor)를 통해 객체를 생성할 수 있도록 한다.   
  또한 생성된 객체 단위로 특정 객체에 서비스를 요청하는 메시지를 전송할 수 있도록 하고 있다.

<h3>상속</h3>

* Java에서는 객체지향 개념의 상속 개념을 `extends` 키워드를 통해 구현할 수 있도록 한다. 이 예약어를 통해서 일반 클래스 간의 상속 관계, 추상 클래스와   
  일반 클래스간의 상속 관계, 그리고 인터페이스 간의 상속 관계를 표현할 수 있도록 하고 있다. 상속 관계를 통해 함수 오버로딩, 오버라이딩 메커니즘을   
  실현할 수 있도록 제공하고 있다.

<h3>추상 클래스</h3>

* Java에서는 추상 클래스를 구현하기 위해 클래스명 앞에 `abstract` 키워드를 선언함으로서 해당 클래스가 추상 클래스임을 나타낸다. 또한 추상 클래스 내의   
  추상 함수를 표현하기 위해서 함수명 앞에도 `abstract` 키워드를 붙임으로써 일반 함수와 구별할 수 있다. 상속 관계에 있는 하위 클래스들에서 이 추상   
  함수를 구현함으로써 함수 오버라이딩을 구현할 수 있도록 하고 있다.

<h3>인터페이스</h3>

* Java에서는 객체 지향 개념의 인터페이스를 구현하기 위한 장치로 `interface` 키워드를 통해 인터페이스를 정의할 수 있도록 하고 있다. 인터페이스는   
  함수들의 집합이므로, 인터페이스에 있는 모든 함수들은 `public`으로만 선언하도록 하며, 인터페이스에 선언된 함수들은 모두 클래스를 통해서만   
  구현할 수 있도록 하고 있다. 구현 클래스는 `implements` 키워드를 사용하므로써 특정 인터페이스를 구현한다고 표현한다. Java8부터는 인터페이스에서   
  `default` 접근제한자를 가지는 메소드에는 직접 메소드의 몸체를 구현할 수 있게 되었다.

<h3>컴포넌트</h3>

* Java에서는 `JavaBean`과 `EJB(Enterprise Java Bean)`라는 2개의 기술 플랫폼을 통해 컴포넌트를 구현할 수 있는 장치를 제공하고 있다. 이 2개의   
  플랫폼에서는 컴포넌트 개념들을 반영하여 인터페이스와 인터페이스를 구현하는 컴포넌트 클래스 등에 대한 규약들을 지정하고 있다.
<hr/>