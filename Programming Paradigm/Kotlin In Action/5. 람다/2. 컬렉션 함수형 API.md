# 컬렉션 함수형 API

- 함수형 프로그래밍 스타일을 사용하면 컬렉션을 다룰 때 편리하다. 대부분의 작업에 라이브러리 함수를  
  활용할 수 있고, 그로 인해 코드를 아주 간결하게 만들 수 있다.

## `filter()`, `map()`

- `filter()`, `map()`은 컬렉션을 활용할 때 기반이 되는 함수다. 대부분의 컬렉션 연산을 이  
  두 함수를 통해 표현할 수 있다.

- 계속 봐왔던 `Person`을 사용해보자.

```kt
data class Person(val name: String, val age: Int)
```

- `filter()` 함수는 컬렉션을 순회하면서 주어진 람다에 각 원소를 넘겨 람다가 true를 반환하는  
  원소만 모은다.

```kt
val list = listOf(1, 2, 3, 4)
println(list.filter { it % 2 == 0 })
// [2, 4]
```

- 결과는 입력 컬렉션의 원소 중에서 주어진 predicate를 만족하는 원소만으로 이뤄진 새로운 컬렉션이다.

- 30살 이상인 사람만 필요하다면 `filter()`를 사용한다.

```kt
val people = listOf(Person("Alice", 29), Person("Bob", 31))
println(people.filter { it.age >= 30 })
// [Person(name=Bob, age=31)]
```

- `filter()`는 컬렉션에서 원치 않는 원소를 제거한다. 하지만 `filter()`는 원소를 변환할 수는 없다.  
  원소를 변환하려면 `map()`을 사용해야 한다.

- `map()`은 주어진 람다를 컬렉션의 각 원소에 적용한 결과를 모아서 새로운 컬렉션을 만든다.  
  아래처럼 하면 숫자로 이뤄진 리스트를 각 숫자의 제곱이 모인 리스트로 바꿀 수 있다.

```kt
val list = listOf(1, 2, 3, 4)
println(list.map { it * it })
// [1, 4, 9, 16]
```

- 결과는 원본 리스트와 개수는 같지만, 각 원소는 주어진 람다에 따라 변환된 새로운 컬렉션이다.

- `Person`의 리스트가 아니라 name의 리스트를 출력하고 싶다면 `map()`으로 아래처럼 간략히 할 수 있다.

```kt
val people = listOf(Person("Alice", 29), Person("Bob", 31))
println(people.map { it.name })
// [Alice, Bob]
```

- 위 예시를 멤버 참조를 이용해 더 멋지게 작성할 수도 있다.

```kt
people.map(Person::name)
```

- 위 예시 코드에서 `people.filter { it.age >= 30 }`은 `people.filter({ it.age >= 30})`과 같으므로  
  전체 식은 `people.filter({ it.age >= 30}).map(Person::name)`으로 해석된다.

- 이제 이 목록에서 가장 나이가 많은 사람의 이름을 알고 싶다 하자. 먼저 목록에 있는 사람들의 나이 최대값을 구하고,  
  나이가 그 최대값과 같은 모든 사람을 반환하면 된다.

```kt
people.filter { it.age == people.maxBy(Person::age)!!.age }
```

- 이 코드는 목록에서 최대값을 구하는 작업을 계속 반복한다는 단점이 있다. 만약 목록의 원소가 100개라면  
  100번 최대값 연산을 수행한다.

- 아래는 이를 좀 더 개선해 최대값을 한 번만 계산하게 만든 코드다.

```kt
val maxAge = people.maxBy(Person::age)!!.age
people.filter { it.age == maxAge }
```

- 꼭 필요하지 않은 경우, 굳이 계산을 반복하지 않아야 한다. 람다를 인자로 받는 함수에 람다를 넘기면 겉으로  
  볼 때는 단순해 보이는 식이 내부 로직의 복잡도로 인해 실제로는 엄청나게 불합리한 계산식이 될 때가 있다.

- `filter()`와 변환 함수를 `Map`에 적용할 수도 있다.

```kt
val numbers = mapOf(0 to "zero", 1 to "one")
println(numbers.mapValues { it.value.toUpperCase() })
// {0=ZERO, 1=ONE}
```

- `Map`의 경우 key와 value를 처리하는 함수가 따로 존재한다. `filterKeys()`와 `mapKeys()`는 key를  
  걸러내거나 변환하고, `filterValues()`와 `mapValues()`는 value를 걸러내거나 변환한다.

<hr/>

## all
