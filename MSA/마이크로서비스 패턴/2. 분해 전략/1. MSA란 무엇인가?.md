# 마이크로서비스 아키텍쳐란 무엇인가?

- MSA의 핵심 사상은 **기능 분해**이다. 대규모 단일 애플리케이션을 개발하는 대신 애플리케이션을 여러 개의  
  서비스로 구성하는 것이다. MSA 자체를 기능 분해라고 볼 수도 있지만, 몇 가지 의문점이 생기기 마련이다.

  - MSA는 과거의 소프트웨어 아키텍쳐 개념과 어떤 연관성이 있을까?
  - 서비스란 무엇이고, 그 크기는 어느 정도가 적당할까?

- 소프트웨어 아키텍쳐는 구성 요소 및 그들 간의 의존 관계로 묶인 고수준의 구조물이다.  
  애플리케이션 아키텍쳐는 다차원적이므로 기술하는 방법도 다양하다.  
  아키텍쳐가 중요한 이유는 소프트웨어의 품질 속성, 즉 _~성(~ilities)_ 로 끝나는 지표가  
  아키텍쳐에 의해 결정되기 때문이다. 예전에는 확장성, 신뢰성, 보안 등이 아키텍쳐의 목표였지만  
  이제 신속, 안전하게 소프트웨어를 전달하는 능력도 매우 중요하다.

- MSA는 관리성, 테스트성, 배포성이 높은 애플리케이션을 구축하는 아키텍쳐 스타일이다.

<h2>소프트웨어 아키텍쳐의 정의</h2>

- 소프트웨어 아키텍쳐를 정의하는 문구는 다양하다.  
  그 중, 저자는 아래의 정의를 택했다.

> 컴퓨팅 시스템의 소프트웨어 아키텍쳐는 소프트웨어 엘리먼트(element)와 그들 간의 관계,  
> 그리고 이 둘의 속성(property)으로 구성된 시스템을 추론하는 데 필요한 구조(structure)의 잡합이다.

- 다소 추상적인 문구지만, 핵심은 애플리케이션 아키텍쳐가 여러 부분들(element)로의 분해와 이런 부분들의  
  관계(연관성)이라는 것이다. 분해가 중요한 이유는 다음과 같다.

  - 업무와 지식을 분리한다. 덕분에 전문 지식을 보유한 사람 또는 여러 팀이 함께 생산적으로 애플리케이션  
    작업을 할 수 있다.

  - 소프트웨어 엘리먼트가 어떻게 상호 작용하는지 밝힌다.

<h3>소프트웨어 아키텍쳐의 4+1 뷰 모델</h3>

- 건물과 마찬가지로 애플리케이션 또한 아키텍쳐를 바라보는 관점이 다양하다.

- **4+1 뷰 모델**은 소프트웨어 아키텍쳐를 바라보는 상이한 4개의 뷰를 정의한다.  
  각 뷰는 아키텍쳐의 특정한 측면을 기술하고, 특정 소프트웨어 엘리먼트와 그들 사이의 관계로 구성된다.  
  각 뷰의 목적은 아래와 같다.

  - **논리 뷰(Logical view)** : 개발자가 작성한 소프트웨어 엘리먼트, 객체지향 언어라면 클래스, 패키지가  
    해당되며 결국 상속(inheritance), 연관(association), 의존(depends-on)등 클래스와 패키지의 관계를 의미한다.

  - **구현 뷰(Implementation view)** : 빌드 시스템의 결과물로 모듈(패키징된 코드)과  
    컴포넌트(하나 이상의 모듈로 구성된 실행, 배포 가능 단위)로 구성된다. Java에서 모듈은 보통 jar 파일,  
    컴포넌트는 war 파일이나 실행 가능한 jar 파일이다.  
    모듈 간의 의존성과 컴포넌트, 모듈 간의 조합 관계도 이 뷰에 포함된다.

  - **프로세스 뷰(Process view)** : 런타임 컴포넌트로 각 엘리먼트는 개별 프로세스이며,  
    IPC는 프로세스 간의 관계를 나타낸다.

  - **배포 뷰(Deployment view)** : 프로세스가 머신에 매핑되는 방법으로, 이 뷰의 엘리먼트는 물리 또는 가상 머신 및  
    프로세스이며, 머신 간의 관계가 바로 네트워킹이다. 프로세스와 머신 사이의 관계도 이 뷰에서 기술된다.

- 4개의 뷰 외에도 (4+1 모델의 +1에 해당하는 뷰) 뷰를 구동시키는 시나리오가 있다.  
  각 시나리오는 특정 뷰 내에서 얼마나 다양한 아키텍쳐 요소가 협동하여 요청을 처리하는지 기술한다.  
  가령 논리 뷰의 시나리오는 클래스가 협동하는 방법을, 프로세스 뷰의 시나리오는 프로세스가 서로 어떻게 협동하는지 나타낸다.

- 4+1 뷰 모델은 애플리케이션 아키텍쳐를 명쾌하게 표현하는 수단이다.  
  4개의 뷰는 중요한 아키텍쳐 측면을, 시나리오는 뷰의 여러 엘리먼트가 협동하는 과정을 명시한다.

<hr/>

<h2>아키텍쳐의 중요성</h2>

- 애플리케이션 요건은 크게 두 가지 종류로 나타낸다.  
  첫째, 애플리케이션이 할 일을 정의한 **기능 요건**이 있다. 보통 use case나 user story 포맷으로 기술하는데,  
  이 기능 요건과 아키텍쳐는 거의 무관하다. 기능 요건은 어느 아키텍쳐이든 구현할 수 있기 때문이다.  
  둘째, 이른바 _~성_ 으로 끝나는 **서비스 품질 요건**이 있다. 아키텍쳐는 바로 이 요건을 충족시킬 수 있게  
  설계해야 하므로 매우 중요하다. 서비스 품질 요건은 확장성, 신뢰성 같은 런타임 품질 외에도 관리성, 테스트성, 배포성 처럼  
  개발 시점의 품질도 해당된다. 애플리케이션 아키텍쳐를 어떻게 선택하느냐에 따라 이런 품질 요건을 얼마나 충족할 수 있을지가 결정된다.

<hr/>

<h2>아키텍쳐 스타일 개요</h2>

- 실제 건물 아키텍쳐는 정해진 양식을 따르는 경우가 대부분이다.  
  이런 양식은 각 건물의 특성과 자재를 좌우하는 설계 결정의 모음집이라고 볼 수 있다.  
  아키텍쳐 스타일 개념은 소프트웨어에도 그대로 적용된다.

> 아키텍쳐 스타일은 체계적인 조직의 관점에서 시스템 군을 정의한다.  
> 아키텍쳐 스타일은 그 스타일로 만든 인스턴스에서 사용 가능한 커넥터(connector)와  
> vocabulary, 그리고 이들을 조합할 수 있는 제약 조건(constraint)을 결정한다.

- 특정 아키텍쳐 스타일은 엘리먼트(컴포넌트)와 관게(커넥터)의 한정된 팔레트(사용 범위)를 제공하며,  
  이를 토대로 애플리케이션 아키텍쳐의 뷰를 정의할 수 있다.  
  애플리케이션은 대부분 아키텍쳐 스타일을 조합해서 사용한다.  
  모놀리틱 아키텍쳐도 구현 뷰를 하나의 실행, 배포 가능한 컴포넌트로 구성한 아키텍쳐 스타일이라 할 수 있다.  
  MSA는 애플리케이션을 느슨하게 결합된 여러 서비스로 구성하는 아키텍쳐 스타일이다.

<h3>계층화 아키텍쳐 스타일</h3>

- 소프트웨어 엘리먼트를 계층별로 구성하는 계층화 아키텍쳐(Layered architecture)는 전형적인 아키텍쳐 스타일이다.  
  계층마다 명확히 정의된 역할을 분담하며, 계층 간 의존성은 아키텍쳐로 제한한다. 따라서 어떤 계층은 바로 하위에 있는  
  계층에만 의존하거나, 하위에 위치한 어느 한 계층에 의존한다.

- 계층화 아키텍쳐는 4개의 뷰 모두에 적용할 수 있다.  
  익히 알려진 3계층 아키텍쳐가 바로 계층화 아키텍쳐를 논리 뷰에 적용한 사례로, 애플리케이션을 아래 3개 계층으로 구성한다.

  - Presentation layer(표현 계층): 사용자 인터페이스 또는 외부 API가 구현된 계층
  - Business logic layer(비즈니스 로직 계층): 비즈니스 로직이 구현된 계층
  - Persistence layer(영속화 계층): DB 상호 작용 로직이 구현된 계층

- 하지만 위와 같은 계층화 아키텍쳐는 몇 가지 중요한 흠이 있다.

  - **표현 계층이 하나뿐이다**: 애플리케이션을 호출하는 시스템이 하나 밖에 없을까?
  - **영속화 계층이 하나뿐이다**: 애플리케이션이 상호 작용하는 DB가 정말 하나 뿐일까?
  - **비즈니스 로직 계층을 영속화 계층에 의존하는 형태로 정의한다**: 이론적으로 이러한 의존성 때문에  
    DB 없이 비즈니스 로직만을 테스트하는 것은 불가능하다.

- 또 계층화 아키텍쳐는 잘 설계된 애플리케이션에서 의존성을 잘못 나타내는 문제도 있다.  
  일반적으로 비즈니스 로직 계층은 인터페이스나 데이터 접근 메소드가 정의된 인터페이스 레포지토리를 정의하고,  
  영속화 계층에서 이 레포지토리 인터페이스를 구현한 DAO 클래스를 정의한다.  
  결국 실제 의존성이 계층화 아키텍쳐에 기술된 것과는 정반대이다.

> 기술된 것: 비즈니스 로직 계층(상위)이 영속화 계층(하위)에 의존하는 형태  
> 실제 의존성: 영속화 계층이 비즈니스 로직 계층에서 제공하는 인터페이스를 구현함으로써  
> 거꾸로 영속화 계층이 비즈니스 로직 계층에 의존한다.

- 이러한 문제점을 해결하고자 Hexagonal Architecture이 고안되었다.

<h3>Hexagonal Architecture(육각형 아키텍쳐)</h3>

- Hexagonal 아키텍쳐는 논리 뷰를 비즈니스 로직 중심으로 구성화는 계층화 아키텍쳐 스타일의 대안이다.  
  애플리케이션에 대한 표현 계층 대신 비즈니스 로직을 호출하여 외부에서 들어오는 요청을 처리하는 Inbound Adapter들과  
  영속화 계층 대신 비즈니스 로직에 의해 호출되고 외부 애플리케이션을 호출하는 Outbound Adapter들을 둔다.  
  비즈니스 로직이 어댑터에 전혀 의존하지 않는다는 것이 이 아키텍쳐의 가장 중요한 특징이다.  
  외려 어댑터가 비즈니스 로직에 의존한다.

- 비즈니스 로직에는 하나 이상의 Port가 있다. 포트는 비즈니스 로직이 자신의 외부 세계와 상호 작용하는 방법이 정의된  
  작업(operation)이다. 가령 Java의 경우, 포트는 인터페이스가 된다. 포트는 Inbound Port, Outbound Port로  
  총 2가지가 있다. Inbound port는 비즈니스 로직이 표출된 API로서, 외부 애플리케이션은 이 API를 통해 비즈니스 로직을  
  호출한다. 반대로 Outbound port는 비즈니스 로직이 외부 시스템을 호출하는 방법에 관한 것이다.

- 어댑터는 비즈니스 로직을 감싸고 있다. 포트 처럼 어댑터도 Inbound Adapter, Outbound Adapter로 2가지가 있다.  
  Inbound 어댑터는 외부에서 들어오는 요청을 Inbound 포트를 호출해서 처리한다. (ex. REST Endpoint, Spring Web MVC..).  
  동일한 Inbound 포트를 여러 Inbound 어댑터가 호출할 수도 있다.

- Outbound 어댑터는 비즈니스 로직에서 들어온 요청을 외부 애플리케이션, 서비스를 호출해서 처리한다.(ex. DB 작업이 구현된 DAO 클래스..).  
  Outbound 어댑터는 event를 발행하기도 한다.

- Hexagonal 아키텍쳐 스타일의 가장 큰 장점은 비즈니스 로직에 있던 Presentation, Persistance 로직이 어댑터와 분리되었기 때문에  
  **비즈니스 로직이 Presentation, Persistance 로직 어디에도 의존하지 않는다는 점** 이다.

- 이렇게 분리하면 비즈니스 로직만 테스트하기도 쉽고, 현대 애플리케이션 아키텍쳐를 좀 더 정확하게 반영할 수 있다.  
  제각기 특정한 API나 UI가 구현된 Inbound 어댑터가 비즈니스 로직을 호출하고, 비즈니스 로직은 다양한 외부 시스템을  
  호출하는 Outbound 어댑터를 호출하는 구조이다. Hexagonal 아키텍쳐는 MSA를 이루는 각 서비스 아키텍쳐를 기술하는 최고의 방법이다.

- Hexagonal Architecture가 Layered Architecture의 문제점을 어떻게 해결하는지는 <a href="https://github.com/sang-w0o/Study/blob/master/MSA/DDD%EB%A1%9C%20%EC%A7%84%ED%96%89%ED%95%98%EB%8A%94%20MSA/3.2%20%ED%97%A5%EC%82%AC%EA%B3%A0%EB%82%A0%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90%EC%99%80%20%ED%81%B4%EB%A6%B0%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90.md">여기</a>에서 추가적으로 볼 수 있다.

<hr/>

<h2>MSA는 일종의 아키텍쳐 스타일이다</h2>

- 4+1 뷰 모델과 아키텍쳐 스타일을 보았으니, 이제 모놀리틱 / MSA를 정의해보자.  
  먼저 모놀리틱 아키텍쳐는 구현 뷰를 단일 컴포넌트(하나의 실행 파일 또는 WAR 파일)로 구성한 아키텍쳐 스타일이다.  
  다른 뷰는 일체 등장하지 않는다. 모놀리틱 애플리케이션은 Hexagonal 아키텍쳐 방식으로 구성한 논리 뷰를 가질 수 있다.

- MSA 또한 일종의 아키텍쳐 스타일이다. 하지만 구현 뷰를 다수의 컴포넌트(여러 실행 파일 또는 WAR 파일)로 구성한다는  
  차이점이 있다. 여기서 컴포넌트는 곧 서비스가 되며, 각 서비스는 자체적인 논리 뷰 아키텍쳐를 가지고 있다.  
  전형적인 Hexagonal 아키텍쳐를 가진다. 커넥터는 이러한 서비스들이 서로 협동할 수 있게끔 해주는 통신 프로토콜이다.

<hr/>

<h2>서비스란 무엇인가?</h2>

- 서비스는 어떤 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트이다.  
  서비스는 클라이언트가 자신이 제공하는 기능(functionality)에 접근할 수 있도록 커맨드, 쿼리, 이벤트로 구성된  
  API를 제공한다. 서비스 작업은 크게 Command(명령, CUD), Query(조회, 쿼리, R)로 나뉜다.  
  물론 클라이언트가 소비하는 이벤트를 발행하기도 한다.

- 서비스 API는 내부 구현 상세를 캡슐화한다. 모놀리틱과 달리 개발자는 API를 우회하여 서비스에 접근하는 코드를 작성할 수 없으므로  
  MSA에서 애플리케이션 모듈성은 보장된다.

- 각각의 마이크로서비스는 자체 아키텍쳐를 가지고 있기에 기술 스택을 독자적으로 구축할 수 있지만, 대부분 Hexagonal 아키텍쳐를 취한다.  
  API는 서비스에 구현된 비즈니스 로직과 소통하는 어댑터를 이용하여 구현한다. 작업 어댑터(Operations adapter)는 비즈니스 로직을  
  호출하고 이벤트 어댑터(Events adapter)는 비즈니스 로직이 내어준 이벤트를 발행한다.

- 서비스 구현 뷰는 독립적으로 움직이는(Standalone) 프로세스, 컨테이너 내부에서 실행되는 웹 애플리케이션, OSGI bundle,  
  Serverless cloud 기능 등 다양한 컴포넌트를 사용할 수 있다. 물론 서비스마다 자체 API를 갖고 독립적인 배포가 가능해야 하는  
  핵심 요건은 동일하다.

<hr/>

<h2>느슨한 결합</h2>

- 느슨하게 결합된 서비스는 MSA의 중요 특성 중 하나이다.  
  서비스는 구현 코드를 감싼 API를 통해서만 상호 작용하기에 클라이언트에 영향을 끼치지 않고 서비스 내부 구현 코드를 바꿀 수 있다.  
  느슨하게 결합된 서비스는 유지보수성, 테스트성을 높이고 애플리케이션 개발 시간을 단축하는 효과가 있다.  
  무엇보다 개발자가 서비스를 이해하고, 변경하고 테스트하기가 더 쉽다.

- 서비스는 느슨하게 결합되고 API를 통해서만 동작하기에 서비스가 직접 DB와 통신하는 일은 불가하다.  
  또 클래스 필드 같은 서비스의 영속적 데이터는 반드시 private으로 유지해야 한다.  
  이렇게 해야 개발자가 자신이 맡은 서비스의 DB 스키마를 변경할 때 다른 서비스 개발자와 조율하느라 시간을 허비하지 않는다.  
  서비스가 DB 테이블을 서로 공유하지 않기 때문에 런타임 격리(Runtime Isolation)도 향상된다.  
  어떤 서비스가 DB Lock을 획득하여 다른 서비스를 blocking하는 일 자체가 불가하다.  
  물론 DB를 공유하지 않기에 여러 서비스에 걸쳐 데이터를 쿼리하고, 일관성을 유지하는 일은 더 복잡해지는 단점이 있다.

<hr/>

<h2>공유 라이브러리의 역할</h2>

- 코드 중복 방지를 위해 여러 애플리케이션에서 재사용 가능한 기능을 라이브러리(모듈)로 패키징하는 것은 개발자에게 당연한 일이다.  
  그래서 MSA에서도 공유 라이브러리(Shared Library)를 사용하고픈 유혹에 빠지기 쉬운데, 서비스 코드 중복을 줄이는 것은 좋지만  
  의도치 않은 서비스 간의 결합도를 유발하지 않도록 조심해야 한다.

- 예를 들어, `Order`라는 비즈니스 객체를 여러 서비스가 업데이트해야 하는 상황을 생각해보자.  
  필요한 공용 기능을 라이브러리 하나에 모두 패키징해 배포하면, 코드 중복은 없겠지만 만약 나중에 요건이 수정되어  
  `Order`에 영향을 주는 방향으로 변경되면 어떻게 될까?  
  정답은 관련 서비스를 일제히 다시 빌드해서 재배포해야 한다는 것이다. 이렇게 변경 가능성이 조금이라도 있는 기능이라면  
  별도의 서비스로 구현하는 것이 낫다.

<hr/>

<h2>서비스 규모는 별로 중요하지 않다</h2>

- 마이크로서비스라는 용어는 *Micro*라는 단어 때문에 왠지 서비스를 아주 작게 만들어야 할 것 같은 느낌을 준다.  
  하지만 크기보다는 **팀이 가장 짧은 시간에 다른 팀과 협동하는 부분은 최소로 하여 개발 가능한 서비스를 설계**해야 한다.

- MSA는 작고, 느슨하게 결합된 서비스로 애플리케이션을 구성하기 때문에 유지보수성, 테스트성, 배포성 등 개발 단계의  
  품질 속성이 개선된다. 또 조직 차원에서 소프트웨어를 더 빠르게 개발할 수도 있고, 확장성 또한 확장된다.

<hr/>
