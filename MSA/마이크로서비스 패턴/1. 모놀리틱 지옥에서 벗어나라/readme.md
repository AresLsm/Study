# 모놀리틱 지옥에서 벗어나라

<h2>서서히 모놀리틱 지옥에 빠져들다</h2>

<h3>모놀리틱 아키텍쳐의 장점</h3>

- 개발이 간단하다: IDE 등 개발 툴은 단일 애플리케이션 구축에 초점이 맞추어져 있다.
- 애플리케이션을 쉽게 변경할 수 있다: 코드, DB 스키마를 변경해서 빌드, 배포하기 용이하다.
- 테스트하기 쉽다
- 배포하기 쉽다
- 확장하기 쉽다: Load balancer의 뒷면에 애플리케이션 인스턴스를 여러 개 실행할 수 있다.

<h3>모놀리틱 지옥의 실상</h3>

- 모놀리틱 아키텍쳐는 근본적인 한계점이 있다. 덩치가 계속 커지는 애플리케이션은 모놀리틱 아키텍쳐라는 옷이  
  더 이상 맞지 않게 커진다. 개발 팀이 sprint를 할 때마다 추가 구현할 기능이 늘어났고, 그만큼 코드베이스와  
  관리 오버헤드 역시 증가한다.

- 하나의 애플리케이션에 계속해서 기능을 추가하다보면, 초반에는 소수였던 개발 팀도 나중에는 기능 분야가 특화된  
  scrum 팀들로 분리될 때, 코드가 너무 많아 버그를 고치고 새로운 기능을 정확하게 구현해가기 힘들고,  
  시간도 오래 걸린다. 또한 당연하게도 빌드 시간도 계속해서 길어질 것이고, 이는 곧 개발자의 생산성을 떨어뜨린다.

- 애플리케이션은 모듈 단위로 분리할 수 있는데, 모듈 A는 인메모리 데이터베이스를 사용하기 때문에 메모리 성능이 좋아야 하고,  
  모듈 B는 CPU를 많이 소모해서 CPU 코어 수가 많은 서버에 배포하는 것이 좋다고 해보자. 이렇게 같은 애플리케이션이라도  
  리소스 요건이 상이한 모듈이 존재하게 되면 서버 구성 시 리소스 배분에 신경 써야 하며, 이는 확장을 어렵게 만든다.

- 애플리케이션 자체가 워낙 덩치가 커서 철저하게 테스트하기 어렵고, 이는 곧 프로덕션에 버그가 발생할 가능성을 높인다.

<hr/>

<h2>MSA가 답이다</h2>

- 소프트웨어 아키텍쳐는 기능 요건과는 거의 무관하다. 애플리케이션의 기능 요건(Functional requirement), 즉 use case는  
  그 어느 아키텍쳐든 구현할 수 있다. 그러나 아키텍쳐는 **~성(~ibility)으로 끝나는 갖가지 서비스 품질 요건에 영향을 미친다**.  
  예를 들어, 소프트웨어의 관리성(maintainability), 확장성(extensibility), 테스트성(testability) 등이 있다.

<h3>확장 큐브와 마이크로서비스</h3>

- MSA의 여러 가지 정의론 중, 확장 큐브를 생각해보자.

> 확장 큐브는 애플리케이션을 확장하는 세 가지 방법을 정의한다.
> X축 확장은 동일한 다중 인스턴스에 들어온 요청을 부하 분산한다.  
> Z축 확장은 요청의 속성에 따라 요청을 라우팅하며, Y축 확장은 애플리케이션을  
> 기능에 따라 서비스로 분해한다.

- 이 모델에 따르면 애플리케이션을 X, Y, Z의 3가지 방향으로 확장시킬 수 있다.

<h4>X축 확장: 다중 인스턴스에 고루 요청 분산</h4>

- X축 확장은 일반적인 모놀리틱 애플리케이션의 확장 수단이다.  
  Load Balancer의 뒷단에 애플리케이션의 인스턴스를 N개 띄워 놓고 Load balancer는  
  들어온 요청을 이들 인스턴스에 골고루 분배한다. 이는 애플리케이션의 능력과 가용성을 개선할 수 있는 좋은 방법이다.

<h4>Z축 확장: 요청 속성별 라우팅</h4>

- 모놀리틱 애플리케이션의 다중 인스턴스를 실행하는 것은 X축 확장과 같지만, 인스턴스별로 주어진 데이터 하위 집합(subset)만  
  처리하도록 설정하는 방법이다. 인스턴스의 앞면에 위치한 라우터는 요청의 속성에 알맞은 인스턴스로 요청을 라우팅한다.  
  userId에 따라 요청을 분산하는 경우를 생각해보자. 각 애플리케이션 인스턴스는 자신에게 배정된 사용자 하위 집합만 처리한다.  
  라우터는 요청 헤더 중 Authorization에 포함된 userId를 보고 N개의 동일한 애플리케이션 인스턴스 중 하나를 선택한다.  
  이렇게 Z축 확장은 애플리케이션을 확장해서 증가하는 트랜잭션 및 데이터 볼륨을 처리하기 좋은 수단이다.  
  여러 개의 인스턴스 중 1번 인스턴스는 userId가 a-g인 요청을 받고, 2번 인스턴스는 userId가 h-n인 요청을 받고,  
  3번 인스턴스는 o-z인 요청을 처리한다.

<h4>Y축 확장: 기능에 따라 애플리케이션을 서비스로 분해</h4>

- X, Z축 확장을 하면 애플리케이션 능력과 가용성은 개선되지만, 애플리케이션이 점점 복잡해지는 문제는 해결되지 않는다.  
  따라서 Y축 확장, 즉 기능 분해가 필요하다.

- 쇼핑몰을 생각해보자. 하나의 서비스를 주문 관리, 고객 관리 등 지엽적 기능이 구현된 미니 애플리케이션으로 나눌 수 있을 것이다.  
  서비스에 따라 X, Z축 확장도 가능하다.

- 이렇게 MSA는 고수준에서 바라보면 하나의 애플리케이션을 여러 서비스로 기능 분해하는 아키텍쳐 스타일이다.  
  여기서 중요한 것은 크기가 아니라, 각 서비스가 집중(focus), 응집(cohesive)된 책임을 맡고 있다는 사실이다.

<h3>마이크로서비스의 모듈성</h3>

- 모듈성(Modularity)는 크고 복잡한 애플리케이션을 개발할 때 꼭 필요한 특성이다.  
  요즘 애플리케이션은 규모가 방대하고 내용이 너무 복잡해서 어느 한 개인이 전부 다 이해하고 개발할 수 없다.  
  따라서 여러 사람들이 이해하고 개발할 수 있게끔 애플리케이션을 여러 모듈로 분해한다.

- MSA에서는 모듈성의 단위가 서비스가 된다. 각 서비스는 다른 서비스가 함부로 규칙을 거기고 침투하지 못하게끔  
  API라는 경계선을 갖고 있어서 다른 서비스 API를 우회하여 그 내부 클래스에 마음대로 접근할 수 없다.  
  따라서 시간이 지나도 애플리케이션의 모듈성을 유지하기에 훨씬 수월하다.  
  또 서비스를 각각 독립적으로 배포, 확장할 수 있는 부가적인 장점도 있다.

<h3>서비스마다 DB가 따로 있다</h3>

- 마이크로서비스는 서로 느슨하게 결합되어 있고, **오직 API를 통해서만 통신** 이 가능하다.  
  이렇게 느슨하게 결합된 서비스는 각각 자체 DB를 갖게 된다.  
  서비스마다 다른 DB를 사용한다면 개발 단계에서 다른 서비스 개발자와 일일이 협의하지 않고도 개발자 본인이 담당한  
  서비스 스키마를 변경할 수 있다. 런타임에 서비스는 서로 완전히 분리되어 있기 때문에, 이를테면 다른 서비스가 DB Lock을  
  획득해 서비스를 blocking하는 일은 일어나지 않는다.

<h3>마이크로서비스 아키텍쳐와 SOA</h3>

- SOA(Self Oriented Architecture)와 MSA는 아래의 근본적인 차이점들이 있다.

<h4>서비스 간의 통신</h4>

- SOA 애플리케이션은 SOAP 및 WS 표준 등 무거운 기술들을 주로 사용하고, 서비스를 통합하는 비즈니스와  
  메시지 처리 로직이 포함된 ESB라는 Smart Pipe를 사용한다.  
  반면, MSA에서 애플리케이션은 대개 가벼운 오픈 소스 기술을 사용하며, Message Broker, REST, gRPC와 같이  
  가벼운 프로토콜을 위주의 Dumb Pipe를 사용하여 서비스 간의 통신을 진행한다.

<h4>데이터</h4>

- SOA는 보통 전역 데이터 모델링을 하고, DB도 공유하지만 MSA는 각각 자체의 DB, 자체의 도메인 모델을 소유한다.

<h4>서비스의 크기</h4>

- SOA는 대부분 크고 복잡한 모놀리틱 애플리케이션들을 통합하는 용도로 사용된다.  
  마이크로서비스라고 해서 항상 작은 것은 아니지만, 대체로 SOA보다는 훨씬 규모가 작다.  
  SOA 애플리케이션은 덩치가 큰 서비스 몇 개로 구성되지만, 마이크로서비스 애플리케이션은 이보다 작은  
  수십 ~ 수백개의 서비스로 구성된다.

<hr/>

<h2>MSA의 장단점</h2>

<h3>MSA의 장점</h3>

- 마이크로서비스 아키텍처는 아래와 같은 장점들이 있다.

<h4>크고 복잡한 애플리케이션의 지속적인 전달, 배포</h4>

- MSA로 구축하면 크고 복잡한 애플리케이션을 지속적으로 전달 및 배포할 수 있다.  
  이러한 Continous Delivery는 소프트웨어를 빠르게, 자주, 확실하게 전달하는 관례이다.  
  MSA는 아래의 3가지 방법으로 CD를 실현한다.

  - 테스트성: CD를 하려면 자동화 테스트가 꼭 필요하다. 마이크로서비스는 상대적으로 크기가 작아서  
    자동화 테스트를 작성하기 쉽고, 더 빨리 실행되며, 애플리케이션 버그도 적은 편이다.
  - 배포성: 마이크로서비스는 독립적으로 배포할 수 있기에 개발자가 자신이 담당한 서비스 변경분을  
    배포할 때 굳이 다른 개발자와 협의할 필요가 없다.
  - 자율성, 느슨한 결합: 작은 팀이 여럿 결합된 기술 조직을 꾸려갈 수 있다.  
    팀별로 하나 이상의 관련 서비스를 개발, 배포하는 업무만 담당할 수 있고, 다른 팀과 독립적으로  
    개발, 배포, 확장할 수 있으므로 개발 속도는 더 빨라진다.

<h4>서비스가 작아 관리하기 용이하다</h4>

- 마이크로서비스는 비교적 크기가 작아서 개발자가 코드를 이해하기 쉽다.  
  코드베이스가 작으면 IDE도 느려지지 않으므로 개발 생산성도 올라가며, 덩치 큰 모놀리틱  
  애플리케이션보다 각 서비스를 시동하는 시간이 훨씬 빠르기 때문에 개발자가 작업 후  
  배포하는 과정 역시 더 빠르고 생산적이다.

<h4>서비스를 독립적으로 배포, 확장할 수 있다</h4>

- 마이크로서비스는 독립적으로 X축, Z축 확장을 할 수 있고, 서비스마다 상이한 리소스 요건에 맞추어  
  하드웨어에 배포할 수 있다. 리소스 요건이 전혀 다른(ex. CPU vs Memory) 컴포넌트를 무조건  
  함께 배포할 수 밖에 없었던 모놀리틱 아키텍쳐와는 큰 차이가 있다.

<h4>결함 격리가 잘 된다</h4>

- MSA는 결함 격리가 잘 된다. 가령 어느 서비스에서 메모리 누수가 발생하더라도 해당 서비스만  
  영향을 받고, 다른 서비스는 계속 정상 가동된다. 모놀리틱 아키텍쳐는 어느 한 곳이 고장나면  
  전체 시스템에 영향을 끼친다.

<h3>MSA의 단점</h3>

- MSA는 장점도 있지만, 단점 또한 분명히 있다.

<h4>딱 맞는 서비스를 찾기 쉽지 않다</h4>

- MSA에 맞게 시스템을 여러 서비스로 분해하는, 구체적으로 정립된 알고리즘은 따로 없다.  
  만약 시스템을 잘못 분해할 경우, 모놀리틱, MSA의 단점만 있는 분산 모놀리스를 구축하게 된다.  
  즉, 반드시 함께 배포해야 하는 결합도가 높은 서비스들로 이루어진 시스템이 만들어지는 것이다.

<h4>분산 시스템은 복잡하다</h4>

- 분산 시스템(Distributed System)이라는 또 다른 복잡성은 개발자가 감당해야 한다.  
  서비스 간 통신에 필수적인 IPC 역시 단순 메소드 호출보다는 복잡하며, 사용 불능 또는  
  latency가 긴 원격 서비스, 부분 실패한 서비스를 처리할 수 있게끔 설계해야 한다.

- 여러 서비스를 상대로 use case를 구현하려면 익숙지 않은 기술도 동원해야 한다.  
  특히 서비스마다 DB가 따로 있기 때문에 다중 DB에 접속하여 조회하고, 트랜잭션을  
  구현하는 일이 어렵다. 그래서 마이크로서비스 아키텍쳐는 Saga라는 기술로 서비스 간  
  데이터의 일관성을 유지한다. 또 단순 쿼리로는 여러 서비스에 있는 데이터를 조회할 수 없으므로  
  API를 조합하거나, CQRS View로 쿼리한다.

- 운영 복잡도 역시 증가하는데, 종류가 다른 서비스가 여러 개의 인스턴스로 떠 있으니 프로덕션에서  
  관리해야 할 가동부가 더 늘어난다.

<h4>여러 서비스에 걸친 공통 기능은 배포할 때 잘 살펴야 한다</h4>

- 여러 서비스에 걸친 기능을 배포할 때에는 여러 개발 팀 간에 세심한 조율이 필요할 수 있다.  
  그러므로 서비스 간 의존성에 따라 배포 계획을 빈틈없이 수립해야 한다.  
  이는 여러 컴포넌트를 쉽게 원자적으로 업데이트할 수 있는 모놀리틱 아키텍쳐와는 다소 차이가 있다.

<h4>도입 시기를 결정하기 어렵다</h4>

<hr/>

<h2>MSA 패턴 언어</h2>

- 아키텍쳐와 설계는 전부 결정하기 다름이다. 애플리케이션의 성격, 특성 등에 따라 모놀리틱 아키텍쳐가 맞을지,  
  MSA가 맞을지 결정하려면 수많은 trade off를 검토해야 하고, 그 결과 MSA를 선택했다면 그에 수반되는  
  갖가지 이슈도 해결해야 한다.

- 다양한 아키텍쳐와 설계 옵션을 기술하고 더 나은 결정을 내리는 좋은 방법은 패턴 언어를 사용하는 것이다.

<h3>패턴 및 패턴 언어</h3>

- **패턴**은 특정한 상황에서 발생한 문제에 대해 재사용 가능한 해법을 의미한다.  
  이는 실제로 소프트웨어 아키텍쳐 및 설계 분야에서 이미 검증된 유용한 아이디어이다.

- **패턴 언어**는 특정 영역 내부에서 문제를 해결하는 연관된 패턴의 집합이다.

- 패턴은 자신이 적용되는 맥락을 반드시 기술해야 한다는 점에서 가치가 크다.  
  패턴이 제시한 솔류션이 어떤 맥락에서는 통하지만, 또 다른 어떤 맥락에서는 전혀 통하지 않을 수도 있다는  
  생각 덕분에 더 나은 방법으로 기술을 논할 수 있게 되었다.

- 물론 패턴은 맥락을 고려하게 만드는 것 외에도, 매우 중요하지만 자주 간과되는 솔루션의 측면도 함께  
  기술하도록 강제한다는 점에서 효용성이 크다. 사용 패턴의 구조는 대략 강제 조항, 결과 맥락, 연관 패턴의 3개 부분으로 구성된다.

<h4>강제 조항: 문제해결을 위해 반드시 처리해야할 이슈</h4>

- 주어진 맥락에서 문제를 해결하고자 할 때 반드시 처리해야 할 강제 조항이다.  
  상충하는 강제 조항도 있기 때문에 모든 조항을 전부 충족할 수는 없고, 어느 조항이 더 중요한지는 맥락에 따라  
  다르기 때문에 우선순위를 정해야 한다. 예를 들어, 코드는 이해하기 쉬워야 하는 동시에 성능도 우수해야 한다고 해보자.  
  Reactive 스타일로 작성한 코드는 동기 코드보다 성능은 우수할 지 모르지만, 모르는 개발자가 이해하기에는 상대적으로  
  어렵다. 이렇게 강제 조항을 명시적으로 나열하면 어느 이슈를 해결해야 할지 명확해진다.

<h4>결과 맥락: 패턴 적용 결과</h4>

- 패턴을 적용한 결과를 `장점`, `단점`, `이슈`의 3가지로 기술하는 영역이다.

  - 장점: 패턴의 좋은 점(해결된 강제 조항 등)
  - 단점: 패턴의 나쁜 점(미해결 강제 조항 등)
  - 이슈: 패턴 적용 시 발생한 새로운 문제점

- 결과 맥락은 솔루션을 편견에 치우치지 않는, 좀 더 완전한 시야로 바라보게 해준다.  
  따라서 더 나은 설계 결정을 내릴 수 있다.

<h4>연관 패턴: 다섯 가지 관계 유형</h4>

- 한 패턴과 다른 패턴의 관계를 기술하는 영역으로, 5가지의 정류가 있다.

  - 선행자(Predecessor): 이 패턴을 필요하게 만든 선행 패턴.  
    가령 MSA 패턴은 모놀리틱 아키텍쳐 패턴을 제외한 나머지 패턴들의 선행자이다.
  - 후행자(Successor): 이 패턴으로 야기된 이슈들을 해결하는 패턴.  
    가령 MSA 패턴을 적용하려면 Service Discovery 패턴, Circuit Breaker 패턴 등의  
    후행자 패턴도 함께 적용해야 한다.
  - 대안(Alternative): 이 패턴의 대체 솔루션을 제공하는 패턴.  
    가령 모놀리틱 아키텍쳐 패턴과 MSA 패턴은 서로를 대신할 수 있는 애플리케이션 아키텍쳐링 수단이다.
  - 일반화(Generalization): 문제를 해결하는 일반적인 솔루션에 해당하는 패턴
  - 세분화(Specialization): 특정 패턴을 더 세부적으로 나타낸 형태

- 특정 영역의 문제를 해결하는 연관된 패턴들을 함께 묶어 명시적으로 기술하면, 어떻게 문제를  
  해결할 수 있는지 효과적으로 나타낼 수 있다.

- 여러 패턴을 연관 지어 패턴 언어라는 포맷으로 도출하고, 이 패턴 언어의 패턴을 사용하여  
  특정 문제를 해결할 수 있다.

<h3>MSA 패턴 언어 개요</h3>

- MSA 패턴 언어는 전체 애플리케이션을 MSA로 구성할 때 유용한 패턴의 모음집이다.  
  패턴 언어는 모놀리틱 아키텍처 및 MSA의 구조와 장단점을 기술하기 때문에 무엇보다 MSA를  
  사용하는 것이 옳은 일인지 결정할 때 요긴하다. 이렇게 검토한 결과 MSA가 적합한 것으로  
  판단되면 패턴 언어를 이용하여 다양한 아키텍쳐, 설계 이슈를 해결하고 효과적으로 활용할 수 있다.

- 패턴 언어는 여러 그룹의 패턴으로 구성된다. 그리고 패턴은 다시 3개 계층으로 분류된다.

  - 인프라 패턴: 주로 개발 영역 밖의 인프라 문제를 해결한다.
  - 애플리케이션 인프라: 개발에도 영향을 미치는 인프라 문제를 해결한다.
  - 애플리케이션 패턴: 개발자가 맞닥뜨리는 문제를 해결한다.

- 패턴은 해결하려는 문제의 종류별로 묶을 수 있는데, 주요 패턴 그룹을 하나씩 살펴보자.

<h4>애플리케이션을 여러 서비스로 분해하는 패턴</h4>

- 한 시스템을 여러 서비스로 분해하는 방법을 결정하는 것이 진짜 기술인데, 유용한 전략들이 많이 있다.  
  애플리케이션 아키텍쳐를 정의할 때 사용 가능한 두 가지 주요 분해 패턴으로는 _비즈니스 능력에 따라 분해_ 하거나,  
  _하위 도메인에 따라 분해_ 하는 등의 패턴이 있다.

<h4>통신 패턴</h4>

- MSA로 구축한 애플리케이션은 기본적으로 분산 시스템이기 때문에, IPC가 매우 중요하다.  
  그러므로 서비스 상호 간, 그리고 외부 세계와 어떻게 통신하면 좋을지 아키텍쳐 및 설계 관점에서  
  다양한 의사 결정을 해야 한다. 통신 패턴은 크게 5개 그룹으로 정리할 수 있다.

  - 통신 스타일: 어떤 종류의 IPC를 사용하는가?
  - Discovery: 서비스 클라이언트(ex.http request)는 서비스 인스턴스의 IP 주소를 어떻게 가져올까?
  - 신뢰성: 서비스 불능 시 서비스 간 통신의 신뢰성은 어떻게 보장되는가?
  - Transactional Messaging: 비즈니스 데이터를 업데이트하는 DB 트랜잭션에 메시지를 송신하고 이벤트를  
    발행하는 행위를 어떻게 통합하는가?
  - 외부 API: 애플리케이션의 클라이언트는 서비스와 어떻게 통신하는가?

<h4>트랜잭션 관리를 위한 데이터 일관성 패턴</h4>

- 마이크로서비스는 각자 DB를 갖고, 서로 느슨하게 결합한다.  
  하지만 서비스마다 DB를 따로 두면, 몇 가지 중요한 문제점들이 발생한다.  
  기존의 분산 트랜잭션은 요즘 애플리케이션에는 맞지 않는 방법이기에 Saga Pattern에 따라 데이터 일관성을 유지해야 한다.

<h4>데이터 쿼리 패턴</h4>

- 서비스마다 DB를 따로 두면, 각 서비스가 소유한 데이터를 join하는 쿼리도 문제이다.  
  서비스 데이터는 오직 그 서비스의 API를 통해서만 접근할 수 있기 때문에 DB에 분산 쿼리를 사용할 수가 없다.  
  이를 해결하기 위해서는 아래 2가지 패턴을 응용하여 구현해야 한다.

  - API Composition Pattern: 하나 이상의 서비스를 호출해서 결과를 조합한다.
  - CQRS Pattern: 하나 이상의 데이터 Replica를 유지해서 쉽게 쿼리한다.

<h4>서비스 배포 패턴</h4>

- 애플리케이션 배포 작업은 모놀리틱도 쉬운 것은 아니지만, 배포할 애플리케이션이 하나밖에 없기 때문에 직관적이다.  
  물론 Load balancing을 위해 인스턴스를 여러 개 띄우는 것은 필요하다.

- 마이크로서비스 애플리케이션은 다양한 언어와 프레임워크로 구현된 수십 ~ 수백개의 서비스로 이루어져 있기 때문에  
  배포 작업이 훨씬 더 복잡하고, 관리 포인트가 상당히 많다.  
  예전에는 보통 언어에 특정한 패키징 포맷(ex. .WAR)으로 애플리케이션을 수동 배포했으나, 이런 식으로는 MSA가  
  오래 버티기 힘들다. 따라서 고도로 자동화된 배포 인프라를 구축해야 한다.

<h4>관측성 패턴: 애플리케이션 동작 파악</h4>

- 운영자의 주 임무는 애플리케이션의 런타임 동작을 이해하고, 요청 실패, 높은 latency 등 갖가지 문제들을 진단 및  
  조치하는 일이다. 모놀리틱 애플리케이션도 운영은 어렵지만, 요청이 비교적 단순하고 알기 쉽게 처리되므로 비교적  
  troubleshooting이 수월한 편이다. 들어온 요청은 Load balancing으로 분산되어 특정 인스턴스로 routing되고,  
  애플리케이션 인스턴스는 DB 쿼리 결과를 수신한 데이터를 클라이언트에 반환하면 끝이다. 사용자 요청이 어떻게 처리되었는지는  
  해당 인스턴스의 로그 파일을 찾아보면 된다.

- 하지만 MSA는 요청 결과가 클라이언트에게 반환되기 까지 어떤 서비스를 어떻게 오고 갈지 모르기 때문에  
  로그 파일 하나만으로는 원인을 파악할 수 없고, 원인 파악 및 진단이 매우 번거로워진다.  
  또 Latency 파악 또한 짚어 봐야할 대상이 많아 원인을 특정하기 까다롭다.  
  이를 해결하기 위해서는 아래와 같은 패턴이 필요하다.

  - Health Check API: 서비스의 가동 상태(health)를 반환하는 endpoint를 expose
  - Log Aggregation: 서비스 내역을 기록하고 중앙 로깅 서버에 로그를 출력하여 검색, 경고 기능을 제공
  - Distributed Tracing: 각 외부 요청마다 ID를 부여하여 서비스를 통과하는 과정 추적
  - Exception Tracking: 예외가 발생하면 예외 추적 서비스에 보고한다. 이 서비스는 중복된 예외를 걸러내고  
    개발자에게 경고를 보내거나, 해결 상태를 추적한다.
  - Application Metrics: 카운터, 게이지 등의 metric을 측정하여 지표 서버에 표출한다.
  - Audit Logging: 사용자가 한 일을 기록한다.

<h4>서비스 테스트 자동화 패턴</h4>

- MSA는 단위 서비스의 크기가 비교적 작아서 테스트하기 쉽지만, 서로 다른 여러 서비스가 조화롭게 잘 작동되는지  
  테스트하는 것이 중요하다. 느리고 복잡한 E2E Test는 가급적 피하는 것이 좋다. 따라서 아래와 같이 서비스를  
  따로 분리해서 테스트하는 테스트 단순화 패턴이 필요하다.

  - Consumer-Driven contract test: 클라이언트가 의도한 대로 서비스가 동작하는지 확인
  - Consumer-Side contract test: 클라이언트와 서비스가 상호 통신 가능한지 확인
  - Service component test: 서비스를 따로따로 테스트한다.

<h4>횡단 관심사 처리 패턴</h4>

- MSA는 관측성 패턴, 디스커버리 패턴 등 모든 서비스가 반드시 구현해야 할 관심사가 한두 가지가 아니고,  
  DB Credential 같은 구성 매개변수를 런타임 서비스에 제공하는 외부화 구성 패턴을 적용해야 한다.  
  신구 서비스 구축 시 이런 횡단 관심사(cross-cutting concerns)를 처음부터 다시 개발하려면  
  시간이 매우 많이 걸린다. 따라서 횡단 관심사를 처리하는 프레임워크에서 Microservice Chassis 패턴을  
  적용하여 서비스를 구축하는 편이 바람직하다.

<h4>보안 패턴</h4>

- MSA에서는 일반적으로 API Gateway가 신원(Id Entity), 역할(Role) 등 사용자 정보를 인증한 후  
  호출할 서비스에 관련 정보를 전달한다. 가장 일반적인 솔루션은 JWT와 같은 Access Token 패턴을  
  적용하는 것이다. API Gateway는 Access Token을 서비스에게 건네고, 서비스는 토큰을 확인한 후  
  사용자 정보를 조회한다.

<Hr/>
