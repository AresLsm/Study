<h1>Spring Data JPA</h1>

<h2>중복 코드의 발생</h2>

* 아래 코드를 보자. `User` Entity에 대한 JPA 관련 코드이다.
```java
@Repository
public class UserRepository {

    @PersistenceContext
    private EntityManager entityManager;

    public User find(String email) {
        return entityManater.find(User.class, email);
    }

    public void save(User user) {
        entityManager.persist(user);
    }
}
```

* `Hotel` Entity가 존재한다면 다음과 같은 코드를 작성할 것이다.
```java
@Repository
public class HotelRepository {

    @PersistenceContext
    private EntityManager entityManager;

    public Hotel find(String id) {
        return entityManager.find(Hotel.class, id);
    }

    public void save(Hotel hotel) {
        entityManager.persist(hotel);
    }
}
```

* `UserRepository`와 `HotelRepository`는 다루는 Entity의 타입만 다를 뿐 `EntityManager`를 사용해서 Entity를 찾고 저장하는 코드는   
  완전히 동일한 구조를 갖는다. 이렇게 구조적으로 동일한 코드를 중복해서 작성하는 것은 좋지 않으며, 이를 해결하는 방법 중 하나가 Spring   
  Data JPA를 사용하는 것이다.
<hr/>

<h2>Spring Data JPA 소개</h2>

* Spring Framework 사용 시 Spring Data JPA를 사용하면 많은 중복 코드 작성을 줄일 수 있다. 예를 들어, Spring Data JPA를 사용하면   
  아래와 같은 인터페이스로 `UserRepository`를 구현할 수 있다.
```java
public interface UserRepository extends Repository<User, String> {

    User findOne(String email);
    User save(User user);
    void delete(User user);

    @Query("SELECT u FROM User u ORDER BY u.name")
    List<User> findAll();
}
```

* `Repository`는 Spring Data JPA가 제공하는 인터페이스이다. 이 인터페이스만 상속받아 정해진 규칙에 맞게 메소드를 작성하면 된다.   
  예를 들어, 식별자로 Entity를 검색하고 싶다면 이름이 `findOne()`이고 파라미터 타입이 식별자와 같은 메소드를 추가하면 된다. 나머지   
  과정은 Spring Data JPA가 알아서 해준다. 따라서 `EntityManager`를 이용한 코드를 중복해서 구현할 필요가 없다.

* Spring Data JPA는 `Repository`를 상속한 인터페이스를 검색하고, 그 인터페이스를 알맞게 구현한 객체를 Spring Bean으로 등록한다.   
  위 코드의 경우, `UserRepository` 인터페이스를 구현한 객체를 Spring Context에 Bean으로 등록한다.

* `UserRepository`를 사용할 코드는 아래 처럼 의존 주입을 통해 `UserRepository` bean을 전달받고 사용하면 된다.
```java
@Service
public class GetUserListService {

    private UserRepository userRepository;

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }

    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

* `Hotel` Entity를 위한 DB 연동이 필요하다면 다음과 같이 `Repository`를 상속받은 인터페이스만 작성하면 된다.
```java
public interface HotelRepository extends Repository<Hotel, String> {

    Hotel findOne(String id);
}
```
<hr/>

<h2>JpaRepository 인터페이스 메소드 작성 규칙</h2>

* Spring Data JPA를 위한 Repository 인터페이스는 지정한 규칙에 따라 메소드를 작성해야 한다.

<h3>1. Repository 인터페이스 작성</h3>

* 가장 먼저 해야할 일은 Spring Data JPA를 위한 repository interface를 작성하는 것이다.
* 기본 repository 타입은 `Repository` 인터페이스로, 아래와 같이 정의되어 있다.
```java
import org.springframework.data.repository.JpaRepository;

import java.io.Serializable;

public interface JpaRepository<T, ID extends Serializable> {}
```

* 타입 파라미터 `T`는 Entity의 타입을 의미하고, `ID`는 식별자의 타입을 의미한다. `Repository` 타입을 상속하는 repository 인터페이스는   
  알맞은 타입 파라미터를 지정하면 된다. Entity 타입이 `User`이고 식별자 타입이 `String`이라면 아래와 같이 `Repository` 인터페이스를   
  상속하면 된다.
```java
public interface UserRepository extends Repository<User, String> {

    // 규칙에 맞게 메소드 작성

}
```

<h3>2. 기본 메소드</h3>

* Repository 인터페이스를 작성했다면, 규칙에 맞게 메소드를 추가하면 된다. 기본이 되는 3가지 메소드는 다음 형식을 갖는다.
```java
public interface UserRepository extends Repository<User, String> {
    User findOne(String id);
    User save(User user);
    void delete(User user);
}
```

* `findOne()` 메소드는 식별자를 인자로 받는다. 이 메소드는 `EntityManager#find()` 메소드를 이용해서 식별자를 갖는 Entity를 구한다.   
  식별자에 해당하는 Entity가 존재하면 해당 Entity를 반환하고, 존재하지 않으면 null을 반환한다. (`JpaRepository`에서는 작동 X)
* `save()` 메소드는 인자로 받은 Entity를 저장하고, 저장한 Entity를 반환한다. 저장 시점에 식별자를 생성한다면 `save()` 메소드가 반환한   
  Entity를 이용해서 식별자를 구할 수 있다.

<h3>3. 조회 메소드 작성 규칙</h3>

* 모든 Entity를 조회하고 싶다면 `findAll()` 메소드를 사용한다.
```java
public interface UserRepository {
    List<User> findAll();
}
```
* 목록을 조회하므로 컬렉션 타입인 `List`를 반환형으로 사용했다.

* 특정 속성을 이용해서 Entity를 검색하고 싶다면 `findBy속성(비교값)` 형태의 메소드를 사용하면 된다.
```java
public interface HotelRepository {
    List<Hotel> findByGrade(Grade grade);
}
```

* Spring Data JPA는 메소드명을 대문자를 기준으로 구성 요소를 판단한다. `findByGrade`의 경우, find, By, Grade의 3가지로 구성 요소를   
  분리한다. find는 SELECT query를 수행하는 메소드를 의미하며, By 키워드는 WHERE 조건의 시작을 의미한다. By 키워드 뒤에 오는 Grade는   
  grade 속성을 뜻한다. 파라미터는 속성을 비교할 때 사용할 값이다.

* And 키워드로 두 개 이상의 속성에 대한 비교 연산을 조합할 수 있다.
```java
List<Hotel> findByGradeAndName(Grade grade, String name);
```

* 비슷하게 Or 키워드를 사용해서 두 개 이상의 비교 조건을 연결할 수도 있다.
* 속성명 뒤에 비교 연산자를 위한 키워드를 추가할 수도 있다. 예를 들어, `Date` 타입인 createDate 속성값이 지정한 날짜 이후인지 비교하고   
  싶다면 다음과 같이 After 키워드를 사용해서 메소드를 작성할 수 있다.
```java
List<User> findByCreateDateAfter(Date date);
```

* 아래 표는 Spring Data JPA Reference Document에 있는 키워드 목록을 정리한 것이다.

<table>
    <tr>
        <td>키워드</td>
        <td>예시</td>
        <td>JPQL 변환 예시</td>
    </tr>
    <tr>
        <td>Is, Equals(둘 다 생략 가능)</td>
        <td>findByNameIs, findByNameEquals, findByName</td>
        <td>WHERE h.name = ?</td>
    </tr>
    <tr>
        <td>Between</td>
        <td>findByCreateDateBetween</td>
        <td>WHERE u.createDate between &lt;? AND ?</td>
    </tr>
    <tr>
        <td>LessThan</td>
        <td>findByPriceLessThan</td>
        <td>WHERE p.price &lt; ?</td>
    </tr>
    <tr>
        <td>LessThanEqual</td>
        <td>findByPriceLessThanEqual</td>
        <td>WHERE p.price &lt;= ?</td>
    </tr>
    <tr>
        <td>GreaterThan</td>
        <td>findByPriceGreaterThan</td>
        <td>WHERE p.price &gt; ?</td>
    </tr>
    <tr>
        <td>GreaterThanEqual</td>
        <td>findByPriceGreaterThanEqual</td>
        <td>WHERE p.price &gt;= ?</td>
    </tr>
    <tr>
        <td>After</td>
        <td>findByCreateDateAfter</td>
        <td>WHERE p.price &gt; ?</td>
    </tr>
    <tr>
        <td>Before</td>
        <td>findByCreateDateBefore</td>
        <td>WHERE p.price &lt; ?</td>
    </tr>
    <tr>
        <td>IsNull</td>
        <td>findByOwnerIsNull</td>
        <td>WHERE b.owner IS NULL;</td>
    </tr>
    <tr>
        <td>IsNotNull, NotNull</td>
        <td>findByOwnerIsNotNull, findByOwnerNotNull</td>
        <td>WHERE b.owner IS NOT NULL;</td>
    </tr>
    <tr>
        <td>Like</td>
        <td>findByNameLike</td>
        <td>WHERE u.name LIKE ?</td>
    </tr>
    <tr>
        <td>NotLike</td>
        <td>findByNameNotLike</td>
        <td>WHERE u.name NOT LIKE ?</td>
    </tr>
    <tr>
        <td>StartingWith</td>
        <td>findByNameStartingWith</td>
        <td>WHERE u.name LIKE ? (파라미터 뒤에 % 추가)</td>
    </tr>
    <tr>
        <td>EndingWith</td>
        <td>findByNameEndingWith</td>
        <td>WHERE u.name LIKE ? (파라미터 뒤에 % 추가)</td>
    </tr>
    <tr>
        <td>Containing</td>
        <td>findByNameContaining</td>
        <td>WHERE u.name LIKE ? (파라미터 앞뒤로 % 추가)</td>
    </tr>
    <tr>
        <td>Not</td>
        <td>findByGradeNot</td>
        <td>WHERE h.grade &gt;&lt; ?</td>
    </tr>
    <tr>
        <td>In</td>
        <td>findByGradeIn(컬렉션)</td>
        <td>WHERE h.grade IN ?</td>
    </tr>
    <tr>
        <td>NotIn</td>
        <td>findByGradeNotIn(컬렉션)</td>
        <td>WHERE h.grade NOT IN ?</td>
    </tr>
    <tr>
        <td>True</td>
        <td>findByClosedTrue</td>
        <td>WHERE i.closed = true</td>
    </tr>
    <tr>
        <td>False</td>
        <td>findByClosedFalse</td>
        <td>WHERE i.closed = false</td>
    </tr>
    <tr>
        <td>IgnoreCase</td>
        <td>findByNameIgnoreCase</td>
        <td>WHERE UPPER(u.name) = UPPER(?)</td>
    </tr>
</table>

<h3>4. 한 개 결과 조회</h3>

