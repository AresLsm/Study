# Asynchronous Flow

- Suspending function은 비동기적으로 하나의 값을 반환한다.  
  하지만 만약 비동기적으로 계산돤 여러 개의 값을 반환하고 싶다면 어떻게 해야 할까? 이때 Kotlin Flow를 사용할 수 있다.

## Representing Multiple Values

- 여러 개의 값들은 코틀린에서 컬렉션으로 표현할 수 있다. 예를 들어 아래의 `simple()` 함수는 3개의 숫자를 담은 `List`를 반환하고,  
  반환받은 `List`의 원소를 각각 `main()`에서 출력한다.

```kt
fun simple(): List<Int> = listOf(1, 2, 3)

fun main() {
	simple().forEach { println(it) }
}
```

### Sequences

- 아래 처럼 하나의 값을 계산하는 데 100ms가 소요된다고 해보자. 이때, 이 값들을 `Sequence`로 표현할 수 있다.

```kt
fun simple(): Sequence<Int> = sequence {
	for (i in 1..3) {
		Thread.sleep(100)
		yield(i) // yield next value
	}
}

fun main() {
	simple().forEach { println(it) }
}
```

- 위 코드는 100ms씩 각 숫자를 출력한다.

### Suspending Functions

- 위에서 본 코드는 코드를 실행하는 main thread를 block한다는 단점이 있다. 만약 계산되는 값들이 비동기적으로 계산된다면, `simple()`을 suspending  
  function으로 표시해 blocking을 하지 않고 비동기적으로 처리할 수 있다.

```kt
suspend fun simple(): List<Int> {
	delay(1000)
	return listOf(1, 2, 3)
}

func main() = runBlocking<Unit> {
	simple().forEach { println(it) }
}
```

- 위 코드는 1초 후 모든 원소들을 출력한다.

### Flows

- 위에서 본 `simple()`은 반환형이 `List<Int>`인데, 이는 곧 모든 값들을 한 번에 반환해야 함을 의미한다.  
  비동기적으로 계산되는 값들의 _stream_ 을 나타내기 위해서는 `Flow<Int>` 타입을 사용할 수 있다.

```kt
fun simple(): Flow<Int> = flow {
	for (i in 1..3) {
		delay(100)
		emit(i) // emit next value
	}
}

func main() = runBlocking<Unit> {
	launch {
		for (k in 1..3) {
			println("I'm not blocked $k")
			delay(100)
		}
	}
	simple().collect { println(it) }
}

/*
I'm not blocked 1
1
I'm not blocked 2
2
I'm not blocked 3
3
*/
```

- 위 코드는 각 숫자를 출력하기 전 main thread를 blocking하지 않고 100ms 씩 기다린다.  
  "I'm not blocked"가 100ms 씩 출력되는 것으로 이를 알 수 있다.

- `Flow`를 사용한 이 코드에서 다른 코드의 차이점을 보자.

  - 우선 `Flow`를 사용하기 위한 builder function은 `flow { .. }`이다.
  - `flow { .. }` 안의 코드는 suspendable하다.
  - `simple()` 함수는 더 이상 suspend 키워드가 적용되어 있지 않다.
  - 값들은 `emit()`을 통해 flow로부터 _emit_ 된다.
  - 값들은 `collect()`를 통해 flow로부터 _collect_ 된다.

> `flow { .. }` 내의 `delay()`를 `Thread.sleep()`으로 바꾸면 main thread가 block된다.

---

## Flows are cold

- `Flows`는 `Sequence`와 비슷하게 _cold_ 한데, 즉 `flow { .. }` builder 내의 코드는 flow가 _collect_ 되기 전까지 실행되지 않는다.

```kt
fun simple(): Flow<Int> = flow {
    println("Flow started")
    for (i in 1..3) {
        delay(100)
        emit(i)
    }
}

fun main() = runBlocking<Unit> {
    println("calling simple()..")
    val flow = simple()
    println("calling simple().collect()..")
    flow.collect { println(it) }
    println("calling collect() again..")
    flow.collect { println(it) }
}

/*
calling simple()..
calling simple().collect()..
Flow started
1
2
3
calling collect() again..
Flow started
1
2
3
*/
```

- 여기서 왜 `simple()`이 suspend 키워드가 없어도 되는지 알 수 있다. `simple()`은 재빠르게 return하고 아무런 것도 기다리지 않는다.  
  flow는 _collect_ 될 때마다 시작된다. 위 코드에서 `collect()`가 호출되었을 때 "Flow started"가 출력된 것을 볼 수 있다.

---

## Flow cancellation basics

- `Flow`는 일반적인 coroutine의 cancellation과 비슷하게 동작한다. 마찬가지로 flow _collection_ 은 flow가 `delay()`와 같은  
  cancellable suspending function에 의해 suspend 되었을 때 cancel될 수 있다.

- 아래 예시 코드는 `withTimeoutOrNull { .. }` 블록 내에서 어떻게 flow가 cancel 되는지 보여준다.

```kt
fun simple(): Flow<Int> = flow {
    for (i in 1..3) {
        delay(100)
        println("Emitting $i")
        emit(i)
    }
}

fun main() = runBlocking<Unit> {
    withTimeoutOrNull(250) {
        simple().collect { println(it) }
    }
    println("Done")
}

/*
Emitting 1
1
Emitting 2
2
Done
*/
```

## Flow builders

- 이전에 코드에서 본 `flow { .. }` builder는 기본적인 flow builder이다.  
  Flow의 사용을 위한 다른 builder들도 있는데, 아래와 같다.

  - `flowOf { .. }` builder는 고정된 값들을 반환하는 flow를 정의한다.
  - 다양한 컬렉션과 `Sequence`는 `asFlow()` 함수를 통해 `Flow`로 변환될 수 있다.

```kt
(1..3).asFlow().collect { println(it) }
```

---
