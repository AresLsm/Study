# 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언

- Java에서는 생성자를 하나 이상 선언할 수 있다. 코틀린도 비슷하지만 한 가지 바뀐 부분이 있다.  
  코틀린은 주(primary) 생성자와 부(secondary) 생성자를 구분한다.

> 주 생성자(Primary Constructor): 클래스를 초기화할 때 주로 사용하는 간략한 생성자로,  
> 클래스 본문 밖에서 정의한다.
>
> 부 생성자(Secondary Constructor): 클래스 본문 안에서 정의한 생성자

- 또한 코틀린에서는 **초기화 블록(Initializer Block)** 을 통해 초기화 로직을 추가할 수 있다.

## 클래스 초기화: 주 생성자와 초기화 블록

- 이전에 본 간단한 클래스를 선언하는 방법을 보자.

```kt
class User(val nickname: String)
```

- 보통 클래스의 모든 선언은 중괄호(`{}`) 사이에 들어간다. 하지만 이 클래스의 선언에는 중괄호가 없고,  
  소괄호 사이에 val 선언만 존재한다. 이렇게 클래스 이름 뒤에 오는 소괄호로 둘러싸인 코드를  
  **주 생성자(Primary Constrcutor)** 라 한다. 주 생성자는 생성자 파라미터를 지정하고, 그 생성자  
  파라미터에 의해 초기화되는 프로퍼티를 정의하는 두 가지 목적에 쓰인다. 이제 이 선언과 같은 목적을  
  달성할 수 있는 가장 명시적인 선언으로 풀어서 실제로는 어떤 일이 벌어지는지 살펴보자.

```kt
class User constructor(_nickname: String) {
    val nickname: String

    init {
	nickname = _nickname
    }
}
```

- 위 예시에서 constructor와 init이라는 새로운 키워드를 볼 수 있다. constructor 키워드는 주 생성자나  
  부 생성자의 정의를 시작할 때 사용한다. init 키워드는 초기화 블록을 시작한다. 초기화 블록에는 클래스의  
  객체가 만들어질 때, 즉 인스턴스화될 때 실행될 초기화 코드가 들어간다. 초기화 블록은 주 생성자와 함께  
  사용된다. 주 생성자는 제한적이기 때문에 별도의 코드를 포함할 수 없으므로 초기화 블록이 필요하다.  
  필요하다면 클래스 안에 여러 개의 초기화 블록을 선언할 수도 있다.

- 생성자 파라미터 \_nickname 에서 맨 앞의 밑줄(`_`)은 프로퍼티와 생성자 파라미터를 구분해준다.  
  다른 방법으로 Java에서 흔히 쓰는 방식처럼 `this.nickname = nickname;` 같은 식으로 생성자  
  파라미터와 프로퍼티의 이름을 같게 하고, 프로퍼티에 this를 써서 모호성을 없애도 된다.

- 위 예제에서는 nickname 프로퍼티를 초기화하는 코드를 nickname 프로퍼티 선언에 포함시킬 수 있어서  
  초기화 코드를 초기화 블록에 넣을 필요가 없다. 또 주 생성자 앞에 별다른 어노테이션이나 가시성 변경자가  
  없다면 constructor 키워드를 생략해도 된다. 이런 변경을 적용하고 나면 코드를 아래처럼 바꿀 수 있다.

```kt
class User(_nickname: String) {
    val nickname = _nickname
}
```

- 이 예제는 같은 클래스를 정의하는 여러 방법 중 하나다. **프로퍼티를 초기화하는 식이나 초기화 블록 안에서만**  
  **주 생성자의 파라미터를 참조할 수 있다**는 점에 유의하자.

- 방금 본 두 예시 코드에서는 클래스 본문에서 val 키워드를 통해 프로퍼티를 정의했다.  
  하지만 주 생성자의 파라미터로 프로퍼티를 초기화한다면 그 주 생성자 파라미터명 앞에 val을 추가하는  
  방식으로 프로퍼티 정의와 초기화를 간략히 쓸 수 있다.

```kt
class User(val nickname: String)
```

- 지금까지 본 `User`의 세 가지 선언은 모두 동일하다. 하지만 마지막 선언이 가장 간결하다.

- 함수 파라미터와 마찬가지로 생성자 파라미터에도 디폴트 값을 정의할 수 있다.

```kt
class User(val nickname: String, val isSubscribed: Boolean = true)
```

- 클래스의 인스턴스를 만들려면 new 키워드 없이 생성자를 직접 호출하면 된다.

```kt
val sangwoo = User("sangwoo")
```

> 생성자의 모든 파라미터에 디폴트 값을 지정하면 컴파일러가 자동으로 파라미터가 없는 생성자를 만들어준다.  
> 그렇게 자동으로 만들어진 파라미터 없는 생성자는 디폴트 값을 사용해 클래스를 초기화한다.  
> 의존 관계 주입(DI, Dependency Injection) 프레임워크 등 Java 라이브러리 중에는 파라미터가 없는  
> 생성자를 통해 객체를 생성해야만 라이브러리 사용이 가능한 경우가 있는데, 코틀린이 제공하는 파라미터 없는  
> 생성자는 그런 라이브러리와의 통합을 쉽게 해준다.

- 클래스에 기반 클래스가 있다면 주 생성자에서 기반 클래스의 생성자를 호출해야 할 필요가 있다.  
  기반 클래스를 초기화하려면 기반 클래스명 뒤에 소괄호를 치고, 생성자 인자를 넘긴다.

```kt
open class User(val nickname: String) { /* ... */ }

class TwitterUser(nickname: String) : User(nickname) { /* ... */ }
```

- 클래스를 정의할 때 별도로 생성자를 정의하지 않으면 컴파일러가 자동으로 아무 일도 하지 않는 인자가 없는  
  디폴트 생성자를 만들어준다.

```kt
open class Button
```

- `Button`의 생성자는 아무 인자도 받지 않지만, `Button` 클래스를 상속한 하위 클래스는 반드시  
  `Button`의 생성자를 호출해야 한다.

```kt
class RadioButton : Button()
```

- 이 규칙으로 인해 기반 클래스명 뒤에는 꼭 빈 괄호가 들어간다. 반면, 인터페이스는 생성자가 없기 때문에  
  어떤 클래스가 인터페이스를 구현하는 경우, 그 클래스의 상위 클래스 목록에 있는 인터페이스명 뒤에는 아무런  
  괄호도 없다. 클래스 정의에 있는 상위 클래스 및 인터페이스 목록에서 이름 뒤에 괄호가 붙었는지를 살펴보면  
  쉽게 기반 클래스와 인터페이스를 구별할 수 있다.

- 어떤 클래스를 클래스 외부에서 인스턴스화하지 못하게 막거 싶다면 모든 생성자를 private으로 만들면 된다.  
  아래와 같이 주 생성자에 private 변경자를 붙일 수 있다.

```kt
class Secretive private constructor() { }
```

- `Secretive` 클래스 안에는 주 생성자밖에 없고, 그 주 생성자는 비공개이므로 외부에서는 `Secretive`를  
  인스턴스화할 수 없다.

<hr/>
