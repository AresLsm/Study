# 데이터 클래스와 클래스 위임

- Java 플랫폼에서는 클래스가 `equals()`, `hashCode()`, `toString()` 등의 메소드를 구현해야 한다.  
  그리고 이런 메소드들은 보통 비슷한 방식으로 기계적으로 구현할 수 있다. 물론 IDE가 자동으로 만들어주기도  
  해서 이런 메소드를 직접 작성할 일은 많지 않다. 하지만 자동으로 `equals()`, `hashCode()`,  
  `toString()` 등을 구현하다 해도 코드베이스가 번잡해지는 것은 동일하다. 코틀린 컴파일러는 한 걸음 더  
  나아가서 이런 메소드들을 기계적으로 생성하는 작업을 보이지 않는 곳에서 해준다. 따라서 필수 메소드로  
  인한 잡음 없이 소스 코드를 깔끔히 유지할 수 있다.

## 모든 클래스가 정의해야 하는 메소드

- Java와 마찬가지로 코틀린 클래스도 `toString()`, `hashCode()`, `equals()` 등을 오버라이드할 수  
  있다. 각각이 어떤 메소드이고 어떻게 그런 메소드를 정의해야 하는지 살펴보자. 코틀린은 이런 메소드들의  
  구현을 자동으로 생성할 수 있다.

```kt
class Client(val name: String, val postalCode: Int)
```

- 위 클래스의 인스턴스를 문자열로 어떻게 표현할지 생각해보자.

### 문자열 표현: `toString()`

- Java 처럼 코틀린의 모든 클래스도 인스턴스의 문자열 표현을 얻을 방법을 제공한다. 주로 디버깅과  
  로깅 시 이 메소드를 사용한다. 물론 다른 맥락에서도 사용할 수 있다. 기본 제공되는 객체의 문자열  
  표현은 `Client@5e32ja42c` 같은 식인데, 이는 그다지 유용하지 않다. 이 기본 구현을 바꾸려면  
  `toString()`을 오버라이드해야 한다.

```kt
class Client(val name: String, val postalCode: Int) {
    override fun toString(): String {
	return "Client(name=$name, postalCode=$postalCode)"
    }
}
```

- 이제 어떤 고객에 대한 문자열 표현은 아래와 같다.

```kt
val client1 = Client("sangwoo", 1234)
println(client)
// Client(name=sangwoo, postalCode=1234)
```

- 이런 문자열 표현으로부터 기본 문자열 표현보다 더 많은 정보를 얻을 수 있다.

### 객체의 동등성: `equals()`

- `Client`를 사용하는 모든 계산은 클래스 밖에서 이뤄진다. `Client`는 단지 데이터를 저장할 뿐이며,  
  그에 따라 구조도 단순하고 내부 정보를 투명하게 외부에 노출하게 설계되었다. 그렇지만 클래스 자체는  
  단순할지라도 동작에 대한 몇 가지 요구사항이 있을 수 있다. 예를 들어, 서로 다른 두 객체가 내부에  
  동일한 데이터를 포함하는 경우 그 둘을 동등한 객체로 간주해야 할 수도 있다.

```kt
val client1 = Client("sangwoo", 1234)
val client2 = Client("sangwoo", 1234)
println(client1 == client2) // false
```

- 위 예시 코드에서 두 객체는 동일하지 않다. 이런 `Client`의 요구사항을 만족시키고 싶다면 `equals()`를  
  오버라이드할 필요가 있다는 뜻이다.

> **동등성 연산에 `==`를 사용했다.**
>
> - Java에서는 `==`를 원시 타입과 참조 타입을 비교할 때 사용한다. 원시 타입의 경우, `==`는 두 피연산자의  
>   값이 같은지 비교한다. 반면 참조 타입의 경우 `==`는 두 피연산자의 주소가 같은지를 비교한다. 따라서 Java에서는  
>   두 객체의 동등성을 알려면 `equals()`를 호출해야 한다.
>
> - 코틀린에서는 `==` 연산자가 두 객체를 비교하는 기본적인 방법이다. `==`는 내부적으로 `equals()`를 호출해서  
>   객체를 비교한다. 따라서 클래스가 `equals()`를 오버라이드하면 `==`를 통해 안전하게 그 클래스의 인스턴스를  
>   비교할 수 있다. 참조 비교를 위해서는 `===` 연산자를 사용할 수 있다. `===`는 Java에서 객체의 참조를 비교할 때  
>   사용하는 `==`와 동일하다.

- 이제 `equals()`를 오버라이드한 `Client`를 보자.

```kt
class Client(val name: String, val postalCode: Int) {
    override fun equals(other: Any?): Boolean {
	if(other == null || other !is Client)
	    return false
	return name == other.name && postalCode == other.postalCode
    }

    override fun toString(): String {
	return "Client(name=$name, postalCode=$postalCode)"
    }
}
```

- 코틀린에서는 override 변경자가 필수여서 실수로 `override fun equals(other: Any?)` 대신  
  `override fun equals(other: Client)`를 작성할 수 없다. 이는 Java에서 `@Override`를  
  사용하는 것보다 강제성이 추가되어 미연의 실수를 방지해준다.

> <a href="https://github.com/sang-w0o/Study/blob/master/Programming%20Paradigm/Effective%20Java/5.%20%EC%97%B4%EA%B1%B0%20%ED%83%80%EC%9E%85%EA%B3%BC%20%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98/Item%2040.%20%40Override%20%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98%EC%9D%84%20%EC%9D%BC%EA%B4%80%EB%90%98%EA%B2%8C%20%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC.md">Effective Java Item40. `@Override` 어노테이션을 일관되게 사용하라</a>

### 해시 컨테이너: `hashCode()`

- <a href="https://github.com/sang-w0o/Study/blob/master/Programming%20Paradigm/Effective%20Java/2.%20%EA%B0%9D%EC%B2%B4%EC%9D%98%20%EA%B3%B5%ED%86%B5%20%EB%A9%94%EC%86%8C%EB%93%9C/Item%2011.%20equals%EB%A5%BC%20%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%A9%B4%20hashCode%EB%8F%84%20%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC.md">Effective Java Item 11. `equals()`를 재정의하면 `hashCode()`도 재정의하라.</a> 에서 봤듯이,  
  Java에서 `equals()`를 오버라이드 할 때 반드시 `hashCode()`도 함께 오버라이드해야 한다. 이는 당연히  
  코틀린에도 동일하게 동일한 이유와 함께 적용된다.

```kt
class Client(val name: String, val postalCode: Int) {
    //..

    override fun hashCode(): Int {
	return name.hashCode() * 31 + postalCode
    }
}
```

<hr/>
