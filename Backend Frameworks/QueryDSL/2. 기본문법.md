# 기본 문법

<h2>JPQL vs Querydsl</h2>

- username이 member1인 `Member`를 조회하는 쿼리를 각각 JPQL, Querydsl로  
  작성하는 간단한 테스트 코드를 짜보자.

```kt
@SpringBootTest
@Transactional
class QuerydslBasicTest {

    @Autowired
    private lateinit var entityManager: EntityManager

    @BeforeEach
    fun before() {
        val teamA = Team("teamA")
        val teamB = Team("teamB")
        entityManager.persist(teamA)
        entityManager.persist(teamB)

        val member1 = Member("member1", 10, teamA)
        val member2 = Member("member2", 20, teamA)
        val member3 = Member("member3", 30, teamB)
        val member4 = Member("member4", 40, teamB)
        entityManager.persist(member1)
        entityManager.persist(member2)
        entityManager.persist(member3)
        entityManager.persist(member4)

        entityManager.flush()
        entityManager.clear()
    }

    @Test
    fun jpqlTest() {
        // Find member1 with JPQL
        val member = entityManager.createQuery(
            "SELECT m FROM Member m WHERE m.username = :username", Member::class.java
        )
            .setParameter("username", "member1")
            .singleResult

        assertEquals("member1", member.username)
    }

    @Test
    fun querydslTest() {
        // Find member1 with Querydsl
        val query = JPAQueryFactory(entityManager)
        // QMember가 필요하므로 ./gradlew compileQuerydslKotlin 실행
        val qMember = QMember("m")

        val member = query.select(qMember)
            .from(qMember)
            .where(qMember.username.eq("member1"))
            .fetchOne()!!

        assertEquals("member1", member.username)
    }
}
```

- JPQL로 했을 때는 쿼리문을 문자열로 전달하고, 파라미터 바인딩을 해줬다.  
  반면 Querydsl로 작성한 쿼리는 모두 함수로 작성했으며, 별도의 파라미터  
  바인딩을 해주지 않았다.

- 아래는 Querydsl로 수행된 쿼리문이다.

```sql
select
    member0_.id as id1_1_,
    member0_.age as age2_1_,
    member0_.team_id as team_id4_1_,
    member0_.username as username3_1_
from
    member member0_
where
    member0_.username=?
```

- 이렇게 Querydsl로 만들어진 쿼리문은 기본적으로 JDBC의 `PreparedStatement`를  
  만들고, 이후에 파라미터 바인딩을 수행한다.

<hr/>

<h2>기본 Q-Type 활용</h2>

- Q Class를 사용하는 방법에는 두 가지가 있다.  
  위처럼 `QMember("m")`처럼 별칭(m)을 지정하고 인스턴스를 만드는 방법과,  
  `QMember.member`처럼 기본 인스턴스를 사용하는 방법이 있다.

```kt
val qMember = QMember("m") // 직접 별칭 지정

val qMember = QMember.member // 기본 인스턴스 사용
```

- 위에서 작성한 코드를 기본 인스턴스를 사용하도록 바꿔보자.

```kt
@Test
fun querydslTest() {
    // Find member1 with Querydsl

    // QMember가 필요하므로 ./gradlew compileQuerydslKotlin 실행
    val qMember = QMember.member

    val member = query.select(qMember)
        .from(qMember)
        .where(qMember.username.eq("member1"))
        .fetchOne()!!

    assertEquals("member1", member.username)
}
```

- 이렇게 해도 되는 이유는 `QMember`를 직접 보면 알 수 있다.

```java
@Generated("com.querydsl.codegen.EntitySerializer")
public class QMember extends EntityPathBase<Member> {

    //..

    public static final QMember member = new QMember("member1");

    //..
}
```

- Java의 경우에는 Static Import를 사용하여 간단하게 처리할 수 있을 것이다.

- Querydsl로 작성한 쿼리는 결국 JPQL이 된다. 즉 Querydsl은 JPQL을 함수로  
  작성하기 위한 빌더 함수들이다. 이를 확인하려면 아래 속성을 지정해주면 된다.

```properties
spring.jpa.properties.hibernate.use_sql_comments=true
```

- 위 테스트 코드에서 실행되는 JPQL은 아래와 같다.

```sql
SELECT member1 FROM Member member1 WHERE member1.username = ?1
```

- 별칭이 member1으로 지정된 것을 볼 수 있는데, 이는 `QMember`의 member 필드가  
  생성될 때 인자로 지정된 값과 동일하다.

- 비즈니스 로직에 의해 같은 테이블을 JOIN 하지 않는 이상, `QMember.member`를  
  사용하자.

<hr/>

<h2>검색 조건 쿼리</h2>

<hr/>

<h2>결과 조회</h2>

<hr/>

<h2>정렬</h2>

<hr/>

<h2>페이징</h2>

<hr/>

<h2>집합</h2>

<hr/>

<h2>join - 기본 join</h2>

<hr/>

<h2>join - ON 절</h2>

<hr/>

<h2>join - Fetch join</h2>

<hr/>

<h2>서브 쿼리</h2>

<hr/>

<h2>CASE 문</h2>

<hr/>

<h2>상수, 문자 더하기</h2>

<hr/>
