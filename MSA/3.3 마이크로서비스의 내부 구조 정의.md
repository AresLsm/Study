# 마이크로서비스의 내부 구조 정의

<h2>바람직한 마이크로서비스의 내부 아키텍쳐: 클린 마이크로서비스</h2>

- 마이크로서비스의 내부 구조를 정의할 때 반드시 고려해야 할 한 가지는 마이크로서비스 시스템에서 정의해야할  
  마이크로서비스의 내부 구조가 다양할 수 있다는 것이다. 왜냐하면 마이크로서비스는 자율적인 마이크로서비스별 팀에 의한  
  폴리글랏한 내부 구조를 가질 수 있기 때문이다.

- 마이크로서비스 아키텍쳐에서 각 서비스는 각기 목표와 활용도에 따라 명확하게 분리되어야 하고, 각 서비스의 목적에 따라  
  적절한 개발 언어 및 저장소, 내부 아키텍쳐를 정의하는 것이 바람직하다. 조회나 아주 간단한 기능의 경우에는 오히려 굳이  
  헥사고날 아키텍쳐나 클린 아키텍쳐 방식의 구조를 고수할 필요가 없다. 그렇지만 비즈니스 규칙이 복잡한 서비스는  
  고수할 필요성이 분명히 있다.

- 3가지 아키텍쳐(계층형, 헥사고날, 클린)가 지향하는 원칙들을 살펴보자.

  - 지향하는 관심사에 따라 응집성을 높이고 관심사가 다른 영역과는 의존도를 낮추게 해야 한다.
  - 업무 규칙을 정의하는 비즈니스 로직 영역을 다른 기술 기반 영역으로부터 분리하기 위해 노력한다.
  - 세부 기술 중심, 저수준의 외부 영역과 핵심 업무 규칙이 정의된 고수준의 내부 영역으로 구분한다.
  - 고수준 영역은 저수준 영역에 의존하지 않게 해야 하며, 저수준 영역이 고수준 영역에 의존하게 해야 한다.
  - 저수준 영역은 언제든지 교체, 확장 가능해야 하며, 이 같은 변화가 고수준 영역에 영향을 줘서는 안된다.
  - Java처럼 인터페이스 및 추상 클래스를 지원하는 언어의 경우, 저수준 영역의 구체 클래스가 고수준 영역의  
    추상 인터페이스에 의존하게 하는 의존성 역전 원칙을 이용해야 한다.
  - 인터페이스는 고수준의 안정된 영역에 존재해야 하며, 저수준의 어댑터가 이를 구현한다.

- 위 원칙을 준수한 아키텍쳐의 예시 하나를 살펴보자.  
  우선 내부 영역의 맨 안쪽에는 도메인이 존재하고, 서비스가 이 도메인을 감싼다. 도메인에서는 핵심 비즈니스 개념과  
  규칙을 구현하며, 서비스에서는 도메인을 호출해서 업무를 처리하는 절차를 기술한다. 또한 외부 영역과 연계하기 위해  
  서비스 인터페이스를 보유한다. 서비스 인터페이스는 외부에서 내부 영역을 사용할 수 있도록 API를 제공하며,  
  서비스가 이를 구현한다.

- 내부 영역에 있는 또 다른 인터페이스는 저장소 처리를 위한 인터페이스인데, 바로 Repository 인터페이스이다.  
  이 인터페이스는 외부 영역에서 정의하지 않고 내부 영역에서 정의하는데, 비즈니스를 처리하는 데 필요한 기본적인  
  저장소 처리 사항을 추상화해 정의한다. 그렇게 하면 외부 영역의 저장소 어댑터는 이 Repository 인터페이스를  
  각 저장소에 맞는 저장소 처리 세부 기술로 구현하게 된다.

- 외부 영역에는 저장소 처리 어댑터 뿐만 아니라 다양한 Inbound, Outbound를 처리하는 어댑터가 위치한다.  
 이 같이 REST API를 처리하는 어댑터, Event Message를 처리하는 어댑터, Message를 구독하는 Consumer 어댑터,  
 이벤트를 발행하는 어댑터, API 호출 Proxy 어댑터 등의 OutBound Adapter들은 DIP를 적용해 외부 영역에서  
 내부 영역으로 의존하도록 설계한다.
<hr/>

<h2>내부 영역 - 업무 규칙</h2>

- 이제는 각 내부 영역의 구현에 필요한 패턴을 살펴보자. 업무 규칙을 정의하는 내부 영역에는 서비스 인터페이스,  
  서비스 구현체, 도메인, Repository 인터페이스, 도메인 이벤트 인터페이스, API Proxy 인터페이스가 존재한다.

- 서비스 인터페이스는 외부 영역이 내부 영역에 *너무 많이 알지 못하게 하는 역할*을 한다.  
  서비스 인터페이스가 없다면 추이 종속성이 발생할 수 있다.

- Repository 인터페이스, 도메인 이벤트 인터페이스, API Proxy 인터페이스는 DIP를 지원한다.  
  더 안정된 곳인 고수준 영역에 인터페이스가 존재하고, 저수준의 외부 어댑터가 이러한 인터페이스를 구현하게 한다.

- 다음으로 고려해야할 사항은 비즈니스 로직의 핵심인 서비스와 도메인이다.  
  서비스와 도메인은 클린 아키텍쳐의 UseCase와 Entity의 역할과 같다.  
  도메인은 비즈니스 개념을 표현하고, 서비스는 도메인을 활용해 시스템 흐름 처리를 수행한다.

<h3>트랜잭션 스크립트 패턴</h3>

- Transaction Script 패턴에서는 비즈니스 개념을 표현하는 도메인 객체가 **행위를 갖지 않는다.**  
  서비스가 비즈니스 절차에 따라 절차적으로 도메인 객체를 이용해 모든 처리를 수행한다.  
  이런 방식에서는 시간이 지남에따라 서비스가 비대해지고, 도메인 객체는 점점 정보 묶음의 역할, 곧  
  DTO의 역할만 수행하게 될 뿐이다.

- 또한 서비스는 UseCase 처리의 단위이고, 대부분의 비즈니스 로직 처리가 서비스에서 일어나게 되므로  
  비슷한 UseCase의 경우 서비스에 중복되는 코드가 계속 생겨날 수 있다. 이러한 점이 유지보수를 어렵게 할 수 있다.

- Transaction Script 패턴은 절차식 프로그래밍과 같기 때문에 객체지향 지식이 없어도 일반적으로  
 쉽게 이해할 수 있는 구조이고, 기존 데이터베이스 중심의 아키텍쳐에 익숙하다면 더 쉽게 적응할 수 있다.  
 이 패턴은 **비즈니스가 간단한 경우**에는 쉽게 적용할 수 있다. 하지만 비즈니스가 복잡해질 경우  
 서비스 코드의 양이 점점 증가하는 등 데이터베이스 중심 아키텍쳐에서 겪었던 문제점이 발생할 여지가 있다.  
 따라서 간단한 비즈니스를 처리할 때 적용하는 것이 좋다.
<hr/>

<h3>도메인 모델 패턴</h3>

- Domain Model 패턴은 도메인 객체가 데이터 뿐만 아니라 비즈니스 행위를 가지고 있으며, 도메인 객체가  
  소유한 데이터는 도메인 객체가 제공하는 행위에 의해 은닉된다.

- 도메인 객체는 각 비즈니스 개념 및 행위에 대한 책임을 수행하고, 서비스는 비즈니스 Use Case를  
  구현하기 위해 서비스의 행위를 도메인 객체에 일부분 위임해서 처리한다.

- 서비스의 책임들이 도메인으로 적절히 분산되기에 서비스가 비대해지지 않고 서비스 메소드는 단순해진다.  
  도메인 모델 패턴의 도메인 모델은 객체지향 설계의 객체 모델이다. 거대한 서비스 클래스 대신 각기  
  적절한 책임을 가진 여러 클래스로 구성되므로 이해하기가 쉽고, 관리 및 테스트하기 쉽다.  
  여기서 더 진화해서 도메인 주도 설계의 Aggregate 패턴을 적용할 수 있는 구조이다.

- 잘 만들어진 도메인 모델은 복잡한 비즈니스 로직을 처리하는데 유용하며, 잘 정의된 도메인 모델은  
  코드의 양을 줄이고 재사용성도 높인다. 따라서 이 패턴은 복잡한 비즈니스 로직이 많은 마이크로서비스의  
  구조로 선택하는 것이 좋다.

<h3>도메인 주도 설계의 Aggregate 패턴</h3>

- Aggregate 패턴은 점점 복잡해질 수 있는 객체 모델링의 단점을 보완한 패턴이라 볼 수 있다.  
  도메인 모델링을 하다 보면 객체 간의 관계를 참조로 표현하게 되는데, 참조로 정의할 경우  
  일대다(One-To-Many) 관계의 객체를 쉽게 사용할 수 있다는 장점이 있다. 그렇지만 업무가 복잡해지면  
  참조로 인한 다단계 계층 구조가 생기고 점점 참고 관계가 복잡해지고 무거워질 수 있다.

- 또한 이러한 복잡한 도메인 모델은 모델 내부의 경계가 불명확하다. 예를 들어 어떤 도메인 모델이 일대다  
  관계를 맺고 있고, Many측에 있는 클래스의 총 개수를 One측에 있는 클래스에서 집계해야 하는 규칙이  
  있다고 해보자. 서비스에서 이러한 로직을 처리할 때 Many측에 클래스가 추가되면, One측의 클래스에서  
  집계한 값을 수정해야 한다. 그런데 Many측의 클래스만 추가하고 집계한 값은 수정하지 않는다면 비즈니스의  
  일관성이 깨질 것이다. 즉, 도메인 모델이 커짐에 따라 이러한 문제가 복잡해지고 꼬일 수 있다. 이를 개선할  
  방안으로 최상위에 존재하는 Root Entity를 중심으로 개념의 집합을 분리한 것이 Aggregate 패턴이다.

- 예를 들어, 복잡한 도메인을 3 덩어리의 개념으로 분리했다고 하자. 그러면 분리된 3 덩어리는 각각  
  1개 이상의 Entity와 값 객체(Value Object)로 구성되는데, 개념적으로 묶인 Entity 모음 전체를  
  Aggregate라 한다.

- Aggregate 패턴에서는 이처럼 Aggregate를 한 단위로 일관되게 처리하기 위해 아래의 규칙을 부여한다.
  - Aggregate Root만 참조한다.
  - Aggregate 내의 상세 클래스를 참조하지 않고 값의 수정 등을 하더라도 무조건 Root를 통해 참조한다.
  - Aggregate 간의 참조는 객체를 직접 참조하는 대신 기본 키를 사용한다.
  - 기본 키를 사용하면 느슨하게 연관되고 수정이 필요하지 않은 Aggregate를 함께 수정하는 실수를 방지할 수 있다.
  - 하나의 트랜잭션으로 하나의 Aggregate만 생성 및 수정한다.

<hr/>

<h2>외부 영역 - 세부사항</h2>

- 외부 영역은 내부 영역의 서비스 인터페이스를 사용하는 Inbound Adapter와 내부 영역에서 선언한  
  Outbound 인터페이스를 구현하는 다양한 어댑터로 구성한다. 어댑터는 플러그인처럼 언제든지 교체되거나  
  확장될 수 있어야 한다. 따라서 내부 영역이 먼저 정의된 후에 외부 영역의 세부사항은 늦게 정의되도  
  상관없도록 해야 한다. 이 같은 방식이 소프트웨어를 부드럽게(Soft) 만든다.
- 그럼 어댑터들이 주로 하는 작업인 동기/비동기 통신 및 저장소 처리에 필요한 각 어댑터의  
  구현 메커니즘과 고려사항을 살펴보자.

<h3>API 퍼블리싱 어댑터</h3>

- API Publishing Adapter는 REST API를 발행하는 Inbound 어댑터다. 내부 영역의 서비스 인터페이스를  
   호출해서 REST 형식의 API를 제공한다. 명시적인 REST 리소스 명칭을 정의하고, 각 REST 메소드가  
   의도에 맞게 서비스 인터페이스를 호출한다. Entity를 직접 제공하지 않고 API의 필요에 맞는  
   DTO를 생성해서 Entity를 변환 및 매핑해서 전달하는 것이 바랍직하다.
  > 엔티티를 직접 제공하면 클라이언트에게 도메인 규칙이 유출된다.
