# 함수

## 함수 선언과 호출

- Go는 메소드도 가지며, 함수도 가진다. 제어 구조와 마찬가지로 Go는 함수 기능에 고유한 변형을 몇 가지 추가한다.

- 함수 선언은 네 부분으로 나뉜다. 키워드 func, 함수명, 파라미터, 타입이다.  
  Go는 정적 타입 언어(statically typed language)라 파라미터에 반드시 타입을 명시해야만 한다.

```go
fun main() {
	result := div(5, 2)
	fmt.Println(result)
}
```

### 이름이 지정된 파라미터와 선택적 파라미터 대응

- 이름이 지정된 파라미터와 선택적 파라미터는 Go가 제공하지 않는 기능이다. 이후에 볼 한 가지 예외적인 상황을 제외하고, 함수를 위한 파라미터는  
  호출 시 모두 넘겨져야 한다. 이름이 지정된 파라미터나 선택적 파라미터 처럼 사용하고 싶다면, 파라미터로 사용될 것과 동일하게 구조체로 만들어  
  함수에 넘겨줘야 한다.

```go
type MyFuncOpts struct {
	FirstName string
	LastName string
	Age int
}

func MyFunc(opts MyFuncOpts) error {
	// ..
}

func main() {
	MyFunc(MyFuncOpts {
		LastName: "Patel",
		Age: 50,
	})
	MyFunc(MyFuncOpts {
		FirstName: "John",
		LastName: "Doe",
		Age: 50,
	})
}
```

- 실제로 이름이 지정된 파라미터와 선택적 파라미터를 갖지 않더라도 제한은 아니다. 함수는 파라미터가 몇 개 이상을 가져서는 안되며, 이름이 지정돤  
  파라미터와 선택적 파라미터는 함수에 입력이 많을 때 주료 유용하다. 이런 상황이라면 작성된 함수가 너무 복잡할 수 있다.

### 가변 입력 파라미터와 slice

- `fmt.Println()` 같은 함수는 임의 개수의 입력 파라미터를 갖는다. 다른 언어처럼 Go는 **가변 파라미터(variadic parameter)** 를  
  지원한다. 가변 파라미터는 **반드시** 입력 파라미터 리스트에 있는 마지막 파라미터에 있어야 한다. 타입 **전에** `...`를 붙인다.  
  함수 내에서 생성된 변수는 지정된 타입의 slice이다. 즉, 가변 파라미터는 함수 내에서 다른 slice와 마찬가지로 사용이 가능하다.

```go
func addTo(base int, vals ...int) []int {
	out := make([]int, 0, len(vals))
	for _, v := range vals {
		out = append(out, base + v)
	}
	return out
}

func main() {
	fmt.Println(addTo(3))
	fmt.Println(addTo(3, 2))
	fmt.Println(addTo(3, 2, 5))
	a := []int{1, 2, 3}
	fmt.Println(addTo(3, a...))
	fmt.Println(addTo(3, []int{1, 2, 3, 4}...))
}
```

### 다중 반환값

- Go와 다른 언어들 사이의 첫 번째 차이점은 Go는 다중 반환값을 허용한다는 것이다.

```go
func divAndRemainder(numerator int, denominator int) (int, int, error) {
	if denominator == 0 {
		return 0, 0, errors.New("cannot devide by zero")
	}
	return numerator / denominator, numerator % denominator, nil
}
```

- 다중 반환 값을 지원하기 위해 몇 가지 변경 사항이 있다. Go 함수가 여러 값을 반환할 때, 반환값의 타입들을 괄호내에 `,`로 구분해 나열한다.  
  또한 함수가 여러 값을 반환한다면, 반드시 해당 값들을 쉼표로 구분해 반환해야 한다. 반환되는 값들을 괄호로 감싸면 컴파일 에러가 발생한다.

```go
func main() {
	result, remainder, err := divAndRemainder(5, 2)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	fmt.Println(result, remainder)
}
```

### 다중 반환값은 다중값

- 다중 반환값을 갖는 함수를 호출할 때, 해당 함수로부터 반환되는 각각의 값은 변수로 할당되어야 한다.  
  반환되는 여러 값을 하나의 변수로 할당하려 한다면, 컴파일 에러가 발생한다.

### 반환값 무시

- 함수 호출 시, 모든 반환 값이 의미를 갖지 않을 수 있다. 이럴 때는 반환값을 무시할 수 있는데, 무시할 반환값이 할당될 변수명을  
  `_`로 지정하면 된다.

- Go는 암묵적으로 함수에서 반환되는 값들을 **모두** 무시할 수 있다. 예를 들어 `fmt.Println()`의 경우에도 2개의 반환값이 있지만,  
  관용적으로 해당 값들을 무시한다. 거의 모든 다른 경우에는 사용하지 않을 반환값에 대해서는 `_`를 사용해 명시적으로 무시하도록 하자.

### 이름이 지정된 반환값

- Go에서는 다중 반환값 함수에서 반환값에 대해 이름을 지정할 수 있다.

```go
func divAndRemainder(numerator int, denominator int) (result int, remainder int, err error) {
	if denominator == 0 {
		err = errors.New("cannot devide by zero")
		return
	}
	result, reaminder = numerator / denominator, numerator % denominator
	return result, remainder, err
}
```

- 반환값에 대해 이름을 지정하는 것은 함수 내에서 반환값을 담기 위해 사용되는 변수를 미리 선언하는 것과 같다.  
  참고해야 할 중요한 사항은 이름이 지정된 반환값은 해당 함수 내에서만 접근 가능하다는 것이다.  
  함수 외부에서는 해당 이름의 변수가 적용되지 않는다.

- 이름이 지정된 반환값은 어떤 부분에 대해서는 코드를 명확하게 해주는 반면, 잠재적인 corner case를 가진다.  
  첫 번째로는 변수 shadowing 문제다. 다른 모든 변수와 마찬가지로 이름이 지정된 반환값이 shadowing될 수 있다.

### 빈 반환

- 이름이 지정된 반환값을 사용했다면, Go에서 하나의 심각한 오류인 blank return(빈 반환)을 조심해야 한다.  
  이름이 지정된 반환값이 있다면, 반환될 값을 명시하지 않고 return만 사용해야 한다. 해당 반환값은 이름이 지정된 변수에  
  마지막으로 할당된 값으로 처리된다.

```go
func divAndRemainder(numerator int, denominator int) (result int, remainder int, err error) {
	if denominator == 0 {
		err = errors.New("cannot devide by zero")
		return
	}
	result, reaminder = numerator / denominator, numerator % denominator
	return
}
```

- 빈 반환을 사용하면서 해당 함수에 몇 가지 변경을 했다. 유효하지 않은 입력이 있을 때 즉시 함수가 return되어 종료된다.  
  이때 result와 remainder에는 할당된 값이 없기에 해당 변수의 zero value를 반환한다. 이름이 지정된 반환 값에 대해  
  zero value를 반환하는 경우에 어떤 의미기 있는지를 생각해야 한다. 또한 함수의 마지막에는 여전히 return을 넣어야 한다.

- 빈 반환은 어느 정도 typing의 수고가 없어지기에 편리해 보이지만, 대부분의 Go 개발자들은 데이터 흐름을 이해하기 어려워지게  
  만들기 때문에 빈 반환을 좋은 선택지로 보지 않는다. 좋은 소프트웨어는 명확하고 가독성이 좋아 어떤 일이 일어나는지를 분명히  
  파악되게 할 수 있어야 한다. 빈 반환을 사용하면 코드를 읽는 사람은 반환 파라미터에 할당된 마지막 값을 추적하고, 어떤 값이  
  정확히 반환되는지 확인하기 위해 이전 코드를 다시 봐야할 수도 있다.

---

## 함수는 값이다

- 많은 다른 언어들과 마찬가지로 Go에서 함수는 값이다. 함수의 타입은 키워드 func와 파라미터 타입 및 반환값으로 구성된다.  
  이런 조합을 **함수 시그니처**라 한다. 정확히 같은 파라미터의 수와 타입을 갖는 함수는 타입 시그니처를 만족한다.

- 함수를 값으로 사용하면 함수를 map의 value로 사용해 기본 계산기를 만드는 영리한 작업을 할 수 있다.

```go
func add(i int, j int) int { return i + j}
func sub(i int, j int) int { return i - j}
func mul(i int, j int) int { return i * j}
func div(i int, j int) int { return i / j}

var opMap = map[string]func(int, int) int {
	"+": add,
	"-": sub,
	"*": mul,
	"/": div,
}

func main() {
	expressions := [][]string{
		[]string{"2", "+", "3"},
		[]string{"2", "-", "3"},
		[]string{"2", "*", "3"},
		[]string{"2", "/", "3"},
		[]string{"2", "%", "3"},
		[]string{"two", "+", "three"},
		[]string{"5"},
	}

	for _, expression := range expressions {
		if len(expression) != 3 {
			fmt.Println("invalid expression:", expression)
			continue
		}
		p1, err := strconv.Atoi(expression[0])
		if err != nil {
			fmt.Println(err)
			continue
		}
		op := expression[1]
		opFunc, ok := opMap[op]
		if !ok {
			fmt.Println("unsupported operation:", op)
			continue
		}
		p2, err := strconv.Atoi(expression[2])
		if err != nil {
			fmt.Println(err)
			continue
		}
		result := opFunc(p1, p2)
		fmt.Println(result)
	}
}
```

- 위 예시 코드에서는 표준 라이브러리의 `strconv.Atoi()` 함수를 사용해 문자열을 정수로 변환했다. 이 함수의 두 번째 반환값은  
  `error`이다. 함수가 반환하는 오류 값을 확인해 오류에 대한 처리를 알맞게 했다.

- op는 opMap이라는 map 변수의 key로 사용하고, key에 대응되는 value는 OpFunc에 할당된다. opFunc의 타입은  
  `func(int, int) int`이다. Map에 제공된 key에 연관된 함수가 존재하지 않는다면 오류 메시지 출려과 함께 loop 내에 남은  
  사항은 진행하지 않고 다음으로 넘어갈 것이다.(continue)

### 함수 타입 선언

- 구조체를 정의하기 위해 type 키워드를 사용한 것과 같이, type 키워드는 함수 타입을 정의하는 데도 사용할 수 있다.

```go
type opFuncType func(int, int) int
```

- opMap 변수 선언을 다시하면, 아래와 같다.

```go
var opMap = map[string]opFuncType {
	"+": add,
	"-": sub,
	"*": mul,
	"/": div,
}
```

- 함수는 전혀 손댈 필요가 없다. 두 개의 int 입력 파라미터를 갖고 단일 int 반환값을 갖는 모든 함수는 타입을 만족시키며, opMap의  
  value에 할당될 수 있다.

- 함수 타입을 선언하는 것의 장점은 우선 문서화가 있다. 여러 번 참조하는 경우, 이름을 붙일 수 있어 유용하다.

### 익명 함수

- 함수를 변수에 할당할 뿐만 아니라, 함수 내에 새로운 함수를 정의해 변수에 할당할 수 있다.  
  이런 이름이 필요없는 내부 함수를 **익명 함수(anonymous function)** 라 한다. 또한 해당 함수를 변수에 할당해야 할 필요도 없다.  
  함수를 inline으로 작성하고 바로 호출할 수 있다.

```go
func main() {
	for i := 0; i < 5; i++ {
		func(j int) {
			fmt.Println("printing", j, "from inside of an anonymous function")
		}(i)
	}
}
```

- 익명 함수는 func 키워드 바로 뒤에 입력 파라미터, 반환값을 넣고 여는 중괄호를 사용해 선언할 수 있다.  
  func 키워드와 입력 파라미터 사이에 함수명을 넣으려 한다면 컴파일 오류가 발생한다.

- 다른 함수와 마찬가지로 익명 함수는 괄호를 사용해 호출된다.

- 위 코드는 일반적으로 사용되는 모양은 아니다. 익명 함수를 선언하고 즉시 실행하는 경우라면, 익명 함수를 제거하고 코드로 호출하는 것이 좋다.  
  하지만 선언된 익명 함수를 변수에 할당하지 않고 사용하는 유용한 두 가지 상황이 있다. defer 문과 goroutine을 사용하는 경우이다.

---
