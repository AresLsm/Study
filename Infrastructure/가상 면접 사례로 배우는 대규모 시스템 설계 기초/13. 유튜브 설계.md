# Youtube 설계

## 문제 이해 및 설계 범위 확정

- 유튜브에서는 단순히 비디오를 보는 것 말고도 많은 일을 할 수 있다. 댓글 남기기, 비디고 공유 및 좋아요 버튼 클릭, 재생 목록에 추가,  
  채널 구독 등도 할 수 있다. 이 모두를 설계하는 것은 사실상 불가능하니, 설계 범위를 좁혀보자.

- 비디오를 올리는 기능, 시청하는 기능에 집중한다.
- 모바일 웹, 웹 브라우저, 스마트 TV를 지원한다.
- DAU는 500만이다.
- 사용자는 평균적으로 30분동안 서비스를 사용한다.
- 다국어 지원이 가능해야 한다.
- 현존하는 비디오 종류와 해상도를 대부분 지원해야 한다.
- 암호화가 필요하다.
- 비디오의 최대 크기는 1GB이다.
- 클라우드 서비스를 활용해도 좋다.

- 이번 장에서는 아래와 같은 기능을 갖춘 비디오 스트리밍 서비스 설계에 초점을 맞출 것이다.

  - 빠른 비디오 업로드
  - 원활한 비디오 재생
  - 재생 품질 선택 기능
  - 낮은 인프라 비용
  - 높은 가용성과 규모 확장성, 그리고 안정성
  - 지원 클라이언트: 모바일 웹, 웹 브라우저, 스마트 TV

### 개략적 규모 추정

- DAU: 500만 명
- 한 사용자는 하루에 평균 5개의 비디오 시청
- 10%의 사용자는 하루에 1개의 비디오 업로드
- 비디오의 평균 크기는 300MB(0.3GB)
- 비디오 저장을 위해 매일 새로 요구되는 저장 용량 = `500만 * 10% * 300MB = 150TB`
- CDN 비용
  - 클라우드 CDN을 통해 비디오를 서비스할 경우 CDN에서 나가는 데이터량에 비례해 과금된다.
  - AWS CloudFront를 사용할 경우 100%의 트래픽이 미국에서 발생한다 가정하면 1GB당 $0.02의 요금이 발생한다.
  - 따라서 매일 발생하는 요금은 `500만 * 5개 비디오 * 0.3GB * $0.02 = $150,000`이다.

---

## 개략적 설계안 제시 및 동의 구하기

> 앞서 클라우드 서비스를 사용해도 좋다고 했다. 따라서 여기서 볼 CDN과 BLOB storage는 기존 클라우드 서비스를 활용할 것이다.
> 왜 전부 직접 만들지 않을까? 그 이유는 아래와 같다.
>
> - 시스템 설계 면접은 모든 것을 밑바닥부터 만드는 것과는 관계가 없다. 주어진 시간 내에 적절한 기술을 골라 설계를 마치는 것이  
>   그 기술 각각이 어떻게 동작하는지 상세히 설명하는 것보다 중요하다. 예를 들어 비디오를 저장하기 위해 BLOB Storage를 사용할 것이라면  
>   그 사실만 언급해도 충분하다.
>
> - 규모 확장이 쉬운 BLOB Storage나 CDN을 만드는 것은 지극히 복잡할 뿐 아니라 많은 비용이 드는 일이다. Netflix나 Facebook같은  
>   큰 회사도 모든 것을 스스로 직접 구축하지 않는다. Netflix는 AWS, Facebook은 Akamai의 CDN을 이용한다.

- 개략적으로 보면, 이 시스템은 아래의 세 개 컴포넌트로 구성된다.

![picture 23](/images/SDI_YT_1.png)

- Client: 컴퓨터, 모바일 폰, 스마트 TV를 통해 유튜브를 시청할 수 있다.
- CDN: 비디오는 CDN에 저장한다. 재생 버튼을 누르면 CDN으로부터 스트리밍이 이뤄진다.
- API Server: 비디오 스트리밍을 제외한 모든 요청은 API Server가 처리한다.  
  Feed recommendation, 비디오 업로드 URL 생성, 메타데이터 데이터베이스와 cache 갱신, 사용자 가입 등등을 처리하게 된다.

- 지금부터 아래 두 영역을 개략적으로 설계해 볼 것이다.

  - 비디오 업로드 절차
  - 비디오 스트리밍 절차

### 비디오 업로드 절차

- 아래 그림은 비디오 업로드 절차의 개략적 설계안이다.

![picture 24](/images/SDI_YT_2.png)

- 사용자: 컴퓨터, 모바일 폰 혹은 스마트 TV를 통해 유튜브를 시청하는 이용자
- Load Balancer: API Server 각각으로 요청을 고르게 분산하는 역할 담당
- API Server: 비디오 스트리밍을 제외한 다른 모든 요청 처리
- Metadata Database: 비디오의 메타데이터 보관  
  Sharding과 Replication을 적용해 성능 및 가용성 요구사항을 충족한다.
- Metadata Cache: 성능을 높이기 위해 비디오의 메타데이터와 user object는 caching한다.
- Original Storage: 원본 비디오를 보관할 대형 이진 파일 저장소로, BLOB(Binary Large Object storage) 시스템이다.  
  BLOB Storage는 _"이진 데이터를 하나의 개체로 보관하는 데이터베이스 관리 시스템"_ 이다.
- Transcoding Server: 비디오 transcoding은 비디오 encoding이라 부르기도 하는 절차로, 비디오의 포맷(MPEG, HLS 등)을 변환하는 절차다.  
  단말이나 대역폭 요구사항에 맞는 최적의 비디오 스트림을 제공하기 위해 필요하다.
- Transcoded Storage: Transcoding이 완료된 비디오를 저장하는 BLOB Storage이다.
- CDN: 비디오를 cache하는 역할을 담당한다. 사용자가 재생 버튼을 누르면 비디오 스트리밍은 CDN을 통해 이뤄진다.
- Transcoding Completion Queue: 비디오 transcoding 완료 이벤트들을 보관할 message queue
- Transcoding Completion Handler: Transcoding Completion Queue에서 이벤트 데이터를 꺼내 Metadata Cache와 Database를 갱신할 작업 서버

- 각 컴포넌트들이 어떤 일을 하는지 살펴봤으니, 비디오가 업로드가 어떻게 처리되는지를 들여다보자. 아래 두 프로세스가 병렬적으로 수행된다 보면 된다.

  - (a) 비디오 업로드
  - (b) 비디오 메타데이터 갱신. 메타데이터에는 비디오 URL, 크기, 해상도, 포맷, user data가 포함된다.

#### (a): 비디오 업로드

- 아래 그림은 비디오 업로드의 과정을 보여준다.

![picture 25](/images/SDI_YT_3.png)

- 각 과정을 요약해 살펴보자.

  - (1) 비디오를 Original Storage에 업로드한다.
  - (2) Transcoding Server는 Original Storage에서 해당 비디오를 가져와 transcoding을 시작한다.
  - (3) Transcoding이 완료되면 아래의 두 절차가 병렬적으로 수행된다.
    - (3a) 완료된 비디오를 Transcoded Storage로 업로드한다.
      - (3a-1) Transcoding이 끝난 비디오를 CDN에 올린다
    - (3b) Transcoding 완료 이벤트를 Transcoding Completion Queue에 넣는다.
      - (3b-1): Transcoding Completion Handler가 이벤트 데이터를 queue에서 꺼낸다.  
        이후 Metadata Database와 Metadata Cache를 갱신한다.
  - (4) API Server가 단말에게 비디오 업로드가 끝나서 스트리밍 준비가 완료되었음을 알린다.

#### (b): 비디오 메타데이터 갱신

- Original Storage에 파일이 업로드되는 동안, 단말은 병렬적으로 비디오 메타데이터 갱신 요청을 API Server에 보낸다.  
  이 요청에 포함된 메타데이터에는 파일명, 크기, 포맷 등의 정보가 들어있다. API Server는 이 정보로 Metadata Cache와  
  Metadata Database를 갱신한다.

### 비디오 스트리밍 절차

- 유튜브에서 비디오 재생 버튼을 누르면 스트리밍은 바로 시작되며, 비디오 다운로드가 완료되어야 영상을 볼 수 있다거나 하는 불편함은 없다.  
  여기서 _다운로드_ 라 함은 영상을 단말로 내려 받는 것을 말하며, 스트리밍은 장치가 원격지의 비디오로부터 지속적으로 비디오 스트림을  
  전송받아 영상을 재생하는 것을 말한다.

- 그런데 비디오 스트리밍이 이뤄지는 절차를 보기에 앞서, 먼저 streaming protocol이라는 중요한 개념을 알아둬야 한다.  
  Streaming protocol은 비디오 스트리밍을 위해 데이터를 전송할 때 쓰이는 표준화된 통신 방법이다.  
  널리 사용되는 streaming protocol로는 아래와 같은 것들이 있다.

  - MPEG-DASH: MPEG는 "Moving Picture Experts Group"의 약어이며, DASH는 "Dynamic Adaptive Streaming over HTTP"의 약어이다.
  - Apple HLS: HLS는 "HTTP Live Streaming"의 약어이다.
  - Microsoft Smooth Streaming
  - Adobe HTTP Dynamic Streaming(Adobe HDS)

- 이 프로포콜의 동작 원리를 정확히 이해하거나 이름들을 외울 필요는 없다. 구현 세부 사항에 해당하는 부분일 뿐인데다, 확실히 이해하려면  
  관련 분야의 도메인 지식을 알아야 하기 때문이다. 다만 기억해야 할 것은 **프로토콜마다 지원하는 비디오 encoding이 다르고, 플레이어도 다르다는 것** 이다.  
  따라서 비디오 스트리밍 서비스를 설계할 때는 서비스의 용례에 맞는 프로토콜을 잘 골라야 한다.

- 비디오는 CDN에서 바로 스트리밍된다. 사용자의 단말에 가장 가까운 CDN Edge Server가 비디오 전송을 담당할 것이기에 latency는 아주 낮다.  
  아래 그림은 이 부분의 개략적 설계안이다.

![picture 26](/images/SDI_YT_4.png)

---

## 상세 설계

- 이번에도 전체 시스템을 비디오 업로드를 담당하는 부분과 비디오 스트리밍을 담당하는 부분으로 나눠 보고, 그 각각에 대한 최적화 방안과 함께  
  좀 더 상세히 다듬고 오류 처리 메커니즘도 살펴보자.

### 비디오 transcoding

- 비디오를 녹화하면 단말은 보통 해당 비디오를 특정 포맷으로 저장한다. 이 비디오가 다른 단말에서도 순조롭게 재생되려면 다른 단말과  
  호환되는 bitrate와 포맷으로 저장되어야 한다. Bitrate는 비디오를 구성하는 bit가 얼마나 빨리 처리되어야 하는지를 나타내는 단위다.  
  Bitrate가 높은 비디오는 일반적으로 고화질 비디오다. Bitrate가 높은 비디오 스트림을 정상 재생하려면 보다 높은 성능의 computing power가  
  필요하고, 인터넷 회선 속도도 빨라야 한다.

- 비디오 transcoding은 아래와 같은 이유로 중요하다.

  - Raw video는 저장 공간을 많이 차지한다. 가령 60 FPS로 녹화된 HD 비디오는 수백 GB의 저장공간을 차지하게 될 수 있다.
  - 상당수의 단말과 브라우저는 특정 종류의 비디오 포맷만 지원한다. 따라서 호환성 문제를 해결하려면 하나의 비디오를 여러 포맷으로  
    encoding 해두는 것이 바람직하다.
  - 사용자에게 끊김 없는 고화질 비디오 재생을 보장하려면, 네트워크 대역폭이 충분하지 않은 사용자에게는 저화질 비디오를, 대역폭이 충분한  
    사용자에게는 고화질 비디오를 보내는 것이 바람직하다.
  - 모바일 단말의 경우 네트워크 상황이 수시로 달라질 수 있다. 비디오가 끊김없이 재생되도록 하기 위해서는 비디오 화질을 자동으로 변경하거나  
    수동으로 변경할 수 있도록 하는 것이 바람직하다.

- encoding 포맷은 아주 다양한데, 그 대부분은 아래 두 부분으로 구성되어 있다.

  - Container: 비디오 파일, 오디오, 메타데이터를 담는 바구니 같은 것이다. Container 포맷은 `.avi`, `.mov`, `.mp4`와 같은  
    확장자를 보면 알 수 있다.
  - Codec: 비디오 화질은 보존하면서 파일 크기를 줄일 목적으로 고안된 압축 및 압축 해제 알고리즘이다.  
    가장 많이 사용되는 video codec으로는 H, 264, VP9, HEVC가 있다.

### DAG Model(Directed Acyclic Graph, 유향 비순환 그래프) 모델

- 비디오를 transcoding하는 것은 computing 자원을 많이 소모할 뿐 아니라 시간도 많이 드는 작업이다. 게다가 컨텐츠 창작자는 각자  
  자신만의 비디오 processing 요구사항을 갖고 있다. 가령 어떤 사람은 비디오 위에 watermark를 표시하고 싶어 할 것이고,  
  어떤 사람은 thumbnail 이미지를 자기가 손수 만들어 쓰고 싶어할 것이고, 어떤 사람은 고화질 비디오를 선호하는 반면, 어떤 또다른  
  사람은 저화질 비디오도 충분하다고 생각할 것이다.

- 이처럼 각기 다른 유형의 비디오 processing pipeline을 지원하는 한편 처리 과정의 병렬성을 높이기 위해서는 적절한 수준의 추상화를  
  도입해 클라이언트 프로그래머로 하여금 실행할 task를 손수 정의할 수 있도록 해야 한다. 예를 들어 Facebook의 비디오 스트리밍 엔진은  
  DAG 프로그래밍 모델을 도입, task를 단계별로 배열할 수 있도록 해 해당 작업들이 순차적으로 혹은 병렬적으로 실행될 수 있도록 학 ㅗ있다.  
  이 설계안에서도 이와 유사한 DAG Model을 도입해 유연성과 병렬성을 달성할 수 있도록 할 것이다.  
  아래 그림은 비디오 transcoding을 위해 이 설계안에서 채택한 DAG Model이다.

![picture 27](/images/SDI_YT_5.png)

- 위 그림에서 원본 비디오는 일단 비디오, 오디오, 메타데이터의 세 부분으로 나뉘어 처리된다.  
  비디오 부분에 적용되는 작업은 아래와 같다.

  - Inspection(검사): 좋은 품질의 비디오인지, 손상은 없는지 확인하는 작업
  - Encoding: 비디오를 다양한 해상도, codec, bitrate 조합으로 encoding하는 작업  
    아래는 그 결과물의 사례이다.

  ![picture 28](/images/SDI_YT_6.png)

  - Thumbnail: 사용자가 업로드한 이미지나 비디오에서 자동 추출된 이미지로 thumbnail을 만드는 작업
  - Watermark: 비디오에 대한 식별정보를 이미지 위에 overlay 형태로 띄워 표시하는 작업

### 비디오 transcoding 아키텍쳐

- 이 설계안에서는 클라우드 서비스를 활용한 비디오 transcoding 아키텍쳐를 아래와 같이 정의했다.

![picture 29](/images/SDI_YT_7.png)

- 이 아키텍쳐의 각 컴포넌트들을 살펴보자.

#### 전처리기

![picture 30](/images/SDI_YT_8.png)

- 전처리기가 하는 일은 아래의 세 가지이다.

  - (1) Video Splitting: 비디오 스트림을 GOP(Group Of Pictures)라 불리는 단위로 쪼갠다. GOP는 특정 순서로 배열된  
    frame group이다. 하나의 GOP는 독립적으로 재생 가능하며, 길이는 보통 몇 초 정도이다. 어떤 종류의 오래된 단말이나 브라우저는  
    GOP 단위의 video splitting을 지원하지 않는다. 그런 단말의 경우에는 전처리기가 video splitting을 대신 한다.

  - (2) DAG 생성: 클라이언트 프로그래머가 작성한 설정 파일에 따라 DAG를 만들어낸다.  
    아래 그림은 2개의 node와 1개의 edge로 구성된 DAG의 사례이며, 아래 2개의 설정 파일로부터 생성된 것이다.

  ![picture 31](/images/SDI_YT_9.png)
  ![picture 32](/images/SDI_YT_10.png)

  - (3) 데이터 caching: 전처리기는 split된 비디오의 cache이기도 하다. 안정성을 높이기 위해 전처리기는 GOP와 메타데이터를  
    temporary storage에 저장한다. 비디오 encoding이 실패하면 시스템은 이렇게 보관된 데이터를 활용해 encoding을 재개한다.

#### DAG Scheduler

- DAG Scheduler는 DAG를 몇 개의 stage로 분할한 다음, 그 각각을 resource manager의 task queue에 넣는다.  
  아래 그림은 DAG Scheduler가 어떻게 동작하는지 보여주는 하나의 사례이다.

![picture 33](/images/SDI_YT_11.png)

- 위 그림은 하나의 DAG를 2개의 작업 stage로 쪼갠 사례이다. 첫 단계에서는 비디오, 오디오, 메타데이터를 분리한다.  
  두 번째 단계에서는 해당 비디오 파일을 encoding하고 thumbnail을 추출하며, 오디오 파일 또한 encoding한다.

#### Resource Manager

![picture 34](/images/SDI_YT_12.png)

- Resource Manager(작업 관리자)는 자원 배분을 효과적으로 수행하는 역할을 담당한다.  
  아래 그림과 같이 3개의 queue와 task scheduler로 구성된다.

![picture 35](/images/SDI_YT_13.png)

- Task Queue(작업 큐): 실행할 작업이 보관되어 있는 Priority queue
- Worker Queue(작업 서버 큐): 작업 서버의 가용 상태 정보가 보관되어 있는 Priority queue
- Running Queue(실행 큐): 현재 실행 중인 작업 및 작업 서버 정보가 보관되어 있는 queue
- 작업 스케쥴러: 최적의 작업/서버 조합을 골라 해당 작업 서버가 작업을 수행하도록 지시하는 역할 담당

- 작업 관리자는 아래와 같이 동작한다.

  - 작업 관리자는 Task Queue에서 가장 높은 우선순위를 가진 작업(task)을 꺼낸다.
  - 작업 관리자는 해당 task를 실행하기 적합한 Worker Server를 고른다.
  - 작업 스케쥴러는 해당 worker server에게 작업 실행을 지시한다.
  - 작업 스케쥴러는 해당 작업이 어떤 서버에게 할당되었는지에 대한 정보를 Running Queue에 넣는다.
  - 작업 스케쥴러는 작업이 완료되면 해당 작업을 Running Queue에서 제거한다.

#### Worker Server

- 작업 서버는 DAG에 정의된 작업을 수행한다. 아래 그림에 보이는 대로, 작업 종류에 따라 작업 서버도 구분해 관리한다.

![picture 36](/images/SDI_YT_14.png)

#### Temporary Storage

![picture 37](/images/SDI_YT_15.png)

- 임시 저장소의 구현에는 여러 저장소 시스템을 활용할 수 있다. 어떤 시스템을 선택할 것이냐는 저장할 데이터의 유형, 크기, 이용 빈도,  
  데이터 유효기간 등에 따라 달라진다. 예를 들어 metadata는 작업 서버가 빈번히 참조하는 정보이고 그 크기도 보통 작다.  
  따라서 메모리에 cache해두면 좋을 것이다. 그러나 비디오, 오디오 데이터는 BLOB Storage에 두는 것이 바람직하다.  
  임시 저장소에 보관된 데이터는 비디오 processing이 완료되면 삭제한다.

#### Encoded Video

- encoding된 비디오는 encoding pipeline의 최종 결과물이다. `a.mp4`와 같은 이름을 갖는다.

### 시스템 최적화

- 이제 속도, 안전성, 그리고 비용 측면에서 이 시스템을 최적화해보도록 하자.

#### 속도 최적화: 비디오 병렬 업로드

- 비디오 전부를 한 번에 업로드하는 것은 비효율적이다. 하나의 비디오는 아래 그림처럼 작은 GOP들로 분할할 수 있다.

![picture 38](/images/SDI_YT_16.png)

- 이렇게 분할한 GOP를 병렬적으로 업로드하면 설사 일부가 실패해도 빠르게 업로드를 재개할 수 있다.  
  따라서 비디오를 GOP 경계에 맞춰 분할하는 작업을 단말이 수행하면 아래와 같이 업로드 속도를 높일 수 있다.

![picture 39](/images/SDI_YT_17.png)

#### 속도 최적화: 업로드 센터를 사용자 근거리에 지정

- 업로드 속도를 개선하는 또 다른 방법은 업로드 센터를 여러 곳에 두는 것이다. 즉, 미국 거주자는 비디오를 북미 지역 업로드 센터로  
  보내도록 하고, 중국 사용자는 아시아 업로드 센터로 보내도록 하는 것이다. 이를 위해 이 설계안에서는 CDN을 업로드 센터로 이용한다.

![picture 40](/images/SDI_YT_18.png)

#### 속도 최적화: 모든 절차를 병렬화

- 낮은 latency를 달성하는 것은 어려운 일이다. 이를 위해 시도해볼 수 있는 또 하나의 방법은, 느슨하게 결합된 시스템을 만들어서  
  병렬성을 높이는 것이다.

- 이를 위해서는 지금까지의 설계안을 조금 변경해야 한다. 비디오를 Original Storage에서 CDN으로 옮기는 절차를 조금 더 자세히 들여다보자.  
  이 절차는 아래 그림과 같다. 어떤 단계의 결과물은 이전 단계의 결과물을 입력으로 사용해 만들어진다는 것을 알 수 있다.  
  이런 의존성이 있으면 병렬성을 높이기 어렵다.

![picture 41](/images/SDI_YT_19.png)

- 이 시스템의 결합도를 낮추기 위해, 아래 그림과 같이 Message Queue를 도입해보자.  
  이 Message queue가 어떻게 시스템 결합도를 낮추는지 예를 들어 살펴보자.

![picture 42](/images/SDI_YT_20.png)

- Message queue를 도입하기 전 encoding module은 download module의 작업이 끝나기를 기다려야 했다.
- Message queue를 도입한 후 encoding module은 download module의 작업이 끝나기를 더 이상 기다릴 필요가 없다.  
  Message queue에 보관된 이벤트 각각을 encoding module은 병렬적으로 처리할 수 있다.

#### 안전성 최적화: Pre-signed Upload URL

- 안전성은 모든 제품의 가장 중요한 측면 가운데 하나일 것이다. 허가받은(authorized) 사용자만이 올바른 장소에 비디오를 업로드할 수 있도록  
  하기 위해, 여기서는 아래 그림과 같이 pre-signed upload URL을 시용한다.

![picture 43](/images/SDI_YT_21.png)

- 이를 위해 업로드 절차는 아래와 같이 변경된다.

  - (1) 클라이언트는 HTTP Server에 POST 요청을 보내 pre-signed URL을 받는다.  
    해당 URL이 가리키는 객체(object)에 대한 접근 권한이 이미 주어져 있는 상태다. Pre-signed URL은 사실 Amazon S3에서 사용하는 용어이다.  
    다른 클라우드 업체는 다른 이름을 사용할 수도 있다.
  - (2) API Server는 pre-signed URL을 돌려준다.
  - (3) 클라이언트는 해당 URL이 가리키는 위치에 비디오를 업로드한다.

#### 안전성 최적화: 비디오 보호

- 많은 컨텐츠 제작자가 비디오를 인터넷에 업로드하기를 주저하는데, 비디오의 원본을 도난 당할까 우려해서이다. 비디오의 저작권을 보고하기 위해  
  아래의 세 가지 선택지 중 하나를 채택할 수 있다.

  - DRM(Digital Rights Management) 시스템 도입: 이 부문에서 가장 널리 사용되는 시스템으로, Apple FairPlay, Google Widevine,  
    Microsoft PlayReady가 있다.

  - AES Encryption: 비디오를 암호화하고 접근 권한을 설정하는 방식이다. 암호화된 비디오는 재생 시에만 복호화된다. 허가된 사용자만  
    암호화된 비디오를 시청할 수 있다.

  - Watermark: 비디오 위에 소유자 정보를 포함하는 이미지 overlay를 올리는 것이다. 회사 로고, 이름 등을 이 용도에 사용할 수 있다.

#### 비용 최적화

- CDN은 이 시스템의 핵심 부분이다. 세계 어디에서도 끊김 없이 빠르게 비디오를 시청할 수 있도록 해준다. 하지만 개략적인 추정치에서도  
  알 수 있듯이 CDN은 비싸다. 데이터 크기가 크면 클수록 더하다. 이 비용을 낮출 수 있는 방법은 무엇이 있을까?

- 연구 결과에 따르면, youtube의 비디오 스트리밍은 long-tail 분포를 따른다. 인기 있는 비디오는 빈번히 재생되는 반면, 나머지는 거의  
  보는 사람이 없다는 것이다. 이에 착안해 몇 가지 최적화를 시도해볼 수 있다.

  - (1) 인기 비디오는 CDN을 통해 재생하되, 다른 비디오는 비디오 서버를 통해 재생하는 것이다.

  ![picture 44](/images/SDI_YT_22.png)

  - (2) 인기가 별로 없는 비디오는 encoding할 필요가 없을 수도 있다. 짧은 비디오라면 필요 시 encoding 해 재생할 수 있다.
  - (3) 어떤 비디오는 특정 지역에서만 인기가 높다. 이런 비디오는 다른 지역에 옮길 필요가 없다.
  - (4) CDN을 직접 구축하고 ISP와 제휴할 수 있다. CDN을 직접 구축하는 것은 초대형 프로젝트다. ISP로는 comcast, AT&T 등이 있다.  
    ISP는 전세계 어디에나 있으며 사용자와 가깝다. 이들과 제휴하면 UX를 향상시키고 인터넷 사용 비용을 낮출 수 있을 것이다.

- 이 모든 최적화는 컨텐츠의 인기도, 이용 패턴, 비디오의 크기 등의 데이터에 근거한 것이다.  
  최적화를 시도하기 전에 시청 패턴을 분석하는 것이 매우 중요하다.

### 오류 처리

- 시스템 오류는 대형 시스템에서는 불가피하다. 장애를 아주 잘 감대하는(highly fault-tolerant) 시스템을 만들려면 이런 오류를 우아하게 처리하고  
  빠르게 회복해야 한다. 시스템 오류에는 두 가지 종류가 있다.

  - Recoverable Error(회복 가능 오류): 특정 비디오 segment를 transcoding하다가 실패했다든가 하는 오류는 회복 가능한 오류에 속한다.  
    일반적으로 보면 이런 오류는 몇 번 retry(재시도)하면 해결된다. 하지만 계속해서 실패하고 복구가 어렵다 판단되면 클라이언트에게 적절한  
    오류 코드를 반환해야 한다.

  - Non-Recoverable Error(회복 불가능 오류): 비디오 포맷이 잘못되었다거나 하는 회복 불가능한 오류가 발견되면 시스템은 해당 비디오에 대한  
    작업을 중단하고 클라이언트에게 적절한 오류 코드를 반환해야 한다.

- 아래는 시스템 컴포넌트 각각에 발생할 수 있는 오류에 대한 전형적인 해결 방안이다.

  - 업로드 오류: 몇 회 retry한다.
  - 비디오 분할 오류: 낡은 버전의 클라이언트가 GOP 경계에 따라 비디오를 분할하지 못하는 경우라면, 전체 비디오를 서버로 전송하고 서버가 해당  
    비디오 분할을 처리하도록 한다.
  - Transcoding 오류: retry 한다.
  - 전처리 오류: DAG를 재생성한다.
  - DAG Scheduler 오류: 작업을 re-schedule 한다.
  - Resource Manager queue 장애: replica를 사용한다.
  - Worker server 장애: 다른 서버에서 해당 작업을 재시도한다.
  - API Server 장애: API Server는 stateless server이므로 신규 요청은 다른 API Server로 우회될 것이다.
  - Metadata Cache server 장애: 데이터는 replication되어 있으므로 다른 node에서 여전히 데이터를 가져올 수 있을 것이다.  
    장애가 난 cache server는 새로운 것으로 교체한다.
  - Metadata Database server 장애
    - Master 장애: Slave들 중 하나를 Master로 교체한다.
    - Slave 장애: 다른 slave를 통해 read 연산을 처리하고 죽은 서버는 새로운 것으로 교체한다.

---
