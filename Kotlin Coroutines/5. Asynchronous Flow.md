# Asynchronous Flow

- Suspending function은 비동기적으로 하나의 값을 반환한다.  
  하지만 만약 비동기적으로 계산돤 여러 개의 값을 반환하고 싶다면 어떻게 해야 할까? 이때 Kotlin Flow를 사용할 수 있다.

## Representing Multiple Values

- 여러 개의 값들은 코틀린에서 컬렉션으로 표현할 수 있다. 예를 들어 아래의 `simple()` 함수는 3개의 숫자를 담은 `List`를 반환하고,  
  반환받은 `List`의 원소를 각각 `main()`에서 출력한다.

```kt
fun simple(): List<Int> = listOf(1, 2, 3)

fun main() {
	simple().forEach { println(it) }
}
```

### Sequences

- 아래 처럼 하나의 값을 계산하는 데 100ms가 소요된다고 해보자. 이때, 이 값들을 `Sequence`로 표현할 수 있다.

```kt
fun simple(): Sequence<Int> = sequence {
	for (i in 1..3) {
		Thread.sleep(100)
		yield(i) // yield next value
	}
}

fun main() {
	simple().forEach { println(it) }
}
```

- 위 코드는 100ms씩 각 숫자를 출력한다.

### Suspending Functions

- 위에서 본 코드는 코드를 실행하는 main thread를 block한다는 단점이 있다. 만약 계산되는 값들이 비동기적으로 계산된다면, `simple()`을 suspending  
  function으로 표시해 blocking을 하지 않고 비동기적으로 처리할 수 있다.

```kt
suspend fun simple(): List<Int> {
	delay(1000)
	return listOf(1, 2, 3)
}

func main() = runBlocking<Unit> {
	simple().forEach { println(it) }
}
```

- 위 코드는 1초 후 모든 원소들을 출력한다.

### Flows

- 위에서 본 `simple()`은 반환형이 `List<Int>`인데, 이는 곧 모든 값들을 한 번에 반환해야 함을 의미한다.  
  비동기적으로 계산되는 값들의 _stream_ 을 나타내기 위해서는 `Flow<Int>` 타입을 사용할 수 있다.

```kt
fun simple(): Flow<Int> = flow {
	for (i in 1..3) {
		delay(100)
		emit(i) // emit next value
	}
}

func main() = runBlocking<Unit> {
	launch {
		for (k in 1..3) {
			println("I'm not blocked $k")
			delay(100)
		}
	}
	simple().collect { println(it) }
}

/*
I'm not blocked 1
1
I'm not blocked 2
2
I'm not blocked 3
3
*/
```

- 위 코드는 각 숫자를 출력하기 전 main thread를 blocking하지 않고 100ms 씩 기다린다.  
  "I'm not blocked"가 100ms 씩 출력되는 것으로 이를 알 수 있다.

- `Flow`를 사용한 이 코드에서 다른 코드의 차이점을 보자.

  - 우선 `Flow`를 사용하기 위한 builder function은 `flow { .. }`이다.
  - `flow { .. }` 안의 코드는 suspendable하다.
  - `simple()` 함수는 더 이상 suspend 키워드가 적용되어 있지 않다.
  - 값들은 `emit()`을 통해 flow로부터 _emit_ 된다.
  - 값들은 `collect()`를 통해 flow로부터 _collect_ 된다.

> `flow { .. }` 내의 `delay()`를 `Thread.sleep()`으로 바꾸면 main thread가 block된다.

---

## Flows are cold

- `Flows`는 `Sequence`와 비슷하게 _cold_ 한데, 즉 `flow { .. }` builder 내의 코드는 flow가 _collect_ 되기 전까지 실행되지 않는다.

```kt
fun simple(): Flow<Int> = flow {
    println("Flow started")
    for (i in 1..3) {
        delay(100)
        emit(i)
    }
}

fun main() = runBlocking<Unit> {
    println("calling simple()..")
    val flow = simple()
    println("calling simple().collect()..")
    flow.collect { println(it) }
    println("calling collect() again..")
    flow.collect { println(it) }
}

/*
calling simple()..
calling simple().collect()..
Flow started
1
2
3
calling collect() again..
Flow started
1
2
3
*/
```

- 여기서 왜 `simple()`이 suspend 키워드가 없어도 되는지 알 수 있다. `simple()`은 재빠르게 return하고 아무런 것도 기다리지 않는다.  
  flow는 _collect_ 될 때마다 시작된다. 위 코드에서 `collect()`가 호출되었을 때 "Flow started"가 출력된 것을 볼 수 있다.

---

## Flow cancellation basics

- `Flow`는 일반적인 coroutine의 cancellation과 비슷하게 동작한다. 마찬가지로 flow _collection_ 은 flow가 `delay()`와 같은  
  cancellable suspending function에 의해 suspend 되었을 때 cancel될 수 있다.

- 아래 예시 코드는 `withTimeoutOrNull { .. }` 블록 내에서 어떻게 flow가 cancel 되는지 보여준다.

```kt
fun simple(): Flow<Int> = flow {
    for (i in 1..3) {
        delay(100)
        println("Emitting $i")
        emit(i)
    }
}

fun main() = runBlocking<Unit> {
    withTimeoutOrNull(250) {
        simple().collect { println(it) }
    }
    println("Done")
}

/*
Emitting 1
1
Emitting 2
2
Done
*/
```

## Flow builders

- 이전에 코드에서 본 `flow { .. }` builder는 기본적인 flow builder이다.  
  Flow의 사용을 위한 다른 builder들도 있는데, 아래와 같다.

  - `flowOf { .. }` builder는 고정된 값들을 반환하는 flow를 정의한다.
  - 다양한 컬렉션과 `Sequence`는 `asFlow()` 함수를 통해 `Flow`로 변환될 수 있다.

```kt
(1..3).asFlow().collect { println(it) }
```

---

## Intermediate flow operators

- `Flow`에는 컬렉션과 `Sequence`에 대해서와 마찬가지로 다양한 연산을 진행할 수 있다. 중간 연산들이 upstream flow에 적용된 후  
  downstream flow를 반환한다. 호출하는 연산 함수들 자체는 suspending function이 아니다. 이 함수들은 `Flow`와 마찬가지로  
  _cold_ 한데, 즉 필요할 때까지 연산을 수행하지 않는다는 것이다.

- 기본적인 중간 연산들은 `map()`, `filter()`와 같이 친숙한 이름을 갖고 있다.  
  `Sequence`와의 중요한 차이점 중 하나는 `Flow`의 중간 연산 블록 내에서는 suspending function을 호출할 수 있다는 점이다.

- 예를 들어 수신되는 요청들의 flow는 아무리 연산이 오래 걸리는 suspending function으로 값을 구하더라도 `map()`으로  
  결과값을 받아올 수 있다. 아래 코드를 보자.

```kt
suspend fun performRequest(request: Int): String {
	delay(1000)
	return "response $request"
}

fun main() = runBlocking<Unit> {
	(1..3).asFlow()
		.map { request -> performRequest(request) }
		.collect { response -> println(response) }
}

/*
response 1
response 2
response 3
*/
```

- 위 코드는 1초씩 하나의 결과를 출력한다.

### Transform Operator

- Flow transformation operator들 중, 가장 일반적인 것은 `transform()`이다. 이 함수를 사용해 `map()`, `filter()`등과 같은  
  간단한 변환 연산을 흉내낼 수도 있고, 더 복잡한 연산도 수행할 수 있다. `transform()`을 사용하면 값들에 대해 여러 가지의 연산을 수행할 수 있다.

- 예를 들어, 아래 코드에서는 `transform()`을 사용해 오래 걸리는 작업(`performRequest()`)을 하기 전에 하나의 문자열을 emit 한다.

```kt
(1..3).asFlow()
	.transform { request ->
		emit("Making request $request")
		emit(performRequest(request))
	}
	.collect { response -> println(response) }

/*
Making request 1
response 1
Making request 2
response 2
Making request 3
response 3
*/
```

### Size-limiting operators

- `take()`와 같이 size를 제한하는 intermediate operator들은 지정된 size 제한만큼 결과를 얻어내면 flow의 연산을 중지한다.  
  Coroutine의 cancellation은 항상 예외를 던지는 것으로 이뤄지기에, `try { .. } finally { .. }` 등과 같이 리소스를 관리하는  
  블록이나 함수들도 cancellation에 대해 정상적으로 작동한다.

```kt
fun numbers(): Flow<Int> = flow {
	try {
		emit(1)
		emit(2)
		println("This line will not execute")
	} finally {
		println("Finally in numbers")
	}
}

fun main() = runBlocking<Unit> {
	number()
		.take(2)
		.collect { value -> println(value) }
}

/*
1
2
Finally in numbers
*/
```

---

## Terminal flow operators

- `Flow`에 대한 terminal operator들은 `Flow`에 대해 컬렉션을 만들어내는 suspending function이다.  
  `collect()` 연산자는 이 중 가장 기본적인 것이지만, 더 많은 다른 terminal operator들도 있다.

  - `toList()`, `toSet()` 등과 같이 다양한 컬렉션으로 변환할 수 있다.
  - `first()`로 첫 번째 값을 가져오거나, `single()`을 통해 flow가 하나의 값만 emit하는지 확인할 수 있다.
  - `reduce()`와 `fold()`를 사용해 `Flow`를 하나의 값으로 reducing할 수 있다.

```kt
val sum = (1..5).asFlow()
	.map { it * it }
	.reduce { a, b -> a + b }
println(sum)  // 55
```

---

## Flows are sequential

- `Flow`의 각 연산은 특별한 연산자들이 적용되지 않는 이상 순차적으로 진행된다. 연산은 terminal operator를 호출하는 coroutine에서  
  바로 수행된다. 즉, 기본적으로 새로운 coroutine이 생기진 않는다. Emit된 값들은 upstream에서 downstream으로 각 intermediate  
  operator들에 의해 계산되고, 각각 terminal operator로 전달된다.

```kt
(1..5).asFlow()
	.filter {
		println("Filter $it")
		it % 2 == 0
	}
	.map {
		println("Map $it")
		"string $it"
	}.collect {
		println("Collect $it")
	}

/*
Filter 1
Filter 2
Map 2
Collect string 2
Filter 3
Filter 4
Map 4
Collect string 4
Filter 5
*/
```

---

## Flow context

- Flow에서 _collect_ 는 항상 호출되는 coroutine 내에서 발생한다. 예를 들어 `simple`이라는 flow가 있다고 해보자.  
  아래 코드는 `simple` flow의 구현 세부사항과 관계없이 `simple` flow를 호출하는 context 내에서 실행된다.

```kt
withContext(context) {
	simple().collect { value -> println(value) }
}
```

- 이러한 flow의 프로퍼티를 _context preservation_ 이라 한다.

- 따라서 기본적으로 `flow { .. }` builder 내의 코드는 호출부의 context 내에서 실행된다. 예를 들어, 실행되는 thread 정보를 출력하는  
  아래의 `simple()` 함수를 보자.

```kt
fun simple(): Flow<Int> = flow {
	log("Started simple flow")
	for (i in 1..3) {
		emit(i)
	}
}

fun main() = runBlocking<Unit> {
	simple().collect { value -> println("Collected $value" )}
}

/*
[main @coroutine#1] Started simple flow
[main @coroutine#1] Collected 1
[main @coroutine#1] Collected 2
[main @coroutine#1] Collected 3
*/
```

- `simple().collect{ .. }`가 main thread에서 호출되었기에 `simple` flow의 구현부도 main thread에서 수행된다.  
  이러한 flow의 구현 방식은 매우 빠르게 동작하거나 비동기적으로 동작하는 코드가 실행되는 context를 신경쓰지 않아도 되고, 호출부를  
  block하지 않기에 매우 좋은 방식이다.

### Wrong emission withContext

- 경우에 따라 CPU를 많이 소모하고 시간이 매우 오래 걸리는 작업들은 `Dispatchers.Default`의 context에서 수행되어야 할 때가 있다.  
  또한 UI를 갱신하는 코드는 `Dispatchers.Main` 의 context에서 수행되어야 할 수도 있다. 보통 `withContext { .. }`를 사용해  
  coroutine이 실행될 context를 지정해줄 수 있지만, `flow { .. }` builder 내에서는 context preservation property가 존재하기에  
  이를 사용하면 안된다. 따라서 다른 context에서 값을 emit할 수 없다.

```kt
fun simple(): Flow<Int> = flow {
	kotlinx.coroutines.withContext(Dispatchers.Default) {
		for (i in 1..3) {
			Thread.sleep(100)
			emit(i)
		}
	}
}

fun main() = runBlocking<Unit> {
	simple().collect { value -> println(value) }
}
```

- 위 코드는 예상하다 시피 예외를 발생시킨다.

### `flowOn()` operator

- Context preservation property를 무시하고 꼭 특정 flow가 수행될 context를 지정하고 싶다면 `flowOn()` operator를 사용하면 된다.  
  `flowOn()`을 사용하는 것이 flow의 context를 변경하는 올바른 방식이다. 아래 코드를 보자.

```kt
fun simple(): Flow<Int> = flow {
	for (i in 1..3) {
		Thread.sleep(100)
		println("Emitting $i")
		emit(i)
	}
}.flowOn(Dispatchers.Default)

fun main() = runBlocking<Unit> {
	simple().collect { value -> println("Collected $value") }
}

/*
[DefaultDispatcher-worker-1] Emitting 1
[main] Collected 1
[DefaultDispatcher-worker-1] Emitting 2
[main] Collected 2
[DefaultDispatcher-worker-1] Emitting 3
[main] Collected 3
*/
```

- 위 결과를 보면 `flow { .. }`의 내용은 background thread에서 동작하지만, collection은 main thread에서 수행됨을 알 수 있다.

- 위 결과에서 유의해야할 또다른 점은 `flowOn()`이 flow가 순차적으로 수행되는 것을 변경했다는 것이다.  
  Collection은 하나의 coroutine(c1)에서 진행되고, emission은 또다른 coroutine(c2)에서 수행된다. 그리고 c1과 c2는 병렬적으로 수행된다.  
  즉, `flowOn()` operator는 해당 context의 `CoroutineDispatcher`를 변경해야 할 때 upstream flow를 위한 새로운  
  coroutine을 생성하게 된다.

---
