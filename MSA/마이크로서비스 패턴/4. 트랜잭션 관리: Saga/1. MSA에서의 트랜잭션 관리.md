# MSA에서의 트랜잭션 관리

- 엔터프라이즈 애플리케이션은 거의 모든 요청을 하나의 DB 트랜잭션으로 처리한다.  
  개발자는 보통 트랜잭션 관리를 간소화한 프레임워크, 라이브러리를 사용하고  
  그중에는 트랜잭션을 명시적으로 시작, 커밋, 롤백할 수 있는 프로그램형 API를  
  제공하는 제품도 있다. Spring Framework는 선언형 메커니즘을 제공한다.  
  즉, 메소드 선언부에 `@Transactional` 어노테이션만 붙이면 해당 메소드를  
  하나의 트랜잭션으로 자동 실행하므로 개발자가 간편하게 트랜잭셔널 비즈니스  
  로직을 작성할 수 있다.

- 단일 DB에 접근하는 모놀리틱 애플리케이션의 트랜잭션 관리는 어렵지 않다.  
  하지만 다중 DB, 다중 메시지 브로커를 사용하는 모놀리틱 애플리케이션이나,  
  자체 DB를 가진 여러 서비스로 구성된 MSA는 트랜잭션 관리가 어렵기 때문에  
  좀 더 정교한 메커니즘이 필요하다.

- Saga에 대해 살펴보기 전에, 먼저 MSA에서 트랜잭션 관리가 어려운 이유를 알아보자.

<h2>분산 트랜잭션의 필요성</h2>

- `createOrder()`는 주문 가능한 소비자인지 확인하고, 주문 내역을 확인하고,  
  소비자의 신용카드를 승인하고, DB에 주문을 생성하는 작업으로 이뤄진다.  
  모놀리틱 애플리케이션에서 이런 작업을 구현하기에는 그렇게 어렵지 않다.  
  주문 검증에 필요한 데이터를 그냥 가져오면 되기 때문이다.  
  Spring을 사용할 경우, `createOrder()` 메소드에 `@Transactional`만  
  붙여주면 ACID 트랜잭션이 자동으로 걸려, 데이터 일관성이 보장된다.

- 반면, 데이터가 여러 서비스에 흩어져 있는 MSA는 복잡하다.  
  `createOrder()`는 소비자 서비스, 주문 서비스, 주방 서비스, 회계 서비스 등  
  여러 서비스에 있는 데이터에 접근해야 한다.

- 서비스마다 DB가 따로 있기 때문에 여러 DB에 걸쳐 데이터 일관성을 유지할 수 있는  
  수단을 강구해야 한다.

<hr/>
