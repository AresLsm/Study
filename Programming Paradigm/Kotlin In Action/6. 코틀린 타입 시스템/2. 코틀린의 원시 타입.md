# 코틀린의 원시 타입

## 원시 타입: `Int`, `Boolean` 등

- Java는 원시 타입(primitive type)과 참조 타입(reference type)을 구분한다.  
  원시 타입의 변수에는 그 값이 직접 들어가지만, 참조 타입의 변수에는 메모리상의 객체 위치가 들어간다.

- 원시 타입의 값을 더 효율적으로 저장하고 여기저기 전달할 수 있다. 하지만 그런 값에 대해 메소드를  
  호출하거나 컬렉션에 원시 타입 값을 담을 수는 없다. Java는 참조 타입이 필요한 경우, 특별한  
  wrapper type(`java.lang.Integer` 등)으로 원시 타입 값을 감싸서 사용한다.  
  따라서 정수의 컬렉션을 정의하려면 `Collection<int>`가 아니라 `Collection<Integer>`를 사용해야 한다.

- 코틀린은 원시 타입과 참조 타입을 구분하지 않으므로 항상 같은 타입을 사용한다.

```kt
val i: Int = 1
val list: List<Int> = listOf(1, 2, 3)
```

- Wrapper 타입을 따로 구분하지 않으면 편리하다. 더 나아가 코틀린에서는 숫자 타입 등 원시 타입의 값에 대해  
  메소드를 호출할 수 있다. 예를 들어, 아래 코드는 표준 라이브러리 함수인 `coerceIn()`을 사용해 값을 특정 범위로 제한한다.

```kt
fun showProgress(progress: Int) {
    val percent = progress.coerceIn(0, 100)
    println("$percent%")
}
```

- 원시 타입과 참조 타입이 같다면 코틀린은 항상 그들을 객체로 표현하는 걸까? 그렇게 한다면 비효율적이지 않을까?  
  실제로도 항상 객체로 표현한다면 비효율적이겠지만, 코틀린은 그러지 않는다.

- 실행 시점에 숫자 타입은 가능한 한 가장 효율적인 방식으로 표현된다. 대부분의 경우(변수, 프로퍼티, 파라미터 등)  
  코틀린의 `Int`는 Java의 int로 변환된다. 이런 컴파일이 불가능한 경우는 컬렉션과 같은 제네릭 클래스를 사용하는  
  경우 뿐이다. 예를 들어, `Int` 타입을 컬렉션의 타입 파라미터로 넘기면 그 컬렉션에는 `Int`의 wrapper 타입에  
  해당하는 `java.lang.Integer` 객체가 들어간다.

- Java 원시 타입에 해당하는 타입은 아래와 같다.

  - 정수 타입: `Byte`, `Short`, `Int`, `Long`
  - 부동소수점 수 타입: `Float`, `Double`
  - 문자 타입: `Char`
  - 불리언 타입: `Boolean`

- `Int`와 같은 코틀린 타입에는 null 참조가 들어갈 수 없기에 쉽게 그에 상응하는 Java 원시 타입으로 컴파일할 수 있다.  
  마찬가지로 반대로 Java의 원시 타입은 절대 null이 될 수 없으므로 Java 원시 타입을 코틀린에서 사용할 때도  
  플랫폼 타입이 아니라, null이 될 수 없는 타입으로 취급할 수 있다.

<hr/>

## nullable한 원시 타입: `Int?`, `Boolean?` 등

- null 참조를 Java의 참조 타입 변수에만 대입할 수 있기에 null이 될 수 있는 코틀린 타입은 Java의 원시 타입으로  
  표현할 수 없다. 따라서 코틀린에서 nullable한 원시 타입을 사용하면, 그 타입은 Java의 wrapper type으로 컴파일된다.

```kt
data class Person(val name: String, val age: Int? = null) {
    fun isOlderThan(other: Person): Boolean? {
	if(age == null || other.age == null) return null
	return age > other.age
    }
}
```

- 위 코드에서 null 가능성 관련 규칙을 어떻게 적용하는지 살펴보자. null이 될 가능성이 있으므로 `Int?` 타입의  
  두 값을 직접 비교할 수는 없다. 먼저 두 값이 모두 null이 아닌지 검사해야 한다. 컴파일러는 null 검사를 마친  
  다음에야 두 값을 일반적인 값처럼 다루게 허용한다.

- `Person`에 선언된 age 프로퍼티의 값은 `java.lang.Integer`로 저장된다. 하지만 그런 자세한 사항은 Java에서  
  가져온 클래스를 다룰 때만 문제가 된다. 코틀린에서 적절한 타입을 찾으려면 그 변수나 프로퍼티에 null이 들어갈 수  
  있는지만 고민하면 된다.

- 앞서 본 대로 제네릭 클래스의 경우, wrapper 타입을 사용한다. 어떤 클래스의 타입 인자로 원시 타입을 넘기면, 그 타입에  
  대한 Boxed type을 사용한다. 예를 들어, 아래 코드에서는 null이나 nullable한 타입을 전혀 사용하지 않았지만,  
  만들어지는 리스트는 `Integer` 타입으로 이뤄진 리스트다.

```kt
val listOfInts = listOf(1, 2, 3)
```

- 이렇게 컴파일되는 이유는 JVM에서 제네릭을 구현하는 방법 때문이다. JVM은 타입 인자로 원시 타입을 허용하지 않는다.  
  따라서 Java, 코틀린 모두에서 제네릭 클래스는 항상 boxed type을 사용해야 한다. 원시 타입으로 이뤄진 대규모 컬렉션을  
  효율적으로 저장해야 한다면 원시 타입으로 이뤄진 효율적인 컬렉션을 제공하는 서드 파티 라이브러리를 사용하거나, 배열을  
  사용해야 한다.

<hr/>

## 숫자 변환

- 코틀린과 Java의 가장 큰 차이점 중 하나는 숫자를 변환하는 방식이다. 코틀린은 한 타입의 숫자를 다른 타입의 숫자로  
  자동 변환하지 않는다. 결과 타입이 허용하는 숫자의 범위가 원래 타입의 범위보다 넓은 경우조차도 자동 변환은 불가능하다.  
  예를 들어, 아래 코드는 에러가 발생한다.

```kt
val i = 1
val l: Long = i // error
```

- 대신 직접 변환 메소드를 호출해야 한다.

```kt
val i = 1
val l: Long = i.toLong()
```

- 코틀린은 `Boolean`을 제외한 모든 원시 타입에 대한 변환 함수를 제공한다. 그런 변환 함수의 이름은 `toByte()`, `toShort()` 등과 같다.  
  양방향 변환 함수가 모두 제공된다. ex.) `Int.toLong()`

- 코틀린은 개발자의 혼란을 피하기 위해 변환을 명시하기로 결정했다. 특히 Boxed 타입을 비교하는 경우 문제가 많다.  
  두 Boxed 타입 간의 `equals()`는 그 안에 들어 있는 값이 아닌 Boxed 타입 객체를 비교한다. 따라서 Java에서  
  `new Integer(42).equals(new Long(42))`는 false이다. 코틀린에서 묵시적 변환을 허용했다면, 아래처럼 쓸 수 있을 것이다.

```kt
val x = 1
val list = listOf(1L, 2L, 3L)
x in list
```

- 대부분의 사람들이 생각하는 바와 달리, 위 식의 결과는 false이다. 따라서 `x in list`는 컴파일되면 안된다.  
  코틀린에서는 아래처럼 타입을 명시적으로 변환해서 같은 타입의 값으로 만든 후 비교해야 한다.

```kt
val x = 1
println(x.toLong() in listOf(1L, 2L, 3L)) // true
```

- 코드에서 동시에 여러 숫자 타입을 사용하려면 예상치 못한 동작을 피하기 위해 각 변수를 명시적으로 변환해야 한다.

> - **원시 타입 리터럴**
>
> - 코틀린은 소스코드에서 단순한 10진수(정수) 외에 아래와 같은 숫자 리터럴을 허용한다.
>
> - `L` 접미사가 붙은 `Long` 타입 리터럴(1L, 100L, -42L)
> - 표준 부동소수점 표기법을 사용한 `Double` 타입 리터럴: 0.12, 2.0, 1.2e10
> - `f`나 `F` 접미사가 붙은 `Float` 타입 리터럴: 0.12f, 2.0f, 1.2e10f
> - `0x`나 `0X` 접두사가 붙은 16진 리터럴: 0xFF, 0X7FFFFFFF
> - `0b`나 `0B` 접두사가 붙은 2진 리터럴: 0b1010, 0B1100101
>
> - 코틀린 1.1부터는 숫자 리터럴 중간에 밑줄(`_`)을 넣을 수 있다. (1_234, 1_0000_0000_000L)
>
> - 문자 리터럴의 경우 Java와 마찬가지 구문을 사용한다.

- 숫자 리터럴을 사용할 때는 보통 변환 함수를 호출할 필요가 없다. 42L이나 42.0f처럼 상수 뒤에 타입을 표현하는  
  문자를 붙이면 변환이 필요 없다. 또한 직접 변환하지 않아도 숫자 리터럴을 타입이 알려진 변수에 대입하거나 함수에 인자로  
  넘기면 컴파일러가 필요한 변환을 자동으로 넣어준다. 추가로 산술 연산자는 적당한 타입의 값을 받아들일 수 있게 이미  
  오버로딩되어 있다. 예를 들어, 아래처럼 별도 변환 없이도 코드가 잘 동작한다.

```kt
fun foo(l: Long) = println(l)

// client
val b: Byte = 1
val l = b = 1L
foo(42) // 42
```

- 코틀린 산술 연산자에서도 Java와 마찬가지로 숫자 연산 시 overflow가 발생할 수 있다.  
  코틀린은 overflow를 검사하느라 추가 비용을 들이지 않는다.

<hr/>
