# 비동기: 동시성 프로그래밍 1

<h2>callback, Promise</h2>

- JavaScript에서 비동기 동시성 프로그래밍을 하는 방법으로는 크게 두 가지가 있다.  
  첫 번째는 callback을 사용하는 것이며, 두 번째는 `Promise`를 기반으로 하여  
  메소드 체이닝을 하는 것이다.

- 먼저 callback 방식이다.

```js
function add10(a, callbackFn) {
  setTimeout(() => callbackFn(a + 10), 100);
}

add10(5, (res) => {
  console.log(res);
}); // 15

add10(5, (res) => {
  add10(res, (res) => {
    add10(res, (res) => {
      console.log(res);
    });
  });
});
```

- 다음으로 promise 기반의 메소드 체이닝 방식을 보자.

```js
function add20(a) {
  return new Promise((resolve) => setTimeout(() => resolve(a + 20), 100))();
}

add20(5).then((res) => console.log(res));

add20(5)
  .then(add20)
  .then(add20)
  .then(add20)
  .then(add20)
  .then((res) => console.log(res));
```

- 벌써 callback 방식에 비해 promise기반의 메소드 체이닝 방식이 눈에 띄게 편리하고, 가독성이 좋다.  
  이때, promise 기반의 방식이 callback에 비해 근본적으로 가지는 차이점은 `.then()`을 사용하여  
  결과를 꺼내본다는 것이 아니라 **비동기 상황을 일급 값으로 다룬다는 중요한 차이점이 있다.**

- promise는 `Promise`라는 클래스를 통해서 만들어진 인스턴스를 반환하는데, 그 인스턴스는 _대기_, _성공_,  
  _실패_ 를 다루는 일급 값으로 이루어져 있다.

- 위 코드에서 `add10()` callback 함수를 보면 비동기적인 상황을 다루는 것이 코드로만 표현되고 있는데,  
  `add20()`같은 경우에는 비동기 상황에 대한 값을 만들어서 리턴을 하고 있다는 것이 매우 중요한 차이점이다.

```js
const a = add10(5, (res) => {
  add10(res, (res) => {
    add10(res, (res) => {
      console.log(res);
    });
  });
});

const b = add20(5)
  .then(add20)
  .then(add20)
  .then((res) => console.log(res));
```

- a는 `undefined`, b는 `Promise`라는 값이 나온다. 이 점이 그 중요한 차이점이다.

- 아래 코드와 주석은 콘솔에 입력했을 때의 결과값이다.

```js
add10(5, (_) => _);
// undefined

add20(5, (_) => _);
// Promise {<pending>}

var c = add20(5, (_) => _);
console.log(c); // Promise {<pending>}

var d = c.then((a) => a - 5);
console.log(d); // Promise {<resolved>: 20}

d.then(console.log()); // 20
```

- 이렇게 Promise는 비동기를 값으로 만들어주고, 값으로 만들어 준다는 것은 일급임을 의미한다.

<hr/>
