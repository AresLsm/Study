## 문장을 함수로 옮기기

```js
// 리팩토링 적용 전

result.push(`<p>제목: ${person.photo.title}>/p>`);
result.concat(photoData(person.photo));

function photoData(photo) {
  return [
    `<p>위치: ${photo.location}</p>`,
    `<p>날짜: ${photo.data.toDateString()}</p>`,
  ];
}

// 리팩토링 적용 후

result.concat(photoData(person.photo));

function photoData(photo) {
  return [
    `<p>제목: ${person.photo.title}>/p>`,
    `<p>위치: ${photo.location}</p>`,
    `<p>날짜: ${photo.data.toDateString()}</p>`,
  ];
}
```

### 배경

- 중복 제거는 코드를 건강하게 관리하는 가장 효과적인 방법 중 하나다. 예를 들어, 특정 함수를  
  호출하는 코드가 나올 때마다 그 앞이나 뒤에서 똑같은 코드가 추가로 실행되는 모습을 보면,  
  그 반복되는 부분을 피호출 함수로 합치는 방법을 궁리해보자. 이렇게 해두면 추후 반복되는  
  부분에서 무언가 수정할 일이 생겼을 때 단 한 곳만 수정하면 된다. 호출하는 곳이 아무리 많더라도  
  말이다. 혹시 나중에 이 코드의 동작을 여러 변형들로 나눠야 하는 순간이 오면, **문장을 호출한 곳으로 옮기기**를  
  적용해 쉽게 다시 뽑아낼 수 있다.

- 문장들은 함수로 옮기려면 그 문장들이 피호출 함수의 일부라는 확신이 있어야 한다.  
  피호출 함수와 한 묶음은 아니지만, 여전히 함께 호출돼야 하는 경우라면 단순히 해당 문장들과  
  피호출 함수를 통째로 또 하나의 **함수로 추출** 한다. 이 방법도 절차는 똑같다. 단, 마지막의  
  인라인과 이름 바꾸기 단계(`(5)`, `(6)`) 만 제외하면 된다. 이 역시 자주 사용되는 방법이며,  
  나중에 필요하다면 생략했던 마지막 단계들을 마저 수행할 수도 있다.

### 절차

- (1) 반복 코드가 함수 호출과 멀리 떨어져 있다면 **문장 슬라이드하기**를 적용해 근처로 옮긴다.
- (2) 대상 함수를 호출하는 곳이 한 곳 뿐이면, 단순히 소스 위치에서 해당 코드를 잘라내 피호출  
  함수로 복사하고 테스트한다. 이 경우라면 뒤의 나머지 단계는 무시한다.
- (3) 호출자가 둘 이상이면 호출자 중 하나에서 대상함수 호출 부분과 그 함수로 옮기려는 문장들을 함께  
  다른 **함수로 추출**한다. 추출한 함수에는 기억하기 쉬운 임시 이름을 지어준다.
- (4) 다른 호출자 모두가 방금 추출한 함수를 사용하도록 수정한다.  
  하나씩 수정할 때마다 테스트한다.
- (5) 모든 호출자가 새로운 함수를 사용하게 되면, 원래 함수를 새로운 함수 안으로 **인라인**한 후  
  원래 함수를 제거한다.
- (6) 새로운 함수의 이름을 원래 함수명으로 바꿔준다. (**함수이름 바꾸기**)

### 예시

- 사진 관련 데이터를 HTML로 내보내는 코드를 보자.

```js
function renderPerson(outStream, person) {
  const result = [];
  result.push(`<p>${person.name}</p>`);
  result.push(renderPhoto(person.photo));
  result.push(`<p>제목: ${person.photo.title}</p>`);
  result.push(emitPhotoData(person.photo));
  return result.join("\n");
}

function photoDiv(p) {
  return ["<div>", `<p>제목: ${p.title}</p>`, emitPhotoData(p), "</div>"].join(
    "\n"
  );
}

function emitPhotoData(photo) {
  const result = [];
  result.push(`<p>위치: ${photo.location}</p>`);
  result.push(`<p>날짜: ${photo.date.toDateString()}</p>`);
  return result.join("\n");
}
```

- 위 코드에서는 총 두 곳에서 `emitPhotoData()`를 호출하며, 두 곳 모두 바로 앞에는 제목 출력 코드가  
  나온다. 제목을 출력하는 코드를 `emitPhotoData()` 안으로 옮겨 이 중복을 없애보자.  
  호출자가 하나였다면 단순히 해당 코드를 잘라 붙이면 되지만, 호출자 수가 늘어날수록 더 안전한  
  길을 선택해야 한다.

- 가장 먼저 _(3) 호출자 중 하나에 함수 추출하기를 적용_ 하자. 아래와 같이 `emitPhotoData()`로  
  옮기려는 코드와 `emitPhotoData()` 호출문을 함께 추출하면 된다.

```js
function photoDiv(p) {
  return ["<div>", zznew(p), "</div>"].join("\n");
}

function zznew(p) {
  return [`<p>제목: ${p.title}</p>`, emitPhotoData(p)].join("\n");
}
```

- 이제 _(4) 다른 호출자들이 새로운 함수를 사용하게 수정_ 하자.

```js
function renderPerson(outStream, person) {
  const result = [];
  result.push(`<p>${person.name}</p>`);
  result.push(renderPhoto(person.photo));
  result.push(zznew(person.photo));
  return result.join("\n");
}
```

- 호출자들을 빠짐없이 수정했다면, _(5) 원래 함수를 새로운 함수 안으로 인라인_ 하자.

```js
function zznew(p) {
  return [
    `<p>제목: ${p.title}</p>`,
    `<p>위치: ${p.location}</p>`,
    `<p>날짜: ${p.date.toDateString()}</p>`,
  ].join("\n");
}
```

- 그리고 _(6) 새로운 함수명을 바꿔_ 마무리하자.

```js
function renderPerson(outStream, person) {
  const result = [];
  result.push(`<p>${person.name}</p>`);
  result.push(renderPhoto(person.photo));
  result.push(emitPhotoData(person.photo));
  return result.join("\n");
}

function photoDiv(p) {
  return ["<div>", emitPhotoData(p), "</div>"].join("\n");
}

function emitPhotoData(photo) {
  return [
    `<p>제목: ${photo.title}</p>`,
    `<p>위치: ${photo.location}</p>`,
    `<p>날짜: ${photo.date.toDateString()}</p>`,
  ].join("\n");
}
```

<hr/>
