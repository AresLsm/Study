# 지연성 2

<h2>결과를 만드는 함수 reduce, take</h2>

- 기존의 `reduce()`, `take()` 함수를 보자.

```js
const take = curry(limit, iterable) => {
  let res = [];
  for(const a of iterable) {
    res.push(a);
    if(res.length === limit) return res;
  }
  return res;
});

const reduce = curry((fn, start, iterable) => {
  if(!iterable) {
    iterable = start[Symbol.iterator]();
    start = iterable.next().value;
  }
  for(const a of iterable) {
    start = fn(start, a);
  }
  return start;
});
```

- `reduce()`, `take()`는 최종적으로 어떤 함수의 결과를 만드는 함수라고 할 수 있다.  
  이들은 iterable이나 배열의 값들을 꺼내서 특정 연산을 하는 식으로 값을 변경 후 다시 iterable 또는 배열에  
  넣는 것이 아니라, 값을 빼내서 그 값을 깨뜨려야 하기에 최종적으로 결과를 만드는 함수라고 할 수 있다.  
  즉, 연산을 시작하는 함수라고 할 수 있다.

- `take()`도 조건에 맞으면 yield 시키도록 하여 지연성을 줄 수 있지만, 몇 개의 원소를 가지는지 모르는 배열 또는 iterable을  
  전달받아 특정 개수의 배열로 축약을 하고 완성을 지어버리는 성질을 가지기에 `take()` 자체에는 지연성을 주는 것보다  
  실제로 `take()`가 수행될 때 값이 평가되도록 다른 함수들에 지연성을 주는 것이 중요하다.

<hr/>

<h2>queryStr 함수 만들기</h2>

- `reduce()`를 활용한 함수를 만들어보자.  
  이 함수는 객체로부터 URL의 query string 부분을 만들어 내는 함수이다.

```js
const queryStr = (obj) =>
  go(
    obj,
    Object.entries,
    map(([k, v]) => `${k}=${v}`),
    reduce((a, b) => `${a}&${b}`)
  );

console.log(queryStr({ limit: 10, offset: 10, type: "notice" }));
// limit=10&offset=10&type=notice
```

- obj를 받아 첫 번째 인자로 obj를 그대로 전달하기에 아래처럼 해도 된다.

```js
const queryStr = pipe(
  Object.entries,
  map(([k, v]) => `${k}=${v}`),
  reduce((a, b) => `${a}&${b}`)
);
```

<hr/>

<h2>Array.prototype.join 보다 다형성이 높은 join 함수</h2>

- `reduce()`를 `Array.prototype.join()` 함수와 비슷하다고 생각할 수 있다.  
  `Array.prototype.join()`은 말 그대로 배열에 대해서만 적용이 되는 반면,  
  `reduce()`는 iterable을 다 순회하며 축약할 수 있으므로 더 다형성이 높은 함수라고 할 수 있다.

- 직접 모든 iterable에 대한 작업을 할 수 있는 `join()`을 구현해보자.  
  받는 값을 `reduce()`를 통해 축약하기에 배열 뿐만 아니라 모든 iterable에 대해 작업을 할 수 있다.

```js
const join = curry((seperator = ",", iterable) =>
  reduce((a, b) => `${a}${seperator}${b}`, iterable)
);
```

- 이제 `queryStr`를 다시 작성해보자.

```js
const queryStr = pipe(
  Object.entries,
  map(([k, v]) => `${k}=${v}`),
  join("&")
);
```

- 이렇게 함수형 프로그래밍을 하면 `pipe()` 사이 사이에 있는 함수들을 꺼내서 더 조합성과 재사용성이  
  높게 되도록 프로그래밍을 할 수 있다.

```js
function* a() {
  yield 10;
  yield 11;
  yield 12;
  yield 13;
}

console.log(join(" - ", a());  // 10 - 11 - 12 - 13
```

- 위에서 구현한 `join()`은 iterable protocol을 따르며, 그 말은 `join()`에 들어가는 값들이  
  사용될 때 평가되도록 지연할 수도 있다는 이야기이다.

```js
const queryStr = pipe(
  Object.entries,
  L.map(([k, v]) => `${k}=${v}`),
  join("&")
);
```

- `Object.entries` 또한 아래와 같이 지연성을 가지도록 할 수 있다.

```js
L.entries = function* (obj) {
  for (const key in obj) {
    yield (key, obj[key]);
  }
};

const queryStr = pipe(
  L.entries,
  L.map(([k, v]) => `${k}=${v}`),
  join("&")
);
```

<hr/>
