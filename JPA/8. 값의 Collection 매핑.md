<h1>값의 Collection Mapping</h1>

<h2>값 컬렉션</h2>

* JPA는 String, Int와 같은 단순 값에 대한 컬렉션을 지원한다.   
  JPA가 지원하는 컬렉션 타입은 아래와 같다.
  * `List`, `Set`, `Map`, `Collection`
<hr/>

<h2>단순 값 List 매핑</h2>

* 우선 2개의 테이블을 생성하자.
  * Itinerary 테이블 : `id(Long)`, `name(String)`, `description(String)`, `sites(List<String>)`
  * itinerary_sites 테이블 : `itinerary_id(Long`, `list_idx(int)`, `site(String)`
    * itinerary_sites.itinerary_id는 Itinerary.id를 참조하며, list_idx는 리스트의 인덱스 값을 가진다.

* `Itinerary` 클래스와 두 테이블(itinerary, itinerary_sites) 사이의 매핑은 `@ElementCollection` 어노테이션을 사용한다.
```java
@Entity
public class Itinerary {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String description;

    @ElementCollection
    @CollectionTable(name = "itinerary_site", joinColumns = @JoinColumn(name = "itinerary_id"))
    @OrderColumn(name = "list_idx")
    @Column(name = "site")
    private List<String> sites;

    public Itinerary() {}

    public Itinerary(String name, String description, List<String> sites) {
        this.name = name;
        this.description = description;
        this.sites = sites != null ? sites : new ArrayList<>();
    }

    // getters

    public void changeSites(List<String> sites) {
        this.sites = sites;
    }

    public void clearSites() { sites.clear(); }
}
```
  * `@ElementCollection`은 매핑 대상이 값 컬렉션임을 지정한다.
  * `@CollectionTable`은 컬렉션을 지정할 때 사용할 테이블을 지정한다. name 속성은 컬렉션 테이블명을 지정하며,   
    joinColumns 속성은 컬렉션 테이블에서 Entity 테이블을 참조할 때 사용할 컬럼명을 지정한다.
  * `@OrderColumn` 어노테이션은 컬렉션 테이블에서 리스트의 인덱스 값을 저장할 컬럼명을 지정한다.

* 이제 `Itinerary` 객체를 저장하면 컬렉션에 보관된 값을 `@CollectionTable`로 지정한 테이블에 저장한다.
```java
entityManager.getTransaction().begin();
List<String> sites = Arrays.asList("ONE", "TWO", "THREE");
Itinerary itinerary = new Itinerary("NUMBERS", "DESC", sites);
entityManager.persist(itinerary);
entityManager.getTransaction().commmit();
```

* 위 코드에 의해 수행되는 query문은 아래와 같다.
```sql
INSERT INTO itinerary(description, name) VALUES("DESC","NUMBERS");

INSERT INTO itinerary_site(itinerary_id, list_idx, site) VALUES(1, 0, "ONE");
INSERT INTO itinerary_site(itinerary_id, list_idx, site) VALUES(1, 1, "TWO");
INSERT INTO itinerary_site(itinerary_id, list_idx, site) VALUES(1, 2, "THREE");
```

* `@ElementCollection`의 fetch 속성은 기본값이 `FetchType.LAZY` 이다. 따라서 아래 코드에서 실제 sites 컬렉션의   
  데이터에 처음 접근하는 `sites.get(0)`이 호출되는 시점에 itinerary_site 테이블에서 데이터를 읽어와 컬렉션을 생성한다.
```java

// SELECT 생략 FROM Itinerary where id=? 수행
Itinerary itinerary = entityManager.find(Itinerary.class, primaryKey);

List<String> sites = itinerary.getSites();

// SELECT 생략 from itinerary_sites WHERE itinerary_id=? 수행
String firstSite = sites.get(0);
```
* 만약 Entity 조회 시점에 `@ElementCollection`으로 지정한 컬렉션도 함께 조회하고 싶다면,   
  fetch 속성을 `FetchType.EAGER`로 지정하면 된다.

* List의 값을 변경한다면 JPA는 상황에 따라 알맞은 query를 수행해준다.   
  만약 기존의 리스트를 지우고, 아예 새로운 리스트를 `changeSites()`로 지정한다면, 처음에는 DELETE query로 기존 데이터를   
  삭제한 뒤에 INSERT query를 수행하여 새로운 리스트를 삽입할 것이다. 만약 컬렉션의 일부만 변경하게 된다면 JPA는 변경된   
  기존 항목에 대해서는 UPDATE query를 수행하며, 새로 추가된 항목에 대해서는 INSERT query를 수행한다. 또한 리스트 중간의   
  항목을 삭제하고 새로운 항목을 추가하면, JPA는 list_idx값에 공백이 생기지 않게 알아서 UPDATE, DELETE, INSERT query를 수행한다.

* 컬렉션의 데이터를 삭제하려면 아래와 같이 `Collection#clear()` 메소드를 사용하면 된다.
```java
entityManager.getTransaction().begin();
Itinerary itinerary = entityManager.find(Itinerary.class, 1L);

// list에 대해 clear()를 수행하는 메소드 수행
itinerary.clearSites();
entityManager.getTransaction().commit();
```
  * 위 코드는 아래와 같은 DELETE query를 수행하여 컬렉션 테이블에서 Entity와 연관된 데이터를 삭제한다.
  ```sql
  DELETE FROM itinerary_sites WHERE itinerary_id=1;
  ```

* 컬렉션 데이터를 삭제하는 또다른 방법으로는 컬렉션에 null을 할당하는 방법이 있다.
<hr/>

<h2>List요소와 null</h2>

* 