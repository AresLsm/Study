# Channels

- Deffered된 값들은 coroutine 사이에서 하나의 값을 주고받을 수 있는 편리한 방법을 제공한다.  
  **Channel**은 값들의 stream을 coroutine 사이에서 주고받을 수 있게 해준다.

## Channel basics

- `Channel`은 개념적으로 `BlockingQueue`와 매우 유사하다. 이 둘의 가장 중요한 차이점 중 하나는 `BlockingQueue`는 `put()` 연산을  
  blocking하는 반면 `Channel`은 `send()`라는 suspending operation이 있다. 또한 `BlockingQueue`처럼 `take()` 연산을  
  blocking하는 대신 `Channel`은 `receive()`라는 suspending operation이 있다.

```kt
fun main() = runBlocking {
	val channel = Channel<Int>()
	launch {
		for(x in 1..5) channel.send(x * x)
	}
	repeat(5) { println(channel.receive()) }
	println("Done")
}

/*
1
4
9
16
25
Done
*/
```

---

## Closing and iteration over channels

- Queue와 달리 `Channel`은 더 이상 새로운 값이 오지 않는 다는 것을 표현하기 위해 _close_ 될 수 있다.  
  값을 빼가는(receive) 쪽에서 일반적인 for loop을 사용해 channel에서 원소들을 하나씩 꺼내올 수 있다.

- 개념적으로 `close()`는 channel에 channel을 close하기 위한 특별한 token을 보내는 것과 유사하다.  
  순회는 close token이 receive되는 순간 종료된다. 따라서 channel이 close되기 전에 있던 모든 원소들이 모두 receive 됨이 보장된다.

```kt
fun main() = runBlocking {
	val channel = Channel<Int>()
	launch {
		for(x in 1..5) channel.send(x * x)
		channel.close()
	}
	for (y in channel) println(y)
	println("Done")
}

/*
1
4
9
16
25
Done
*/
```

---

## Building channel producers

- Coroutine이 일련의 원소들을 생성(produce)하는 패턴은 매우 흔하다. 이는 동시성을 활용하는 코드의 _producer-consumer pattern_ 의  
  일부이다. 이러한 패턴에서 produce하는 작업을 channel을 파라미터로 받는 함수를 만들어 추상화할 수 있지만, 결과는 함수로부터 반환되어야  
  한다는 일반적인 프로그래밍 관점에서 벗어나게 된다.

- `produce()`라는 coroutine builder를 사용하면 값들을 channel에 쉽게 produce할 수 있게 하고, consumer 쪽에서는  
  `consumeEach()`를 사용해 channel의 값들을 하나씩 꺼내와 각각에 대한 작업을 할 수 있다.

```kt
fun CoroutineScope.produceSquares(): ReceiveChannel<Int> = produce {
	for (x in 1..5) send(x * x)
}

fun main() = runBlocking {
	val squares = produceSquares()
	squares.consumeEach { println(it) }
	println("Done!")
}

/*
1
4
9
16
25
Done!
*/
```

---

## Pipelines

- **Pipeline** : 하나의 coroutine이 값들의 stream을 무한대로 produce하는 패턴

```kt
fun CoroutineScope.produceNumbers() = produce<Int> {
	var x = 1
	while(true) send(x++)
}
```

- `produceNumbers()`는 1부터 무한대의 정수들을 담은 stream을 produce한다. 그럼 이번에는 해당 stream으로부터 consuming하는  
  coroutine을 만들어보자. consume하고 또다시 결과들을 produce하도록 해보았다.

```kt
fun CoroutineScope.square(numbers: ReceiveChannel<Int>): ReceiveChannel<Int> = produce {
	for (x in numbers) send(x * x)
}
```

- 이제 위의 두 함수를 사용하는 `main()`을 보고, 그 결과도 보자.

```kt
fun main() = runBlocking {
	val numbers = produceNumbers()
	val squares = square(numbers)
	repeat(5) {
		println(squares.receive())
	}
	println("Done!")
	coroutineContext.cancelChildren()
}

/*
1
4
9
16
25
Done!
*/
```

> 새로운 Coroutine을 생성하는 함수들은 모두 `CoroutineScope`의 확장 함수로 정의된다.  
> 이렇게 하는 이유는 Structured Concurrency를 지켜 누수되는 coroutine이 발생하지 않도록 하기 위함이다.

---

## Prime numbers with pipeline

- Pipeline을 더 활용해보기 위해 이번에는 coroutine의 pipeline을 사용해 소수를 생성하는 예제 코드를 보자.  
  우선 숫자들을 순차적으로 무한대로 producing하는 것으로 시작해보자.

```kt
fun CoroutineScope.numbersFrom(start: Int) = produce<Int> {
	var x = start
	while (true) send(x++)
}
```

- 다음으로 아래의 `filter()`는 prime이라는 정수 하나와 stream을 인자로 받아 stream으로부터 값을 받아 prime과 나누어 떨어지지 않는, 즉  
  소수를 판별한 후 소수들만 다시 produce한다.

```kt
fun CoroutineScope.filter(numbers: ReceiveChannel<Int>, prime: Int) = produce<Int> {
	for (x in numbers) if (x % prime != 0) send(x)
}
```

- 이제 2부터 시작하는 무한한 정수의 stream을 담는 pipeline을 만들고 발견된 소수 각각에 대해서도 produce하는 pipeline을 아래의  
  순서대로 진행되게 만들어보자.

```
numbersFrom(2) -> filter(2) -> filter(3) -> filter(5) -> filter(7) -> ,,,
```

- 아래의 예시 코드는 모든 pipeline을 main thread의 context에서 실행시키며 첫 10개의 소수를 출력한다.  
  모든 coroutine들이 `main()`에 있는 `runBlocking { .. }`의 scope에서 시작되었기에 시작한 coroutine들 각각을 관리하지 않아도 된다.  
  단지 아래처럼 `cancelChildren()` 확장 함수를 사용해 첫 10개의 소수를 출력한 후 child coroutine들을 모두 cancel시키면 된다.

```kt
fun main() = runBlocking {
    var cur = numbersFrom(2)
    repeat(10) {
        val prime = cur.receive()
        println(prime)
        cur = filter(cur, prime)
    }
    coroutineContext.cancelChildren()
}

/*
2
3
5
7
11
13
17
19
23
29
*/
```

> 위의 코드에서 pipeline을 `produce { .. }`로 만들었지만, `iterator { .. }` coroutine builder로도 똑같이 구현할 수 있다.  
> `produce()`를 `iterator()`로 바꾸고 `send()`를 `yield()`로, `receive()`를 `next()`로, `ReceiveChannel`을 `Iterator`로  
> 바꾸고 Coroutine Scope 관련 부분을 모두 제거해주면 된다. 즉, `runBlocking()`도 필요 없다.  
> 하지만 pipeline을 사용하면 `Dispatchers.Default` context 내에서 실행하면 multiple CPU core들을 사용해 처리할 수 있다는 점이다.

---
