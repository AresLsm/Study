## 질의 함수와 변경 함수 분리하기

```js
// 리팩토링 적용 전
function getTotalOutstandingAndSendBill() {
  const result = customer.invoices.reduce(
    (total, each) => each.amount + total,
    0
  );
  sendBill();
  return result;
}

// 리팩토링 적용 후
function totalOutstanding() {
  return customer.invoices.reduce((total, each) => each.amount + total, 0);
}

function sendBill() {
  emailGateway.send(formatBill(customer));
}
```

### 배경

- 우리는 외부에서 관찰할 수 있는 겉보기 부수효과(Observable side effect)가 전혀 없이 값을 반환해주는  
  함수를 추구해야 한다. 이런 함수는 어느 때든 원하는만큼 호출해도 아무런 문제가 없다. 호출하는 문장의  
  위치를 호출하는 함수 안 어디로든 옮겨도 되며 테스트하기도 쉽다. 한마디로, 이용할 때 신경 쓸 거리가 매우 적다.

- 겉보기 부수효과가 있는 함수와 없는 함수는 명확히 구분하는 것이 좋다. 이를 위한 한 가지 방법은  
  _'질의 함수(읽기 함수)는 모든 부수효과가 없어야 한다'_ 는 규칙을 따르는 것이다. 이를  
  **명령-질의 분리(Command-Query Seperation)** 라 하는데, 이 규칙을 100% 따르려 노력하자.

- 값을 반환하면서 부수 효과도 있는 함수를 발견하면 상태를 변경하는 부분과 질의하는 부분을 분리하자.

- _겉보기_ 부수효과라고 하는 데는 이유가 있다. 흔히 쓰는 최적화 기법 중 요청된 값을 캐싱해두고  
  다음번 호출 때 빠르게 응답하는 방법이 있는데, 이러한 캐싱도 객체의 상태를 변경하지만 객체 밖에서는  
  관찰할 수 없다. 즉, 겉보기 부수효과 없이 어떤 순서로 호출하든 모든 호출에 항상 똑같은 값을 반환할 뿐이다.

### 절차

- (1) 대상 함수를 복제하고 질의 목적에 충실한 이름을 짓는다.  
  함수 내부를 살펴 무엇을 반환하는지 찾고, 만약 어떤 변수의 값을 반환한다면 그 변수명이  
  훌륭한 단초가 된다.

- (2) 새 질의 함수에서 부수효과를 모두 제거한다.

- (3) 정적 검사 수행

- (4) 원래 함수(변경 함수)를 호출하는 곳을 모두 찾아낸다. 호출하는 곳에서 반환 값을 사용한다면  
  질의 함수를 호출하도록 바꾸고, 원래 함수를 호출하는 코드를 바로 아래줄에 새로 추가한다.  
  하나 수정할 때마다 테스트한다.

- (5) 원래 함수에서 질의 관련 코드를 제거한다.

- (6) 테스트한다.

### 예시

- 이름 목옥을 훑어 악당을 찾는 함수를 보자. 악당을 찾으면 그 사람의 이름을 반환하고 경고를 울린다.

```js
function alertForMiscreant(people) {
  for (const p of people) {
    if (p === "JOKER") {
      setOffAlarms();
      return "JOKER";
    }
    if (p === "EVIL") {
      setOffAlarms();
      return "EVIL";
    }
  }
  return "";
}
```

- 첫 단계는 _(1) 함수를 복제하고 질의 목적에 맞는 이름짓기다._

```js
function findMiscreant(people) {
  for (const p of people) {
    if (p === "JOKER") {
      setOffAlarms();
      return "JOKER";
    }
    if (p === "EVIL") {
      setOffAlarms();
      return "EVIL";
    }
  }
  return "";
}
```

- 다음으로 _(2) 새 질의 함수에서 부수효과를 낳는 부분을 제거_ 한다.

```js
function findMiscreant(people) {
  for (const p of people) {
    if (p === "JOKER") {
      return "JOKER";
    }
    if (p === "EVIL") {
      return "EVIL";
    }
  }
  return "";
}
```

- 이제 _(4) 원래 함수를 호출하는 곳을 모두 찾아 새로운 질의 함수를 호출하도록 하고_,  
  _이어서 원래의 변경 함수를 호출하는 코드를 바로 아래 삽입한다._

```js
// client(before)
const found = alertForMiscreant(people);

// client(after)
const found = findMiscreant(people);
alertForMisceant(people);
```

- 마지막으로 _(5) 원래의 변경 함수에서 질의 관련 코드를 제거한다._

```js
function alertForMiscreant(people) {
  for (const p of people) {
    if (p === "JOKER") {
      setOffAlarms();
      return;
    }
    if (p === "EVIL") {
      setOffAlarms();
      return;
    }
  }
  return;
}
```

#### 더 가다듬기

- 이번 아이템은 여기서 끝이지만, 변경 함수의 새로운 질의 함수에는 중복 코드가 많아 보인다.  
  이번 경우에는 변경 함수에서 질의 함수를 사용하도록 고치면 된다.(**알고리즘 교체하기**)

```js
function alertForMiscreant(people) {
  if (findMiscreant(people) !== "") setOffAlarms();
}
```

<hr/>

## 함수 매개변수화하기

```js
// 리팩토링 적용 전
function tenPercentRaise(person) {
  person.salary = person.salary.multiply(1.1);
}

// 리팩토링 적용 후
function raise(person, factor) {
  person.salary = person.salary.multiply(1 + factor);
}
```

### 배경

- 두 함수의 로직이 아주 비슷하고 단지 리터럴값만 다르다면 그 다른 값만 매개변수로 받아 처리하는  
  함수 하나로 합쳐서 중복을 없앨 수 있다. 이렇게 하면 매개변수 값만 바뀌어 여러 곳에서  
  사용할 수 있으니 함수의 유용성이 커진다.

### 절차

- (1) 비슷한 함수 중 하나를 선택한다.
- (2) **함수 선언 바꾸기**로 리터럴들을 매개변수로 추가한다.
- (3) 이 함수를 호출하는 곳 모두에 적절한 리터럴값을 추가한다.
- (4) 테스트한다.
- (5) 매개변수로 받은 값을 사용하도록 함수 본문을 수정한다. 하나 수정할 때마다 테스트한다.
- (6) 비슷한 다른 함수를 호출하는 코드를 찾아 매개변수화된 함수를 호출하도록 하나씩 수정한다.  
  하나 수정할 때마다 테스트한다.

### 예시

- 먼저 명백한 예시를 보자.

```js
function tenPercentRaise(person) {
  person.salary = person.salary.multiply(1.1);
}

function fivePercentRaise(person) {
  person.salary = person.salary.multiply(1.05);
}
```

- 앞의 두 함수는 확실히 다음 함수로 대체할 수 있다.

```js
function raise(person, factor) {
  person.salary = person.salary.multiply(1 + factor);
}
```

- 하지만 이렇게 간단히 끝나지 않는 경우도 있다. 아래 코드를 보자.

```js
function baseCharge(usage) {
  if (usage < 0) return usd(0);
  const amount =
    bottomBand(usage) * 0.03 + middleBand(usage) * 0.05 + topBand(usage) * 0.07;
  return usd(amount);
}

function bottomBand(usage) {
  return Math.min(usage, 100);
}

function middleBand(usage) {
  return usage > 100 ? Math.min(usage, 200) - 100 : 0;
}

function topBand(usage) {
  return usage > 200 ? usage - 200 : 0;
}
```

- band를 다루는 세 함수의 로직이 상당히 비슷한 것은 사실이지만, 과연 매개변수화 함수로 통함할 수  
  있을만큼 비슷할까? 그렇다. 하지만 앞서 본 예시보다는 덜 직관적이다.

- 우선 비슷한 함수들을 매개변수화하여 통합할 때는 _(1) 대상 함수 중 하나를 골라 매개변수를 추가_ 하자.  
  단, 다른 함수들까지 고려해 선택해야 한다. 지금 예시처럼 범위를 다루는 로직에서는 대개 중간에  
  해당하는 함수에서 시작하는 것이 좋다. 그러니 `middleBand()`에 매개변수를 추가하고  
  다른 호출들을 여기에 맞춰보자.

- `middleBand()`를 보니 리터럴을 두개(100, 200) 사용하며, 그 각각은 중간 band의 하한과  
  상한을 뜻한다. _(2) 함수 선언 바꾸기_ 를 적용하고 _(3) 이 리터럴들을 호출 시점에 입력하도록 변경_  
  해보자. 이 과정에서 함수명도 매개변수화된 기능에 어울리게 수정한다.

```js
function withinBand(usage, bottom, top) {
  return usage > 100 ? Math.min(usage, 200) - 100 : 0;
}

function baseCharge(usage) {
  if (usage < 0) return usd(0);
  const amount =
    bottomBand(usage) * 0.03 +
    withinBand(usage, 200, 300) * 0.05 +
    topBand(usage) * 0.07;
  return usd(amount);
}
```

- _(5) 함수에서 사용하던 리터럴들을 적절한 매개변수로 대체_ 하자.  
  하나 변경할 때마다 테스트한다.

```js
function withinBand(usage, bottom, top) {
  return usage > bottom ? Math.min(usage, top) - bottom : 0;
}
```

- 이제 _(6) band의 하한 및 상한을 호출하는 부분도 새로 만든 매개변수화 함수를 호출하도록 바꾸자._

```js
function baseCharge(usage) {
  if (usage < 0) return usd(0);
  const amount =
    withinBand(usage, 0, 100) * 0.03 +
    withinBand(usage, 200, 300) * 0.05 +
    withinBand(usage, 200, Infinity) * 0.07;
  return usd(amount);
}
```

<hr/>
