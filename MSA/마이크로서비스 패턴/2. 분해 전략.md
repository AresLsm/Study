# 분해 전략

- 마이크로서비스의 가장 핵심 과제는 **마이크로서비스를 정의하는 방법** 이다.

<h2>마이크로서비스 아키텍쳐란 무엇인가?</h2>

- MSA의 핵심 사상은 **기능 분해**이다. 대규모 단일 애플리케이션을 개발하는 대신 애플리케이션을 여러 개의  
  서비스로 구성하는 것이다. MSA 자체를 기능 분해라고 볼 수도 있지만, 몇 가지 의문점이 생기기 마련이다.

  - MSA는 과의의 소프트웨어 아키텍쳐 개념과 어떤 연관성이 있을까?
  - 서비스란 무엇이고, 그 크기는 어느 정도가 적당할까?

- 소프트웨어 아키텍쳐는 구성 요소 및 그들 간의 의존 관계로 묶인 고수준의 구조물이다.  
  애플리케이션 아키텍쳐는 다차원적이므로 기술하는 방법도 다양하다.  
  아키텍쳐가 중요한 이유는 소프트웨어의 품질 속성, 즉 _~성(~ilities)_ 로 끝나는 지표가  
  아키텍쳐에 의해 결정되기 때문이다. 예전에는 확장성, 신뢰성, 보안 등이 아키텍쳐의 목표였지만  
  이제 신속, 안전하게 소프트웨어를 전달하는 능력도 매우 중요하다.

- MSA는 관리성, 테스트성, 배포성이 높은 애플리케이션을 구축하는 아키텍쳐 스타일이다.

<h3>소프트웨어 아키텍쳐의 정의</h3>

- 소프트웨어 아키텍쳐를 정의하는 문구는 다양하다.  
  그 중, 저자는 아래의 정의를 택했다.

> 컴퓨팅 시스템의 소프트웨어 아키텍쳐는 소프트웨어 엘리먼트(element)와 그들 간의 관계,  
> 그리고 이 둘의 속성(property)으로 구성된 시스템을 추론하는 데 필요한 구조(structure)의 잡합이다.

- 다소 추상적인 문구지만, 핵심은 애플리케이션 아키텍쳐가 여러 부분들(element)로의 분해와 이런 부분들의  
  관계(연관성)이라는 것이다. 분해가 중요한 이유는 다음과 같다.

  - 업무와 지식을 분리한다. 덕분에 전문 지식을 보유한 사람 또는 여러 팀이 함께 생산적으로 애플리케이션  
    작업을 할 수 있다.

  - 소프트웨어 엘리먼트가 어떻게 상호 작용하는지 밝힌다.

<h4>소프트웨어 아키텍쳐의 4+1 뷰 모델</h4>

- 건물과 마찬가지로 애플리케이션 또한 아키텍쳐를 바라보는 관점이 다양하다.

- **4+1 뷰 모델**은 소프트웨어 아키텍쳐를 바라보는 상이한 4개의 뷰를 정의한다.  
  각 뷰는 아키텍쳐의 특정한 측면을 기술하고, 특정 소프트웨어 엘리먼트와 그들 사이의 관계로 구성된다.  
  각 뷰의 목적은 아래와 같다.

  - **논리 뷰(Logical view)** : 개발자가 작성한 소프트웨어 엘리먼트, 객체지향 언어라면 클래스, 패키지가  
    해당되며 결국 상속(inheritance), 연관(association), 의존(depends-on)등 클래스와 패키지의 관계를 의미한다.

  - **구현 뷰(Implementation view)** : 빌드 시스템의 결과물로 모듈(패키징된 코드)과  
    컴포넌트(하나 이상의 모듈로 구성된 실행, 배포 가능 단위)로 구성된다. Java에서 모듈은 보통 jar 파일,  
    컴포넌트는 war 파일이나 실행 가능한 jar 파일이다.  
    모듈 간의 의존성과 컴포넌트, 모듈 간의 조합 관계도 이 뷰에 포함된다.

  - **프로세스 뷰(Process view)** : 런타임 컴포넌트로 각 엘리먼트는 개별 프로세스이며,  
    IPC는 프로세스 간의 관계를 나타낸다.

  - **배포 뷰(Deployment view)** : 프로세스가 머신에 매핑되는 방법으로, 이 뷰의 엘리먼트는 물리 또는 가상 머신 및  
    프로세스이며, 머신 간의 관계가 바로 네트워킹이다. 프로세스와 머신 사이의 관계도 이 뷰에서 기술된다.

- 4개의 뷰 외에도 (4+1 모델의 +1에 해당하는 뷰) 뷰를 구동시키는 시나리오가 있다.  
  각 시나이로는 특정 뷰 내에서 얼마나 다양한 아키텍쳐 요소가 협동하여 요청을 처리하는지 기술한다.  
  가령 논리 뷰의 시나리오는 클래스가 협동하는 방법을, 프로세스 뷰의 시나리오는 프로세스가 서로 어떻게 협동하는지 나타낸다.

- 4+1 뷰 모델은 애플리케이션 아키텍쳐를 명쾌하게 표현하는 수단이다.  
  4개의 뷰는 중요한 아키텍쳐 측면을, 시나리오는 뷰의 여러 엘리먼트가 협동하는 과정을 명시한다.

<h3>아키텍쳐의 중요성</h3>

- 애플리케이션 요건은 크게 두 가지 종류로 나타낸다.  
  첫째, 애플리케이션이 할 일을 정의한 **기능 요건**이 있다. 보통 use case나 user story 포맷으로 기술하는데,  
  이 기능 요건과 아키텍쳐는 거의 무관하다. 기능 요건은 어느 아키텍쳐이든 구현할 수 있기 때문이다.  
  둘째, 이른바 _~성_ 으로 끝나는 **서비스 품질 요건**이 있다. 아키텍쳐는 바로 이 요건을 충족시킬 수 있게  
  설계해야 하므로 매우 중요하다. 서비스 품질 요건은 확장성, 신뢰성 같은 런타임 품질 외에도 관리성, 테스트성, 배포성 처럼  
  개발 시점의 품질도 해당된다. 애플리케이션 아키텍쳐를 어떻게 선택하느냐에 따라 이런 품질 요건을 얼마나 충족할 수 있을지가 결정된다.

<h3>아키텍쳐 스타일 개요</h3>

- 실제 건물 아키텍쳐는 정해진 양식을 따르는 경우가 대부분이다.  
  이런 양식은 각 건물의 특성과 자재를 좌우하는 설계 결정의 모음집이라고 볼 수 있다.  
  아키텍쳐 스타일 개념은 소프트웨어에도 그대로 적용된다.

> 아키텍쳐 스타일은 체계적인 조직의 관점에서 시스템 군을 정의한다.  
> 아키텍쳐 스타일은 그 스타일로 만든 인스턴스에서 사용 가능한 커넥터(connector)와  
> vocabulary, 그리고 이들을 조합할 수 있는 제약 조건(constraint)을 결정한다.

- 특정 아키텍쳐 스타일은 엘리먼트(컴포넌트)와 관게(커넥텨)의 한정된 팔레트(사용 범위)를 제공하며,  
  이를 토대로 애플리케이션 아키텍쳐의 뷰를 정의할 수 있다.  
  애플리케이션은 대부분 아키텍쳐 스타일을 조합해서 사용한다.  
  모놀리틱 아키텍쳐도 구현 뷰를 하나의 실행, 배포 가능한 컴포넌트로 구성한 아키텍쳐 스타일이라 할 수 있다.  
  MSA는 애플리케이션을 느슨하게 결합된 여러 서비스로 구성하는 아키텍쳐 스타일이다.

<h4>계층화 아키텍쳐 스타일</h4>

- 소프트웨어 엘리먼트를 계층별로 구성하는 계층화 아키텍쳐(Layered architecture)는 전형적인 아키텍쳐 스타일이다.  
  계층마다 명확히 정의된 역할을 분담하며, 계층 간 의존성은 아키텍쳐로 제한한다. 따라서 어떤 계층은 바로 하위에 있는  
  계층에만 의존하거나, 하위에 위치한 어느 한 계층에 의존한다.

- 계층화 아키텍쳐는 4개의 뷰 모두에 적용할 수 있다.  
  익히 알려진 3계층 아키텍쳐가 바로 계층화 아키텍쳐를 논리 뷰에 적용한 사례로, 애플리케이션을 아래 3개 계층으로 구성한다.

  - Presentation layer(표현 계층): 사용자 인터페이스 또는 외부 API가 구현된 계층
  - Business logic layer(비즈니스 로직 계층): 비즈니스 로직이 구현된 계층
  - Persistence layer(영속화 계층): DB 상호 작용 로직이 구현된 계층

- 하지만 위와 같은 계층화 아키텍쳐는 몇 가지 중요한 흠이 있다.

  - **표현 계층이 하나뿐이다**: 애플리케이션을 호출하는 시스템이 하나 밖에 없을까?
  - **영속화 계층이 하나뿐이다**: 애플리케이션이 상호 작용하는 DB가 정말 하나 뿐일까?
  - **비즈니스 로직 계층을 영속화 계층에 의존하는 형태로 정의한다**: 이론적으로 이러한 의존성 때문에  
    DB 없이 비즈니스 로직만을 테스트하는 것은 불가능하다.

- 또 계층화 아키텍쳐는 잘 설계된 애플리케이션에서 의존성을 잘못 나타내는 문제도 있다.  
  일반적으로 비즈니스 로직 계층은 인터페이스나 데이터 접근 메소드가 정의된 인터페이스 레포지토리를 정의하고,  
  영속화 계층에서 이 레포지토리 인터페이스를 구현한 DAO 클래스를 정의한다.  
  결국 실제 의존성이 계층화 아키텍쳐에 기술된 것과는 정반대이다.

> 기술된 것: 비즈니스 로직 계층(상위)이 영속화 계층(하위)에 의존하는 형태  
> 실제 의존성: 영속화 계층이 비즈니스 로직 계층에서 제공하는 인터페이스를 구현함으로써  
> 거꾸로 영속화 계층이 비즈니스 로직 계층에 의존한다.

- 이러한 문제점을 해결하고자 Hexagonal Architecture이 고안되었다.

<h4>Hexagonal Architecture(육각형 아키텍쳐)</h4>

- Hexagonal 아키텍쳐는 논리 뷰를 비즈니스 로직 중심으로 구성화는 계층화 아키텍쳐 스타일의 대안이다.  
  애플리케이션에 대한 표현 계층 대신 비즈니스 로직을 호출하여 외부에서 들어오는 요청을 처리하는 Inbound Adapter들과  
  영속화 계층 대신 비즈니스 로직에 의해 호출되고 외부 애플리케이션을 호출하는 Outbound Adapter들을 둔다.  
  비즈니스 로직이 어댑터에 전혀 의존하지 않는다는 것이 이 아키텍쳐의 가장 중요한 특징이다.  
  외려 어댑터가 비즈니스 로직에 의존한다.

- 비즈니스 로직에는 하나 이상의 Port가 있다. 포트는 비즈니스 로직이 자신의 외부 세계와 상호 작용하는 방법이 정의된  
  작업(operation)이다. 가령 Java의 경우, 포트는 인터페이스가 된다. 포트는 Inbound Port, Outbound Port로  
  총 2가지가 있다. Inbound port는 비즈니스 로직이 표출된 API로서, 외부 애플리케이션은 이 API를 통해 비즈니스 로직을  
  호출한다. 반대로 Outbound port는 비즈니스 로직이 외부 시스템을 호출하는 방법에 관한 것이다.

- 어댑터는 비즈니스 로직을 감싸고 있다. 포트 처럼 어댑터도 Inbound Adapter, Outbound Adapter로 2가지가 있다.  
  Inbound 어댑터는 외부에서 들어오는 요청을 Inbound 포트를 호출해서 처리한다. (ex. REST Endpoint, Spring Web MVC..).  
  동일한 Inbound 포트를 여러 Inbound 어댑터가 호출할 수도 있다.

- Outbound 어댑터는 비즈니스 로직에서 들어온 요청을 외부 애플리케이션, 서비스를 호출해서 처리한다.(ex. DB 작업이 구현된 DAO 클래스..).  
  Outbound 어댑터는 event를 발행하기도 한다.

- Hexagonal 아키텍쳐 스타일의 가장 큰 장점은 비즈니스 로직에 있던 Presentation, Persistance 로직이 어댑터와 분리되었기 때문에  
  **비즈니스 로직이 Presentation, Persistance 로직 어디에도 의존하지 않는다는 점** 이다.

- 이렇게 분리하면 비즈니스 로직만 테스트하기도 쉽고, 현대 애플리케이션 아키텍쳐를 좀 더 정확하게 반영할 수 있다.  
  제각기 특정한 API나 UI가 구현된 Inbound 어댑터가 비즈니스 로직을 호출하고, 비즈니스 로직은 다양한 외부 시스템을  
  호출하는 Outbound 어댑터를 호출하는 구조이다. Hexagonal 아키텍쳐는 MSA를 이루는 각 서비스 아키텍쳐를 기술하는 최고의 방법이다.

- Hexagonal Architecture가 Layered Architecture의 문제점을 어떻게 해결하는지는 <a href="https://github.com/sang-w0o/Study/blob/master/MSA/DDD%EB%A1%9C%20%EC%A7%84%ED%96%89%ED%95%98%EB%8A%94%20MSA/3.2%20%ED%97%A5%EC%82%AC%EA%B3%A0%EB%82%A0%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90%EC%99%80%20%ED%81%B4%EB%A6%B0%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90.md">여기</a>에서 추가적으로 볼 수 있다.

<h3>MSA는 일종의 아키텍쳐 스타일이다</h3>

- 4+1 뷰 모델과 아키텍쳐 스타일을 보았으니, 이제 모놀리틱 / MSA를 정의해보자.  
  먼저 모놀리틱 아키텍쳐는 구현 뷰를 단일 컴포넌트(하나의 실행 파일 또는 WAR 파일)로 구성한 아키텍쳐 스타일이다.  
  다른 뷰는 일체 등장하지 않는다. 모놀리틱 애플리케이션은 Hexagonal 아키텍쳐 방식으로 구성한 논리 뷰를 가질 수 있다.

- MSA 또한 일종의 아키텍쳐 스타일이다. 하지만 구현 뷰를 다수의 컴포넌트(여러 실행 파일 또는 WAR 파일)로 구성한다는  
  차이점이 있다. 여기서 컴포넌트는 곧 서비스가 되며, 각 서비스는 자체적인 논리 뷰 아키텍쳐를 가지고 있다.  
  전형적인 Hexagonal 아키텍쳐를 가진다. 커넥터는 이러한 서비스들이 서로 협동할 수 있게끔 해주는 통신 프로토콜이다.

<h3>서비스란 무엇인가?</h3>

- 서비스는 어떤 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트이다.  
  서비스는 클라이언트가 자신이 제공하는 기능(functionality)에 접근할 수 있도록 커맨드, 쿼리, 이벤트로 구성된  
  API를 제공한다. 서비스 작업은 크게 Command(명령, CUD), Query(조회, 쿼리, R)로 나뉜다.  
  물론 클라이언트가 소비하는 이벤트를 발행하기도 한다.

- 서비스 API는 내부 구현 상세를 캡슐화한다. 모놀리틱과 달리 개발자는 API를 우회하여 서비스에 접근하는 코드를 작성할 수 없으므로  
  MSA에서 애플리케이션 모듈성은 보장된다.

- 각각의 마이크로서비스는 자체 아키텍쳐를 가지고 있기에 기술 스택을 독자적으로 구축할 수 있지만, 대부분 Hexagonal 아키텍쳐를 취한다.  
  API는 서비스에 구현된 비즈니스 로직과 소통하는 어댑터를 이용하여 구현한다. 작업 어댑터(Operations adapter)는 비즈니스 로직을  
  호출하고 이벤트 어댑터(Events adapter)는 비즈니스 로직이 내어준 이벤트를 발행한다.

- 서비스 구현 뷰는 독립적으로 움직이는(Standalone) 프로세스, 컨테이너 내부에서 실행되는 웹 애플리케이션, OSGI bundle,  
  Serverless cloud 기능 등 다양한 컴포넌트를 사용할 수 있다. 물론 서비스마다 자체 API를 갖고 독립적인 배포가 가능해야 하는  
  핵심 요건은 동일하다.

<h3>느슨한 결합</h3>

- 느슨하게 결합된 서비스는 MSA의 중요 특성 중 하나이다.  
  서비스는 구현 코드를 감싼 API를 통해서만 상호 작용하기에 클라이언트에 영향을 끼치지 않고 서비스 내부 구현 코드를 바꿀 수 있다.  
  느슨하게 결합된 서비스는 유지보수성, 테스트성을 높이고 애플리케이션 개발 시간을 단축하는 효과가 있다.  
  무엇보다 개발자가 서비스를 이해하고, 변경하고 테스트하기가 더 쉽다.

- 서비스는 느슨하게 결합되고 API를 통해서만 동작하기에 서비스가 직접 DB와 통신하는 일은 불가하다.  
  또 클래스 필드 같은 서비스의 영속적 데이터는 반드시 private으로 유지해야 한다.  
  이렇게 해야 개발자가 자신이 맡은 서비스의 DB 스키마를 변경할 때 다른 서비스 개발자와 조율하느라 시간을 허비하지 않는다.  
  서비스가 DB 테이블을 서로 공유하지 않기 때문에 런타임 격리(Runtime Isolation)도 향상된다.  
  어떤 서비스가 DB Lock을 획득하여 다른 서비스를 blocking하는 일 자체가 불가하다.  
  물론 DB를 공유하지 않기에 여러 서비스에 걸쳐 데이터를 쿼리하고, 일관성을 유지하는 일은 더 복잡해지는 단점이 있다.

<h3>공유 라이브러리의 역할</h3>

- 코드 중복 방지를 위해 여러 애플리케이션에서 재사용 가능한 기능을 라이브러리(모듈)로 패키징하는 것은 개발자에게 당연한 일이다.  
  그래서 MSA에서도 공유 라이브러리(Shared Library)를 사용하고픈 유혹에 빠지기 쉬운데, 서비스 코드 중복을 줄이는 것은 좋지만  
  의도치 않은 서비스 간의 결합도를 유발하지 않도록 조심해야 한다.

- 예를 들어, `Order`라는 비즈니스 객체를 여러 서비스가 업데이트해야 하는 상황을 생각해보자.  
  필요한 공용 기능을 라이브러리 하나에 모두 패키징해 배포하면, 코드 중복은 없겠지만 만약 나중에 요건이 수정되어  
  `Order`에 영향을 주는 방향으로 변경되면 어떻게 될까?  
  정답은 관련 서비스를 일제히 다시 빌드해서 재배포해야 한다는 것이다. 이렇게 변경 가능성이 조금이라도 있는 기능이라면  
  별도의 서비스로 구현하는 것이 낫다.

<h3>서비스 규모는 별로 중요하지 않다</h3>

- 마이크로서비스라는 용어는 *Micro*라는 단어 때문에 왠지 서비스를 아주 작게 만들어야 할 것 같은 느낌을 준다.  
  하지만 크기보다는 **팀이 가장 짧은 시간에 다른 팀과 협동하는 부분은 최소로 하여 개발 가능한 서비스를 설계**해야 한다.

- MSA는 작고, 느슨하게 겳하된 서비스로 애플리케이션을 구성하기 때문에 유지보수성, 테스트성, 배포성 등 개발 단계의  
  품질 속성이 개선된다. 또 조직 차원에서 소프트웨어를 더 빠르게 개발할 수도 있고, 확장성 또한 확장된다.

<hr/>

<h2>마이크로서비스 아키텍쳐 정의</h2>

- 애플리케이션은 사용자의 요청을 처리하기 위해 존재한다.  
  따라서 애플리케이션을 정의하는 1단계는 **애플리케이션 요건을 핵심 요청으로 추출하는 것**이다.  
  그러나 저자는 요청을 REST, Messaging과 같은 특정 IPC 기술이 아닌 좀 더 추상적인 관념으로 시스템 작업을  
  바라보고자 한다. 시스템 작업은 애플리케이션이 처리하는 요청을 추상화한 것이다. 데이터를 업데이트하는 커맨드나  
  조회하는 쿼리가 모두 해당된다. 각 커맨드의 동작은 추상적인 도메인 모델 관점에서 정의되며, 이또한 요건에서 도출된다.  
  결국 시스템 작업은 여러 서비스가 서로 협동하는 방식을 표현한 아키텍쳐 시나리오가 된다.

- 2단계는 **어떻게 여러 서비스로 분해할지 결정하는 것**이다. 여러 가지 전략을 선택할 수 있는데,  
  비즈니스 아키텍쳐의 시각에서 비즈니스 능력에 따라 서비스를 정의할 수도 있고, DDD의 하위 도메인별로 서비스를  
  구성하는 전략도 가능하다. 어떤 전략을 구사하든 최종 결과는 기술 개념이 아닌 비즈니스 개념 중심으로 이루어진 서비스들이다.

- 3단계는 **서비스별로 API를 정의하는 일**이다. 이를 위해 먼저 1단계에서 식별된 시스템 작업을 각 서비스에 배정해야 한다.  
  완전한 홀로서기 작업이 구현된 서비스도 있겠지만, 다른 서비스와 협동할 수밖에 없는 작업이 구현된 서비스도 있다.  
  이때 여러 서비스가 협동하는 방식을 결정해야 하는데, 대부분 서비스에 추가 지원 작업을 두는 형태가 될 것이다.  
  API 구현시 사용할 IPC도 정해야 한다.

- 분해 과정에는 장애물들이 많다.  
  첫째, **네트워크 지연(Network Latency)**가 있다. 서비스 간의 왕복이 너무 잦아 실제로 분해할 수 없는 경우도 있다.  
  둘째, **서비스 간 동기 통신으로 인해 가용성이 떨어지는 문제**이다.  
  셋째, **여러 서비스에 걸쳐 데이터 일관성을 지키는 요건**이다. 이 문제는 보통 Saga로 해결한다.  
  넷째, **애플리케이션 도처에 숨어 있는 만능 클래스**이다. 이런 클래스들은 DDD의 개념을 활용하면 쉽게 제거할 수 있다.

<h3>시스템 작업 식별</h3>

- 애플리케이션 아키텍쳐를 정의하는 첫 단추는 시스템 작업을 정의하는 일이다.  
  그 출발점은 user story와 이와 연관된 시나리오 등의 애플리케이션 요건이다.  
  `Applying UML and Patterns`에서는 객체 지향 설계 프로세스에서 영향을 받는 2단계 프로세스로 시스템 작업을 정의한다.  
  1단계는 **시스템 작업을 기술하기 위해 필요한 vocabulary를 제공하는 핵심 클래스로 구성된 고수준의 도메인 모델을 생성하는 것**이다.  
  2단계는 **시스템 작업 식별 후 그 동작을 도메인 모델 관점에서 기술하는 것**이다.

- 도메인 모델은 주로 user story의 명사에서 도출한다. Event Storming 기법을 사용해도 된다.  
  시스템 작업은 주로 동사에서 도출하며, 각각 하나 이상의 도메인 객체와 그들 간의 관계로 기술한다.  
  시스템 작업은 도메인 모델을 생성, 수정, 삭제하거나 모델 간의 관계를 맺고 끊을 수 있다.

<h4>고수준 도메인 모델 생성</h4>

- 시스템 작업을 저의하기 위해 우선 고수준 애플리케이션의 도메인 모델을 대략 그려보자.  
  물론 최종적으로 구현할 모델보다는 훨씬 단순한 모델이다.  
  각 서비스는 자체 도메인 모델을 소유하기에 도메인 모델이 하나뿐인 애플리케이션은 없다.  
  지나친 단순화일 수 있지만, 고수준 도메인 모델은 시스템 작업의 동작을 기술하는 데 필요한 vocabulary를  
  정의하기 때문에 이 단계에서는 유용하다.

- 도메인 모델은 스토리에 포함된 명사를 분석하고, 도메인 전문가와 상담하는 등 표준 기법을 활용하여 생성한다.  
  예를 들어, _주문하기_ 스토리는 아래와 같이 다양한 사용자 시나리오로 확장시킬 수 있다.

  - 전제(Given)

    - 소비자가 있다.
    - 음식점이 있다.
    - 음식점은 소비자의 주소로 제시간에 음식을 배달할 수 있다.
    - 주문 총액이 음식점의 최소 주문량 조건에 부합된다.

  - 조건(When)

    - 소비자가 음식점에 음식을 주문한다.

  - 결과(Then)

    - 소비자의 신용 카드가 승인된다.
    - 주문이 `PENDING_ACCEPTANCE` 상태로 생성된다.
    - 생성된 주문이 소비자와 연관된다.
    - 생성된 주문이 음식점과 연관된다.

  - 위 시나리오에 포함된 명사를 보면 `Consumer(소비자)`, `Order(주문)`, `Restaurant(음식점)`,  
    `CreditCard(신용카드)` 등 다양한 클래스가 필요해 보인다.

- 마찬가지로 _주문 접수_ 스토리는 아래의 시나리오로 확장할 수 있다.

  - 전제(Given)

    - 현재 주문은 `PENDING_ACCEPTANCE` 상태이다.
    - 주문 배달이 가능한 배달원이 있다.

  - 조건(When)

    - 주문을 접수한 음식점은 언제까지 음식을 준비할 수 있다고 약속한다.

  - 결과(Then)

    - 주무 상태가 `ACCEPTED`로 바뀐다.
    - 주문의 promiseByTime 값을 음식점이 준비하기로 약속한 약속 시간으로 업데이트한다.
    - 주문을 배달할 배달원을 배정한다.

- 시나리오를 보니 `Courier(배달원)`, `Delivery(배달)` 클래스가 필요할 것 같다.  
  이런 분석을 몇 차례 거듭하면 `MenuItem(메뉴 항목)`, `Address(주소)` 등 기타 클래스도 도출되어  
  아래의 핵심 클래스들로 구성된 도메인 모델이 완성된다.

  - `Consumer`: 주문을 하는 소비자
  - `Order`: 소비자가 한 주문, 어떤 주문인지 나타내며 상태를 추적한다.
  - `OrderLineItem`: `Order`의 품목
  - `DeliveryInfo`: 주문을 배달할 시간 및 장소
  - `Restaurant`: 배달할 주문을 준비하는 음식점
  - `MenuItem`: 음식점의 메뉴 항목
  - `Courier`: 주문을 배달하는 배달원, 배달원의 가용성 및 현재 위치를 추적한다.
  - `Address`: 소비자 또는 음식점의 주소
  - `Location`: 배달원의 위치(위도, 경도)

- 이제 아키텍쳐 시나리오에 맞게 시스템 작업을 정의하자.

<h4>시스템 작업 정의</h4>

- 애플리케이션이 어떤 요청을 처리할지 식별하자.  
  시스템 작업은 크게 아래 두 종류로 나뉜다.

  - 커맨드(command): 데이터 생성(C), 수정(U), 삭제(D)
  - 쿼리(query): 데이터 조회(R)

- 시스템 작업은 결국 REST, RPC, Messaging endpoint로 구현되겠지만, 일단 추상적으로 생각해보자.  
  먼저 커맨드를 식별해보자.

- 시스템 커맨드를 식별하려면 사용자 스토리, 시나리오에 포함된 동사를 먼저 분석한다.  
  예를 들어 _주문하기_ 스토리를 보면 당연히 주문 생성 작업이 필요할 것이다.  
  다른 스토리도 대부분 시스템 커맨드와 직접 매핑된다.

- 예를 들어, 액터(actor)가 `소비자(Consumer)`이며, 스토리는 `주문 생성`이고 커맨드는 `createOrder()`인  
  시스템 커맨드가 도출되었다. 이 커맨드는 주문을 생성한다.

- 커맨드는 매개변수, 반환값, 동작 방식의 명세를 도메인 모델 클래스로 정의한다.  
  이 명세는 작업 호출 시 충족되어야할 선행 조건(precondition), 작업 후 충족되어야할 후행 조건(postcondition)으로  
  구성된다. 가령 `createOrder()`의 시스템 작업 명세는 아래와 같이 정의될 수 있다.

  - 작업: `createOrder(소비자 ID, 결제 수단, 배달 주소, 배달 시각, 음식점 ID, 주문 품목)`
  - 반환값: orderId
  - 선행 조건
    - 소비자가 존재하고 주문할 수 있다.
    - 주문 품목은 음식점의 메뉴 항목에 들어 있다.
    - 배달 주소, 시각은 음식점에서 서비스할 수 있다.
  - 후행 조건
    - 소비자 신용카드는 주문 금액만큼 승인 처리되었다.
    - 주문은 `PENDING_ACCEPTANCE` 상태로 생성되었다.

- 선행 조건은 주문하기 시나리오의 전제(Given)를, 후행 조건은 주문하기 시나리오의 결과(Then)을 나타낸다.  
  시스템 작업 호출 시 먼저 선행 조건을 확인한 후, 후행 조건을 만족시키는 액션을 수행한다.  
  아래는 `acceptOrder()` 시스템 작업의 명세이다.

  - 작업: `acceptOrder(restaurantId, orderId, readByTime)`
  - 반환값: 없음
  - 선행 조건
    - order.status는 `PENDING_ACCEPTANCE`이다.
    - 배달원은 주문을 배달할 수 있다.
  - 후행 조건
    - order.status는 `ACCEPTED`로 변경되었다.
    - order.readByTime은 readByTime으로 변경되었다.
    - 주문을 배달할 배달원이 확정되었다.

- 선행, 후행 조건을 보니 사용자 시나리오가 잘 반영되어 있다.  
  데이터를 가져오는 쿼리도 중요하지만, 아키텍쳐와 연관된 시스템 작업은 대부분 커맨드이다.  
  가령, 소비자가 주문을 하는 과정을 떠올려보자.

  - 사용자는 배달 주소 및 시간을 입력한다.
  - 시스템은 배달 가능한 음식점을 표시한다.
  - 사용자는 음식점을 선택한다.
  - 시스템은 메뉴를 표시한다.
  - 사용자는 원하는 메뉴를 선택한 후 체크아웃한다.
  - 시스템은 주문을 생성한다.

- 위와 같은 시나리오라면, 아래의 2개 쿼리가 필요할 것이다.

  - `findAvailableRestaurants(deliveryAddress, deliveryTime)`
  - `findRestaurantMenu(restaurantId)`

- 둘 중 지리 검색이 필요한 `findAvailableRestaurants()` 가 더 복잡한 쿼리라서 아키텍쳐 관점에서는 더 중요하다.  
  이 쿼리의 지리 검색 컴포넌트는 배달 주소에 해당하는 곳 주변의 전체 음식점을 검색한 후, 주문을 준비/픽업할 시점에 영업 종료하는  
  음식점을 필터해야 한다. 이 쿼리는 소비자가 주문을 할 때마다 실행되므로 성능 역시 중요하다.

- 고수준 도메인 모델과 시스템 작업을 보면, 애플리케이션이 무슨 일을 하는지 알 수 있기에 아키텍쳐를 정의하는 데 대단히 유용하다.  
  각 시스템 작업은 도메인 모델 중심으로 기술하는데, 중요한 시스템 작업은 아키텍쳐 측면에서도 중요한 시나리오를 나타내고  
  이런 시나리오 자체가 아키텍쳐를 기술하는 일부가 된다.

- 시스템 작업을 정의한 후에는 애플리케이션 서비스를 식별한다.  
  서비스를 기계적으로 식별하는 방법은 없지만 다양한 분해 전략을 선택할 수 있다.  
  어떤 분해 전략이든 최종 결과는 **기술 개념이 아닌 비즈니스 개념 중심으로 서비스가 구성된 아키텍쳐**이다.

<h3>서비스 정의: 비즈니스 능력 패턴별 분해</h3>

- MSA를 구축하는 첫 번째 전략은 **비즈니스 능력에 따라 분해하는 것**이다.  
  비즈니스 아키텍쳐 모델링에서 비롯된 비즈니스 능력은 비즈니스가 가치를 생산하기 위해 하는 일을 말한다.

<h4>비즈니스 능력은 곧 조직이 하는 일이다</h4>

- 비즈니스 능력을 보면 그 조직의 비즈니스가 무엇인지를 알 수 있다. 조직이 비즈니스를 하는 방법은 그때마다 다르고  
  급격히 변하기도 하지만 비즈니스 능력은 대체로 크게 달라지지 않는다. 특히 비즈니스 프로세스를 자동화하는 요즘은  
  더 그렇다. 가령, 예전에는 은행에 직접 가서 수표를 예금했지만 어느 시점부터는 ATM으로도 수표를 예금할 수 있게  
  되었고, 요즘은 대부분 스마트폰으로 간편하게 처리한다.  
  *수표 예금*이라는 비즈니스 능력은 거의 불변이지만, 처리하는 방법은 상당히 달라졌다.

<h4>비즈니스 능력 식별</h4>

- 한 조직의 비즈니스 능력은 조직의 목표, 구조, 비즈니스 프로세스를 분석하여 식별한다.  
  사실 기술보다 비즈니스 위주라는 점만 제외하면 일종의 서비스로도 볼 수 있다.  
  비즈니스 능력 명세는 입력, 출력, SLA 등 다양한 컴포넌트로 구성된다.  
  예를 들어, 보험사의 증권 인수라는 능력의 입력은 소비자 신청서, 출력은 승인과 단가가 될 것이다.

- 비즈니스 능력은 보통 특정 비즈니스 객체에 집중하며, 여러 개의 하위 능력으로 분해할 수 있다.  
  이를테면 Claim이라는 비즈니스 객체는 Claim 관리 능력을 주심으로 Claim 정보 관리, Claim 검토,  
  Claim 지불 관리 등의 하위 능력이 있을 것이다.

- 배달 음식 주문 비즈니스의 능력도 쉽게 아래와 같이 도출할 수 있다.

  - 공급자 관리
    - 배달원 관리: 배달 정보 관리
    - 음식점 정보 관리: 음식점 메뉴, 위치, 영업 시간, 기타 정보 관리
  - 소비자 관리: 소비자에 관한 정보 관리
  - 주문 접수 및 이행
    - 주문 관리: 소비자가 주문을 생성/관리할 수 있게 한다.
    - 음식점 주문 관리: 음식점의 주문 준비 상태를 관리한다.
    - Logistics
    - 배달원 가용성 관리: 배달원이 배달 가능한지 실시간 관리
    - 배달 관리: 주문을 소비자에게 전달
  - 회계
    - 소비자 회계: 소비자 과금 관리
    - 음식점 회계: 음식점 지불 관리
    - 배달원 회계: 배달원 지불 관리

- 위 4개는 모두 최상위 능력이다. 이런 최상위 능력 하위에는 여러 개의 하위 능력이 있다.  
  가령 주문 접수 및 이행 능력은 5개의 하위 능력으로 분해된다.

- 이렇게 도출한 비즈니스 능력으로 서비스를 정의해보자.

<h4>비즈니스 능력을 여러 서비스로</h4>

- 비즈니스 능력을 식별한 후 능력에 따라, 또는 연관된 능력 그룹에 따라 서비스를 정의한다.  
  최상위 능력이 하나의 서비스로 바로 매핑될 수도 있고, 하위 능력 하나 또는 묶음이 서비스에 매핑될 수 있다.

- 능력 체계의 어느 수준(level)을 서비스에 매핑할지는 주관적인 문제이지만, 저자는 아래처럼 판단한다.

  - 공급자 관리 능력의 두 개 하위 능력은 각각 두 서비스로 매핑했다. 음식점과 배달원은 전혀 다른 성격의  
    공급자이기 때문이다.
  - 주문 접수 및 이행 능력은 서비스마다 상이한 프로세스 단계를 담당하도록 세 개의 서비스로 매핑했다.  
    (주문 관리 => 주문 서비스, 음식점 주문 관리 => 주방 서비스, Logistics 및 나머지 => 배달 서비스) .  
    배달원 가용성 관리와 배달 관리 능력은 밀접한 연관이 있기에 하나의 서비스로 묶었다.
  - 회계 능력은 유형별 회계가 대동소이하기 때문에 모든 하위능력을 통째로 하나의 서비스에 매핑했다.

- 이렇게 서비스를 **거의 변하지 않는 비즈니스 능력에 따라 구성**하면 비교적 안정적인 아키텍쳐 구축이 가능하다.  
  나중에 비즈니스 요건이 달라져도 아키텍쳐를 구성하는 개별 컴포넌트는 아키텍쳐는 그대로 둔 채 발전시킬 수 있다.

- 지금까지의 결론은 아키텍쳐를 정의하는 첫 번째 버전에 불과하다.  
  애플리케이션 도메인에 대한 파악이 더 될 수록 서비스 역시 더 정교해지기 마련이다.  
  특히 아키텍쳐를 정의하는 과정에서는 각각의 핵심 아키텍쳐 서비스와 나머지 서비스가 어떻게 협동하는지 살피는 과정이 중요하다.  
  가령 IPC가 너무 잦아 분해하는 것이 외려 비효율적이라 서비스를 재결합하는 경우도 있다.  
  반대로 어떤 서비스는 여러 개의 서비스로 나누는 것이 더 나을 정도로 복잡해지는 경우도 있다.

<h3>서비스 정의: 하위 도메인 패턴별 분해</h3>

- DDD는 객체 지향 도메인 모델 중심의 복잡한 소프트웨어 애플리케이션을 구축하는 방법이다.  
  도메인 내부에서 문제 해결이 가능한 형태로 도메인을 모델링하는 기법이라고 볼 수 있다.  
  DDD는 팀 내에서 사용할 vocabulary, 즉 공용 언어(Ubiqutous Language)를 정의한다.  
  도메인 모델은 애플리케이션의 설계, 구현에 밀접하게 반영된다.  
  DDD에는 MSA에 적용하면 정말 유용한 하위 도메인(Sub domain)과 Bounded Context 개념이 있다.

> DDD는 하위 도메인별로 서비스를 정의한다.

- 기존에는 전체 비즈니스를 포괄하는 단일 통합 모델을 만들었다.  
  예를 들어 소비자, 주문 등의 비즈니스 엔티티를 각각 따로 정의했다.  
  이렇게 모델링하면 하나의 모델에 대해 조직 내 여러 부서의 합의를 이끌어내기가 정말 어렵다는 단점이 있다.  
  반면 DDD는 범위가 분명한 도메인 모델을 여러 개 정의하여 기존 방식의 문제점을 해결하는 전혀 다른 방식의 모델링이다.

- DDD는 도메인을 구성하는 각 하위 도메인(Sub domain)마다 도메인 모델을 따로 정의한다.  
  하위 도메인은 비즈니스 능력과 같은 방법(비즈니스를 분석하고 상이한 전문 영역 식별)으로 식별하므로 십중팔구  
  비즈니스 능력과 유사한 하위 도메인이 도출된다. 가령 위에서 살펴본 배달 음식 주문의 경우 주문 접수, 주문 관리,  
  주방 관리, 배달, 재무 등이 있다.

- 도메인 모델의 범위를 DDD의 용어로는 Bounded Context라 한다.  
  Bounded Context는 도메인 모델을 구현한 코드 아티팩트(Code artifact)를 포함하며, MSA에 DDD를 적용하면  
  각 서비스들 자체가 Bounded Context가 된다. 예를 들어 하위 도메인들 중 *주문 접수 하위 도메인*의 경우에는  
  이 하위 도메인 자체가 *주문 서비스*와 매핑된다. *주문 서비스*내에는 자체적인 *주문 도메인 모델*이 있다.

- DDD와 MSA는 거의 찰떡궁합이다. DDD의 하위 도메인, Bounded Context 개념은 MSA의 서비스와 잘 맞고,  
  MSA의 서비스 자율 팀 개념은 도메인 모델을 개별 팀이 소유 및 개발한다는 DDD의 사고방식과 잘 오울린다.  
  자체 도메인 모델을 가진 하위 도메인이라는 개념 덕분에 만능 클래스를 제거하고 서비스로 분해하기가 더 수월해진다.

<h3>분해 지침</h3>

- 비즈니스 능력에 따른 분해, 하위 도메인에 따른 분해는 MSA를 정의하는 주요 수단이다.  
  이 밖에도 클래스의 책임을 정의하는 단일 책임 원칙(SRP), 공동 폐쇄 원칙(CCP)이 있다.  
  MSA에 이 두 원칙을 어떻게 적용할 수 있는지 알아보자.

<h4>단일 책임 원칙(SRP)</h4>

- 소프트웨어 아키텍쳐 및 설계의 주요 목표 중 하나는 각 소프트웨어 엘리먼트의 책임을 할당하는 것이다.  
  단일 책임 원칙은 아래의 한 문장으로 표현된다.

> 클래스는 오직 하나의 변경 사유를 가져야 한다.

- 클래스가 맡은 책임은 각각 그 클래스가 변경될 잠재적 사유이다. 클래스가 독립적으로 변경 가능한 책임을 여러 개 짊어지고 있다면  
  안정적일 수 없다. 따라서 SRP에 따라 단일 책임 원칙을 가진, 즉 변경 사유가 오직 하나인 클래스를 정의하라는 것이다.

- 이 원칙을 MSA에 적용하면 하나의 책임만 가지고 응집된 서비스를 정의할 수 있다. 덕분에 더 작고 안정된 서비스를 만들 수 있다.  
  위에서 살펴본 배달 음식 주문 비즈니스는 이를 실천한 좋은 예시이다. 주문 접수부터 주문 준비, 배달에 이르기까지 소비자가  
  주문한 음식이 배달되는 과정 하나하나 모두 개별 서비스가 맡아 처리하기 때문이다.

<h4>공동 폐쇄 원칙(CCP)</h4>

- 아래는 CCP(Common Closure Principle) 원칙의 정의이다.

> 패티지의 클래스들은 동일한 유형의 변경에 대해 닫혀 있어야 한다.  
> 패키지에 영향을 주는 변경은 그 패키지에 속한 모든 클래스에 영향을 끼친다.

- 즉, 어떤 두 클래스가 동일한 사유로 맞물려 변경된다면 동일한 패키지에 있어야 한다는 것이다.  
  가령 동일한 비즈니스 규칙도 상이한 측면을 구현한 클래스가 여러 개 있을 수 있다.  
  이 비즈니스 규칙이 나중에 바뀌어도 개발자는 가급적 소수(1개가 이상적) 패키지에 있는 코드만 고치면 될 수 있게 하자는 것이다.  
  CCP를 잘 지키면 애플리케이션의 유지보수성이 현저히 향상된다.

- CCP를 적용해서 MSA를 구축하면 동일한 사유로 변경되는 컴포넌트를 모두 같은 서비스로 묶을 수 있다.  
  요건이 바뀌어도 수정, 배포할 서비스 개수는 줄어들 것이다. 가능하면 변경 영향도를 한 서비스에 국한시키는 것이 좋다.  
  즉 CCP는 분산 모놀리틱 anti-pattern의 해독제인 셈이다.

- SRP, CCP와 더불어 비즈니스 능력, 하위 도메인에 따른 분해는 애플리케이션을 서비스로 분해하는 훌륭한 길잡이이다.  
  그러나 이런 좋은 기법들도 성공적으로 적용하려면 트랜잭션 관리, IPC 등 여러 이슈를 해결해야 한다.

<h3>서비스 분해의 장애물</h3>

- 비즈니스 능력과 하위 도메인별로 서비스를 정의해서 MSA를 구축하는 전략은 장애 요소가 많다.

  - 네트워크 지연
  - 동기 통신으로 인한 가용성 저하
  - 여러 서비스에 걸쳐 데이터 일관성 유지
  - 데이터의 일관된 뷰 확보
  - 분해를 저해하는 만능 클래스

<h4>네트워크 지연</h4>

- 네트워크 지연은 분산 시스템의 고질적인 문제이다. 서비스를 여러 개로 나누면 서비스 간의 왕복 횟수가 급증하게 된다.  
  그래서 한 차례 왕복으로 여러 객체를 한 번에 가져오는 Batch API를 구현하거나, 값비싼 IPC를 언어 수준의 메소드나  
  함수 호출로 대체하는 식으로 서비스 결합에 따른 지연 시간을 줄인다.

<h4>동기 IPC로 인한 가용성 저하</h4>

- 가용성을 떨어뜨리지 않고 서비스 간의 통신을 어떻게 할 수 있을까?  
  가령 주문 서비스의 `createOrder()`는 타 서비스의 REST API를 동기 호출하는 것이 가장 쉬운 구현 방법이지만,  
  타 서비스 중 하나라도 불능일 경우 주문은 생성되지 않기 때문에 REST와 같은 프로토콜은 가용성이 떨어지게 된다.  
  이 정도는 감수해야하는 trade off라고 볼 수도 있지만, 비동기 메시징으로 강한 결합도를 제거하고 가용성을 높이는  
  방법이 더 좋다.

<h4>여러 서비스에 걸쳐 데이터 일관성 유지</h4>

- 여러 서비스에 걸쳐 데이터의 일관성을 유지하는 것도 난제이다. 여러 서비스에 있는 데이터를 업데이트하는 시스템 작업이 있다고 하자.  
  가령 음식점이 주문을 접수하면 주방 서비스는 티켓 상태를 변경하고 배달 서비스는 배달 스케쥴을 잡아야 하므로 두 서비스 모두  
  업데이트 상태가 발생한다. 이때, 두 업데이트는 모두 원자적(atomically)으로 일어나야 한다.

- 과거에는 2단계 커밋(2PC) 분산 트랜잭션을 많이 사용했지만, 요즘 애플리케이션과는 잘 맞지 않기 때문에 Saga라는  
  전혀 다른 방식으로 트랜잭션을 관리해야 한다. Saga는 메시징을 이용한 일련의 로컬 트랜잭션이다. 기존 ACID 트랜잭션보다는  
  복잡하지만 다양한 상황에서도 잘 동작한다. 한 가지 단점은 최종 일관성(Eventual Consistency)을 보장한다는 것이다.  
  어떤 데이터를 원자적으로 업데이트해야 한다면 그 데이터를 하나의 서비스 내에 둬야 하는데, 이는 결국 분해의 걸림돌이 될 수 있다.

<h4>일관된 데이터 뷰 확보</h4>

- 여러 DB에 걸쳐 일관된 데이터 뷰를 확보하기도 어렵다. 모놀리틱 애플리케이션에서는 ACID 트랜잭션의 속성 덕분에 어떻게 쿼리를 하든  
  일관된 데이터 뷰가 반환되었지만, MSA는 각 서비스의 DB가 일관적이라 하더라도 전역 볌위에서의 일관된 데이터 뷰는 확보할 수 없다.  
  어떤 데이터를 일관된 뷰로 바라보려면 하나의 서비스 내부에 두어야 하는데, 이 역시 분해의 걸림돌이 된다.  
  하지만 다행이도 실제로 이는 거의 문제가 되지 않는다.

<h4>만능 클래스는 분해의 걸림돌</h4>

- 애플리케이션 곳곳에서 사용되는 만능 클래스는 그 존재만으로도 분해의 걸림돌이 된다.  
  이런 클래스에는 대부분 애플리케이션의 여러 측면에 관한 비즈니스 로직이 있는데, 굉장히 많은 필드가 다수의 컬럼을 가진  
  DB 테이블에 매핑된 경우가 많다. 이런 클래스는 거의 모든 애플리케이션에 하나쯤은 있다.  
  가령 은행 시스템의 계좌, 전자 상거래 시스템의 주문, 보험사 시스템 정책 등 주요 도메인과 연관된 클래스가 그렇다.  
  만능 클래스는 애플리케이션의 여러 측면의 상태/동작을 보이지 않게 감싸고 있기 때문에 이 클래스를 사용하는 전체 비즈니스 로직을  
  서비스로 분리하려면 매우 어렵다.

- 배달 음식 주문 애플리케이션의 `Order` 클래스도 만능 클래스이다. 소비자가 주문한 음식을 배달하는 것이 이 애플리케이션의  
  목표이므로 거의 모든 시스템이 주문과 연관되어 있다. 단일 도메인 모델 체계라면 `Order`는 애플리케이션 곳곳의 상태/동작을  
  가리키는 아주 큰 클래스일 것이다. 예를 들어 주문 처리, 음식점 주문 관리, 배달, 지불에 해당하는 필드/메소드가 `Order`  
  클래스에 몰려있다. 즉 한 모델이 완전히 떨어져 있는 다른 애플리케이션 파트의 상태 전이까지 기술하고 있는 것이다.  
  이런 구조로는 코드를 여러 서비스로 나누려 해도 이 클래스 하나 때문에 작업을 진행하기가 버겁다.

- `Order` 클래스를 라이브러리로 묶고 `Order` DB를 중앙화해서 주문을 처리하는 모든 서비스가 이 라이브러리를 통해  
  DB에 접근하도록 만들면 어떨까? 이 방법은 MSA의 핵심 원칙에 위배되어 결국 단단히 결합된 바람직하지 못한 구조가 된다.  
  `Order`의 스키마를 변경할 일이 있다면 모든 서비스의 코드가 영향 받을 것이기 때문이다.

- 다른 솔루션은 주문 DB를 주문 서비스 내로 캡슐화해서 다른 서비스가 주문 서비스를 통해서만 주문을 조회/수정하도록 하는 것이다.  
  그러나 이렇게하면 주문 서비스는 비즈니스 로직이 거의 없는, 빈껍데기 도메인 모델을 가진 데이터 서비스로 전락하게 된다.

- 가장 좋은 방법은 DDD를 적용하여 각 서비스를 자체 도메인 모델을 갖고 있는 개별 하위 도메인으로 취급하는 것이다.  
  즉, 배달 음식 주문 애플리케이션에서 주문과 조금이라도 연관된 서비스는 모두 각자 버전의 `Order` 클래스를 가진 도메인 모델을  
  따로 두는 것이다. 이런 다중 도메인 모델의 가장 좋은 사례가 배달 서비스이다. 배달 서비스에서는 `Order` 대신 `Delivery`라는  
  더 적절한 이름의 모델을 사용하며, 배달 상태, 픽업 주소/시간, 배달 주소/시간 등의 상태를 가지게 할 수 있다.  
  배달 서비스는 다른 주문 속성에는 전혀 관심이 없다.

- 주방 서비스 역시 `Order` 뷰가 아주 단순하다. 이 서비스에서의 `Order`는 `Ticket`이라고 네이밍되었다고 하자.  
  `Ticket`은 status(상태), requestedDeliveryTime(배달 요청 시간), prepareByTime(준비 완료 시간) 속성으로  
  구성되며, 음식점이 준비해야할 음식들을 나타내는 품목 리스트(`TicketLineItem`)를 참조한다.  
  소비자, 지불, 배달 등 다른 항목은 전혀 관심 없다.

- 이렇게 해도 주문 서비스는 뷰가 복잡하지만, 기존에 비해서는 훨씬 단순해진다.

- 이처럼 각 도메인 모델의 `Order` 클래스는 `Order`라는 동일한 비즈니스 엔티티의 상이한 측면을 나타낸다.  
  상이한 서비스의 상이한 객체 간의 일관성을 유지하는 것은 애플리케이션의 몫이다.  
  가령 주문 서비스는 소비자의 신용 카드가 승인처리되면 반드시 주방 서비스의 `Ticket` 생성을 trigger해야 한다.  
  마찬가지로 음식점이 주방 서비스를 통해 주문을 거부하면 주문 서비스는 해당 주문의 카드 승인 내역을 취소해야 한다.  
  이러한 서비스 간의 일관성은 이벤트 주도 메커니즘인 Saga를 활용하여 유지할 수 있다.

- 기술적인 문제 외에도 도메인 모델을 여러 개 두면 UX 구현에도 영향이 있다.  
  애플리케이션은 그 자체가 도메인 모델인 UX와 각 서비스의 도메인 모델을 서로 변환해야 한다.  
  가령 소비자가 주회한 주문 상태는 여러 서비스에 저장된 `Order`에서 비롯된 것이다.  
  이러한 변환 작업은 보통 API Gateway로 처리한다.

<h3>서비스 API 정의</h3>

<h4>시스템 작업을 서비스로 배정</h4>

<h4>서비스 간 협동 지원에 필요한 API 확정</h4>
