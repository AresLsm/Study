# 객체를 이터러블 프로그래밍으로 다루기

<h2>values</h2>

- 아래 객체가 있다고 하자.

```js
const obj1 = {
  a: 1,
  b: 2,
  c: 3,
  d: 4,
};

console.log(Object.values(obj1)); // [1, 2, 3, 4]

_.go(
  obj1,
  Object.values,
  _.map((a) => a + 10),
  _.reduce((a, b) => a + b),
  console.log
); // 50
```

- 위 코드의 `Object.values`를 함수형으로 다시 구현해보자.

```js
L.values = function* (obj) {
  for (const k in obj) {
    yield obj[k];
  }
};
```

- `L.values`가 효율적인 이유는 아래 코드를 보면 알 수 있다.

```js
var it = L.values(obj1);
it = L.take(2, it);
[...it];
```

- `[...it]`로 인해 iterator내의 모든 값이 평가될 때, `L.take()`가 값을 평가해야 하므로  
  `L.values`의 yield가 실행된다. 즉, `L.take()`가 가져갈 개수 만큼만 값이 평가되기에  
  `Object.entries` 보다 효율적인 것이다.

```js
_.go(
  obj1,
  L.values,
  _.map((a) => a + 10),
  _.reduce((a, b) => a + b),
  console.log
); // 50
```

- 이렇게 key:value의 쌍으로 된 객체를 더 효율적으로 다룰 수 있다.

<hr/>

<h2>entries</h2>

- 이번에는 key, value를 모두 꺼내오는 `Object.entries` 를 효율화해보자.

```js
L.entries = function* (obj) {
  for (const k in obj) {
    yield [k, obj[k]];
  }
};

_.go(
  obj1,
  L.entries,
  L.filter(([_, v]) => v % 2),
  _.each(console.log)
); // ["a", 1], ["c", 3]

_.go(
  obj1,
  L.entries,
  L.filter(([_, v]) => v % 2),
  L.map(([k, v]) => ({ k, v })),
  _.reduce(Object.assign),
  console.log
); // { a: 1, c: 3 }
```

- 위 코드에서는 obj1이 어떤 형식이던지 상관 없이 `L.entries`를 통해 뒤의 함수들이  
  이터러블 프로그래밍을 할 수 있게 해준다.

<hr/>

<h2>keys</h2>

- `Object.keys`를 지연적으로 구현해보자.

```js
L.keys = function* (obj) {
  for (const k in obj) {
    yield k;
  }
};

_.go(obj1, L.keys, _.each(console.log)); // "a", "b", "c", "d"
```

<hr/>
