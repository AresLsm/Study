# object 키워드를 통한 클래스 선언과 인스턴스 생성

- 코틀린에서는 object 키워드를 다양한 상황에서 사용하지만 모든 경우  
  **클래스를 정의하면서 동시에 인스턴스를 생성한다는 공통점이 있다.**  
  object 키워드를 사용하는 여러 상황을 살펴보자.

  - **객체 선언(object declaration)** : 싱글톤을 정의하는 방법 중 하나
  - **동반 객체(companion object)** : 인스턴스 메소드는 아니지만, 어떤 클래스와 관련 있는 메소드와  
    팩토리 메소드를 담을 때 사용한다. 동반 객체 메소드에 접근할 때는 동반 객체가 포함된 클래스의 이름을  
    사용할 수 있다.
  - 객체 식은 Java의 무명 내부 클래스(anonymous inner class) 대신 쓰인다.

## 객체 선언: 싱글톤을 쉽게 만들기

- 객체지향 시스템을 설계하다 보면, 인스턴스가 단 하나만 필요한 클래스가 유용한 경우가 많다.  
  Java에서는 보통 클래스의 생성자를 private으로 제한하고, 정적인 필드에 그 클래스의 유일한  
  객체를 저장하는 싱글톤 패턴(Singleton Pattern)을 통해 이를 구현한다.

- 코틀린은 **객체 선언** 기능을 통해 싱글톤을 언어 차원에서 기본 지원한다. 객체 선언은 클래스 선언과  
  그 클래스에 속한 **단일 인스턴스**의 선언을 합친 선언이다.

- 예를 들어, 객체 선언을 사용해 회사 급여 대장을 만들 수 있다. 한 회사에 여러 개의 급여 대장이 필요하진  
  않을 테니 싱글톤을 쓰는 게 정당해보인다.

```kt
object Payroll {
    val allEmployees = arrayListOf<Person>()

    fun calculateSalary() {
	for(person in allEmployees) {
	    //..
	}
    }
}
```

- 객체 선언은 object 키워드로 시작한다. 객체 선언은 클래스를 정의하고 그 클래스의 인스턴스를 만들어서 변수에  
  저장하는 모든 작업을 단 한 문장으로 처리한다.

- 클래스와 마찬가지로 객체 선언 안에도 프로퍼티, 메소드, 초기화 블록 등이 들어갈 수 있다.  
  하지만 **생성자는 주 생성자, 부 생성자 모두 객체 선언에 쓸 수 없다.** 일반 클래스 인스턴스와 달리  
  싱글톤 객체는 객체 선언문이 있는 위치에서 생성자 호출 없이 즉시 만들어진다. 따라서 객체 선언에는  
  생성자 정의가 필요 없다.

- 사용하는 부분을 보자.

```kt
Payroll.allEmployees.add(Person(/* .. */))
Payroll.calculateSalary();
```

- 객체 선언도 클래스나 인스턴스를 상속할 수 있다. 프레임워크를 사용하기 위해 특정 인터페이스를 구현해야하는데,  
  그 구현 내부에 다른 상태가 필요하지 않은 경우에 이런 기능이 유용하다. `java.util.Comparator`를 살펴보자.  
  `Comparator`의 구현은 두 객체를 인자로 받아 그중 어느 객체가 더 큰지 알려주는 정수를 반환한다.  
  `Comparator` 안에는 데이터를 저장할 필요가 없다. 따라서 어떤 클래스에 속한 객체를 비교할 때 사용하는  
  `Comparator`는 보통 클래스마다 단 하나씩만 있으면 된다. 따라서 `Comparator` 인스턴스를 만드는 방법으로는  
  객체 선언이 가장 좋은 방법이다.

- 두 파일 경로를 대소문자 관계없이 비교해주는 `Comparator`를 구현해보자.

```kt
object CaseInsensitiveFileComparator : Comparator<File> {
    override fun compare(file1: File, file2: File): Int {
	return file1.path.compareTo(file2.path, ignoreCase = true)
    }
}
```

- 일반 객체(클래스 인스턴스)를 사용할 수 있는 곳에서는 항상 싱글톤 객체를 사용할 수 있다.  
  예를 들어, 이 객체를 `Comparator`를 인자로 받는 함수에게 인자로 건넬 수 있다.

```kt
val files = listOf(File("/z"), File("/a"))
println(files.sortedWith(CastInsensitiveFileComparator))
```

- 위 예시 코드는 전달받은 `Comparator`에 따라 리스트를 정렬하는 `sortedWith()`를 사용한다.

- 클래스 안에서도 객체 선언을 할 수 있다. 그런 객체도 인스턴스는 단 하나뿐이다. 예를 들어, 어떤 클래스의  
  인스턴스를 비교하는 `Comparator`를 클래스 내부에 정의하는 게 더 바람직하다.

```kt
data class Person(val name: String) {
    object NameComparator : Comparator<Person> {
	override fun compare(p1: Person, p2: Person): Int {
	    return p1.name.compareTo(p2.name)
	}
    }
}
```

> **코틀린 객체를 Java에서 사용하기**
>
> - 코틀린 객체 선언은 유일한 인스턴스에 대한 정적 필드가 있는 Java 클래스로 컴파일된다.  
>   이때 인스턴스 필드명은 항상 INSTANCE이다. 싱글톤 패턴을 Java에서 구현해도 비슷한 필드가  
>   필요하다. Java코드에서 코틀린 싱글톤 객체를 사용하려면, 정적인 INSTANCE를 통하면 된다.
>
> ```java
> CaseInsensitiveFileComparator.INSTANCE.compare(file1, file2);
> ```

<hr/>

## 동반 객체: 팩토리 메소드와 정적 멤버가 들어갈 장소

- 코틀린 클래스 안에는 정적인 멤버가 없다. 코틀린 언어는 Java의 static 키워드를 지원하지 않는다.  
  그 대신 코틀린에서는 패키지 수준의 최상위 함수와 객체 선언을 활용한다. 대부분의 경우, 최상위  
  함수를 활용하는 편을 더 권장한다. 하지만 최상위 함수는 클래스의 private 멤버에 접근할 수 없다.  
  그래서 클래스의 인스턴스와 관계없이 호출해야 하지만, 클래스 내부 정보에 접근해야 하는 함수가  
  필요할 때는 클래스 안에 중첩된 객체 선언의 멤버 함수로 정의해야 한다.  
  그런 함수의 대표적인 예로 팩토리 메소드를 들 수 있다.

- 클래스 안에 정의된 객체 중 하나에 companion이라는 특별한 표시를 붙이면, 그 클래스의 동반 객체로  
  만들 수 있다. 동반 객체의 프로퍼티나 메소드에 접근하려면 그 동반 객체가 정의된 클래스명을 사용한다.  
  이때, 객체의 이름을 따로 지정할 필요가 없다. 그 결과 동반 객체의 멤버를 사용하는 구문은 Java의  
  정적 메소드 호출이나 정적 필드 사용 구문과 같아진다.

```kt
class A {
    companion object {
	fun bar() = println("Companion object called.")
    }
}

// client
A.bar()
```

- 동반 객체는 private 생성자를 호출하기 좋은 위치다. **동반 객체는 자신을 둘러싼 클래스의 모든 private**
  **멤버에 접근할 수 있다.** 따라서 동반 객체는 바깥쪽 클래스의 private 생성자도 호출할 수 있다.  
  따라서 동반 객체는 팩토리 패턴을 구현하기 가장 적합한 위치다.

- 예시로 부 생성자가 2개 있는 클래스를 보고, 다시 그 클래스를 동반 객체 내에서 팩토리 클래스를  
  정의하는 방식으로 변경해보자.

```kt
class User {
    val nickname: String

    constructor(email: String) {
	nickname = email.substringBefore('@')
    }

    constructor(facebookAccountId: Int) {
	nickname = getFacebookName(facebookAccountId)
    }
}
```

- 이런 로직을 표현하는 더 유용한 방법으로 클래스의 인스턴스를 생성하는 팩토리 메소드가 있다.  
  아래 코드를 사용하면, 생성자를 통해 `User` 인스턴스를 만들 수는 없고, 팩토리 메소드를  
  통해야만 한다.

```kt
class User private constructor(val nickname: String) {
    companion object {
	fun newSubscribingUser(email: String) = User(email.substringBefore('@'))
	fun newFacebookUser(accountId: Int) = User(getFacebookName(accountId))
    }
}

// client
val subscribingUser = User.newSubscribingUser("sangwoo@test.com")
val facebookUser = User.newFacebookUser(123456789)
```

- 팩토리 메소드는 매우 유용하다. 이 예시 코드 처럼 목적에 따라 팩토리 메소드명을 정할 수 있다.  
  게다가 팩토리 메소드는 그 팩토리 메소드가 선언된 클래스의 하위 클래스를 반환할 수도 있다.  
  또한 팩토리 메소드는 객체를 생성할 필요가 없는 객체를 생성하지 않을 수도 있다. 예를 들어 이메일  
  주소별로 유일한 `User` 인스턴스를 만드는 경우, 팩토리 메소드가 이미 존재하는 인스턴스에 해당  
  이메일 주소를 전달받으면 새로운 인스턴스를 만들지 않고 캐시에 있는 기존 인스턴스를 반환할 수 있다.  
  하지만 **클래스를 확장해야만 하는 경우에는 동반 객체 멤버를 하위 클래스에서 오버라이드할 수 없으므로**  
  **여러 생성자를 사용하는 편이 더 나은 해법이다.**

<hr/>
