## 질의 함수와 변경 함수 분리하기

```js
// 리팩토링 적용 전
function getTotalOutstandingAndSendBill() {
  const result = customer.invoices.reduce(
    (total, each) => each.amount + total,
    0
  );
  sendBill();
  return result;
}

// 리팩토링 적용 후
function totalOutstanding() {
  return customer.invoices.reduce((total, each) => each.amount + total, 0);
}

function sendBill() {
  emailGateway.send(formatBill(customer));
}
```

### 배경

- 우리는 외부에서 관찰할 수 있는 겉보기 부수효과(Observable side effect)가 전혀 없이 값을 반환해주는  
  함수를 추구해야 한다. 이런 함수는 어느 때든 원하는만큼 호출해도 아무런 문제가 없다. 호출하는 문장의  
  위치를 호출하는 함수 안 어디로든 옮겨도 되며 테스트하기도 쉽다. 한마디로, 이용할 때 신경 쓸 거리가 매우 적다.

- 겉보기 부수효과가 있는 함수와 없는 함수는 명확히 구분하는 것이 좋다. 이를 위한 한 가지 방법은  
  _'질의 함수(읽기 함수)는 모든 부수효과가 없어야 한다'_ 는 규칙을 따르는 것이다. 이를  
  **명령-질의 분리(Command-Query Seperation)** 라 하는데, 이 규칙을 100% 따르려 노력하자.

- 값을 반환하면서 부수 효과도 있는 함수를 발견하면 상태를 변경하는 부분과 질의하는 부분을 분리하자.

- _겉보기_ 부수효과라고 하는 데는 이유가 있다. 흔히 쓰는 최적화 기법 중 요청된 값을 캐싱해두고  
  다음번 호출 때 빠르게 응답하는 방법이 있는데, 이러한 캐싱도 객체의 상태를 변경하지만 객체 밖에서는  
  관찰할 수 없다. 즉, 겉보기 부수효과 없이 어떤 순서로 호출하든 모든 호출에 항상 똑같은 값을 반환할 뿐이다.

### 절차

- (1) 대상 함수를 복제하고 질의 목적에 충실한 이름을 짓는다.  
  함수 내부를 살펴 무엇을 반환하는지 찾고, 만약 어떤 변수의 값을 반환한다면 그 변수명이  
  훌륭한 단초가 된다.

- (2) 새 질의 함수에서 부수효과를 모두 제거한다.

- (3) 정적 검사 수행

- (4) 원래 함수(변경 함수)를 호출하는 곳을 모두 찾아낸다. 호출하는 곳에서 반환 값을 사용한다면  
  질의 함수를 호출하도록 바꾸고, 원래 함수를 호출하는 코드를 바로 아래줄에 새로 추가한다.  
  하나 수정할 때마다 테스트한다.

- (5) 원래 함수에서 질의 관련 코드를 제거한다.

- (6) 테스트한다.

### 예시

- 이름 목옥을 훑어 악당을 찾는 함수를 보자. 악당을 찾으면 그 사람의 이름을 반환하고 경고를 울린다.

```js
function alertForMiscreant(people) {
  for (const p of people) {
    if (p === "JOKER") {
      setOffAlarms();
      return "JOKER";
    }
    if (p === "EVIL") {
      setOffAlarms();
      return "EVIL";
    }
  }
  return "";
}
```

- 첫 단계는 _(1) 함수를 복제하고 질의 목적에 맞는 이름짓기다._

```js
function findMiscreant(people) {
  for (const p of people) {
    if (p === "JOKER") {
      setOffAlarms();
      return "JOKER";
    }
    if (p === "EVIL") {
      setOffAlarms();
      return "EVIL";
    }
  }
  return "";
}
```

- 다음으로 _(2) 새 질의 함수에서 부수효과를 낳는 부분을 제거_ 한다.

```js
function findMiscreant(people) {
  for (const p of people) {
    if (p === "JOKER") {
      return "JOKER";
    }
    if (p === "EVIL") {
      return "EVIL";
    }
  }
  return "";
}
```

- 이제 _(4) 원래 함수를 호출하는 곳을 모두 찾아 새로운 질의 함수를 호출하도록 하고_,  
  _이어서 원래의 변경 함수를 호출하는 코드를 바로 아래 삽입한다._

```js
// client(before)
const found = alertForMiscreant(people);

// client(after)
const found = findMiscreant(people);
alertForMisceant(people);
```

- 마지막으로 _(5) 원래의 변경 함수에서 질의 관련 코드를 제거한다._

```js
function alertForMiscreant(people) {
  for (const p of people) {
    if (p === "JOKER") {
      setOffAlarms();
      return;
    }
    if (p === "EVIL") {
      setOffAlarms();
      return;
    }
  }
  return;
}
```

#### 더 가다듬기

- 이번 아이템은 여기서 끝이지만, 변경 함수의 새로운 질의 함수에는 중복 코드가 많아 보인다.  
  이번 경우에는 변경 함수에서 질의 함수를 사용하도록 고치면 된다.(**알고리즘 교체하기**)

```js
function alertForMiscreant(people) {
  if (findMiscreant(people) !== "") setOffAlarms();
}
```

<hr/>

## 함수 매개변수화하기

```js
// 리팩토링 적용 전
function tenPercentRaise(person) {
  person.salary = person.salary.multiply(1.1);
}

// 리팩토링 적용 후
function raise(person, factor) {
  person.salary = person.salary.multiply(1 + factor);
}
```

### 배경

- 두 함수의 로직이 아주 비슷하고 단지 리터럴값만 다르다면 그 다른 값만 매개변수로 받아 처리하는  
  함수 하나로 합쳐서 중복을 없앨 수 있다. 이렇게 하면 매개변수 값만 바뀌어 여러 곳에서  
  사용할 수 있으니 함수의 유용성이 커진다.

### 절차

- (1) 비슷한 함수 중 하나를 선택한다.
- (2) **함수 선언 바꾸기**로 리터럴들을 매개변수로 추가한다.
- (3) 이 함수를 호출하는 곳 모두에 적절한 리터럴값을 추가한다.
- (4) 테스트한다.
- (5) 매개변수로 받은 값을 사용하도록 함수 본문을 수정한다. 하나 수정할 때마다 테스트한다.
- (6) 비슷한 다른 함수를 호출하는 코드를 찾아 매개변수화된 함수를 호출하도록 하나씩 수정한다.  
  하나 수정할 때마다 테스트한다.

### 예시

- 먼저 명백한 예시를 보자.

```js
function tenPercentRaise(person) {
  person.salary = person.salary.multiply(1.1);
}

function fivePercentRaise(person) {
  person.salary = person.salary.multiply(1.05);
}
```

- 앞의 두 함수는 확실히 다음 함수로 대체할 수 있다.

```js
function raise(person, factor) {
  person.salary = person.salary.multiply(1 + factor);
}
```

- 하지만 이렇게 간단히 끝나지 않는 경우도 있다. 아래 코드를 보자.

```js
function baseCharge(usage) {
  if (usage < 0) return usd(0);
  const amount =
    bottomBand(usage) * 0.03 + middleBand(usage) * 0.05 + topBand(usage) * 0.07;
  return usd(amount);
}

function bottomBand(usage) {
  return Math.min(usage, 100);
}

function middleBand(usage) {
  return usage > 100 ? Math.min(usage, 200) - 100 : 0;
}

function topBand(usage) {
  return usage > 200 ? usage - 200 : 0;
}
```

- band를 다루는 세 함수의 로직이 상당히 비슷한 것은 사실이지만, 과연 매개변수화 함수로 통함할 수  
  있을만큼 비슷할까? 그렇다. 하지만 앞서 본 예시보다는 덜 직관적이다.

- 우선 비슷한 함수들을 매개변수화하여 통합할 때는 _(1) 대상 함수 중 하나를 골라 매개변수를 추가_ 하자.  
  단, 다른 함수들까지 고려해 선택해야 한다. 지금 예시처럼 범위를 다루는 로직에서는 대개 중간에  
  해당하는 함수에서 시작하는 것이 좋다. 그러니 `middleBand()`에 매개변수를 추가하고  
  다른 호출들을 여기에 맞춰보자.

- `middleBand()`를 보니 리터럴을 두개(100, 200) 사용하며, 그 각각은 중간 band의 하한과  
  상한을 뜻한다. _(2) 함수 선언 바꾸기_ 를 적용하고 _(3) 이 리터럴들을 호출 시점에 입력하도록 변경_  
  해보자. 이 과정에서 함수명도 매개변수화된 기능에 어울리게 수정한다.

```js
function withinBand(usage, bottom, top) {
  return usage > 100 ? Math.min(usage, 200) - 100 : 0;
}

function baseCharge(usage) {
  if (usage < 0) return usd(0);
  const amount =
    bottomBand(usage) * 0.03 +
    withinBand(usage, 200, 300) * 0.05 +
    topBand(usage) * 0.07;
  return usd(amount);
}
```

- _(5) 함수에서 사용하던 리터럴들을 적절한 매개변수로 대체_ 하자.  
  하나 변경할 때마다 테스트한다.

```js
function withinBand(usage, bottom, top) {
  return usage > bottom ? Math.min(usage, top) - bottom : 0;
}
```

- 이제 _(6) band의 하한 및 상한을 호출하는 부분도 새로 만든 매개변수화 함수를 호출하도록 바꾸자._

```js
function baseCharge(usage) {
  if (usage < 0) return usd(0);
  const amount =
    withinBand(usage, 0, 100) * 0.03 +
    withinBand(usage, 200, 300) * 0.05 +
    withinBand(usage, 200, Infinity) * 0.07;
  return usd(amount);
}
```

<hr/>

## 플래그 인수 제거하기

```js
// 리팩토링 적용 전
function setDimension(name, value) {
  if (name === "height") {
    this._height = value;
    return;
  }
  if (name === "width") {
    this._width = value;
    return;
  }
}

// 리팩토링 적용 후
function setHeight(value) {
  this._height = value;
}

function setWidth(value) {
  this._width = value;
}
```

### 배경

- 플래그 인수(Flag argument)란 호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택하기 위해  
  전달하는 인수다. 아래 함수를 보자.

```js
function bookConcert(customer, isPremium) {
  if (isPremium) {
    // premium booking logic
  } else {
    // regular booking logic
  }
}
```

- 이제 클라이언트에서는 아래처럼 호출해야 한다.

```js
// boolean flag
bookConcert(customer, true);

// enum flag
bookConcert(customer, CustomerType.PREMIUM);

// string flag
bookConcert(customer, "premium");
```

- 플래그 인수는 호출할 수 있는 함수들이 무엇이며 어떻게 호출해야 하는지를 이해하기 어렵게 한다.  
  API를 익힐 때 사람들은 주로 함수 목록부터 살펴보는데, 플래그 인수가 있으면 함수들 간의  
  기능 차이가 잘 드러나지 않는다. 사용할 함수를 선택한 후에도 플래그 인수로 어떤 값을 넘겨야  
  하는지를 또 알아내야 한다. boolean 플래그는 코드를 읽는이에게 뜻을 온전히 전달하지 못하기에  
  더욱 좋지 못하다. 함수에 전달한 true의 의미가 도대체 무엇일까?  
  이보다는 특정한 기능 하나만 수행하는 명시적인 함수를 제공하는 편이 훨씬 깔끔하다.

- 물론 이렇게 생긴 인수라고 해서 모두 다 플래그 인수인 것은 아니다. 플래그 인수가 되려면 호출하는  
  쪽에서 boolean 값으로 프로그램에서 사용되는 데이터가 아닌 리터럴 값을 건네야 한다. 또한 호출되는  
  함수는 그 인수를 다른 함수에 전달하는 데이터가 아닌 제어 흐름을 결정하는 데 사용해야 한다.

- 함수 하나에서 플래그 인수를 두 개 이상 사용하면 플래그 인수를 써야 하는 합당한 근거가 될 수 있다.  
  플래그 인수 없이 구현하려면 플래그 인수들의 가능한 조합 수만큼의 함수를 만들어야 하기 때문이다.  
  그런데 다른 관점에서 보면 플래그 인수가 둘 이상이면 함수 하나가 너무 많은 일을 처리하고 있다는  
  신호이기도 하다. 그러니 같은 로직을 조합해내는 더 간단한 함수를 만들 방법을 고민해봐야 한다.

### 절차

- (1) 매개변수로 주어질 수 있는 값 각각에 대응하는 명시적인 함수들을 생성한다.  
  주가 되는 함수에 깔끔한 분배 조건문이 포함돼 있다면 **조건문 분해하기**로 명시적 함수들을 생성하자.  
  그렇지 않다면 wrapping 함수 형태로 만든다.

- (2) 원래 함수를 호출하는 코드들을 모두 찾아서 각 리터럴 값에 대응되는 명시적 함수를  
  호출하도록 수정한다.

### 예시

- 배송일자 계산함수를 호출하는 곳을 발견했다 해보자.

```js
shipment.deliveryDate = deliveryDate(order, true);
```

- 다른 곳에서는 아래 처럼 호출한다.

```js
shipment.deliveryDate = deliveryDate(order, false);
```

- 위 코드를 보면 boolean 값의 의미를 궁금해 하게 된다.  
  `deliveryDate()`는 아래와 같았다.

```js
function deliveryDate(order, isRush) {
  if (isRush) {
    let deliveryTime;
    if (["MA", "CT"].includes(order.deliveryState)) deliveryTime = 1;
    else if (["NY", "NH"].includes(order.deliveryState)) deliveryTime = 2;
    else deliveryTime = 3;
    return order.placedOn.plusDays(1 + deliveryTime);
  } else {
    let deliveryTime;
    if (["MA", "CT"].includes(order.deliveryState)) deliveryTime = 2;
    else if (["NY", "NH"].includes(order.deliveryState)) deliveryTime = 3;
    else deliveryTime = 4;
    return order.placedOn.plusDays(2 + deliveryTime);
  }
}
```

- 즉, 호출하는 쪽에서는 이 boolean 리터럴 값을 이용해서 어느 쪽 코드를 실행할지를 정한 것이다.  
  이는 전형적인 플래그 인수다. 이 함수가 어느 코드를 실행할지는 전적으로 호출자의 지시에 따른다.  
  따라서 명시적인 함수를 사용해 호출자의 의도를 밝히는 편이 나을 것이다.

- 먼저 _(1) 조건문 분해하기를 적용하자._

```js
function deliveryDate(order, isRush) {
  if (isRush) return rushDeliveryDate(order);
  else return regularDeliveryDate(order);
}

function rushDeliveryDate(order) {
  let deliveryTime;
  if (["MA", "CT"].includes(order.deliveryState)) deliveryTime = 1;
  else if (["NY", "NH"].includes(order.deliveryState)) deliveryTime = 2;
  else deliveryTime = 3;
  return order.placedOn.plusDays(1 + deliveryTime);
}

function regularDeliveryDate(order) {
  let deliveryTime;
  if (["MA", "CT"].includes(order.deliveryState)) deliveryTime = 2;
  else if (["NY", "NH"].includes(order.deliveryState)) deliveryTime = 3;
  else deliveryTime = 4;
  return order.placedOn.plusDays(2 + deliveryTime);
}
```

- 보다시피 새로 만든 두 함수가 호출자의 의도를 더 잘 드러낸다.  
  다음으로 _(2) 원래 함수를 호출하는 코드를 아래처럼 바꾸자._

```js
// client 1
shipment.deliveryDate = rushDeliveryDate(order);

// client 2
shipment.deliveryDate = regularDeliveryDate(order);
```

### 예시: 매개변수를 까다로운 방식으로 사용할 때

- 위처럼 조건문을 쪼개면 이 리팩토링을 수행하기 수월한데, 하지만 매개변수에 따른 분배 로직이  
  함수의 핵심 로직 바깥에 있을 때만 사용할 수 있다. 조금 더 매개변수가 까다롭게 쓰이는 버전의  
  `deliveryDate()`를 보자.

```js
function deliveryDate(order, isRush) {
  let result;
  let deliveryTime;
  if (order.deliveryState === "MA" || order.deliveryState === "CT")
    deliveryTime = isRush ? 1 : 2;
  else if (order.deliveryState === "NY" || order.deliveryState === "NH") {
    deliveryTime = 2;
    if (order.deliveryState === "NH" && !isRush) deliveryTime = 3;
  } else if (isRush) deliveryTime = 3;
  else if (order.deliveryState === "ME") deliveryTime = 3;
  else deliveryTime = 4;
  result = order.placeOn.plusDays(2 + deliveryTime);
  if (isRush) result = result.minusDays(1);
  return result;
}
```

- 위 코드에서 isRush를 최상위 분배 조건문으로 뽑아내려면 생각보다 일이 커질 수도 있어 보인다.  
  그러므로 _(1) `deliveryRate()`를 감싸는 wrapper 함수를_ 작성해보자.

```js
function rushDeliveryDate(order) {
  return deliveryDate(order, true);
}
function regularDeliveryDate(order) {
  return deliveryDate(order, false);
}
```

<hr/>
