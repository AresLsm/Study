# 포인터

## 빠른 포인터 입문

- 포인터는 간단히 말해 값이 저장된 메모리의 위치 값을 갖는 변수이다.

```go
var x int32 = 10
var y bool = true
```

- 모든 변수는 하나 혹은 그 이상의 연속적인 메모리 공간에 저장되는데, 그것을 **주소**라 한다. 서로 다른 타입의 변수들은 서로 다른 양의 메모리를  
  차지한다. 예를 들어 x는 int32이므로 4바이트가 필요하고, y는 bool이기에 1비트만 필요하다.(주소 지정을 통해 가질 수 있는 최소 공간은 1바이트이다.)

- 포인터는 단순히 다른 변수가 저장된 주소를 내용으로 갖는 변수이다.

```go
var x int32 = 10
var y bool = true
pointerX := &x
pointerY := &y
var pointerZ *string
```

- 서로 다른 타입은 서로 다른 수의 메모리를 차지하지만, 모든 포인터는 어떤 타입을 가리키던 간에 항상 같은 크기를 가지는데, 그 수는 데이터가 저장된  
  메모리의 위치를 가질 만큼이다. 예를 들어 위 코드에서 x가 1번지~4번지를(4byte) 차지하고, y가 5번지(1byte)를 차지한다고 해보자.  
  그리고 pointerX기 메모리의 6번지에 저장되었다고 하면 값으로는 x의 주소인 1을 갖는다. 비슷하게 y를 가리키는 pointer가 10번지에 저장되었다 하면  
  값으로는 y의 주소인 5를 갖는다. 마지막으로 pointerZ는 어딘가에 저장되긴 하지만, 아무것도 가리키지 않기에 0의 값을 가진다.

- 포인터의 zero value는 nil이다. nil은 slice, map, 함수를 위한 zero value이기도 하다. 추가로 channel, interface가 있는데 이들 모두  
  포인터로 구현되어 있다. nil은 특정 값의 부재를 표현하는 타입이 지정되지 않은 식별자이다. C언어의 NULL과 다르게, nil은 0의 다른 이름이 아니다.  
  그래서 nil을 숫자로 바꾸거나 숫자를 nil로 바꿀 수 없다.

> 이전에 보았듯이 nil은 Universe Block에 정의되어 있다. 즉, shadowing될 수 있다는 뜻이다.  
> 따라서 절대 함수나 변수명을 nil로 지정하지 말자.

- Go의 포인터 구문은 일부 C와 C++에서 차영했다. Go는 GC를 갖기에 메모리 관리에 대한 고통이 거의 사라졌다. 게다가 포인터 산술을 포함한 C와 C++에서  
  포인터를 갖고 할 수 있는 기교 중 일부는 Go에서는 허용되지 않는다.

- `&`는 주소 연산자로, 변수 앞에 `&`를 붙이면 해당 변수의 값이 저장된 메모리 위치의 주소를 반환하게 된다.

```go
x := "hello"
pointerToX := &x
```

- `*`는 간접 연산자로, 포인터 타입의 변수 앞에 붙이면 가리키는 값을 반환하게 된다. 이를 **역참조(dereferencing)** 라 한다.

```go
x := 10
pointerToX := &x
fmt.Println(pointerToX) // x의 메모리 주소
fmt.Println(*pointerToX) // 10
z := 5 + *pointerToX
fmt.Println(z) // 15
```

- 포인터를 역참조하기 전에 꼭 pointer가 nil이 아닌지 확인해야 한다. 만약 nil을 갖는 포인터를 역참조하면, 프로그램은 panic을 일으킨다.

```go
var x *int
fmt.Println(x == nil) // true
fmt.Println(*x) // Panic
```

- **포인터 타입**은 포인터가 어떤 타입을 가리키는지 나타낸다. 타입 이름 앞에 `*`를 사용해 작성한다.

```go
x := 10
var pointerX *int
pointerToX := &x
```

- 내장 함수 `new()`는 포인터 변수를 생성하는데, 제공된 타입의 zero value를 가리키는 포인터를 반환한다.

```go
var x = new(int)
fmt.Println(x == nil) // false
fmt.Println(*x) // 0
```

- `new()`는 드물게 사용된다. 구조체를 위해 포인터 인스턴스를 만들려면 구조체 리터럴 앞에 `&`를 사용한다. 기본 타입 리터럴이나 상수 앞에는  
  메모리 주소를 갖지 않기에 `&`를 사용할 수 없다. 이들은 단지 컴파일 과정에 존재하기 때문이다. 기본 타입을 위한 포인터가 필요하면, 변수를  
  선언하고 해당 변수를 가리키게끔 하도록 하자.

```go
x := &Foo{}
var y sring
z := &y
```

- 상수의 주소를 가질 수 없기에 때로는 불편함을 야기하기도 한다. 하나의 구조체 내에 기본 타입을 가리키는 포인터가 있다면, 리터럴을 해당 항목에  
  직접 할당할 수 있다.

```go
type person struct {
	FirstName string
	MiddleName *string
	LastName string
}

p := person{
	FirstName: "Pat",
	MiddleName: "Perry", // Compile Error
	LastName: "Peterson",
}
```

- 위 코드는 p변수 중 MiddleName에 값을 할당하는 과정에서 컴파일 에러가 발생한다. `MiddleName: &"Perry"`로도 에러는 해결되지 않는다.

- 이 문제를 회피하기 위한 두 가지 방법이 있는데, 첫 번째는 변수에 상수의 값을 들고 있게끔 하는 것이다.  
  두 번째는 helper 함수를 작성해 불리언, 숫자, 문자열 타입을 파라미터로 받아 해당 타입의 포인터를 반환하도록 하는 방법이다.

```go
func stringp(string s) *string {
	return &s
}
```

- 위 함수로 문제가 된 구조체를 다시 작성해보자.

```go
p := person{
	FirstName: "Pat",
	MiddleName: stringp("Perry"),
	LastName: "Peterson",
}
```

- 위 방식이 왜 동자할까? 상수를 함수로 전달했을 때, 상수는 파라미터로 복사된다. 그것은 변수이기 때문에 메모리에서 주소를 갖는다.  
  즉 `stringp()`는 변수의 메모리 주소를 반환하게 되는 것이다.

---

## 포인터를 두려워하지 말자

- 포인터는 Java, Javscript, Python, Ruby 등의 언어에 익숙하다면 위협적일 수 있다. 하지만 포인터는 실제 클래스의 동작과 유사하다.  
  이런 언어의 모든 클래스 인스턴스는 포인터로 구현이 된다. 클래스 인스턴스를 메소드로 넘길 때, 복사된 값은 인스턴스의 포인터이다.

- Go에서 포인터 변수나 파라미터를 사용할 때, 똑같은 수행을 보인다. Go와 이런 언어들 간의 차이는 원시 값과 구조체 모두를 위해 값으로 사용할지,  
  포인터로 사용할지에 대한 **선택**을 제공한다는 것이다. 대부분의 경우에는 값으로 사용하자. 값으로 사용하는 것은 데이터가 언제, 어떻게 수정되는지  
  이해하기 쉬워진다. 값으로 사용하는 또다른 이득은 GC가 해야하는 일의 양을 줄여준다.

---

## 포인터는 변경 가능한 파라미터를 가리킨다.

- 이전에 봤듯이 Go 상수는 컴파일 과정에서 계산될 수 있는 리터럴 표현을 위한 이름을 제공한다. 언어에는 다른 종류의 갑을 불변으로 선언하는 메커니즘은 없다.  
  최신 소프트웨어 엔지니어링은 불변성을 받아들인다. 불변 타입은 버그로부터 조금 더 안전하고, 더 이해하기 쉬우며 변경에 더 적합하기 때문이다.  
  반대로 가변성은 프로그램이 무엇을 하는지 더 이해하기 힘들게 만들며 협업하기 어렵게 될 수 있다.

- Go에서 불변 상수를 선언할 수 없다는 것은 문제가 될 수 있지만, 파라미터를 값이나 포인터로 선택할 수 있도록 하는 기능이 그런 문제를 해결할 수 있다.  
  소프트웨어 구성 과정 자료는 _"가변의 객체를 사용하는 것은 메소드 내에서 지역적으로 사용하거나 단 하나의 참조만 있게 사용한다면 나쁘지 않다."_ 라고  
  설명을 계속한다. 어떤 변수나 파라미터를 불변으로 선언하는 것보다, Go 개발자들은 가변인 파라미터를 가리키는 포인터를 사용한다.

- Go는 call by value를 사용하는 언어이기에, 함수로 전달된 값은 복사된다. 기본타입, 구조체, 배열과 같은 비 포인터 타입들은 호출된 함수에서  
  원본을 수정할 수 없다는 의미이다. 호출된 함수는 원본의 복사본을 갖기에 원본의 불변성을 보장한다.

- 하지만 포인터가 함수로 전달되면 함수는 포인터의 복사를 얻게 된다. 해당 포인터는 원본 데이터를 가리키고 있는데, 이는 호출된 함수에서 원본 데이터를  
  수정할 수 있다는 의미이다.

- 이에 관련된 몇 가지 예시가 있다.

- 첫 번째 예시는 nil 포인터를 함수로 전달했을 때, 해당 값을 nil이 아닌 값으로 만들 수 없다는 것이다. **포인터에 이미 할당된 값이 있는 경우에만 값을**  
  **재할당할 수 있다.** 메모리 위치가 call by value를 통해 함수로 넘어가기 때문에 정수 파라미터의 값을 변경할 수 있는 것 이상으로 메모리 주소를  
  변경할 수 없다.

```go
func failedUpdate(g *int) {
	x := 10
	g = &x
}

func main() {
	var f *int // f: nil
	failedUpdate(f)
	fmt.Println(f) // nil
}
```

- 위 코드에서 `main()`에서 f는 nil을 갖고 시작한다. `failedUpdate()`를 호출하면 f의 값인 nil을 복사하고, 복사된 값을 파라미터 g에 넣는다.  
  이는 곧 g 또한 nil로 설정된다는 의미이다. `failedUpdate()` 내에서 새로운 변수 x를 선언하고, 값으로 10을 할당한다. 그 다음 `failedUpdate()`의  
  g가 x를 가리키도록 변경한다. 이는 `main()`의 f를 변경하지는 않으며, `failedUpdate()`를 끝내고 `main()`으로 돌아와도 f는 여전히 nil을 가진다.

- 복사되는 포인터의 두 번째 예시는 함수를 종료해도 포인터 파라미터에 할당된 값이 그대로 유지되도록 하기 위해서는 포인터를 역참조 해 값을 설정해야 한다는  
  것이다. 포인터를 변경하면, 복사본을 변경하는 것이지 원본을 변경하는 것이 아니다. 역참조는 원본과 복사본이 가리키는 메모리 위치에 새로운 값을 넣어준다.  
  이것이 어떻게 동작하는지 간단한 프로그램으로 알아보자.

```go
func failedUpdate(px *int) {
	x2 := 20
	px = &x2
}

func update(px *int) {
	*px = 20
}

func main() {
	x := 10
	fmt.Println(&x)
	fmt.Println(10) // 10
	update(&x)
	fmt.Println(x) // 20
}
```

- 위 예시 코드에서는 `main()`에서 x에 10을 넣는 것으로 시작한다. `failedUpdate()`가 호출될 때, x의 주소를 복사해 px 파라미터에 넣는다.  
  다음으로 `failedUpdate()`에서 x2를 선언하고 20을 할당한다. 그리고 나서 `failedUpdate()`에서 px는 x2의 주소를 가리키도록 한다.  
  `main()`으로 돌아왔을 때, x의 값은 변하지 않는다. `update()`가 호출될 때, x의 주소를 복사해 px에 다시 넣는다. 하지만 이번에는  
  `update()`에서 px가 가리키는 `main()`의 x 값을 변경한다. `main()`으로 돌아왔을 때, x는 변경되어 있다.

---

## 포인터는 최후의 수단

- Go에서 포인터를 사용할 때 주의를 기울여야 한다. 앞서 봤듯이 포인터들은 데이터 흐름을 이해하기 어렵게 만들며, GC에게 추가적인 작업을 준다.  
  함수로 구조체 전달을 포인터로 해 항목을 채우는 것보다, 함수 내에서 구조체를 초기화하고 반환하는 것이 좋다.

```go
// BAD
func MakeFoo(f *Foo) error {
	f.Field1 = "val"
	f.Field2 = 20
	return nil
}

// BETTER
func MakeFoo() (Foo, error) {
	f := Foo{
		Field1: "val",
		Field2: 20,
	}
	return f, nil
}
```

- 변수를 수정하기 위해 포인터 파라미터를 사용해야하는 유일한 경우는 함수가 해당 포인터를 인터페이스로 예상할 때이다.  
  이런 패턴은 JSON을 사용할 때 볼 수 있다.

```go
f := struct {
	Name string `json:"name"`
	Age int `json:"age"`
}
err := json.Unmarshal([]byte({`{"name": "Bob", "age": 30}`), &f)
```

- `json.Unmarshal()` 함수는 JSON을 포함하는 byte slice로부터 변수를 채운다. 이 함수는 byte slice와 `interface{}`를 받도록 선언되어 있다.  
  `interface{}`를 위해 전달된 값은 반드시 포인터여야 한다. 그렇지 않다면, 오류를 반환할 것이다. 이는 Go가 제네릭을 갖고 있지 않기에 생긴 패턴이다.  
  즉 무엇을 unmarshalling할지를 지정하기 위해 함수에 타입을 전달하는 편리한 방법이 없으며, 타입이나 다른 반환 타입을 지정하는 방법도 없다.

- 함수에서 값을 반환할 때는 값 타입을 사용하는 것을 선호해야 한다. 데이터 타입 내에 수정될 필요가 있는 상태 정보를 갖고 있는 경우에만 포인터를  
  반환 타입으로 사용하자.

---

## 포인터로 성능 개선

- 구조체가 충분히 커진다면, 입력 파라미터나 반환값으로 구조체에 대한 포인터를 사용해 성능을 향상시킬 수 있다. 포인터는 모든 데이터 타입을 함수로  
  전달할 때 상수 시간이 걸리는데, 보통 1ns 정도이다. 그것도 그럴 것이, 모든 데이터 타입을 위한 포인터의 크기는 항상 동일하다.  
  반면 데이터를 그대로 함수로 전달하면, 데이터의 크기에 비례해 전달하는 데 시간은 더 걸릴 것이다. 약 10MB의 데이터를 전달하는 데에는 약  
  1ms가 걸린다.

- 포인터를 반환하는 수행과 값을 반환하기 위한 수행의 차이에서 조금 더 흥미로운 점이 있다.  
  1MB보다 작은 데이터 구조의 경우, 실제로 값 타입으로 반환하는 것 보다 포인터 타입으로 반환하는 것이 더 느리다.  
  예를 들어 100byte 데이터는 반환되는 데 10ns가 걸린다면, 포인터로 넘기면 30ns가 걸린다. 일단 해당 데이터가 1MB보다 커지면, 성능은  
  반대가 된다. 10MB의 데이터를 값으로 반환하면 2ms가 걸리는데, 포인터로 넘기면 0.5ms가 걸린다.

- 한 가지 짚고갈 점은 위에서 살펴본 시간은 매우 짧다는 것이다. 대부분의 경우에서 포인터의 사용과 값의 차이는 프로그램의 성능에 영향을 주지 않는다.  
  하지만 함수 간에 MB 단위의 데이터를 전달한다면, 데이터를 변경할 수 없는 경우에도 포인터 사용을 고려해보자.

---

## Zero Value와 nil의 차이

- Go에서 포인터의 다른 일반적인 사용은 zero value가 할당된 변수나 항목과 아무런 값도 할당되지 않은 변수나 항목의 차이를 나타낼 수 있다.  
  이런 구분이 프로그램에서 중요하다면, 할당되지 않은 변수나 구조체 항목을 나타내기 위해 nil pointer를 사용하자.

- 포인터는 또한 변경 가능함을 나타내므로, 이런 패턴을 사용할 때는 주의를 기울여야 한다. 함수에서 포인터를 nil로 설정하고 반환하는 것 보단,  
  이전에 map을 다루면서 봤던 값과 boolean flag를 사용한 comma ok idiom을 사용하자.

- nil pointer를 파라미터나 파라미터의 한 항목으로 넘긴다면, 값을 어디에도 저장할 수 없기 때문에 함수 내에서 값을 설정할 수가 없다는 것을  
  기억하자. nil이 아닌 값을 포인터로 전달하더라도, 해당 동작을 문서화하지 않는 한 수정하지 않도록 하자.

- JSON 변환은 위의 규칙에서 예외적인 경우이다. JSON에서 데이터를 변환하거나 데이터를 JSON으로 변환할 때, zero value와 값이 할당되지 않은  
  것을 구분짓는 방법이 필요할 것이다. nil이 입력 가능한 구조체 항목을 위해 포인터 값을 사용하자.

- JSON 또는 기타 외부 프로토콜을 다루지 않을 때에는 포인터 항목에 값이 없음을 나타내려고 시도하지 않도록 하자.  
  포인터는 값이 없음을 나타내는 쉬운 방법을 제공하지만, 값을 수정할 일이 없다면 대신에 boolean flag와 쌍을 이루는 값의 타입을 사용하자.

---

## Map vs Slice

- 함수로 넘겨진 map의 수정은 원본 변수에 반영된다. 이를 이해하기 위해서는 포인터 개념을 알아야 한다.  
  Go runtime 내에서 map은 구조체를 가리키는 포인터로 구현되어 있다. 즉, 함수로 map을 넘기는 것은 포인터를 복사한다는 의미이다.

- 이런 이유 때문에 특히나 공용 API에서 입력 파라미터나 반환값으로 map의 사용을 피해야 한다. API 설계 단계에서 map에는 어떤 값이 포함되어  
  있는지 알 수가 없기 때문에 나쁜 선택이 된다. map에 어떤 key가 있는지 명시적으로 정의하는 것은 없으므로, 어떤 key-value가 들어가는지를  
  파악하기 위해서는 코드를 추적해보는 수 밖에 없다. 불변성 관점에서도 map은 최종적으로 어떤 결과가 들어 있을 것인지를 확인하는 유일한 방법이  
  map이 이용된 모든 함수를 추적하는 것 뿐이기에 나쁜 선택이 된다. 이렇게 되면 API 자체가 문서화되는 것을 방해한다. 동적 언어를 사용했다면,  
  다른 언어의 구조체의 결핍을 위한 대체제로 map이 사용되어서는 안된다. Go는 강한 타입 언어이다. 따라서 map을 넘기기보다는 구조체를 사용하도록 한다.

- 반면, 함수로 slice를 넘기는 것은 조금 더 복잡한 행동을 한다. slice의 내용을 수정하는 것은 원본 변수에 반영이 되지만, `append()`를 통해 길이를  
  변경하는 것은 slice의 수용력이 길이보다 큰 경우 조차도 원본 변수에 반영되지 않는다. 그 이유는 slice는 3개의 항목을 갖는 구조체로 구현이 되어  
  있기 때문이다. 길이를 위한 정수 항목, 수용력을 위한 정수 항목, 그리고 메모리 block을 가리키는 포인터이다.

- slice가 다른 변수로 복사되거나 함수로 전달될 때, 길이, 수용력, 포인터 모두를 함께 복사하게 된다.  
  slice 내의 값의 변경은 포인터가 가리키는 메모리를 변경하기에 원본과 복사본 모두 변경이 발생한다.  
  길이와 수용력을 변경하는 것은 원본으로 다시 반영이 안되는데, 이는 복사본만 변경되기 때문이다. 수용력의 변경은 곧 포인터가 이제 새롭고 더 큰  
  메모리 block을 가리킨다는 의미이기 때문이다.

- 만약 복사된 slice에 값이 추가되고, 새로운 slice를 할당하지 않아도 될 정도로 충분한 수용력이 있는 경우에는 복사된 slice의 길이가 변경되고  
  새로운 값은 복사본과 원본이 공유하는 메모리 block에 저장된다. 하지만 원본 slice의 길이 항목은 변하지 않는다. 이 경우에는 Go runtime이  
  원본 slice의 길이를 넘어서서 존재하는 값들을 원본 slice에서 확인할 수 없도록 한다.

- 위의 내용을 통해 함수로 넘겨진 slice는 해당 내용을 수정할 수는 있지만, slice의 크기를 재조정할 수 없다는 것을 알 수 있다.  
  단 하나의 선형 데이터 구조로써, slice는 Go 프로그램에서 자주 전달된다. **기본적으로 함수에 의해 수정할 수 없다고 가정하자.**  
  만약 slice의 내용을 수정한다면, 함수의 문서에 꼭 넣어두도록 하자.

- 입력 파라미터로 slice를 사용하는 다른 경우는 재사용이 가능한 buffer를 위한 것이 가장 이상적이다.

---

## Buffer Slice

- 외부 자원(파일, 네트워크 연결 등)에서 데이터를 읽어들일 때, 많은 언어들이 아래와 같이 코드를 사용한다.

```py
r = open_resource()
while r.has_date() {
	data_chunk = r.next_chunk()
	process(data_chunk)
}
close(r)
```

- 이런 패턴의 문제는 while loop를 순회할 때마다 단지 한 번만 사용되더라도 data_chunk가 매번 할당되어야 한다는 것이다.  
  이는 많은 불필요한 메모리 할당을 하게 만든다. GC를 사용하는 언어는 자동으로 이런 할당들을 처리하지만, 이런 일들은 처리가 끝나고 난 뒤에  
  정리를 해줘야 할 필요가 있다.

- Go도 GC를 사용하는 언어이지만, 관용적 Go로 작성하면 불필요한 할당을 줄일 수 있다.  
  데이터 소스에서 매번 읽을 때마다 새로운 할당을 반환하기 보단, 일단 byte slice를 생성하고 데이터 소스를 읽어들이는 buffer로 사용한다.

```go
file, err := os.Open(filename)
if err != nil {
	return err
}

defer file.Close()
data := make([]byte, 100)
for {
	count, err := file.Read(data)
	if err != nil {
		return err
	}
	if count == 0 {
		return nil
	}
	process(data[:count])
}
```

- 함수로 넘겨진 slice의 길이와 수용력은 바꿀 수 없지만, 현재 길이에서 해당 내용을 변경할 수는 있다는 것을 기억하자.  
  위 코드에서는 100 byte buffer를 만들어 매 loop에서 다음 block의 byte(100byte까지)만큼 slice에 복사한다.  
  Buffer에 채워진 곳 까지만 `process()`로 넘겨 처리할 수 있도록 했다.

---
