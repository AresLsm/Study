# 동적 계획법과 분할 정복

## 정의

- 동적 계획법(DP, Dynamic Programming)

  - 입력 크기가 작은 부분 문제들을 해결한 후, 해당 부분 문제들의 해를 이용해 보다 큰 크기의 부분 문제를 해결, 최종적으로 전체 문제를 해결하는 방법
  - 상향식 접근법으로 가장 최하위 해답을 구한 후 이를 저장하고 해당 결과값을 이용해 상위 문제를 풀어가는 방식
  - Memoization 기법 활용
    - Memoization: 프로그램 실행 시 이전에 계산한 값을 저장해 다시 계산하지 않도록 하여 전체 실행 속도를 높이는 기술
  - 문제를 잘개 쪼갤 때 부분 문제들은 중복되어 재활용된다.

- 분할 정복(Divide and Conquer)

  - 문제를 나눌 수 없을 때까지 나눠 각각을 풀면서 다시 합병해 문제의 답을 얻는 방법
  - 하향식 접근법으로, 상위의 해답을 구하기 위해 아래로 내려가면서 하위의 해답을 구하는 방식
    - 일반적으로 재귀 함수로 구현한다.
  - 문제를 잘게 쪼갤 때 부분 문제는 서로 중복되지 않는다.

---

## 공통점과 차이점

### 공통점

- 문제를 잘게 쪼개서 가장 작은 단위로 분할

### 차이점

- 동적 계획법

  - 부분 문제는 중복되어 상위 문제 해결 시 재활용된다.
  - Memoization 기법 사용(부분 문제의 해답을 저장해 재활용하는 최적화 기법으로 사용)

- 분할 정복

  - 부분 문제는 서로 중복되지 않는다.
  - Memoization 기법을 사용하지 않는다.

---

## 동적 계획법 이해하기

### 피보나치 수열

- n을 입력 받아 아래와 같이 계산한다.

  - F(n)
    - n = 0: 0
    - n = 1: 1
    - n > 1 : F(n-1) + F(n-2)

- 재귀 용법을 사용해 구현하면 아래와 같다.

```java
public class Fibonacci {
    public static int run(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        } else return run(n - 1) + run(n - 2);
    }
}
```

- 동적 계획법을 사용해 구현하면 아래와 같다.

```java
public class Fibonacci {
    public static int run(int n) {
        int[] cache = new int[n + 1];
        cache[0] = 0;
        cache[1] = 1;
        for (int i = 2; i < n + 1; i++) {
            cache[i] = cache[i - 1] + cache[i - 2];
        }
        return cache[n];
    }
}
```

---
