<h1>추가 Query 기능</h1>

<h2>수정 및 삭제 query</h2>

<h3>수정 query</h3>

* 아래 코드는 update 구문을 이용하여 데이터를 수정하는 JPQL의 예시를 보여준다.
```java
entityManater.getTransaction().begin();
Query query = entityManager.createQuery(
    "UPDATE Hotel h SET h.name = :newName WHERE h.name = :oldName");
query.setParameter("newName", "새로운 이름");
query.setParameter("oldName", "예전 이름");

query.executeUpdate();
entityManager.getTransaction().commit();
```

* SQL의 UPDATE query와 유사하지만, 차이점이라면 SELECT query와 마찬가지로 __컬럼이 아닌 Entity의 속성을 이용한다__ 는 점이다.

* JPQL의 UPDATE query를 사용하려면 transaction 범위 내에서 실행해야 한다. 만약 transaction 범위 밖에서 수행할 경우 예외가 발생한다.

* UPDATE query를 생성할 때에는 결과 타입을 받지 않는 `EntityManager#createQuery(String query)`를 사용한다. 따라서 `TypedQuery`가   
  아닌 `Query` 객체를 사용한다.

* `Query#executeUpdate()`는 UPDATE 또는 DELETE문을 수행하고, 결과로 수정되었거나 변경된 Entity의 개수를 반환한다.

* 아래는 Criteria API를 사용하여 UPDATE query를 수행하는 예시이다.
```java
entityManager.getTransaction().begin();

CriteriaBuilder builder = entityManager.getCriteriaBuilder();
CriteriaUpdate<Hotel> criteriaUpdate = builder.createCriteriaUpdate(Hotel.class);
Root<Hotel> root = criteriaUpdate.from(Hotel.class);
criteriaUpdate.set(root.get("name"), "NEW NAME");
criteriaUpdate.where(builder.equal(root.get("name"), "OLD NAME"));

Query query = entityManager.createQuery(criteriaUpdate);
query.executeUpdate();
entityManager.getTransaction().commit();
```

* `CriteriaBuilder#createCriteriaBuilder()`는 수정 대상 Entity 타입을 인자로 받고, `CriteriaUpdate`객체를 반환한다.   
  `CriteriaUpdate`는 `set()` 메소드와 `where()` 메소드를 이용해서 변경할 값을 지정하고 비교 조건을 지정한다.   
  `CriteriaUpdate#from()` 메소드는 속성을 참고할 때 사용할 `Root` 객체를 반환한다. 이 `Root`객체를 이용해서 `set()`나 비교 조건을   
  생성할 때 사용할 속성을 구한다.

* `EntityManager#createQuery()`의 인자로 `CriteriaUpdate`를 전달하면 query를 실행할 수 있는 `Query` 객체를 반환한다. 그러고 난 후   
  `Query#executeUpdate()` 메소드를 이용해서 실제 query를 수행한다.

* 수정할 속성이 한 개 이상이면 다음과 같이 변경 속성별로 `set()` 메소드를 실행한다.
```java
CriteriaBuilder builder = entityManager.getCriteriaBuilder();
CriteriaUpdate<Hotel> criteriaUpdate = builder.createCriteriaUpdate(Hotel.class);
Root<Hotel> root = criteriaUpdate.from(Hotel.class);

criteriaUpdate.set(root.get("name"), "NEW NAME");
criteriaUpdate.set(root.get("grade"), "FIVE STAR");
criteriaUpdate.where(builder.equal(root.get("name"), "OLD NAME"));
```

<h3>삭제 query</h3>

* 삭제 query를 실행하는 방법은 수정 query를 실행하는 방법과 매우 유사하다. 먼저 삭제를 수행하는 JPQL Query를 보자.
```java
entityManager.getTransaction().begin();
Query query = entityManager.createQuery("DELETE Hotel h WHERE h.name = :name");
query.setParameter("name", "OLD NAME");
query.executeUpdate();
entityManager.getTransaction().commit();
```

* JPQL의 DELETE query 문법은 SQL의 DELETE query와 다르다. SQL DELETE query는 FROM절이 있지만, JPQL의 DELETE query는 FROM절이 없다.   
  DELETE절에 삭제 대상 Entity를 지정하고 WHERE절을 사용해서 삭제할 대상의 조건을 지정할 수 있다.
* 위 코드로 인해 수행되는 SQL문은 아래와 같다.
```sql
DELETE FROM Hotel WHERE name=?;
```

* Criteria API를 사용한 DELETE query는 아래와 같다.
```java
entityManager.getTransaction().begin();

CriteriaBuilder builder = entityManager.getCriteriaBuilder();
CriteriaDelete<Hotel> criteriaDelete = builder.createCriteriaDelete(Hotel.class);
Root<Hotel> root = criteriaDelete.from(Hotel.class);
criteriaDelete.where(builder.equal(root.get("name"), "OLD NAME"));

Query query = entityManager.createQuery(criteriaDelete);
query.executeUpdate();
entityManager.getTransaction().commit();
```

* `CriteriaBuilder#createCriteriaDelete()` 메소드는 삭제 대상 Entity 타입을 인자로 받고, DELETE query를 위한 `CriteriaDelete`객체를   
  반환한다. `CriteriaDelete#from()` 메소드로 삭제 대상 Entity를 query의 root로 추가하고, 조건을 추가하기 위해 `CriteriaDelete#where()`   
  메소드로 삭제 조건을 지정한다.

<h3>수정, 삭제 query와 영속 컨텍스트</h3>

* 수정, 삭제 query를 실행할 때의 주의점은 __영속 컨텍스트에 보관된 객체는 이 query에 영향을 받지 않는다는 점__ 이다.
```java
entityManager.getTransaction().begin();
Hotel hotel = entityManager.find(Hotel.class, "H-1");
// hotel.getName() ==> OLD NAME 반환

Query query = entityManager.createQuery("UPDATE Hotel h SET h.name = :newName WHERE h.id = :id");
query.setParameter("newName", "NEW NAME");
query.setParameter("id", "H-1");
query.executeUpdate();

hotel.getName();  // OLD NAME 반환
entityManager.getTransaction().commit();
```

* 위 코드는 id가 "H-1"인 `Hotel` Entity를 구하고 있다. 이 시점에 영속 컨텍스트에 Entity 객체가 저장된다. 이 Entity의 name 속성이   
  "OLD NAME"이라고 해보자. 그 다음 JPQL을 이용해서 name 속성을 "NEW NAME"으로 변경하고 있다. 하지만 마지막에 `hotel.getName()`으로   
  구한 name 속성은 "NEW NAME"이 아닌 "OLD NAME"이다. 즉, UPDATE query를 이용해서 수정한 결과는 영속 컨텍스트에는 반영되지 않는 것이다.

* 영속 컨텍스트에 보관된 Entity에 UPDATE query의 결과를 반영하고 싶다면 `EntityManager#refresh()` 메소드를 사용해서 DB에서 데이터를   
  읽어와 Entity에 반영하도록 하면 된다.
```java
entityManager.getTransaction().begin();
Hotel hotel = entityManager.find(Hotel.class, "H-1");
// hotel.getName() ==> OLD NAME 반환

Query query = entityManager.createQuery("UPDATE Hotel h SET h.name = :newName WHERE h.id = :id");
query.setParameter("newName", "NEW NAME");
query.setParameter("id", "H-1");
query.executeUpdate();

entityManager.refresh(hotel);
hotel.getName();  // NEW NAME 반환
entityManager.getTransaction().commit();
```

* 이때, DELETE query로 삭제한 Entity에 대해 `refresh()`를 호출하면 예외가 발생한다.
<hr/>