# Asynchronous Flow

- Suspending function은 비동기적으로 하나의 값을 반환한다.  
  하지만 만약 비동기적으로 계산돤 여러 개의 값을 반환하고 싶다면 어떻게 해야 할까? 이때 Kotlin Flow를 사용할 수 있다.

## Representing Multiple Values

- 여러 개의 값들은 코틀린에서 컬렉션으로 표현할 수 있다. 예를 들어 아래의 `simple()` 함수는 3개의 숫자를 담은 `List`를 반환하고,  
  반환받은 `List`의 원소를 각각 `main()`에서 출력한다.

```kt
fun simple(): List<Int> = listOf(1, 2, 3)

fun main() {
	simple().forEach { println(it) }
}
```

### Sequences

- 아래 처럼 하나의 값을 계산하는 데 100ms가 소요된다고 해보자. 이때, 이 값들을 `Sequence`로 표현할 수 있다.

```kt
fun simple(): Sequence<Int> = sequence {
	for (i in 1..3) {
		Thread.sleep(100)
		yield(i) // yield next value
	}
}

fun main() {
	simple().forEach { println(it) }
}
```

- 위 코드는 100ms씩 각 숫자를 출력한다.

### Suspending Functions

- 위에서 본 코드는 코드를 실행하는 main thread를 block한다는 단점이 있다. 만약 계산되는 값들이 비동기적으로 계산된다면, `simple()`을 suspending  
  function으로 표시해 blocking을 하지 않고 비동기적으로 처리할 수 있다.

```kt
suspend fun simple(): List<Int> {
	delay(1000)
	return listOf(1, 2, 3)
}

func main() = runBlocking<Unit> {
	simple().forEach { println(it) }
}
```

- 위 코드는 1초 후 모든 원소들을 출력한다.

### Flows

- 위에서 본 `simple()`은 반환형이 `List<Int>`인데, 이는 곧 모든 값들을 한 번에 반환해야 함을 의미한다.  
  비동기적으로 계산되는 값들의 _stream_ 을 나타내기 위해서는 `Flow<Int>` 타입을 사용할 수 있다.

```kt
fun simple(): Flow<Int> = flow {
	for (i in 1..3) {
		delay(100)
		emit(i) // emit next value
	}
}

func main() = runBlocking<Unit> {
	launch {
		for (k in 1..3) {
			println("I'm not blocked $k")
			delay(100)
		}
	}
	simple().collect { println(it) }
}

/*
I'm not blocked 1
1
I'm not blocked 2
2
I'm not blocked 3
3
*/
```

- 위 코드는 각 숫자를 출력하기 전 main thread를 blocking하지 않고 100ms 씩 기다린다.  
  "I'm not blocked"가 100ms 씩 출력되는 것으로 이를 알 수 있다.

- `Flow`를 사용한 이 코드에서 다른 코드의 차이점을 보자.

  - 우선 `Flow`를 사용하기 위한 builder function은 `flow { .. }`이다.
  - `flow { .. }` 안의 코드는 suspendable하다.
  - `simple()` 함수는 더 이상 suspend 키워드가 적용되어 있지 않다.
  - 값들은 `emit()`을 통해 flow로부터 _emit_ 된다.
  - 값들은 `collect()`를 통해 flow로부터 _collect_ 된다.

> `flow { .. }` 내의 `delay()`를 `Thread.sleep()`으로 바꾸면 main thread가 block된다.

---
