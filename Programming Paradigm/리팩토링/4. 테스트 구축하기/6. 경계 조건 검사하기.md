# 경게 조건 검사하기

- 지금까지 작성한 테스트는 모든 일이 순조롭고 사용자도 우리 의도대로 사용하는, 일명  
  _꽃길_ 상황에 집중했다. 그런데 이 범위를 벗어나는 경게 지점에서 문제가 생기면  
  어떤 일이 벌어지는지 확인하는 테스트도 함께 작성하면 좋다.

- 한 예시로, producers와 같은 컬렉션과 마주했을 때 그 컬렉션이 비어있을 때  
  어떤 일이 일어나는지 확인해보자.

```js
describe("no producers", () => {
  let noProducers;
  beforeEach(() => {
    const data = {
      name: "No producers",
      producers: [],
      demand: 30,
      price: 20,
    };
    noProducers = new Province(data);
  });
  it("shortfall", () => {
    expect(noProducers.shortfall).equal(30);
  });
  it("profit", () => {
    expect(noProducers.profit).equal(0);
  });
});
```

- 숫자형이라면 0일때를 검사해본다.

```js
describe("province", () => {
  //..

  it("zero demand", () => {
    asia.demand = 0;
    expect(asia.shortfall).equal(-25);
    expect(asia.profit).equal(0);
  });
});
```

- 음수도 넣어보면 좋다.

```js
describe("province", () => {
  //..

  it("negative demand", () => {
    asia.demand = -1;
    expect(asia.shortfall).equal(-26);
    expected(asia.profit).equal(-10);
  });
});
```

- 여기서 한 가지 의문점이 들 수 있다. 수요가 음수일 때 수익이 음수가 나온다는 것이  
  이 프로그램을 사용하는 고객 관점에서 말이 되는 소리일까? 수요의 최솟값은 0이어야 하지 않나?  
  그래서 수요 setter에 전달된 인수가 음수라면 에러를 던지거나 무조건 0으로 설정하는 식으로  
  정상적인 경우와 다르게 처리해야하지 않을까?

- 위 의문들은 예리한 지적이다. 이처럼 경계를 확인하는 테스트를 작성해보면 프로그램에서 이런  
  특이 상황들을 어떻게 처리하는게 좋을 지 생각해볼 수 있다.

> 문제가 생길 가능성이 있는 경계 조건을 생각해보고 그 부분을 집중적으로 테스트하자.

- 이 프로그램의 setter들은 의미상 숫자를 입력받아야만 하지만 UI로부터 문자열을 취하고 있다.  
  그러다보니 필드가 아예 비어있을 수 있고, 이때도 의도한 대로 잘 처리하는지 반드시 테스트해야 한다.

```js
describe("province", () => {
  //..

  it("empty string demand", () => {
    asia.demand = "";
    expect(asia.shortfall).NaN;
    expect(asia.profit).NaN;
  });
});
```

- 위와 같이 의식적으로 프로그램을 망가뜨리는 방법을 모색하는 것 자체가  
  생산성과 재미를 끌어올려준다.

- 아래 테스트를 보자.

```js
describe("string for producers", () => {
  it("", () => {
    const data = {
      name: "String producers",
      producers: "",
      demand: 30,
      price: 20,
    };
    const province = new Province(data);
    expect(province.shortfall).equal(0);
  });
});
```

- 위 테스트는 단순히 생산 부족분이 0이 아니라는 실패 메시지를 출력하는 대신,  
  아래와 같이 출력한다.

```
1) string for producers :
	TypeError: doc.producers.forEach is not a function
	at new Province
	at Context.<anonymous>
```

- Mocha는 이 경우를 실패 처리한다. 하지만 mocha와 달리 에러와 실패를 구분하는  
  테스트 프레임워크도 많다. _실패(failure)_ 란 검증 단계에서 실제 값이 예상 범위를  
  벗어났다는 뜻이다. _에러(Error)_ 는 성격이 다르다. 검증보다 앞선 과정(여기서는 설정 단계)에서  
  발생한 예외 상황을 말한다. 코드 작성자가 이 상황을 미처 예상하지 못한 것이고, 그래서 JS 개발자라면  
  지긋지긋하게 보는 오류 메시지인 "... is not a function"이 출력된 것이다.

- 프로그램은 이 상황에 어떻게 대응해야 할까? 에러 상황을 지금보다 더 잘 처리하도록 코드를  
  추가하는 방법도 있다. 더 의미 있는 오류 메시지를 출력할 수도 있고, 그냥 로그 메시지만 남기고  
  producers를 빈 배열로 설정할 수도 있다. 물론 지금 상태로 남겨둘 합당한 이유가 있을 수도 있다.  
  예를 들어 입력 객체를 신뢰할 수 있는 곳에서 만들어주는 경우가 여기에 속한다.  
  같은 코드베이스의 모듈 사이에 유효성 검사 코드가 너무 많으면 다른 곳에서 확인할 걸 중복으로  
  검증하여 오히려 문제가 될 수 있다. 반면, JSON으로 인코딩된 요청처럼 외부에서 들어온 입력 객체는  
  유효한지 확인해봐야 하므로 테스트를 작성한다. 어떤 경우든 경계 조건을 검사하는 테스트를 작성하다 보면  
  이런 고민들을 하게 된다.

- 리팩토링하기 전이라면 이런 테스트를 작성하지 말자. 리팩토링은 겉보기 동작에 영향을 주지 않아야 하며,  
  이런 오류는 겉보기 동작에 해당하지 않는다. 따라서 경계 조건에 대응하는 동작이 리팩토링 때문에  
  변하는지는 신경 쓸 필요 없다.

> 이런 오류로 인해 프로그램 내부에 잘못된 데이터가 흘러서 디버깅하기 어려운 문제가 발생한다면  
> **assertion 추가하기**를 적용해서 오류가 최대한 빨리 드러나게 하자. assertion도 일종의  
> 테스트로 볼 수 있으니 테스트 코드를 따로 작성할 필요는 없다.

- 그렇다면 테스트를 어느 수준까지 해야할까? 아무리 테스트해도 버그 없는 완벽한 프로그램을 만들 수는  
  없다는 말은 많다. 맞는 말이지만, 테스트가 프로그래밍 속도를 높여준다는 사실에는 변함이 없다.  
  테스트에도 *수확 체감 법칙*이 적용된다. 또, 테스트를 너무 많이 작성하다 보면 오히려  
  의욕이 떨어져 나중에는 하나도 작성하지 않게 될 위험도 있다. 따라서 **위험한 부분에 집중**하는게 좋다.  
  코드에서 처리 과정이 복잡한 부분을 찾아보자. 함수에서 오류가 생길만한 부분을 찾아보자.  
  테스트가 모든 버그를 걸러주지는 못할지라도, 안심하고 리팩토링할 수 있는 보호막은  
  되어준다. 그리고 리팩토링을 하면서 프로그램을 더욱 깊이 이해하게 되어 더 많은 버그를  
  찾게 된다.

> 어짜피 모든 버그를 잡아낼 수는 없다고 생각하여 테스트를 작성하지 않는다면, 대다수의 버그를  
> 잡을 수 있는 기회를 날리는 셈이다.

<hr/>

<h2>끝나지 않은 여정</h2>

- 테스트는 리팩토링에 반드시 필요한 토대일 뿐만 아니라, 그 자체로도 프로그래밍에  
  중요한 역할을 한다. 예전에는 테스트를 별도의 조직에 맡겼지만, 이제는 뛰어난 소프트웨어 개발자라면  
  최우선으로 관심을 가지는 주제로 떠오르고 있다. 테스트의 용이성을 아키텍쳐 평가 기준으로  
  활용하는 사례도 많다.

- 여기서 본 모든 테스트는 단위 테스트(Unit test)에 해당한다. 단위 테스트란 코드의 작은 영역만을  
  대상으로 빠르게 실행되도록 설계된 테스트다. 단위 테스트는 자가 테스트 코드의 핵심이자, 자가 테스트  
  시스템은 대부분 단위 테스트가 차지한다. 물론 컴포넌트 사이의 상호작용에 집중하는 테스트나,  
  소프트웨어의 다양한 계층의 연동을 검사하는 테스트, 성능 문제를 다루는 테스트 등 다양한 유형의  
  테스트가 있다.

- Test Suite도 제품 코드에 못지 않게 지속해서 보강해야 한다. 기존 테스트가 충분히 명확한지,  
  테스트 과정을 더 이해하기 쉽게 리팩토링할 수는 없는지, 제대로 검사하는지 등을 확인한다.  
  **버그를 발견하는 즉시 발견한 버그를 명확히 잡아내는 테스트부터 작성하는 습관을 들이자.**  
  그러면 해당 버그가 다시 나타나지 않는지 확인할 수 있다. 또한 그 버그와 테스트를 계기로 test suite에  
  또다른 구멍은 없는지까지 살펴보자.

> **버그 리포트를 받으면 가장 먼저 그 버그를 드러내는 단위 테스트부터 작성하자.**

- _어느 정도 하면 충분히 테스트 했다고 볼 수 있을까?_ 라는 질문에 대한 명확한 기준은 없다.  
  Test Coverage를 기준으로 삼는 사람도 있지만, Test Coverage 분석은 코드에서  
  테스트하지 않은 영역을 찾는 데만 도움될 뿐, Test Suite의 품질과는 크게 상관 없다.

- Test Suite가 충분한지를 평가하는 기준 또한 주관적이다.  
  가령 _누군가 결함을 심으면 테스트가 발견할 수 있다는 믿음_ 을 기준으로 할 수도 있다.  
  이런 기준은 객관적으로 측정할 수 없어서 헛된 믿음일 뿐인지 알 도리가 없다.  
  하지만 자가 테스트 코드의 목적은 이 믿음을 갖게 해주는 것이다. 리팩토링 후 테스트 결과가  
  모두 통과인 것만 보고도 리팩토링 과정에서 생겨난 버그가 하나도 없다고 확신할 수 있다면  
  충분히 좋은 Test Suite라 할 수 있다.

- 테스트를 너무 많이 작성할 가능성도 있다. 제품 코드보다 테스트 코드를 수정하는 데 시간이  
  더 걸린다면, 그리고 테스트 때문에 개발 속도가 느려진다고 생각되면 테스트를 과하게 작성한  
  건 아닌지 의심해보자. 하지만 너무 많은 경우보다는 너무 적은 경우가 훨씬 많다.

<hr/>
