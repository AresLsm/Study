# 문자열과 정규식 다루기

- 코틀린 문자열은 Java 문자열과 같다. 코틀린 코드가 만들어낸 문자열을 아무 Java 메소드에  
  넘겨도 되며, Java 코드에서 받은 문자열을 아무 코틀린 표준 라이브러리 함수에 전달해도 전혀  
  문제 없다. 특별한 변환도 필요 없고, Java 문자열을 감싸는 별도의 wrapper도 생기지 않는다.

- 코틀린은 다양한 확장 함수를 제공함으로써 표준 Java 문자열을 더 쉽게 다루게 해준다. 또한,  
  혼동이 야기될 수 있는 일부 메소드에 대해 더 명확히 코틀린 확장 함수를 제공함으로써 프로그래머의  
  실수를 줄여준다. Java와 코틀린 API의 차이를 알아보기 위한 첫 번째 예시로 문자열을 구분  
  문자열에 따라 나누는 작업을 코틀린에서 어떻게 처리하는지 보자.

## 문자열 나누기

- Java 개발자라면 `String#split()`에 익숙할 것이다. 모든 Java 개발자가 그렇진 않지만, 이에  
  불만을 표시하는 사람도 있다. 예를 들어 `"12.345-6.A".split(".")`의 결과가 `[12, 345-6, A]`이라고  
  생각하는 실수를 저지르는 개발자가 많다. 하지만 Java의 `split()`은 빈 배열을 반환한다. `split()`의  
  구분 문자열은 실제로는 정규식(regular expression)이기 때문이다. 따라서 마침표(`.`)는 모든 문자를  
  나타내는 정규식으로 해석된다.

- 코틀린에서는 Java의 `split()` 대신 여러 가지 다른 조합의 파라미터를 받는 `split()`  
  확장함수를 제공함으로써 혼동을 야기하는 메소드를 감춘다. 정규식을 파라미터로 받는 함수는 `String`이  
  아닌 `Regex` 타입의 값을 받는다. 따라서 코틀린에서는 `split()`에 전달하는 값의 타입에 따라  
  정규식이나 일반 텍스트 중 어느 것으로 문자열을 분리하는지 쉽게 알 수 있다.

- 아래 코드는 마침표나 `-`로 문자열을 분리하는 예시를 보여준다.

```kt
println("12.345-6.A".split("\\.|-".toRegex()))
// (12, 345, 6, A)
```

- 코틀린 정규식 문법은 Java와 똑같다. 위의 패턴은 마침표나 대시에 매치된다. 정규식을 처리하는  
  API는 표준 Java 라이브러리 API와 비슷하지만, 조금 더 코틀린답게 변경되었다. 예를 들어  
  코틀린에서는 `toRegex()` 확장함수를 사용해 문자열을 정규식으로 변환할 수 있다.

- 이런 간단한 경우에는 꼭 정규식을 쓸 필요가 없다. `split()` 확장 함수를 오버로딩한 버전 중에는  
  구분 문자열을 하나 이상 인자로 받는 함수가 있다.

```kt
println("12.345-6.A".split(".", "-"))
// (12, 345, 6, A)
```

- 위 경우에는 `split(".", "-")` 대신 `split('.', '-')`처럼 문자열 대신 문자를 인자로  
  넘겨도 마찬가지 결과를 볼 수 있다. 이렇게 여러 문자를 받을 수 있는 코틀린 확장 함수는 Java에  
  있는 단 하나의 문자만 받을 수 있는 메소드를 대신한다.

<hr/>
