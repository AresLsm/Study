<h1>Middleware 적용하기</h1>

- Middleware가 하는 역할과 이를 NestJS에서 적용하는 방법은 아래 링크에 있다.  
  <a href="https://github.com/sangwoo-98/Study/blob/master/NestJS/Middleware%20%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0.md">링크</a>

- 이 프로젝트에서 Middleware의 역할은 요청 객체의 `Authorization Header`에서  
  accessToken을 받아와서 해당 accessToken이 올바른 토큰인지를 검사하는 작업을 해야한다.

<h2>Middleware 생성하기</h2>

- 이 프로젝트에서는 `Bearer` Schema를 사용한다. 즉, 만약 accessToken이 ABCD라면  
  `Authorization Header`에는 `Bearer ABCD`가 올 것이다.
- 또한 만약 Bearer Schema가 맞다면 컨트롤러에서 요청 객체에 접근해서 accessToken을  
  가져올 수 있도록 할 것이다. 즉, `req.accessToken`처럼 accessToken에 접근하게 하고  
  싶다는 것이다. 하지만 req 객체에는 accessToken 필드가 없기에 `Request`객체를  
  상속하는 인터페이스를 직접 만들어 사용해야 한다.

- 우선 인터페이스를 생성하자.

```ts
// user-request.ts

export default interface IUserRequest extends Request {
  accessToken: string;
}
```

- `IUserRequest` 인터페이스는 `Request` 객체를 상속하기 때문에 기존에 있는  
  `Request`객체의 필드들을 모두 가지며, 추가적으로 accessToken이라는 필드를 가진다.

- 이제 Middleware를 생성해보자.

```ts
@Injectable()
export class UserAuthMiddleware implements NestMiddleware {
  private checkSchemaAndReturnToken(header: string): string {
    const splitTemp = header.split(" ");
    if (splitTemp[0] !== "Bearer") {
      throw new UnauthorizedException(
        "Authorization Header Schema must be Bearer."
      );
    } else {
      return splitTemp[1];
    }
  }
  use(req: IUserRequest, res: Response, next: NextFunction) {
    const authorizationHeader = req.headers["authorization"];
    if (!!authorizationHeader) {
      const token = this.checkSchemaAndReturnToken(authorizationHeader);
      req.accessToken = token;
      next();
    } else throw new BadRequestException("Authorization Header is missing.");
  }
}
```

- 우선 `checkSchemaAndReturnToken`은 Authorization Header의 Schema를 체크한 후  
  Bearer Schema가 맞다면 토큰을 추출하여 반환하고, 아니라면 `UnAuthorizedException`을 던진다.

- 다음으로 Middleware가 수행할 작업을 정의하는 `use()` 메소드 내에서는 `checkSchemaAndReturnToken()`을  
 호출하여 Schema에 대한 검증과 토큰을 받아오고, `req.accessToken`에 추출된 토큰을 전달한다.  
 여기서 `use()`의 req 객체의 타입을 `IUserRequest`로 지정했다는 것을 유의하자.
<hr/>
