# Coroutine Context and Dispatchers

- Coroutine은 항상 Kotlin의 기본 라이브러리에 정의되어 있는 `CoroutineContext` 중 하나의  
  컨텍스트 내에서 실행된다. Coroutine Context는 다양한 원소들의 집합이다.  
  가장 메인이 되는 원소는 Coroutine의 `Job`과 그 `Job`의 dispatcher이다.

<h2>Dispatchers and threads</h2>

- Coroutine Context는 해당 coroutine이 작업을 수행하기 위해 어떤 thread를 사용할지를  
  결정하는 *Coroutine Dispatcher*를 포함한다. Coroutine Dispatcher는 Coroutine의  
  작업을 특정 thread에서 실행되도록 지정할 수 있고, thread pool로 thread를 반납처리할 수도 있다.

- `launch {..}`와 `async {..}`와 같은 모든 Coroutine Builder들은 선택적 매개변수인  
  `CoroutineContext`를 받는다. 이 매개변수는 새로운 coroutine의 dispatcher를 명시적으로 지정해준다.

```kt
fun main(): Unit = runBlocking {
    doSomething()
}

suspend fun doSomething() = coroutineScope {
    launch {
        println("main runBlocking      : I'm working in thread ${Thread.currentThread().name}")
    }
    launch(Dispatchers.Unconfined) {
        println("Unconfined            : I'm working in thread ${Thread.currentThread().name}")
    }
    launch(Dispatchers.Default) {
        println("Default               : I'm working in thread ${Thread.currentThread().name}")
    }
    launch(newSingleThreadContext("MyOwnThread")) {
        println("newSingleThreadContext: I'm working in thread ${Thread.currentThread().name}")
    }
}

/*
Ouptut:
Unconfined            : I'm working in thread main
Default               : I'm working in thread DefaultDispatcher-worker-2
newSingleThreadContext: I'm working in thread MyOwnThread
main runBlocking      : I'm working in thread main
*/
```

- 만약 `launch {..}`가 파라미터 없이 선언되었다면, 해당 함수가 정의된 coroutineScope으로부터  
  context(곧 dispatcher)를 물려받는다. 위 결과로, context가 지정되지 않은 첫 번째 `launch {..}`  
  블록은 호출되는 부분이 `main()` 함수여서, main thread에서 실행된다.

- `Dispatchers.Unconfined`가 지정된 부분 또한 main thread에서 실행되지만, 사실 다른 메커니즘으로  
  동작한다. 아래에서 설명한다.

- `Dispatchers.Default`는 해당 coroutine builder가 있는 coroutineScope내에 명시적으로  
  다른 dispatcher가 선언되지 않을 때 기본값으로 사용되는 dispatcher이다. 이 dispatcher는  
  JVM의 thread pool에서 thread를 가져와 사용하도록 한다.

- `newSingleThreadContext`는 coroutine이 수행되기 위한 thread를 생성한다.  
  하나의 작업을 하기 위해 thread를 사용하는 것은 굉정히 비용이 큰 비용을 사용하는 것이다.  
  실제 애플리케이션에서는 더 이상 사용되지 않을 때 `close()`를 사용해서 thread를 꼭 release해야 한다.  
  아니면 최상단 변수에 저장하여 애플리케이션 내부에서 사용하도록 할 수도 있다.

<hr/>

<h2>Unconfined vs confined Dispatcher</h2>

- `Dispatchers.Unconfined`는 해당 Coroutine Scope를 호출하는 thread에서 coroutine이 작업을  
  수행하도록 하는 coroutine dispatcher인데, suspend될 때 이 작업을 수행한다. Suspend가 된 후에는  
  coroutine의 작업을 오로지 **해당 coroutine이 suspend되도록 한 suspending function의 thread**에서  
  진행하게 된다. Unconfined Dispatcher는 CPU time을 소모하지 않거나 특정 thread에 국한되어 공용 데이터를  
  갱신하지 않는 coroutine들에 대해 유용하게 사용할 수 있다.

- 또한, 기본적으로 dispatcher는 해당 coroutine이 있는 외부의 coroutineScope에서 상속된다.  
  예를 들어, `runBlocking` 내부의 coroutine들의 기본 dispatcher는 이 coroutine의 작업을 호출한  
  thread에 국한되어 있다. 따라서 상속하는 과정은 해당 thread 내에서만 작업을 국한시킬 수 있어서  
  예측 가능한 FIFO 형식의 스케쥴링에 유리하다.

```kt
fun main(): Unit = runBlocking {
    doSomething()
}

suspend fun doSomething() = coroutineScope {
    launch(Dispatchers.Unconfined) { // not confined -- will work with main thread
        println("Unconfined      : I'm working in thread ${Thread.currentThread().name}")
        delay(500)
        println("Unconfined      : After delay in thread ${Thread.currentThread().name}")
    }
    launch { // context of the parent, main runBlocking coroutine
        println("main runBlocking: I'm working in thread ${Thread.currentThread().name}")
        delay(1000)
        println("main runBlocking: After delay in thread ${Thread.currentThread().name}")
    }
}

/*
Output:
Unconfined      : I'm working in thread main
main runBlocking: I'm working in thread main
Unconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor
main runBlocking: After delay in thread main
 */
```

- 우선 `Dispatchers.Unconfined`가 지정된 첫 번째 `launch {..}`를 살펴보자.  
  위에서 말했듯이, `Dispatchers.Unconfined`는 첫 번째 suspension point를 만나기 전까지  
  해당 작업을 호출한 thread에서 작업을 한다고 했다. 첫 번째 `launch {..}`는 `doSomething()`이라는  
  함수 내에 있고, 이 함수는 main함수에서 호출되기에 처음에는 `main` thread에서 실행된다.  
  그 후, 첫 번째 suspension point를 `delay(500)`을 통해 만난다. 따라서 그 후에 찍힌 결과에서  
  다른 thread에서 작업을 수행한 것을 볼 수 있다.

- 그 다음으로 두 번째 `launch {..}`를 보자. 당연히 `launch`에 아무런 dispatcher도 지정되어 있지  
  않기에 해당 coroutine의 작업을 호출한 thread(main)에서 작업이 진행된 것이다.

> Unconfined dispatcher를 사용하는 것은 coroutine을 사용하며 생각지 못한 부작용을 발생시키는 경우와 같이  
>  정말 특수한 상황이 아니면 사용하는 것이 절대 권장되지 않는다.

<hr/>

<h2>Debugging</h2>

- Coroutine의 현재 상태와 어떤 thread에서 실행되고 있는지는 기본적으로 IDE에서 모두 디버깅할 수 있다.  
  (`kotlin-coroutines-core v1.3.8` 이상 부터)

- IDE가 아니라, logging을 통해서도 디버깅 할 수 있다.  
  log file에 thread의 이름과 특정 문구를 로깅할 수 있다.  
  Coroutine을 디버깅할 때, 단순히 thread명만 가져오는건 큰 도움이 되지 않기에 `kotlinx.coroutines`는  
  다양한 logging 방법을 지원한다.

- 아래 코드를 `-Dkotlinx.coroutines.debug` 라는 JVM Option과 함께 실행해보자.

```kt
fun log(msg: String) = println("[${Thread.currentThread().name}] $msg")

fun main() = runBlocking<Unit> {
    val a = async {
        log("I'm computing a piece of the answer.")
        7
    }

    val b = async {
        log("I'm computing another piece of the answer.")
        6
    }

    log("The answer is ${a.await() * b.await()}")
}

/*
Output:
[main @coroutine#2] I'm computing a piece of the answer.
[main @coroutine#3] I'm computing another piece of the answer.
[main @coroutine#1] The answer is 42
 */
```

- 위 코드의 `main()` 함수에는 3개의 다른 coroutine들이 있다.  
  main coroutine은 `runBlocking {..}` 내부에서 수행되는 가장 아래쪽 coroutine이고,  
  나머지 2개는 각각 deffered value를 반환하는 a 와 b 이다.

* 직접 작성한 `log()` 함수의 내용대로라면, 출력에는 `[]` 내에 thread명만 있어아 햐는데, 실제로는  
 해당 coroutine의 식별자와 함께 thread명이 출력되었다. 이 식별자는 debugging 옵션이 주어졌을 때  
 자동적으로 할당된다. 개발자는 이 식별자를 통해 coroutine을 식별할 수 있다.
<hr/>

<h2>Jumping Between Threads</h2>

- 아래 코드를 `-Dkotlinx.coroutines.debug` JVM 옵션과 함께 실행해보자.

```kt
fun log(msg: String) = println("[${Thread.currentThread().name}] $msg")

fun main() = runBlocking<Unit> {
    newSingleThreadContext("Ctx1").use { ctx1 ->
        newSingleThreadContext("Ctx2").use { ctx2 ->
            runBlocking(ctx1) {
                log("Started in Ctx1")
                withContext(ctx2) {
                    log("Working in Ctx2")
                }
                log("Back to Ctx1")
            }
        }
    }
}

/*
Output:
[Ctx1 @coroutine#2] Started in Ctx1
[Ctx2 @coroutine#2] Working in Ctx2
[Ctx1 @coroutine#2] Back to Ctx1
 */
```

- 우선 결과를 보면, 위 코드에서 실행된 coroutine은 모두 동일한 식별자를 갖고 있으므로 동일한 coroutine이다.

* 위 코드에는 새로운 것들이 포함되어 있는데, 첫 번째는 `runBlocking {..}`에 명시적으로 context를 지정해서  
  해당 coroutine이 그 context 내에서 실행되도록 하는 것이고, 두 번째는 `withContext()` 함수를 사용하여  
  coroutine이 다른 context에서 실행되도록 하는 것이다.

* 참고로 kotlin 기본 라이브러리에서 제공하는 `use()`를 사용하여 `newSingleThreadContext()`로 만들어진  
  thread가 더 이상 사용되지 않을 때 자동으로 해제되도록 했다.

<hr/>

<h2>Job in the context</h2>

- Coroutine의 `Job`은 해당 context의 일부로, `coroutineContext[Job]` 표현식을 통해 가져올 수 있다.

```kt
fun main() = runBlocking<Unit> {
   println("My job is ${coroutineContext[Job]}")
}

/*
Output:
My job is "coroutine#1":BlockingCoroutine{Active}@3fa77460
*/
```

- 참고로 이전에 해당 coroutineScope내의 coroutine의 작업을 중단하기 위해 coroutine이 작업 중인지를  
  판단하는 `isActive`는 아래의 식을 축약한 것이다.

```kt
coroutineContext[Job]?.isActive == true
```

<hr/>

<h2>Children of a coroutine</h2>

- 새로운 coroutine(B)가 다른 coroutine(A)의 coroutineScope 내에서 생성되었다고 해보자.  
  이 상황에서 coroutine(B)는 `CoroutineScope.coroutineContext`를 통해 coroutine(A)의  
  context를 물려받으며, coroutine(B)의 `Job`은 부모 coroutine(A)의 `Job`의 *자식*이 된다.  
  만약 부모 coroutine(A)이 중단되었다면, 모든 자식 coroutine들의 작업 또한 중지된다.

- 위의 기본적인 상속 관계는 아래의 2개 방법으로 오버라이딩이 가능하다.

  - 자식 coroutine을 생성할 때 다른 coroutineScope(ex. `GlobalScope.launch`)이 명시적으로 지정된 경우,  
    부모 scope의 coroutine으로부터 `Job`을 상속받지 않는다.
  - 새로운 coroutine을 위해 다른 `Job`이 전달된 경우, 부모 scope의 `Job`을 오버라이딩 한다.  
    (아래 코드)

```kt
fun main() = runBlocking<Unit> {
    // 새로운 coroutine을 실행한다.
    // request가 들어오는 것처럼 만들어 본다.
    val request = launch {
        // 2개의 다른 Job을 생성한다.
        // 바로 아래 Job은 명시적으로 새로 만들어줬다.
        launch(Job()) {
            println("job1: 독립적으로 수행된다.")
            delay(1000)
            println("job1: 부모 coroutine인 request가 cancel되도 난 수행된다.")
        }
        // 아래 Job은 명시적으로 지정된 것이 없으므로 부모 coroutine의 job을 상속한다.
        launch {
            delay(100)
            println("job2: 나는 부모 coroutine인 request의 자식이다.")
            delay(1000)
            println("job2: 부모 coroutine이 cancel되면 이 줄은 출력되지 않는다.")
        }
    }
    delay(500)
    request.cancel()
    delay(1000)
    println("main: Who has survived request cancellation?")
}

/*
Output:
job1: 독립적으로 수행된다.
job2: 나는 부모 coroutine인 request의 자식이다.
job1: 부모 coroutine인 request가 cancel되도 난 수행된다.
main: Who has survived request cancellation?
*/
```

<hr/>

<h2>Parental responsibilities</h2>

- 부모 coroutine은 항상 자식 coroutine들이 모든 작업을 끝날 때까지 기다린다.  
  이때, 자식 coroutine이 실행되는 것을 명시적으로 파악하지 않아도 되며 자식들이 모든 작업을  
  끝낼 때까지 명시적으로 `Job.join()`을 호출할 필요가 없다.

```kt
fun main() = runBlocking<Unit> {
    // 새로운 coroutine 실행
    val request = launch {
        repeat(3) { i ->
            launch {
                // 3번 돌며 각각 200ms, 400ms, 600ms씩 suspend한다.
                delay((i + 1) * 200L)
                println("Coroutine $i 작업 완료")
            }
        }
        println("request: 나의 작업은 모두 끝났고, 명시적으로 자식들의 작업이 끝났는지 검증하지 않았다.")
    }
    // request의 자식을 포함한 모든 작업이 끝나길 기다린다.
    request.join()
    println("request의 작업이 모두 끝났다.")
}

/*
Output:
request: 나의 작업은 모두 끝났고, 명시적으로 자식들의 작업이 끝났는지 검증하지 않았다.
Coroutine 0 작업 완료
Coroutine 1 작업 완료
Coroutine 2 작업 완료
request의 작업이 모두 끝났다.
*/
```

<hr/>
