<h1>고급 스타일링 기법</h1>

<h2>플랫폼별 크기와 스타일</h2>

* `Platform.select`를 통해 iOS 또는 안드로이드에서만 사용할 수 있는 폰트를 선택할 수 있다.
```js
// 예제
const styles = StyleSheet.create({
    centeredText: {
        textAlign: 'center',
        margin: 10,
        fontSize: 24,
        ...Platform.select({
            ios: {
                fontFamily: 'American Typewriter'
            },
            android: {
                fontFamily: 'monospace'
            }
        })
    }
})
```
* 위와 같이 항상 __두 개의 다른 플랫폼에서 동작하는 앱을 개발하고 있다는 점__ 을 염두해야 한다.   
  이전까지 `width`를 지정할 때 값을 `px` 단위로 지정한 적이 없다. 이 이유는 크기의 개념이 iOS와 안드로이드에서 다르기 때문이다.

<h3>픽셀(px), 포인트(pt), dp</h3>

* `픽셀`은 디스플레이에 표현되는 프로그래밍할 수 있는 가장 작은 단위의 색상이며, `RGB`로 구성된다. 각 RGB 값의 농도를   
  조절해서 픽셀은 사용자가 보는 생상을 만들어낸다. 픽셀 단위는 화면의 크기나 1인치당 도트의 수와 같이 물리적인 단위로   
  수치가 정해지지 않는다면 아무런 의미를 가지지 못한다.
* `화면 크기`는 한 모서리부터 대각선 모서리까지의 대각선 길이를 나타낸다.
* `해상도`는 디스플레이에 표시되는 픽셀 수 이며, 보통 디바이스의 높이와 폭에 표현되는 픽셀 수를 의미한다.

* 화면 크기와 해상도를 알아야 픽셀 밀도인 1인치당 픽셀 수(PPI)를 계산할 수 있다. DPI는 1인치당 도트의 수 이며, DPI는   
  인쇄에서 사용되는 용어이다. 따라서 화면에 대해 언급할 때 DPI를 보게 된다면 실제로 이는 PPI를 의미한 것이다.

* iOS나 안드로이드는 디바이스의 화면에 내용물들을 렌더링할 때 실제 물리 단위를 사용하지 않는다.   
  iOS는 `Point`라는 추상적인 단위를 사용하며, 안드로이드는 이와 유사하게 추상적인 단위인 `DP`를 사용한다.

* 예를 들어 아이폰4는 전작과 동일한 화면 크기로 출시되었지만, 기존은 320X480의 해상도인 반면, 아이폰4는 640X960의 해상도로,   
  기존의 앱을 1:1비율로 아이폰4에서 렌더링한다면, 크기가 1/4로 축소돼 보였을 것이다. 이러한 문제를 해결하기 위해 애플은   
  `Point-PT`라는 논리적인 개념을 도입했다. `Point`는 디바이스의 해상도와 상관없이 확대나 축소될 수 있는 거리의 단위이다.

* React Native에서 스타일을 정의할 때, 픽셀의 논리적인 개념을 이용한다. 즉, iOS에서는 PT를, 안드로이드에서는 DP를 사용한다.   
  Native 언어를 사용하여 앱을 개발할 때에는 간혹 논리적인 픽셀 단위의 화면에 화면 크기(scale)를 곱해서 디바이스 픽셀로   
  작업할 필요도 있다.

<h3>shadowPropTypesIOS와 elevation 속성으로 음영 넣기</h3>

* iOS와 안드로이드 모두 `Text` 컴포넌트에 음영을 넣는 기능을 지원하지만, `View` 컴포넌트에 대해서는 iOS와 안드로이드에서   
  공통으로 사용할 수 있는 스타일 속성이 없다. iOS는 `shadowPropTypesIOS` 스타일 속성을 이용하고, 안드로이드는 `elevation`   
  속성으로 음영 효과를 낼 수 있다. `shadowPropTypesIOS`는 컴포넌트의 z-order에 영향을 주지 않으며, `elevation`은 z-order에   
  영향을 준다.

* `shadowPropTypesIOS` 스타일 속성을 이용하여 `View` 컴포넌트에 음영을 넣는 방법은 아래와 같다.
  * `shadowOpacity`속성값을 지정하지 않으면 음영이 나타나지 않는다. (1 : 완전히 불투명, 0.2 : 좀 더 투명하게 보임)
  * `shadowOffset`값은 폭과 높이로 표시하지만, 음영을 x와 y방향으로 이동한다고 생각해도 무방하며, 음수값을 지정할 수 있다.
  * `shadowRadius` : 음영의 모서리를 blur 처리하여 표현하여 좀 더 분산되어 보이게 한다.

* 안드로이드에서 iOS와 동일한 음영 효과를 낼 수는 없지만, 안드로이드의 `elevation` 스타일 속성을 이용하여 컴포넌트의   
  z-order에 영향을 줄 수는 있다. 두 개 이상의 컴포넌트가 같은 공간에 있을 때, 전면에 나올 컴포넌트에 더 높은 `elevation`값,   
  즉 더 높은 z-index 값을 지정해서 약간의 음영 효과를 낼 수 있다. 하지만 iOS에서와 같이 두드러진 음영 효과를 기대할 순 없다.

```js
const styles = StyleSheet.create({
    
    //..

    ,
    cardImageContainer: {
        paddingTop: 15,
        Platform.select({
            ios: {
                shadowColor: 'black',
                shadowOffset: {
                    height: 10
                },
                shadowOpacity: 1
            },
            android: {
                borderWidth: 3,
                borderColor: 'black',
                elevation: 15
            }
        })
    }
})
```
* 위 코드는 `Platform.select`를 사용하여 플랫폼에 따라 컴포넌트에 다른 스타일을 적용하도록 하고 있다.
<hr/>

<h2>컴포넌트의 이동, 회전, 크기 변경, 기울이기</h2>

