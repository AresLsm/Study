# 비동기 메시징 패턴 응용 통신

- 메시징은 서비스가 메시지를 서로 비동기적으로 주고 받는 통신 방식이다.  
  메시징 기반 애플리케이션은 보통 서비스 간 중개 역할을 하는 메시지 브로커를 사용하지만  
  서비스가 직접 서로 통신하는 Brokerless 아키텍쳐도 있다. 클라이언트가 서비스에 메시지를 보내  
  요청을 하면, 요청을 받은 서비스 인스턴스가 응답 가능할 경우 별도의 메시지를 클라이언트에게 응답한다.  
  비동기 통신을 하기 때문에 클라이언트가 응답을 기다리며 블로킹하지 않는다.  
  클라이언트는 응답을 바로 받지 못할 것이라는 전제 하에 작성한다.

<h2>메시징 개요</h2>

- 메시징 모델에 따르면 메시지는 메시지 채널(Message Channel)을 통해 교환된다.  
  송신자(애플리케이션 또는 서비스)가 채널에 메시지를 쓰면 수신자(애플리케이션 또는 서비스)는 채널에서  
  메시지를 읽는다. 우선 메시지와 채널이 각각 무엇인지 살펴보자

<h3>메시지</h3>

- 메시지는 Header와 Body로 구성된다. Header는 송신된 데이터에 대한 메타데이터에 해당하는 키/값들로  
  구성된다. 그 밖에도 송신자 또는 메시징 인프라에서 생성된 메시지 ID, 응답이 출력될 메시지 채널을 가리키는  
  반환 주소(Optional) header가 있다. 메시지 Body는 실제로 송신할 텍스트 또는 이진 포맷의 데이터이다.

- 메시지의 종류는 다양하다.

  - **문서(Document)** : 데이터만 포함한 제네릭한 메시지(ex. 커맨드에 대한 응답).  
    메시지를 어떻게 해석할지는 수신자가 결정한다.
  - **커맨드(Command)** : RPC 요청과 동등한 메시지. 호출할 작업과 전달할 매개변수가 지정되어 있다.
  - **이벤트(Event)** : 송신자에게 어떤 사건이 발생했음을 알리는 메시지. 이벤트는 대부분  
    `Order`, `Customer`와 같은 도메인 객체의 변화를 나타내는 도메인 이벤트이다.

<h3>메시지 채널</h3>

- 메시지는 채널을 통해 교환된다. 송신자의 비즈니스 로직은 하부 통신 메커니즘을 캡슐화한 송신 포트 인터페이스를  
  호출한다. 이 인터페이스는 메시지 송신자 어댑터 클래스로 구현되며, 이 클래스는 메시징 인프라를 추상한 메시지  
  채널을 통해 수신자에게 메시지를 전달한다. 수신자의 메시지 handler 어댑터 클래스는 메시지를 처리하기 위해  
  호출되고, 이 클래스는 Consumer 비즈니스 로직으로 구현된 수신 포트 인터페이스를 호출한다.  
  송신자가 채널에 보낼 수 있는 메시지와 수신자가 채널에서 받을 수 있는 메시지의 개수는 무제한이다.

- 채널은 두 종류가 있다.

  - **점대점(Point-To-Point)채널** : 채널을 읽는 consumer 중 딱 하나만 지정하여 메시지를 전달한다.  
    앞서 본 일대일 상호 작용 스타일의 서비스가 이 채널을 사용한다.(ex. 커맨드 메시지)
  - **발행-구독(Publish-Subscribe)채널** : 같은 채널을 바라보는 모든 Consumer에 메시지를 전달한다.  
    앞서 본 일대다 상호 작용 스타일의 서비스가 이 채널을 사용한다.

<hr/>

<h2>메시징 상호 작용 스타일 구현</h2>

- 메시징은 앞서 설명한 상호 작용 스타일을 모두 지원할 만큼 아주 유용하다.  
  스타일에 따라 메시징으로 직접 구현 가능한 것도 있고, 메시징을 토대로 구현해야 하는 것도 있다.

<h3>요청/응답 및 비동기 요청/응답</h3>

- 요청/응답, 비동기 요청/응답 방식 모두 클라이언트가 요청을 보내면 서비스는 응답을 반환한다.  
  요청/응답은 서비스가 즉시 응답할 것이라고 클라이언트가 기대하지만 비동기 요청/응답은 클라이언트가  
  그런 기대를 하지 않는다. 메시징은 원래 성격 자체가 비동기적이라서 비동기 요청/응답만 제공하지만  
  응답을 수신할 때까지 클라이언트를 블로킹할 수도 있다.

- 클라이언트/서비스는 한 쌍의 메시지를 주고받는 비동기 요청/응답 스타일로 상호 작용한다.  
  먼저 클라이언트는 수행할 작업과 매개변수가 담긴 커맨드 메시지를 서비스가 소유한 점대점 메시징 채널에  
  보낸다. 그러면 서비스는 요청을 처리한 후 그 결과가 담긴 응답 메시지를 클라이언트가 소유한  
  점대점 채널로 돌려보낸다.

- 클라이언트는 서비스가 어디로 응답 메시지를 보내야 하는지 알려주고 이렇게 받은 응답 메시지는 요청과  
  짝이 맞아야 한다. 다행이 이 두가지는 어렵지 않게 해결할 수 있다.  
  클라이언트는 `MessageId` 및 응답 채널이 header에 명시된 커맨드 메시지를 보내고,  
  서버는 `MessageId` 값이 동일한 `CorrelationId`가 포함된 응답 메시지를 지정된 응답 채널에 쓰면 된다.  
  클라이언트는 이 `CorrelationId`를 이용하여 응답 메시지와 요청을 맞춰볼 수 있다.

- 본래 메시징으로 통신하는 클라이언트/서비스 간 상호 작용은 비동기적이다.  
  이론적으로 클라이언트가 응답을 수신할 때까지 블로킹할 수는 있지만. 실제로 클라이언트는 응답을  
  비동기 처리하고 클라이언트 인스턴스 중 하나가 응답을 처리한다.

<h3>단방향 알림</h3>

- 단방향 알림(One-way notification)은 비동기 메시징을 이용하여 직관적으로 구현할 수 있다.  
  서비스가 소유한 점대점 채널로 클라이언트가 커맨드 메시지를 보내면, 서비스는 이 채널을 구독해서  
  메시지를 처리하는 구조이다. 물론 단방향이므로 서비스는 응답을 반환하지 않는다.

<h3>발행/구독</h3>

- 메시징은 발행/구독 스타일의 상호 작용을 기본 지원한다. 클라이언트는 여러 consumer가 읽는  
  발행/구독 채널에 메시지를 발행하고, 서비스는 도메인 객체의 변경 사실을 알리는 도메인 이벤트를 발행한다.  
  이렇게 도메인 이벤트를 발행한 서비스는 해당 도메인 클래스의 이름을 딴 발행/구독 채널을 소유한다.  
  가령 주문 서비스는 `Order` 이벤트를 `Order` 채널에 발행하고, 배달 서비스는 `Delivery` 이벤트를  
  `Delivery` 채널에 발행한다. 서비스는 자신이 관심 있는 도메인 객체의 채널을 구독한다.

<h3>발행/비동기 응답</h3>

- 발행/비동기 응답 스타일은 발행/구독과 요청/응답의 엘리먼트를 조합한 고수준의 상호 작용 스타일이다.  
  클라이언트는 응답 채널 header가 명시된 메시지를 발행/구독 채널에 발행하고, consumer는 `CorrelationId`가  
  포함된 응답 메시지를 지정된 응답 채널에 쓴다. 클라이언트는 이 `CorrelationId`로 응답을 취합하여  
  응답 메시지와 요청을 맞추어본다.

- 비동기 API를 갖고 있는 애플리케이션 서비스는 지금까지 본 기법 중 적어도 하나는 응용한다.  
  비동기 API로 작업을 호출하는 서비스에는 요청용 메시지 채널이 있고, 이벤트를 발행하는 서비스는 이벤트 메시지 채널에  
  이벤트를 발행할 것이다.

<hr/>

<h2>메시징 기반 서비스의 API 명세 작성</h2>

- 서비스의 비동기 API 명세에는 메시지 채널과, 각 채널을 통해 교환되는 메시지 타입과 포맷을 명시하고,  
  메시지 포맷은 JSON, XML, Protocol Buffer 등 표준 포맷으로 기술해야 한다.  
  그러나 REST, Open API와 달리 채널 및 메시지 타입은 딱히 정해진 문서화 표준이 없으므로  
  자유롭게 기술하면 된다.

- 서비스 비동기 API는 클라이언트가 호출하는 작업과 서비스에 의해 발행되는 이벤트로 구성된다.  
  작업과 이벤트는 문서화하는 방법이 다르다.

<h3>비동기 작업 문서화</h3>

- 서비스 작업은 두 가지 상호 작용 스타일 중 하나로 호출할 수 있다.

  - 요청/비동기 응답 스타일 API: 서비스의 커맨드 메시지 채널, 서비스가 받는 커맨드 메시지의 타입과 포맷,  
    서비스가 반환하는 응답 메시지의 타입과 포맷으로 구성된다.
  - 단방향 알림 스타일 API: 서비스의 커맨드 메시지 채널, 서비스가 받는 커맨드 메시지의 타입과 포맷으로 구성된다.

- 서비스는 요청/비동기 응답, 단방향 알림 모두 동일한 요청 채널을 사용할 수 있다.

<h3>발행 이벤트 문서화</h3>

- 서비스는 발행/구독 스타일로도 이벤트를 발행할 수 있다.  
  이런 스타일의 API 명세는 이벤트 채널, 서비스가 채널에 발행하는 이벤트 메시지의 타입과 포맷으로 구성된다.

- 메시지, 메시징의 채널 모델은 서비스 비동기 API를 설계하는 좋은 수단이지만, 서비스를 구현하려면 메시징 기술을  
  선택하고 그 기술이 가진 기능으로 어떻게 설계할지 방향을 잡아야 한다.  
  메시징 기술을 하나씩 구체적으로 살펴보자.

<hr/>

<h2>메시지 브로커</h2>

- 메시징 기반의 애플리케이션은 대부분 메시지 브로커를 사용한다.  
  메시지 브로커는 서비스가 서로 통신할 수 있게 해주는 인프라 서비스이다.  
  물론 서비스가 서로 직접 통신하는 Brokerless 기반의 메시징 아키텍쳐도 있다.  
  제각기 장단점이 있지만, 일반적으로 브로커 기반의 아키텍쳐가 더 낫다.

<h3>브로커리스(Brokerless) 메시징</h3>

- Brokerless 아키텍쳐의 서비스는 메시지를 서로 직접 교환한다.  
  ZeroMQ는 잘 알려진 brokerless 메시징 기술이다. 그 자체가 명세이자, 여러 언어를  
  지원하는 라이브러리 세트이다. TCP, Unix형 Domain Socket, Multicast 등 다양한  
  전송 기술을 지원한다.

- Brokerless 아키텍쳐는 아래와 같은 장점들이 있다.

  - 송신자가 보낸 메시지가 브로커를 거쳐 수신자로 이동하는 것이 아니라, 송신자에서  
    수신자로 직접 전달되므로 네트워크 트래픽이 가볍고 지연 시간이 짧다.
  - 메시지 브로커가 성능 병목점이나 SPOF(Single Point Of Failure)가 될 일이 없다.
  - 메시지 브로커를 설정/관리할 필요가 없으므로 운영 복잡도가 낮다.

- 하지만 아래와 같은 중요한 단점도 있다.

  - 서비스가 서로의 위치를 알고 있어야 하므로 서비스 디스커버리 메커니즘 중  
    하나를 사용해야 한다.
  - 메시지 교환 시 송신자/수신자가 모두 실행 중이어야 하므로 가용성이 떨어진다.
  - 전달 보장(Guaranteed Delivery) 같은 메커니즘을 구현하기가 더 어렵다.

- 가용성 저하 및 서비스 디스커버리가 필요한 것은 사실 동기 요청/응답을 사용하는 방식도  
  별반 다르지 않다. 이런 한계 때문에 엔터프라이즈 애플리케이션은 대부분 메시지 브로커 기반의  
  아키텍쳐를 선호한다.

<h3>브로커 기반 메시징 개요</h3>

- 메시지 브로커는 모든 메시지가 지나가는 중간 지점이다. 송신자가 메시지 브로커에 메시지를 쓰면 메시지 브로커는  
  메시지를 수신자에게 전달한다. 메시지 브로커의 가장 큰 장점은 송신자가 consumer의 네트워크 위치를  
  몰라도 된다는 것이다. 또 consumer가 메시지를 처리할 수 있을 때까지 메시지 브로커에 메시지를  
  버퍼링할 수도 있다.

- 메시지 브로커 제품은 다양하다. 아래는 많이 쓰는 오픈 소스 메시지 브로커들이다.

  - ActiveMQ
  - RabbitMQ
  - Apache Kafka

- AWS Kinesis, AWS SQS 등 클라우드 기반의 메시징 서비스도 있다.

- 메시지 브로커를 선택할 때에는 아래 항목들을 잘 검토해야 한다.

  - 프로그래밍 언어 지원 여부: 다양한 프로그래밍 언어를 지원할 수록 좋다.
  - 메시징 표준 지원 여부: AMQP나 STOMP 등 표준 프로토콜을 지원하는 제품인가, 아니면 자체 표준만  
    지원하는 제품인가?
  - 메시지 순서: 메시지의 순서가 유지되는가?
  - 전달 보장: 어떤 종류의 전달 보장을 하는가?
  - 영속화: 브로커가 고장나도 문제가 없도록 메시지를 디스크에 저장하는가?
  - 내구성: consumer가 메시지 브로커에 다시 접속할 경우, 접속이 중단된 시간에 전달된  
    메시지를 받을 수 있나?
  - 확장성: 얼마나 확장성이 좋은가?
  - 지연 시간: 종단 간 지연 시간은 얼마나 되나?
  - 경쟁사 consumer: 경쟁사의 consumer를 지원하는가?

- 여러 가지 고려할 포인트들 중 **메시징 순서 유지 및 확장성**은 필수 요건이다.

<h3>메시지 브로커로 메시지 채널 구현</h3>

- 메시지 채널은 메시지 브로커마다 구현 방식이 조금씩 다르다.

| 메시지 브로커      | 점대점 채널      | 발행-구독 채널                   |
| ------------------ | ---------------- | -------------------------------- |
| JMS                | Queue            | Topic                            |
| Apache Kafka       | Topic            | Topic                            |
| AMQP(ex. RabbitMQ) | Exchange + Queue | Fanout Exchange + Consumer Queue |
| AWS Kinesis        | Stream           | Stream                           |
| AWS SQS            | Queue            | -                                |

<h3>브로커 기반 메시징의 장단점</h3>

- 브로커 기반의 메시징은 여러모로 장점이 많다.

  - 느슨한 결합: 클라이언트는 적절한 채널에 그냥 메시지를 보내는 식으로 요청한다. 클라이언트는 서비스 인스턴스를  
    몰라도 되므로 서비스 인스턴스 위치를 알려주는 디스커버리 메커니즘도 필요 없다.

  - 메시지 버퍼링: 메시지 브로커는 처리 가능한 시점까지 메시지를 버퍼링한다. HTTP 같은 동기 요청/응답  
    프로토콜을 사용하면 교환이 일어나는 동안 클라이언트/서비스 모두 가동 중이어야 하지만, 메시징을 쓰면  
    consumer가 처리할 수 있을 때 까지 그냥 큐에 메시지가 쌓인다. 덕분에 예를 들어 온라인 상점에서  
    주문 이행 시스템에 느려지거나 불능 상태에 빠지더라도 consumer는 계속 주문을 접수할 수 있다.  
    그냥 언젠가는 처리될 것이라 간주하고 메시지를 차곡차곡 쌓아두는 것이다.

  - 유연한 통신: 메시징은 지금까지 본 모든 상호 작용 스타일을 지원한다.

- 반대로 단점은 아래와 같다.

  - 성능 병목 가능성: 메시지 브로커가 성능 병목점이 될 위험이 있다. 하지만 다행이 요즘 메시지 브로커는  
    대부분 확장이 잘 되도록 설계되었다.
  - 단일 장애점 가능성: 메시지 브로커는 가용성이 높아야 한다. 그렇지 않으면 시스템의 신뢰성에 흠이 갈 수 있다.  
    다행이 요즘 브로커는 대부분 고가용성이 보장되도록 설계되었다.
  - 운영 복잡도 증가: 메시징 시스템 역시 설치, 구성, 운영해야할 시스템 컴포넌트이다.

<hr/>

<h2>수신가 경합과 메시지 순서 유지</h2>

- 