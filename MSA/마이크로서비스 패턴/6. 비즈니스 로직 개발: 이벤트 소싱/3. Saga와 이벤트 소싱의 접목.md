# Saga와 이벤트 소싱의 접목

- 이벤트 소싱에서는 코레오그래피 Saga를 쉽게 이용할 수 있다. 참여자는 자신의 Aggregate가  
  발생시킨 도메인 이벤트를 교환하고, 각 참여자의 Aggregate는 커맨드를 처리하고 새로운  
  이벤트를 발생시키는 식으로 이벤트를 처리한다. 물론 Aggregate 및 Aggregate를 업데이트하는  
  이벤트 핸들러 클래스는 개발자가 직접 작성해야 한다.

- 하지만 이벤트 소싱 기반의 비즈니스 로직을 오케스트레이션 Saga에 연계하는 일은 훨씬 어렵다.  
  이벤트 저장소의 트랜잭션 개념이 상당히 제한적이기 때문이다. 이벤트 저장소를 사용하는  
  애플리케이션은 Aggregate 하나만 생성, 수정하고 결과 이벤트들을 반환할 수 있는데,  
  Saga의 각 단계는 다음과 같이 반드시 원자적으로 수행되어야 하는 액션들로 구성된다.

  - **Saga 생성**: Saga를 시작한 서비스는 원자적으로 Aggregate를 생성, 수정하고 Saga  
    오케스트레이터를 생성해야 한다.
  - **Saga 오케스트레이션**: Saga 오케스트레이터는 원자적으로 응답을 소비하고, 자신의 상태를  
    업데이트한 후 커맨드 메시지를 전송해야 한다.
  - **Saga 참여자**: Saga 참여자는 원자적으로 메시지를 소비하고, 중복 메시지를 솎아 내고,  
    Aggregate를 생성 및 수정하고, 응답 메시지를 전송해야 한다.

- 이처럼 이벤트 저장소의 트랜잭션 능력과 요건 사이에 맞지 않는 부분이 있기 때문에  
  오케스트레이션 Saga와 이벤트 소싱을 연계하는 작업은 쉽지 않은 도전이 될 가능성이 있다.

- 이벤트 저장소의 RDBMS/NoSQL 사용 여부는 이벤트 소싱과 오케스트레이션 Saga의 연계 가능성을  
  가늠하는 핵심 기준이다. Eventuate Tram Saga 프레임워크와 그 하부를 지지하는 Tram Messaging  
  프레임워크는 RDBMS에서 지원하는 유연한 ACID 트랜잭션에 의존한다. Saga 오케스트레이터와  
  참여자는 ACID 트랜잭션을 걸고 DB를 원자적으로 업데이트한 후, 메시지를 교환한다.  
  Eventuate Local 등 RDBMS 기반의 이벤트 저장소를 사용하는 애플리케이션은 융통성 있게  
  Eventuate Tram Saga 프레임워크를 호출해서 이벤트 저장소를 ACID 트랜잭션으로 업데이트할 수 있다.  
  그러나 NoSQL DB를 쓰는 이벤트 저장소는 Eventuate Tram Saga 프레임워크와 동일한 트랜잭션에  
  참여할 수 없기에 다른 방법을 궁리해야 한다.

- 해결해야할 이슈와 가능한 시나리오를 정리해보자.

  - 코레오그래피 Saga 구현
  - 오케스트레이션 Saga 생성
  - 이벤트 소싱 기반의 Saga 참여자 구현
  - 이벤트 소싱을 이용하여 Saga 오케스트레이터 구현

## 코레오그래피 Saga 구현: 이벤트 소싱

- 이벤트 소싱은 속성상 이벤트가 모든 것을 주도하므로 코레오그래피 Saga를 매우 쉽게 구현할 수 있다.  
  Aggregate가 업데이트되면 Saga가 이벤트를 발생시키고, 제각기 배정된 이벤트 핸들러는 해당 이벤트를  
  소비한 후 Aggregate를 업데이트한다. 이벤트 소싱 프레임워크는 각 이벤트 핸들러를 알아서 멱등하게 만든다.

- 이전에 주문 생성 Saga를 코레오그래피 기반으로 구현했을 때, `ConsumerService`, `KitchenService`,  
  `AccountingService`는 `OrderService`의 이벤트를 구독하고, 반대로 `OrderService` 역시  
  이 세 서비스의 이벤트를 구독했다. 각 서비스는 이벤트 핸들러를 갖고 있다. 이벤트 핸들러가 해당 Aggregate를  
  업데이트하면 또 다른 이벤트가 발생한다.

- 이벤트 소싱과 코레오그래피 Saga는 찰떡궁합니다. 이벤트 소싱은 메시징 기반의 IPC, 메시지 중복 제거, 원자적  
  상태 업데이트와 메시지 전송 등 Saga가 필요로하는 여러 가지 메커니즘을 제공한다. 물론 코레오그래피 Saga는  
  단순해서 좋지만, 단점도 많다. 특히 이벤트 소싱에서만 해당되는 단점이 하나 있다.

- 코레오그래피 Saga에 이벤트를 사용하면 이벤트의 목적이 이원화되는 문제가 있다. 이벤트 소싱은 상태 변화를  
  나타내기 위해 이벤트를 이용하는데, 이벤트를 코레오그래피 Saga에 갖다 쓰면 Aggregate는 상태변화가 없어도  
  무조건 이벤트를 발생시켜야 한다. 가령 Aggregate를 업데이트하면 비즈니스 규칙에 위배될 경우, Aggregate는  
  이런 상황에도 반드시 이벤트를 발생시켜 오류를 보고해야 한다. 더 큰 문제는 Saga 참여자가 Aggregate를 생성할 수 없는  
  경우이다. 에러 이벤트를 발생시킬 Aggregate가 하나도 없을 것이다.

- 이런 문제가 있어서 조금 더 복잡하지만 오케스트레이션 Saga를 구현하는 것이 최선이다.  
  먼저 `OrderService#createOrder()` 같은 서비스 메소드에서 Saga 오케스트레이터를  
  생성하는 방법을 살펴보자.

<hr/>
