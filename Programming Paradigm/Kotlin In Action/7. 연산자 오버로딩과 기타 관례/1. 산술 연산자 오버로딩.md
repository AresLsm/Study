# 산술 연산자 오버로딩

- 코틀린에서 관례를 사용하는 가장 단순한 예는 **산술 연산자**다. Java에서는 원시 타입에 대해서만 산술 연산자를  
  사용할 수 있고, 추가적으로 `String`에 대해서는 `+` 연산자를 사용할 수 있다. 그러나 다른 클래스에서도  
  산술 연산자가 유용한 경우가 있다. 예를 들어 `BigInteger`를 다룬다면 `add()`를 명시적으로 호출하기보다는  
  `+` 연산을 사용하는 편이 더 낫다. 컬렉션에 원소를 추가하는 경우에도 `+=` 연산자를 사용할 수 있으면 더 좋다.  
  코틀린에서는 이런 일이 가능하다.

## 이항 산술 연산 오버로딩

- 점을 표현하는 `Point` 클래스를 보자. 이 클래스에서 두 점을 더하는 연산을 지원하고 싶다 하자.  
  아래 코드는 `+` 연산자 구현을 보여준다.

```kt
data class Point(val x: Int, val y: Int) {
    operator fun plus(other: Point): Point {
        return Point(x + other.x, y + other.y)
    }
}


// client
val point1 = Point(1, 2)
val point2 = Point(2, 3)
val point3 = point1 + point2
println(point3)
// Point(x=3, y=5)
```

- `plus()` 함수 앞에 operator 키워드를 붙여야 한다. **연산자를 오버로딩하는 함수 앞에는 oeprator가 꼭 있어야 한다.**  
  operator 키워드를 붙임으로써 어떤 함수가 관례를 따르는 함수임을 명확히 할 수 있다. operator가 없는데 실수로 관례에서  
  사용하는 함수명을 쓰고 우연히 그 이름에 해당하는 기능을 사용한다면 오류가 나며, 이 오류 메시지를 통해 이름이 겹쳤다는 사실을  
  알고 문제를 해결할 수 있다.

- operator 변경자를 추가해 `plus()`를 선언하면 `+` 기호로 두 `Point` 객체를 더할 수 있다.

- 아래처럼 연산자를 멤버 함수로 만드는 대신, 확장 함수로 정의할 수도 있다.

```kt
operator fun Point.plus(other: Point): Point {
    return Point(x + other.x, y + other.y)
}
```

- 위 구현도 앞의 구현과 동일하다. 외부 함수의 클래스에 대한 연산자를 정의할 때는 관례를 따르는 이름의 확장 함수로 구현하는 게  
  일반적인 패턴이다. 프로젝트 내에서 직접 작성한 클래스에 대해 관례를 따르는 확장 함수를 만들어도 역시 잘 작동한다.

- 다른 언어와 비교할 때 코틀린에서 오버로딩한 연산자를 정의하고 사용하기가 더 쉽다. 코틀린에서는 프로그래머가 직접 연산자를  
  만들어 사용할 수 없고, 언어에서 미리 정해둔 연산자만 오버로딩할 수 있으며, 관례에 따르기 위해 클래스에서 정의해야 하는  
  이름이 연산자별로 정의되어 있다. 아래 표를 보자.

| 식     | 함수 이름             |
| ------ | --------------------- |
| a \* b | `times`               |
| a / b  | `div`                 |
| a % b  | `rem`(이전에는 `mod`) |
| a + b  | `plus`                |
| a - b  | `minus`               |

- 직접 정의한 함수를 통해 구현하더라도, 연산자 우선순위는 언제나 표준 숫자 타입에 대한 연산자 우선순위와 같다.

> - **연산자 함수와 Java**
>
> - 코틀린 연산자를 Java에서 호출하기는 쉽다. 모든 오버로딩한 연산자는 함수로 정의되며, 긴 이름(FQN)을 사용하면  
>   일반 함수로 호출할 수 있다. Java를 코틀린에서 호출하는 경우에는 함수명이 코틀린의 관례에 맞아 떨어지기만 하면  
>   항상 연산자 식을 사용해 그 함수를 호출할 수 있다. 다만 Java에서는 따로 연산자에 표시를 할 수 없으므로 operator 변경자를  
>   사용해야 한다는 요구 사항을 Java 메소드에는 적용할 수 없다. 따라서 이름과 파라미터의 개수만 문제가 된다.  
>   Java 클래스에 이미 원하는 연산자 기능을 제공하는 메소드가 있지만, 이름만 다르다면 관례에 맞는 이름을 가진 확장 함수를  
>   작성하고, 연산을 기존 Java 메소드에 위임하면 된다.

- 연산자를 정의할 때 두 피연산자(연산자 함수와 두 파라미터)가 같은 타입일 필요는 없다. 예를 들어, 어떤 점의 비율에 따라  
  확대, 축소하는 연산자를 정의해보자. 이를 사용해 여러 다른 좌표계 사이에 점을 변환할 수 있다.

```kt
operator fun Point.times(scale: Double): Point {
    return Point((x * scale).toInt(), (y * scale).toInt())
}

// client
val p = Point(10, 20)
println(p * 1.5)
// Point(15, 30)
```

- 코틀린 연산자가 자동으로 교환 법칙(`a op b == b op a`)을 지원하지는 않음에 유의하자. 사용자가 `p * 1.5` 외에  
  `1.5 * p`라고도 쓸 수 있어야 한다면 `p * 1.5`와 같은 식에 대응하는 연산자 함수를 `Double`에 확장 함수로  
  따로 정의해야 한다.

- 연산자 함수의 반환 타입이 꼭 두 피연산자 중 하나와 일치해야만 하는 것도 아니다.

```kt
operator fun Char.times(count: Int): String {
    return toString().repeat(count)
}
```

- 위 연산자는 `Char`를 좌항으로 받고, `Int`를 우항으로 받아서 `String`을 돌려준다. 이런 식의 피연산자와  
  결과 타입 조합도 완전히 합법적인 연산자 오버로딩이다.

- 일반 함수와 마찬가지로 operator 함수도 오버로딩할 수 있다. 따라서 이름은 같지만, 파라미터 타입이 서로 다른  
  연산자 함수를 여러 개 만들 수 있다.

<hr/>
