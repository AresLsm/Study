# 시간을 이터러블로 다루기

<h2>range, take의 재해석</h2>

- 아래 코드를 보자.

```js
_.go(
  _.range(10), // 0~9의 배열
  _.take(3), // 앞에서부터 3개만 가져오기
  console.log
);

_.go(
  L.range(10), // 0~9의 이터러블, 최대 10번 동작할 수 있다.
  L.take(3), // 최대 3개의 값이 필요하고, 최대 3번의 일을 수행한다.
  console.log
);
```

- `L.range(10)`을 _어떤 일을 하려 하는데, 최대 10번 일어날 수 있다_ 라고 생각해보자.  
  조금 더 다른 시각으로 바라보기 위해 아래 코드를 보자.

```js
_.go(L.range(10), L.map(_.delay(1000)), L.take(3), console.log);

// 1초에 하나씩 0 1 2 출력
```

- `L.range(10)`을 _앞으로 어떤 일을 할 것인데, 이후에 어떤 일이 일어나도 최대 10번만 일어난다_ 고 표현한 것이다.  
  `L.take(3)` 또한 _어떤 일들을 하고, 최대 3개의 결과값이 필요하다_ 고 표현한 것이다.

<hr/>

<h2>takeWhile, takeUntil</h2>

- `take()`가 숫자를 통해 어떠한 일이 일어날 횟수를 제한하는 함수라면,  
  `takeWhile()`, `takeUntil()`은 제한을 조금 더 동적으로 할 수 있게 해주는 헬퍼 함수라고 볼 수 있다.

- 코드를 보며 어떻게 동작하는지 파악하자.

```js
_.go(
  [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2],
  _.takeWhile((a) => a),
  _.each(console.log)
); // 1 2 3 4 5 6 7 8 9

_.go(
  [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2],
  _.takeUntil((a) => !a),
  _.each(console.log)
); // 1 2 3 4 5 6 7 8 9 0
```

- 위 결과처럼 `takeWhile()`은 인자로 주어진 함수가 true일 때 까지만 값을 담도록 한다.  
  (마치 while문을 실행시킨 것과 같다.)

- `takeUntil()`는 조건을 만족시키는 값을 만날 때 까지 담는 함수이다.  
  위 코드에서는 0을 만났을 때 조건을 만족하므로 1부터 9, 그리고 0까지 담은 것이다.

<hr/>

<h2>할 일들을 이터러블(리스트)로 바꾸기</h2>

- 상황 설명

  - 자동자 경주를 한다. 아래 코드 처럼 track이 있고, 차들이 있다.  
    track 배열 내의 cars가 하나의 조로 묶여 경기를 한다.

```js
const track = [
  { cars: ["철수", "영희", "철희", "영수"] },
  { cars: ["하든", "커리", "듀란트", "탐슨"] },
  { cars: ["폴", "어빙", "릴라드", "맥컬럼"] },
  { cars: ["스파이더맨", "아이언맨"] },
  { cars: [] },
];
```

- 이러한 상황을 이터러블 프로그래밍으로 구현해보자.  
  아래 코드는 경기를 할 차들의 조를 뽑는 코드이다.  
  4개의 차가 있을 때만 경기를 할 수 있다.

```js
_.go(
  L.range(Infinity),
  L.map((i) => track[i]),
  L.map(({ cars }) => cars),
  L.map(_.delay(1000)),
  L.takeWhile(({ length: l }) => l === 4), // 4개의 차들이 있을 때만 경기를 한다.
  L.flat,
  L.map(car => `${car} 출발!`)
  _.each(console.log)
);
```

<hr/>
