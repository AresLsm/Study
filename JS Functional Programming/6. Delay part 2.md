# 지연성 2

<h2>결과를 만드는 함수 reduce, take</h2>

- 기존의 `reduce()`, `take()` 함수를 보자.

```js
const take = curry(limit, iterable) => {
  let res = [];
  for(const a of iterable) {
    res.push(a);
    if(res.length === limit) return res;
  }
  return res;
});

const reduce = curry((fn, start, iterable) => {
  if(!iterable) {
    iterable = start[Symbol.iterator]();
    start = iterable.next().value;
  }
  for(const a of iterable) {
    start = fn(start, a);
  }
  return start;
});
```

- `reduce()`, `take()`는 최종적으로 어떤 함수의 결과를 만드는 함수라고 할 수 있다.  
  이들은 iterable이나 배열의 값들을 꺼내서 특정 연산을 하는 식으로 값을 변경 후 다시 iterable 또는 배열에  
  넣는 것이 아니라, 값을 빼내서 그 값을 깨뜨려야 하기에 최종적으로 결과를 만드는 함수라고 할 수 있다.  
  즉, 연산을 시작하는 함수라고 할 수 있다.

- `take()`도 조건에 맞으면 yield 시키도록 하여 지연성을 줄 수 있지만, 몇 개의 원소를 가지는지 모르는 배열 또는 iterable을  
  전달받아 특정 개수의 배열로 축약을 하고 완성을 지어버리는 성질을 가지기에 `take()` 자체에는 지연성을 주는 것보다  
  실제로 `take()`가 수행될 때 값이 평가되도록 다른 함수들에 지연성을 주는 것이 중요하다.

<hr/>
