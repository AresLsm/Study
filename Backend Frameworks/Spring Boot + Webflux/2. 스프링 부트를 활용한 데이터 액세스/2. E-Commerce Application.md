# E-Commerce Application

<h2>도메인 정의</h2>

- 이번에는 데이터베이스를 연결하고, 실제 이커머스 사이트를 모델링해보자.  
  시작하기 전에 아래의 의존성을 추가해주자.

```gradle
//..

dependencies {
    //..
    implementation("org.springframework.boot:spring-boot-starter-data-mongodb-reactive")
    implementation("de.flapdoodle.embed:de.flapdoodle.embed.mongo")
    implementation("org.mongodb:mongodb-driver-sync")
}
```

- `spring-boot-starter-data-mongodb-reactive`는 Spring Boot Starter이다.  
  이 패키지는 아래의 4개 의존성을 내부적으로 포함한다.

  - `spring-boot-starter`: 스타터를 연결해서 사용할 수 있게 해주는 스프링 부트 핵심 모듈
  - `spring-data-mongodb`: 블로킹 방식 MongoDB 드라이버가 제외된 Spring Data MongoDB
  - `mongodb-driver-reactivestreams`: MongoDB 공식 리액티브 스트림 드라이버
  - `reactor-core`: 프로젝트 리액터 코어 모듈

- `spring-boot-starter-data-mongodb-reactive`는 Spring Data MongoDB를 포함하며,  
  특히 리액티브 버전이 들어있다. (블로킹 버전: `spring-boot-starter-data-mongodb`)  
  Spring Data MongoDB는 리액티브 스트림을 완벽히 지원하며, 아주 쉽게 리액티브 방식으로  
  협업할 수 있게 해준다.

- `de.flapdoodle.embed:flapdoodle.embed.mongo`는 내장형 MongoDB 도구이다.  
  테스트에 주로 사용하며, 애플리케이션 초기 설계 단계에서 data store로 사용할 수 있다.

- 마지막으로 `mongodb-driver-sync`는 리액티브가 아닌 전통적인 MongoDB 드라이버이다.

- 간단한 이커머스 도메인을 정의해보자.

| 도메인 객체               | 설명                                             |
| ------------------------- | ------------------------------------------------ |
| 판매 상품(inventory item) | 일련번호, 가격, 설명 필요                        |
| 장바구니(Cart)            | 장바구니 식별자와 장바구니에 담긴 상품 목록 필요 |
| 구매 상품(Item in a cart) | 장바구니에 담긴 판매 상품의 구매 수량 필요       |

- 먼저 판매 상품부터 정의해보자.

<h3>판매 상품(Item)</h3>

```kt
class Item {
    @Id
    var id: String? = null
    var name: String = ""
    var price = 0.0

    private constructor() {}

    constructor(name: String, price: Double) {
        this.name = name
        this.price = price
    }
}
```

- Spring Data MongoDB를 사용하므로, 어떤 필드를 MongoDB의 ObjectId 값으로 사용할지를 `@Id` 어노테이션으로 지정했다.

- 이제 MongoDB에서 사용될 데이터를 담은 POJO 클래스를 정의해보자.  
  MongoDB에 저장할 객체를 정의할 때는 MongoDB 어노테이션을 사용하는 등 추천할만한 권장 사항을 따르는게 좋다.

- Spring Data는 사용할 데이터 스토어에 맞는 적절한 관례를 사용하도록 권장한다.  
  모든 데이터 스토어에 범용적으로 적용할 수 있는 유일한 해법 같은 것은 없다.  
  따라서 Redis를 사용할 때 썼던 그대로 MongoDB에서도 동작할 것이라 생각하면 안된다.

<h3>아이템과 구매할 상품을 장바구니에 추가하는 작업</h3>

- 우선 아이템과 수량을 포함하는 구매 상품 데이터 클래스를 만들어보자.

```kt
class CartItem {

    var item: Item? = null
    var quantity: Int = 0

    private constructor() {}

    constructor(item: Item) {
        this.item = item
        this.quantity = 1
    }
}
```

- 마지막 도메인 객체로 구매 상품(CartItem)을 담는 장바구니(Cart)이다.

```kt
class Cart {

    @Id
    var id: String? = null
    var cartItems: List<CartItem> = mutableListOf()

    private constructor() {}

    constructor(id: String) {
        this.id = id
        this.cartItems = mutableListOf()
    }

    constructor(id: String, cartItems: List<CartItem>) {
        this.id = id
        this.cartItems = cartItems
    }
}
```

- `Cart`는 유일한 식별자를 가지고 있으며, 구매 상품(`CartItem`)들을 저장할 Java 컬렉션도 가지고 있다.

<hr/>

<h2>레포지토리 만들기</h2>

- 지금까지 MongoDB에 저장할 도메인 객체 만들기 1단계를 수행했다.  
  아직 MongoDB에 데이터를 읽고 쓰는 데 Spring Data를 사용하면 어떤 점이 좋은지는 알아보지 않았다.

- 업계에서는 NoSQL Data Store를 표준화하는 방법을 찾기 위해 다양한 시도를 해왔지만, 아직까지  
  성공한 사례가 없다. 이유는 모든 NoSQL Engine이 각기 다르며, 저마다의 특징과 장단점이 있고,  
  상충되는 부분이 존재하지 않기 때문이다. 이렇게 서로 다른 NoSQL Engine을 하나의 API로  
  통일해서 표준화하려면 매우 복잡한 과정을 거쳐야 하고, 그렇게 해도 개별 엔진의 고유한 특성을 잃게  
  되므로 결국은 실패로 이어진다.

- 그렇다면 Spring Data는 이 문제를 어떻게 해결하는 것일까?  
  Spring이 가진 가장 강력한 패러다임 중 하나는 `JdbcTemplate`, `RestTemplate`, `JmsTemplate` 같은  
  **템플릿 패턴(Template Pattern)** 이다. 템플릿이라는 이름이 붙은 다양한 도구는 타입 안전(Type-safe)하게  
  연산을 처리하고, 다루기 복잡하고 귀찮은 것들을 추상화해서 데이터베이스 등 협력 대상과의 상호작용이  
  바르게 동작하도록 보장한다.

- 가장 간단한 사례로 `JdbcTemplate`을 사용하면 개발자가 데이터베이스 연결을 직접 열고 닫지 않아도 된다.

- Spring Data에는 여러 가지 Data Store별 맞춤형 템플릿이 있다. 예를 들어, MongoDB 용으로는  
  `MongoTemplate`, `ReactiveMongoTemplate`이 제공된다. 오직 하나의 데이터 스토어만을 위한  
  맞춤형 템플릿이므로 해당 데이터 스토어의 특징적인 고유한 연산도 문제없이 지원하며, 결국 해당 데이터베이스의  
  풍부한 기능을 모두 활용할 수 있다.

- 하지만 그게 전부는 아니다. MongoDB를 비롯해 다양한 데이터베이스를 지원하는 Spring Data 모듈에는  
  Repository 계층이 있다. 템플릿에 포함돼 있는 풍부한 연산을 사용하다 보면, 그 많은 API를 모두 익히는 일이  
  결국 MongoDB에서 사용할 새로운 MongoQL 쿼리문을 type safe하게 작성하는 것과 같다는 느낌을 받게 된다.

- 저장, 조회, 삭제 같은 연산은 단순하며 거의 모든 DB에서 지원한다. 이런 단순한 연산을 처리하기 위해  
  MongoDB의 가장 깊숙한 면을 알아야 할 필요는 없다. MongoDB 뿐만 아니라 다른 DB도 마찬가지다.  
  따라서 다른 Spring Boot 프로젝트에서 MongoDB가 아닌 다른 DB를 사용한다 하더라도, 저장, 조회, 삭제 같은  
  단순하고 공통적인 연산은 추상화해서 표준화된 방식으로 접근하면 편리하다.  
  이 추상화를 담당하는 계층이 바로 Repository이다.

- Reactive 애플리케이션에서 레포지토리는 아래와 같이 만든다.

```kt
@Repository
interface ItemRepository : ReactiveCrudRepository<Item, String>
```

- `ReactiveCrudRepository`로부터 상속받는 메소드들은 아래와 같다.

  - `save()`, `saveAll()`
  - `findById()`, `findAll()`, `findAllById()`
  - `existsById()`
  - `count()`
  - `deleteById()`, `delete()`, `deleteAll()`

- 여러 가지 풍분한 CRUD 연산이 망라돼 있으며, 실제 구현 코드를 작성하지 않아도 메소드를 사용할 수 있다.

- 눈여겨봐야 할 것은 **모든 메소드의 반환 타입이 `Mono`, `Flux` 둘 중 하나라는 것**이다.  
  이 부분이 매우 중요한데, `Mono`나 `Flux`를 구독하고 있다가 MongoDB가 데이터를 제공할 준비가 됐을 때  
  데이터를 받을 수 있게 된다. 그리고 이 메소드중 일부는 리액티브 스트림의 `Publisher` 타입을  
  인자로 받을 수 있다.

> 모든 리액터 타입은 `Publisher` 리액티브 스트림 타입을 구현한다. 그래서 리액터 타입을 반환하는 메소드를,  
> 예를 들면 RxJava 코드가 받아서 사용할 수 있다. Spring Data는 `Publisher`를 반환 타입 뿐만 아니라  
> 파라미터로 받을 수도 있으므로 리액티브 스트림 명세를 준수하며 리액티브 스트림과의 호환성을 보장한다.

<hr/>
