<h1>사용자 관련 API 작성하기</h1>

<h2>사용자 관련 API들</h2>

- 생성할 사용자 관련 API는 총 4개인데, 아래와 같다.
  - 회원 등록 : `[POST] /user`
  - 회원 정보 수정 : `[PATCH] /user/{userId}`
  - 회원 정보 조회 : `[GET] /user/{userId}`
  - 회원 정보 삭제 : `[DELETE] /user/{userId}`

* 하나씩 차례대로 해보자.
<hr/>

<h2>회원 등록 API</h2>

- 회원 테이블은 `user_id`, `name`, `email`, `password` 컬럼을 갖는다.  
  이를 TypeORM이 인식할 수 있도록 이전에 아래와 같이 도메인 클래스를 작성했다.

```ts
// user.entity.ts

import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity({ name: "users" })
export class User {
  @PrimaryGeneratedColumn()
  private user_id: number;

  @Column({ nullable: false })
  private name: string;

  @Column({ nullable: false, unique: true })
  private email: string;

  @Column({ nullable: false })
  private password: string;

  // Get, Set accessors
}
```

- 여기서 유의할 점은 `user_id`는 우리가 부여하지 않는다는 점이다.  
  물론 새로운 사용자를 INSERT 하기 전에 가장 SELECT 문의 LIMIT 1을 써서  
  마지막 사용자의 user_id를 가져온 후, 새로 저장되는 컬럼에 그 값에 1을 더한  
  값을 해줘도 된다. 하지만 JPA와 마찬가지로 TypeORM도 AUTO_INCREMENT PK를  
  처리하는 방식을 매우매우 유사하게 제공한다.

- 우선 사용자 등록을 위해 필요한 정보를 담은 `UserCreateDto` 클래스를 생성하자.

```ts
// create-user.dto.ts

export class UserCreateDto {
  @IsString()
  private readonly name: string;

  @IsEmail()
  private readonly email: string;

  @IsString()
  private readonly password: string;

  // Get Accessors..
}
```

- 위 Dto에는 class-validator 패키지가 제공하는 데코레이터들을 사용해서  
  각 필드에 대한 검증을 수행했다. 예를 들어 `@IsString()`이 적용되어 있는  
  name 필드가 dto로 전달되지 않으면 400(BAD_REQUEST) 예외가 던져질 것이다.

- 다음으로는 가입이 완료되었을 때, 그리고 사용자 정보 조회 시 결과를 보여주기 위한  
  `UserInfoResponseDto`를 작성해보자.

```ts
// user-info.dto.ts

export class UserInfoResponseDto {
  constructor(user: User) {
    this.user_id = user.getUser_id;
    this.name = user.getName;
    this.email = user.getEmail;
  }
  private user_id: number;
  private name: string;
  private email: string;
}
```

- 생성자에는 `User` Entity 객체를 넣어줬는데, 이유는 아래와 같다.
  - 이 dto의 모든 정보는 `User` Entity 객체로부터 전달 받는다.
  - 만약 Set Accessor로 각 값들을 채워줄 것이라면, 3번의 호출이 필요하다.
  - 각 값들을 생성자로 받으면 생성자에 필요한 값들이 많아져 혼란을 야기할 수 있다.

* 이제 이 `UserCreateDto`를 받아와서 실제 테이블에 넣는 작업을 수행하는  
  서비스 로직을 써보자.

```ts
// user.service.ts

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User) private readonly userRepository: Repository<User>
  ) {}

  private userCreateDtoToEntity = (dto: UserCreateDto): User => {
    const user = new User();
    user.setEmail = dto.getEmail;
    user.setName = dto.getName;
    user.setPassword = dto.getPassword;
    return user;
  };

  async saveUser(dto: UserCreateDto): Promise<UserInfoResponseDto> {
    const user = await this.userRepository.save(
      this.userCreateDtoToEntity(dto)
    );
    return new UserInfoResponseDto(user);
  }
}
```

- `userCreateDtoToEntity()`는 함수명 그대로 `UserCreateDto`를  
  `User` Entity 객체로 알맞게 바꾸어 반환해주는 함수이다.  
  `userRepository.save()`를 호출하면 인자로 들어간 `User` 객체가  
  실제 테이블에 저장되며, 저장이 된 순간 AUTO_INCREMENT PK인 user_id가 지정된다.  
  그리고 모든 정보가 기입된 `User` 객체를 반환한다.

- 따라서 `userRepository.save()`의 결과로 반환된 Entity 객체를  
  `UserInfoResponseDto`의 생성자로 전달해주면 API 결과는 우리가 예상한대로  
  모든 정보를 가지고 있을 것이다.

- 하지만 여기서 끝난게 아니다..  
  `users.email` 컬럼이 UNIQUE 제약 조건을 가지고 있기 때문에  
  만약 `UserCreateDto`의 email을 가지는 컬럼이 이미 DB에 있다면  
  당연히 query를 수행하면 오류가 날 것이다. 이에 대해 예외 처리를 해줘야 하며,  
  만약 이런 경우가 있다면 409(CONFLICT)를 반환해주도록 하자.  
  이 처리를 하기 위해 TypeORM이 제공하는 `QueryBuilder` API를 사용해 보자.

```ts
private isEmailUsed = async (email: string): Promise<boolean> => {
  return (
    (await this.userRepository
      .createQueryBuilder()
      .select('user.user_id')
      .from(User, 'user')
      .where('user.email = :email', { email })
      .getOne()) !== undefined
  );
};
```

- 위에 작성한 `isEmailUsed()` 함수는 기존에 이미 email을 사용 중인지를 체크한다.  
  `createQueryBuilder()` 메소드는 SQL Query를 문자열 리터럴이 아닌 메소드들을  
  통해 작성할 수 있는 Query Builder를 반환한다.  
  위의 경우에는 `Repository`에서 직접 `QueryBuilder`를 구해서 사용했다.  
  만약 `getOne()`으로 조회된 결과가 없으면 `undefined`가 반환되므로  
  마지막에 `undefined`와 다른지에 대한 값을 반환하도록 했다.

- 이 함수까지 적용해서 완성된 서비스 코드는 아래와 같다.

```ts
// user.service.ts

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User) private readonly userRepository: Repository<User>
  ) {}

  private userCreateDtoToEntity = (dto: UserCreateDto): User => {
    const user = new User();
    user.setEmail = dto.getEmail;
    user.setName = dto.getName;
    user.setPassword = dto.getPassword;
    return user;
  };

  private isEmailUsed = async (email: string): Promise<boolean> => {
    return (
      (await this.userRepository
        .createQueryBuilder()
        .select("user.user_id")
        .from(User, "user")
        .where("user.email = :email", { email })
        .getOne()) !== undefined
    );
  };

  async saveUser(dto: UserCreateDto): Promise<UserInfoResponseDto> {
    if (await this.isEmailUsed(dto.getEmail)) {
      throw new ConflictException("Email is already in use!");
    } else {
      const user = await this.userRepository.save(
        this.userCreateDtoToEntity(dto)
      );
      return new UserInfoResponseDto(user);
    }
  }
}
```

<hr/>

<h2>
