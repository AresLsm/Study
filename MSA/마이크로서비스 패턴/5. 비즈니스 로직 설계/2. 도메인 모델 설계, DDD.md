# 도에민 모델 설계: DDD Aggregate 패턴

- 전통적인 객체지향 설계에 기반한 도메인 모델은 클래스와 클래스 간의  
  관계를 모아놓은 것이다. 클래스는 보통 패키지로 구성된다.

- 주문 애플리케이션을 떠올려보자. `Consumer`, `Order`, `Restaurant`,  
  `Courier` 등 비즈니스 객체에 대응하는 클래스가 있다고 해보자. 그런데 이렇게  
  도메인 모델들을 보면, 비즈니스 객체들의 경계가 불분명하다. 이를테면 어느 클래스가  
  `Order` 라는 비즈니스 객체의 일부인지가 불분명하다. 경계가 불문명하면 MSA에서  
  문제가 발생할 가능성이 높다.

- `Order`라는 비즈니스 객체에 어떤 작업을 수행한다고 해보자. 정확히 무슨 일을  
  하는 것이며, 그 범위는 어디까지일까? 당연히 `Order` 객체를 조회하거나 어떤  
  변경을 일으키는 일이겠지만, 실제로 이 객체 뿐만 아니라 주문 품목, 지불 정보 등  
  다른 연관된 데이터도 많다. 따라서 개발자는 이런 상황에서 도메인 객체의 경계를  
  대략 짐작할 수 밖에 없다.

- 개념적으로도 모호하지만 경계가 본명하지 않으면 비즈니스 객체를 업데이트할 때  
  문제가 생길 수 있다. 비즈니스 객체는 대부분 불변 값(invariant)이 있고,  
  필히 준수해야 할 비즈니스 규칙이 있다. 예를 들어, `Order`객체는 최소 주문량이라는  
  불변 값이 있어서 주문을 업데이트할 때 이 값 이상의 양을 주문해야 한다.  
  그런데 이렇게 불변 값을 강제하려면 비즈니스 로직을 주의 깊게 설계해야 한다.

- 여러 소비자가 주문하는 상황에서 최소 주문량의 충족 여부를 어떻게 보장할 수 있을까?  
  가령 A, B라는 소비자가 주문을 하는 동시에 주문이 본인의 예산을 초과했는지 결정한다고  
  해보자. A는 Food1, B는 Food2를 각각 주문할 생각이다. 애플리케이션 관점에서  
  두 소비자는 DB에서 주문 및 품목을 조회한다. 두 사람은 주문 단가를 낮추기 위해 품목을  
  수정하고, 각자 입장에서 보면 최소 주문량은 충족된다. DB 트랜잭션은 아래 순서대로  
  흘러갈 것이다.

```sql
# Customer: A
BEGIN;
SELECT ORDER_TOTAL FROM ORDER WHERE ORDER_ID = X;
SELECT * FROM ORDER_LINE_ITEM WHERE ORDER_ID = X;
#..
END;

# 최소 주문량 충족 확인 후
BEGIN;
UPDATE ORDER_LINE_ITEM SET ~ WHERE ~;
END;

# Customer: B
BEGIN;
SELECT ORDER_TOTAL FROM ORDER WHERE ORDER_ID = Y;
SELECT * FROM ORDER_LINE_ITEM WHERE ORDER_ID = Y;
#..
END;

# 최소 주문량 충족 확인 후
BEGIN;
UPDATE ORDER_LINE_ITEM SET ~ WHERE ~;
END;
```

- 두 소비자는 두 트랜잭션을 통해 품목을 변경한다. 첫번째 트랜잭션은 주문 및  
  품목을 로드하고, UI는 두 번째 트랜잭션 이전에 최소 주문량이 충족됨을 알려준다.  
  두 번째 트랜잭션은 Optimistic Offline Lock으로 품목을 업데이트한다.

- A는 $X만큼, B는 $Y만큼 주문 총액을 줄인다. 결국 이 `Order`는 더 이상  
  유효하지 않다. 하지만 두 소비자가 업데이트한 후에도 애플리케이션은 이 주문이  
  최소 주문량 조건을 충족한다고 볼 것이다. 이처럼 비즈니스 객체 일부를 직접  
  업데이트하면 결과적으로 비즈니스 규칙을 위반하게 된다.

- DDD Aggregate가 바로 이런 문제의 해결책이다.

<hr/>

<h2>Aggregate는 경계가 분명하다</h2>

- Aggregate는 **한 단위로 취급 가능한 경계 내부의 도메인 객체들**이다.  
  하나의 Root Entity와 하나 이상의 기타 Entity + Value Object로 구성된다.  
  비즈니스 객체는 대부분 Aggregate로 모델링한다.

- `Order` aggregate와 그 경계를 살펴보자. 하나의 `Order` entity와 하나 이상의  
  `OrderLineItem` Value Object, 그 밖에 `DeliveryInfo`, `PaymentInfo`  
  등의 Value Object로 구성된다.

- Aggregate는 도메인 모델을 개별적으로 이해하기 쉬운 덩어리(chunk)로 분해한다.  
  또 조회, 수정, 삭제 같은 작업 범위를 분명하게 설정한다. 작업은 Aggregate의  
  일부가 아닌 전체 Aggregate에 적용한다. Aggregate는 보통 DB에서 통째로 가져오기  
  때문에 복잡한 지연 로딩 문제를 신경 쓸 필요가 없다. 그리고 Aggregate를 삭제하면  
  해당 객체가 DB에서 모두 사라진다.

<h3>Aggregate는 일관된 경계</h3>

- 일부가 아니라 전체 aggregate를 업데이트하므로 좀 전에 본 일관성 문제가 해소된다.  
  업데이트 작업은 Root Aggregate에서 호출되기 때문에 불변 값이 강제되고,  
  동시성 역시 Root Aggregate를 버전 번호나 DB 수준의 lock으로 잠금하여 처리한다.  
  예를 들어, 클라이언트가 직접 품목 수량을 변경할 수 없고 반드시 주문 Aggregate의  
  Root에 있는 메소드를 호출해야 하기 때문에 최소 주문량 같은 불변 값이 강제되는  
  원리이다. 하지만 그렇다고 DB에 있는 전체 Aggregate를 업데이트할 필요는 없다.  
  `Order` 객체와 수정된 `OrderLineItem`에 해당하는 row만 업데이트할 수도 있다.

<h3>Aggregate를 식별하는 일이 관건</h3>

- DDD 도메인 모델 설계의 핵심은 Aggregate와 그 경계, 그리고 Root를 식별하는 것이다.  
  Aggregate의 내부 상세 구조는 부차적인 문제이다. 그러나 Aggregate는 정해진 규칙을  
  반드시 준수해야 하기 때문에 도메인 모델의 모듈화뿐만 아니라 장점이 무궁무진하다.

<hr/>
