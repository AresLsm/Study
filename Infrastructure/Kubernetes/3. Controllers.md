# Controllers

## Replication Controller, ReplicaSet - Template, Replicas, Selector

### K8S의 Controller

- K8S의 `Controller`는 `Service`를 관리 및 운영하는 데 큰 도움을 준다. 어떤 기능들을 제공하는지 보자.

  - **Auto Healing** : 만약 Node1내에 Pod1이 있는데 Pod1에 문제가 생기거나 Node1이 다운되면,  
    해당 `Service`에도 영향이 끼쳐진다. `Controller`는 이를 바로 감지하고, 새로운 `Node`(Node2)에 Pod1을 다시 생성해준다.

  - **Software Update**: 여러 개의 `Pod`의 버전을 업그레이드해야 할 경우, `Controller`를 통해 한 번에 쉽게  
    수행할 수 있다. 또한 업그레이드 도중 문제가 생기면 롤백할 수 있는 기능까지 제공한다.

  - **Auto Scaling** : 예를 들어 `Pod`의 리소스가 한계치에 도달했을 때 `Controller`는 이 상태를 파악하고
    동일한 `Pod`를 하나 더 만들어줌으로써 부하를 분산시키고 `Pod`가 죽지 않게 해준다. 그렇게 된다면 서비스는  
    성능 문제 없이 안정적으로 작동할 수 있다.

  - **Job**: 일시적인 작업을 해야 할 경우, `Controller`가 특정 시점에만 해당 작업을 수행할 `Pod`를 만들어  
    작업을 수행하고, 작업이 완료되면 자동으로 작업을 삭제해준다. 작업 순간에만 자원을 사용하고, 작업이 완료되면  
    자원이 반환되기에 효율적인 자원 사용이 가능하다.

### Replication Controller, ReplicaSet

> `Replication Controller`는 Deprecated되었고, 이를 대체하는 `ReplicaSet`을 사용하자.

### Template

- `Controller`와 `Pod`는 `Service`와 `Pod`처럼 `Label`과 Selector로 연결된다. `type:web`이라는 `Label`이  
  붙어있는 `Pod`가 있다 하자. `Controller`에 `type:web`이라는 Selector를 주면, 이 둘은 연결된다.  
  이때 `Controller`를 만들 때 `Template`에 `Pod`의 내용을 넣을 수 있다. 이전에 `Controller`는 `Pod`가 죽으면  
  재생성시킨다는 Auto Healing기능이 있다고 했다. 기존 `Pod`가 죽어 새로운 `Pod`를 만들 때는 `Template`을 사용해  
  만들게 된다.

- 위와 같은 특성을 사용해 업그레이드를 진행할 수 있다.

- yml 파일을 보자.

```yml
# yml file for Pod
apiVersion: v1
kind: Pod
metadata:
  name: pod-1
  labels:
    type: web
spec:
  containers:
    - name: container
      image: app/v1


# yml file for Controller
apiVersion: v1
kind: ReplicationController
metadata:
  name: replication-1
spec:
  replicas: 1
  selector:
    type: web
  template:
    metadata:
      name: pod-1
      labels:
        type: web
    spec:
      containers:
      - name: container
      	image: app/v2
```

![picture 1](../../images/CONTROLLER_TEMPLATE.png)

### Replicas

- `Replicas`의 기능은 간단하다. `Replicas`에 지정된 숫자 만큼의 `Pod`의 개수가 관리된다.  
  지정된 숫자만큼 재생성, Scale-Out, Scale-In 등을 할 수 있다. yml을 보자.

```yml
# yml file for Pod
apiVersion: v1
kind: Pod
metadata:
  name: pod-1
  labels:
    type: web
spec:
  containers:
    - name: container
      image: app/v1


# yml file for Controller
apiVersion: v1
kind: ReplicationController
metadata:
  name: replication-1
spec:
  replicas: 3
  selector:
    type: web
  template:
    metadata:
      name: pod-1
      labels:
        type: web
    spec:
      containers:
      - name: container
      	image: app/v2
```

> 하나의 `Namespace`에 name이 같은 `Pod`가 여러 개 들어갈 수 없다.  
> 위 yml 파일 중 `Controller`를 위한 파일에서 template에는 `Pod`의 name이 들어있다.  
> 이렇게 실행하면 어떻게 될까? 답은 K8S가 알아서 임의의 문자열을 추가해 name의 중복을 없애준다는 것이다.

- 또한 `Template` 기능과 `Replicas` 기능을 함께 사용해 `Pod`와 `Controller`를 따로 만들지 않고  
  한 번에 만들 수 있다. 실제로 `Controller`를 사용할 때 `Pod`는 만들지 않고, `Controller`에 대한  
  내용만 만들어 사용한다.

![picture 2](../../images/CONTROLLER_REPLICAS.png)

- 기본적으로 위 yml파일을 실행하면 이름이 replication-1인 `Controller`와 3개의 `Pod`가 생성된다.  
  이 상태에서 `Pod`를 지우면 spec.replicas에 지정된 개수만큼 재생성되는데, **`Controller`를 지우게 된다면**  
  **해당 `Controller`에 연결된 모든 `Pod`도 함께 삭제된다.** 이를 비활성화하고 싶다면  
  직접 master에 접속해 kubectl 명령어로 `Controller`를 지우고, 이때 `--cascase=false` 옵션을 지정하면 된다.

```sh
kubectl delete replicationcontrollers replication-1 --cascade=false
```

- 추가적으로 직접 명령 인자 옵션을 주는 방식 대신, yml 파일에 지정할 수도 있다.

```yml
apiVersion: v1
kind: ReplicaSet
metadata:
  name: replicaset-1
spec:
  replicas: 3
  selector:
    matchLabels:
      cascase: "false"
  template:
    metadata:
      labels:
      	type: web
    spec:
      containers:
      - name: container
      	image: app/v1
```

### Selector

- `Template`, `Replicas`는 Replication Controller와 ReplicaSet에 모두 있는 기능인 반면  
  `Selector`는 ReplicaSet에만 있는 기능이다.

- 먼저 Replication Controller의 `Selector`는 key, value가 모두 같은 `Label`을 가진 `Pod`들과만  
  연결을 해준다. 반면 ReplicaSet에는 `Selector`에 두 가지 추가적인 속성이 있다.

  - matchLabels 속성은 Replication Controller와 같이 key, value가 모두 같은 `Label`만 선택한다.

  - matchExpressions 속성은 선택할 key, value를 조금 더 섬세하게 지정할 수 있다. 예를 들어 key에는 ver을,  
    operator에는 Exists 라고 넣게 되면 value는 다르지만 key가 ver인 `Label`을 가진 모든 `Pod`들을  
    선택할 수 있다.

- matchExpressions의 operator에는 Exists 외에 아래와 같은 옵션들이 더 있다.

  - Exists: key만 정하면 value와는 관계 없이 해당 key를 가진 `Label`을 가지는 `Pod`들을 선택한다.

  - DoesNotExist: Exists와 정반대로, key에 지정된 key를 갖지 않는 `Label`을 가진 `Pod`들을 선택한다.

  - In: value로 가능한 후보들을 지정할 수 있다. 예를 들어 key가 A이며 values가 2, 3이라면 `A:1`과  
    `A:2`, `A:3` 의 3개 `Label` 중 `A:2`, `A:3` 을 가진 `Pod`들을 선택한다.

  - NotIn: In과 반대로, In의 예시 상황에서라면 `A:1`의 `Label`을 가진 `Pod`들만 선택된다.

```yml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: replica-1
spec:
  replicas: 3
  selector:
    matchLabels:
      type: web
    matchExpressions:
      - { key: type, operation: In, values: [web] }
      - { key: ver, operator: Exists }
  template:
    metadata:
      name: pod
# ..
```

![picture 3](../../images/CONTROLLER_SELECTOR.png)

- `Selector`를 사용할 때의 주의점이 몇 가지 있다.

  - `Selector`에 있는 내용이 template.metadata.labels의 내용에 포함되어야 한다.
  - spec.selector에는 matchLabels와 matchExpressions를 동시에 사용할 수 있는데, 이 둘 모두  
    template.metadata.labels에 포함되어야 한다.

<hr/>

## Deployment - Recreate, RollingUpdate

- Deployment는
