# 이터러블 프로그래밍 혹은 리스트 프로세싱(LISP)

<h2>홀수 n개 더하기</h2>

- 홀수 n개를 뽑아서 제곱한 값들을 더해보자.

```js
function f1(limit, list) {
  let res = 0;
  for (const a of list) {
    if (a % 2) {
      const b = a * a;
      res += b;
      if (--limit === 0) break;
    }
  }
  console.log(res);
}

f1(3, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
```

- 위 코드의 `f1()` 함수는 명령형으로 작성된 코드로, if문을 사용하여  
  limit개 만큼의 원소를 제곱하여 더한 값을 반환한다.(코드 상에서는 console.log)

<h3>함수형으로 바꿔보기</h3>

- 이제 문장으로 구성되어 있는 위의 함수를 이터러블 프로그래밍으로 바꿔보자.  
  명령형 프로그래밍의 if문, break, 그리고 값 할당을 중점적으로 바꿔보자.  
  핵심적인 사고 방식은 아래와 같다.

  - if문을 `filter()`로
  - 값 변화 후 변수 할당을 `map()`으로
  - break를 `take()`로
  - 축약 및 합산을 `reduce()`로

<h4>if를 filter로</h4>

- else문이 없는 if는 `filter()`로 변경할 수 있다.

```js
// 기존 문장형 함수
function f1(limit, list) {
  let res = 0;
  for (const a of list) {
    if (a % 2) {
      const b = a * a;
      res += b;
      if (--limit === 0) break;
    }
  }
  console.log(res);
}

// 함수형으로 if를 filter로 바꾼 후
function f2(limit, list) {
  let res = 0;
  for (const a of L.filter((a) => a % 2, list)) {
    const b = a * a;
    res += b;
    if (--limit === 0) break;
  }
  console.log(res);
}
```

<h4>값 변화 후 변수 할당을 map으로</h4>

- 값을 바꾼 후 변수 할당을 하는 `const b = a * a; res += b` 부분을 바꿔보자.

```js
// 기존 함수
function f2(limit, list) {
  let res = 0;
  for (const a of L.filter((a) => a % 2, list)) {
    const b = a * a;
    res += b;
    if (--limit === 0) break;
  }
  console.log(res);
}

// map사용 후
function f2(limit, list) {
  let res = 0;
  for (const a of L.map(
    (a) => a * a,
    L.filter((a) => a % 2, list)
  )) {
    res += a;
    if (--limit === 0) break;
  }
  console.log(res);
}
```

<h4>break를 take로</h4>

- 특정 조건에 if문을 탈출하기 위한 break를 `take()`로 바꿔보자.

```js
// 기존 함수
function f2(limit, list) {
  let res = 0;
  for (const a of L.map(
    (a) => a * a,
    L.filter((a) => a % 2, list)
  )) {
    res += a;
    if (--limit === 0) break;
  }
  console.log(res);
}

// 변경 후
function f2(limit, list) {
  let res = 0;
  for (const a of L.take(
    limit,
    L.map(
      (a) => a * a,
      L.filter((a) => a % 2, list)
    )
  )) {
    res += a;
    if (--limit === 0) break;
  }
  console.log(res);
}
```

<h4>축약 및 합산을 reduce로</h4>

- 기존 함수를 보자.

```js
function f2(limit, list) {
  let res = 0;
  for (const a of L.map(
    (a) => a * a,
    L.filter((a) => a % 2, list)
  )) {
    res += a;
    if (--limit === 0) break;
  }
  console.log(res);
}
```

- 위처럼 상위 스코프에 어떤 변수(res)를 만들고, 계속해서 그 변수에 값을 누적해가는(res += a;) 부분은  
  `reduce()`로 교체할 수 있다.

```js
const add = (a, b) => a + b;

function f2(limit, list) {
  console.log(
    _.reduce(
      add,
      L.take(
        limit,
        L.map(
          (a) => a * a,
          L.filter((a) => a % 2, list)
        )
      )
    )
  );
}
```

- 위 코드는 해석하기가 매우 쉬운데, 아래처럼 된다.
  먼저 list로부터 시작해서 홀수만 걸러내는 `filter()`를 하고, 걸러진 값들만을 대상으로  
  제곱을 하고(`map()`), limit개수 만큼만 가져와서 (`take()`) 모두 더하는 작업(`reduce()`)을 한다.

- 조금 더 가독성을 높이기 위해 `go()` 파이프라인을 사용해서 순서를 뒤집어보자.

```js
_.go(
  list,
  L.filter((a) => a % 2),
  L.map((a) => a * a),
  L.take(limit),
  L.reduce(add)
);
```

<hr/>
