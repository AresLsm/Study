# 제네릭 타입 파라미터

- 제네릭을 사용하면 **타입 파라미터(type parameter)** 를 받는 타입을 정의할 수 있다. 제네릭 타입의 인스턴스를 만들려면  
  타입 파라미터를 구체적인 **타입 인자(type argument)** 로 치환해야 한다. 예를 들어 `List`라는 타입이 있다면, 그 안에  
  들어가는 원소의 타입을 안다면 쓸모 있을 것이다. 타입 파라미터를 사용하면 _"이 변수는 리스트이다"_ 라고 말하는 대신,  
  _"이 변수는 문자열을 담는 리스트다"_ 라고 말할 수 있다. 코틀린에서 문자열을 담는 리스트를 표현하는 구문은 Java와  
  마찬가지로 `List<String>`이다. 클래스에 타입 파라미터가 여럿 있을 수도 있다. 예를 들어, `Map` 클래스는 key와  
  value 타입을 타입 파라미터로 받으므로 `Map<K, V>`가 된다. 이러한 제네릭 클래스에 `Map<String, Person>` 처럼  
  구체적인 타입을 타입 인자로 넘기면 타입을 인스턴스화할 수 있다.  
  여기까지는 모든 내용이 Java와 동일해 보인다.

- 코틀린 컴파일러는 보통 타입과 마찬가지로 타입 인자도 추론할 수 있다.

```kt
val authors = listOf("Dmitry", "Svetlana")
```

- `listOf()`에 전달된 두 값이 문자열이기에 컴파일러는 여기서 생기는 리스트가 `List<String>`임을 추론한다. 반면, 빈 리스트를  
  만들어야 한다면 타입 인자를 추론할 근거가 없기 때문에 직접 타입 인자를 명시해야 한다. 리스트를 만들 때 변수 타입을 지정해도 되고  
  변수를 만드는 함수의 타입 인자를 지정해도 된다.

```kt
val readers: MutableList<String> = mutableListOf()

val readers2 = mutableListOf<String>()
```

- 위 두 선언은 동일하다.

> - Java에는 1.5부터 제네릭이 지원되었기 때문에 이전 버전과의 호환성을 유지하기 위해 Raw Type을 허용한다.  
>    자세한 내용은 [여기](https://github.com/sang-w0o/Study/blob/master/Programming%20Paradigm/Effective%20Java/4.%20%EC%A0%9C%EB%84%A4%EB%A6%AD/Item%2026.%20Raw%20%ED%83%80%EC%9E%85%EC%9D%80%20%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80%20%EB%A7%88%EB%9D%BC.md) 에서 볼 수 있다.  
>   반면, 코틀린은 처음부터 제네릭을 도입했기 때문에 raw type을 지원하지 않는다. 따라서 제네릭 타입의 타입 인자를 항상 정의해서  
>   코틀린 컴파일러가 제네릭 타입 인자를 추론할 수 있도록 해야 한다.

---

## 제네릭 함수와 프로퍼티

- list를 다루는 함수를 작성한다면, 어떤 특정 타입을 저장하는 리스트뿐만 아니라 모든 리스트(제네릭 리스트)를 다룰 수 있는 함수를 원할 것이다.  
  이럴 때 제네릭 함수를 작성해야 한다. 제네릭 함수를 호출할 때는 반드시 구체적 타입으로 타입 인자를 넘겨야 한다.

- 컬렉션을 다루는 함수는 대부분 제네릭 함수다. 예를 들어, 아래의 `slice()` 정의를 보자. `slice()`는 구체적 범위 안에 든 원소만을  
  포함하는 새로운 리스트를 반환한다.

```kt
fun <T> List<T>.slice(indices: IntRange): List<T>
//   ^-- 타입 파라미터 선언
```

- 함수의 타입 파라미터 `T`가 수신 객체와 반환 타입에 쓰인다. 수신 객체와 반환 타입 모두 `List<T>`이다.  
  이런 함수를 구체적인 리스트에 대해 호출할 때 타입 인자를 명시할 수 있다.  
  하지만 실제로는 대부분 컴파일러가 타입 인자를 추론할 수 있으므로 그럴 필요가 없다.

```kt
val letters = ('a'...'z').toList()
println(letters.slice<Char>(0..2)) // 타입 인자를 명시적으로 지정
println(letters.slice(10..13)) // 컴파일러가 T가 Char 라는 사실을 추론한다.
```

- 위 두 호출의 결과 타입은 모두 `List<Char>`이다. 컴파일러는 반환 타입 `List<T>`의 `T`를 자신이 추론한 `Char`로 치환한다.

- `filter()` 함수는 `(T) -> Boolean` 타입의 함수를 파라미터로 받는다. 아래 코드를 보자.

```kt
// filter 정의
fun <T> List<T>.filter(predicate: (T) -> Boolean): List<T>

// 예시 코드
val authors = listOf("Dmitry", "Svetlana")
val readers = mutableListOf<String>(/*...*/)
readers.filter { it !in authors }
```

- 람다 파라미터에 대해 자동으로 만들어진 변수 it의 타입은 `T`라는 제네릭 타입이다.  
  컴파일러는 `filter()`가 `List<T>` 타입의 리스트에 대해 호출될 수 있다는 사실과 `filter()`의 수신 객체인 readers의 타입이  
  `List<String>` 이라는 사실을 알고, 그로부터 `T`가 `String`이라는 사실을 추론한다.

- 클래스나 인터페이스 안에 정의된 메소드, 확장 함수 또는 최상위 함수에서 타입 파라미터를 선언할 수 있다. 위 두 예시 코드와 같이  
  확장 함수에서는 수신 객체나 파라미터 타입에 타입 파라미터를 사용할 수 있다. 예를 들어 `filter()`는 수신 객체 타입인 `List<T>`와  
  파라미터 함수 타입인 `(T) -> Boolean`에 타입 파라미터 `T`를 사용한다.

- 제네릭 함수를 정의할 때와 마찬가지 방법으로 제네릭 확장 프로퍼티를 선언할 수 있다.  
  예를 들어, 아래 코드는 리스트의 마지막 원소 바로 앞의 원소를 반환하는 확장 프로퍼티이다.

```kt
val <T> List<T>.penultimate: T // 모든 리스트 타입에 대해 이 제네릭 확장 프로퍼티 사용 가능
  get() = this[size - 2]

println(listOf(1, 2, 3, 4, 5).penultimate) // 4
```

---
