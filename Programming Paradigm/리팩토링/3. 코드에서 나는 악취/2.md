# 코드에서 나는 악취(2)

<h2>기능 편애</h2>

- 프로그램을 모듈화할 때는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은  
  최대한 늘리고, 영역 사이에서 이뤄지는 상호작용은 최소한으로 줄이는 데 주력한다.  
  기능 편애는 흔히 어떤 함수가 **자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와**  
  **상호작용 할 일이 더 많을 때** 풍기는 냄새이다. 실행 과정에서 외부 객체의 setter 메소드  
  대여섯개를 호출하도록 작성된 함수는 정말 많다. 다행이 해결하기는 쉽다. 이 함수가 데이터와  
  가까이 있고 싶어 한다는 의중이 뚜렷이 드러나므로 소원대로 **함수 옮기기**를 사용하여  
  데이터 근처로 옮겨주면 된다. 때로는 함수의 일부에서만 기능을 편애할 수 있다. 이럴 때는 그 부분만  
  독립 함수로 **함수 추출하기**를 이용해 빼낸 다음 **함수 옮기기**로 원하는 모듈로 보내주자.

- 물론 어디로 옮겨야 하는지가 명확하게 드러나지 않을 때도 있다.  
  예를 들어 함수가 사용하는 모듈이 다양하다면 어느 모듈로 옮겨야 할까?  
  이럴 때 저자는 **가장 많은 데이터를 포함한 모듈로** 옮긴다.  
  **함수 추출하기**로 함수를 여러 조각으로 나눈 후 각각을 적합한 모듈로 옮기면 더 쉽게  
  해결되는 경우도 많다.

- 한편 앞의 두 문단에서 설명한 규칙을 거스르는 복잡한 패턴도 있다.  
  예를 들어 _전략 패턴_, *방문자 패턴*이 있을 것이다. 이들은 모두 뒤엉킨 변경 냄새를 없앨 때  
  활용하는 패턴들로, 가장 기본이 되는 원칙은 **함께 변경할 대상을 한데 모으는 것**이다.  
  데이터와 이를 활용하는 동작은 함께 변경해야 할 때가 많지만, 예외가 있다.  
  그럴 때는 같은 데이터를 다루는 코드를 한 곳에서 변경할 수 있도록 옮기자.  
  전략 패턴과 방문자 패턴을 적용하면 오버라이드해야 할 소량의 동작 코드를 각각의 클래스로  
  격리해주므로 수정하기가 쉬워진다.

<hr/>

<h2>데이터 뭉치</h2>

- 데이터 항목들은 서로 어울려 노는 것을 좋아한다. 그래서 데이터 항목 서너 개가 여러 곳에서  
  항상 함께 뭉쳐 다니는 모습을 흔히 목격할 수 있다. 클래스 두어 개의 필드에서, 혹은  
  여러 메소드의 시그니처에서 함께 발견되기도 한다. 이렇게 몰려다니는 데이터 뭉치는  
  보금자리를 따로 마련해줘야 마땅하다.

- 가장 먼저 필드 형태의 데이터 뭉치를 찾아서 **클래스 추출하기**로 하나의 객체로 묶는다.  
  다음은 메소드 시그니처에 있는 데이터 뭉치 차례다. 먼저 **매개변수 객체 만들기**나  
  **객체 통째로 넘기기**를 적용해서 매개변수 수를 줄여본다. 그 즉시 메소드 호출 코드는 간결해진다.  
  데이터 뭉치가 앞에서 새로 만든 객체의 일부만 사용하더라도 걱정할 필요 없다. 새로운 객체로 뽑아낸  
  필드가 두 개 이상이기만 해도 확실히 예전보다 나아지기 때문이다.

- 데이터 뭉치인지를 판별하려면 *값 하나를 삭제*해보자. 그랬을 때 나머지 데이터만으로는 의미가 없다면  
  객체로 환생하길 갈망하는 데이터 뭉치라는 뜻이다.

- 방금 설명에서 간단한 레코드 구조가 아닌 **클래스**로 만들기를 권했다는 점을 주의하자.  
  클래스를 이용하면 좋은 향기를 흩뿌릴 기회가 생긴다. 기능 편애를 없애는 과정에서 새로운 클래스를  
  만들었다면, 이어서 그 클래스로 옮기면 좋을 동작은 없는지 살펴보자. 이러한 연계 과정은 종종 상당한  
  중복을 없애고 향후 개발을 가속화하는 유용한 클래스를 탄생시키는 결과로도 이어지기도 한다.  
  데이터 뭉치가 생산성에 기여하는 정식 멤버로 등극하는 순간이다.

<hr/>

<h2>기본형 집착</h2>

- 대부분의 프로그래밍 언어는 정수, 부동소수점 수, 문자열 같은 다양한 primivite type을 제공한다.  
  라이브러리를 통해 날짜 같은 간단한 객체를 추가적으로 제공하기도 한다.  
  한편 프로그래머 중에는 자신에게 주어진 문제에 딱 맞는 기초 타입(화폐, 좌표, 구간 등)을 직접 정의하기를  
  몸시 꺼리는 사람이 많다. 그래서 금액을 그냥 숫자형으로 계산하거나 물리량을 계산할 때 밀리미터, 인치같은  
  단위를 무시하고, 범위도 `if (a < upper && a > lower)`처럼 처리하는 코드가 많다.

- 이 냄새는 문자열을 다루는 코드에서 특히 흔하다. 전화번호를 단순히 문자 집합으로만 표현하기엔 아쉬움이 많다.  
  최소한 사용자에게 보여줄 때는 일관된 형식으로 출력해주는 기능이라도 갖춰야 한다.  
  이런 자료형들을 문자열로만 표현하는 악취는 아주 흔해서, 소위 *문자열화된 변수*라는 이름까지 붙었다.

- **기본형을 객체로 바꾸기**를 적용하면 기본형만이 거주하는 구석기 동굴을 의미있는 자료형들이 사는  
  최신 온돌식 코드로 탈바꿈시킬 수 있다. 기본형으로 표현된 코드가 조건부 동작을 제어하는 type code로  
  쓰였다면 **타입 코드를 서브클래스로 바꾸기**와 **조건부 로직을 다형성으로 바꾸기**를 차례로 적용하자.

- 자주 함께 몰려다니는 기본형 그룹도 데이터 뭉치다. 따라서 **클래스 추출하기**와 **매개변수 객체 만들기**를  
  이용하여 반드시 문명사회로 이끌어줘야 한다.

<hr/>

<h2>반복되는 switch문</h2>

- 순수한 객체 지향에 뜻이 있는 사람들은 코드에 동작하는 switch문은 모조리 **조건부 로직을 다형성으로 바꾸기**로  
  없애야할 대상이라 주장한다. 심지어 모든 조건부 로직을 다형성으로 바꿔 if문까지도 대부분 없애야 한다 주장하는 이도 있다.

- 분기 조건에 몇 가지 기본형만 쓸 수 있던 예전과 달리, 최근에는 문자열 등의 더 복잡한 타입까지 지원하는  
  발전된 switch문을 제공하는 언어가 많아졌다. 그러니 이제는 무조건 모든 조건부 로직에 대해 고민하지 말고,  
  **똑같은 조건부 로직(switch,case 또는 길게 나열된 if-else)이 여러 곳에서 반복해 등장하는 코드** 에 집중하자.

- 중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서  
  함께 수정해야 하기 때문이다. 이럴 때 다형성은 반복된 switch문이 내뿜는 사악한 기운을 제압하여  
  코드베이스를 최신 스타일로 바꿔주는 세련된 무기가 될 수 있다.

<hr/>

<h2>반복문</h2>

- 요즘에는 일급 함수(first-class function)를 지원하는 언어가 많아졌기 때문에  
  **반복문을 파이프라인으로 바꾸기**를 적용해서 시대에 걸맞지 않은 반복문을 제거할 수 있게 됐다.  
  `filter()`, `map()` 같은 파이프라인 연산을 사용하면 코드에서 각 원소들이 어떻게 처리되는지  
  쉽게 파악할 수 있다.

<hr/>

<h2>성의 없는 요소</h2>

- 코드의 구조를 잡을 때는 *프로그램 요소*를 이용하는 것이 좋다. 그래야 그 구조를 변형하거나  
  재사용할 기회가 생기고, 혹은 단순히 더 의미 있는 이름을 가졌기 때문이다.  
  그렇지만 그 구조가 필요 없을 때도 있다. 본문 코드를 그대로 쓰는 것과 진배없는 함수도 있고,  
  실질적으로 메소드가 하나뿐인 클래스도 있다. 이런 구조는 나중에 본문을 더 채우거나 다른 메소드를  
  추가할 생각이었지만, 어떠한 사정으로 인해 그렇게 하지 못한 결과일 수 있다. 혹은 원래는 풍성했던  
  클래스가 리팩토링을 거치면서 역할이 줄어들었을 수 있다. 사정이 어떠하든 이런 프로그램 요소는  
  제거하는게 좋다. 이 제거 작업은 흔히 **함수 인라인하기**나 **클래스 인라인하기**로 처리한다.  
  상속을 사용했다면 **계층 합치기**를 적용한다.

<hr/>
