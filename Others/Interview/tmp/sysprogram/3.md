# 프로세스

## 프로세스 개념

- OS는 아래와 같은 다양한 프로그램을 실행한다.

  - 배치 시스템: Job
  - 시분할 시스템: 사용자 프로그램 또는 Task

- 프로세스: 실행 중인 프로그램. 프로세스의 실행은 순차적으로 이뤄져야 한다.

- 프로그램이 실행되고 메모리에 적재될 때 실행되는 프로세스는 다양한 부분으로 이뤄진다.

  - 프로그램 코드(text section)
  - 프로그램 카운터, 프로세스 레지스터를 포함한 현재 진행 중인 활동
  - 임시 데이터를 저장하는 stack(함수 매개변수, 복귀 주소, 지역 변수 등)
  - 전역 변수를 저장하는 data section
  - 실행 중 동적으로 할당되는 메모리 영역인 heap

- 실행 파일이 메모리에 적재될 때 프로그램은 프로세스가 된다.

### 프로세스 상태

- 프로세스는 실행되면서 상태가 계속 변한다.

  - new: 프로세스가 생성되는 중
  - running: 명령어 실행 중
  - waiting: 어떤 사건이 일어나기를 기다리는 중
  - ready: 처리기가 할당되기를 기다리는 중
  - terminated: 실행 완료

### 프로세스 스케쥴링

- CPU 사용을 최대로 하는 것을 목표로 시간을 나눠쓰기 위해 CPU에 프로세스를 빠르게 전환시킨다.

- Process Scheduler는 실행 가능한 프로세스들 중 다음 차례에 CPU에서 실행할 프로세스를 선택한다.

  - 프로세스의 scheduling queue를 유지한다.

    - Job Queue: 시스템의 모든 프로세스의 집합
    - Ready Queue: 메인 메모리에 존재하고 실행을 기다리며 준비된 모든 프로세스의 집합
    - Device Queue: I/O 장치를 기다리고 있는 프로세스의 집합

  - 프로세스는 위의 다양한 queue들 사이를 이주한다.

### 프로세스 스케쥴러

- 단기 스케쥴러(short-term scheduler, CPU scheduler): 다음 번에 실행될 CPU를 할당할 프로세스를 선택한다.
- 장기 스케쥴러(long-term scheduler, Job scheduler): Ready queue로 불러들일 프로세스를 선택한다.

  - 장기 스케쥴러는 자주 호출되지 않는다.
  - 다중프로그래밍의 정도를 결정한다.

- 프로세스는 아래의 둘 중 하나로 표현될 수 있다.

  - 입출력 집중(I/O Bound) 프로세스: 계산보다 입출력에 더 많은 시간을 소모하며 짧은 CPU 활동 시간을 갖는다.
  - CPU 집중(CPU Bound) 프로세스: 계산하는 데 더 많은 시간을 소모하며 드물게 매우 긴 CPU 활동시간을 갖는다.

- 장기 스케쥴러는 입출력 집중 프로세스와 CPU 집중 프로세스가 고루 섞인 프로세스 혼합(process mix)이 되도록 노력한다.

- 중기 스케쥴러의 추가

  - 다중프로그래밍의 정도를 낮출 필요가 있을 때 중기 스케쥴러(Medium-term scheduler)가 추가될 수 있다.

### Context Switch(문맥 교환)

- Interrupt는 OS가 CPU를 현재 작업에서 빼앗아 커널 루틴을 실행할 수 있게 한다.

- CPU가 다른 프로세스로 전환할 때, 시스템은 context switching을 통해 이전 프로세스의 상태를 저장하고 새로운 프로세스의 context를 적재한다.
- 프로세스의 context는 PCB에 표현된다.
- Context Switching 시간 동안에는 유용한 일을 하지 않기에 이 시간은 오버헤드가 된다.

## 프로세스의 생성

- Parent 프로세스는 child 프로세스를 생성한다. child 프로세스도 다른 프로세스들을 생성하고, 프로세스의 tree를 형성하게 된다.
- 일반적으로 프로세스는 pid(process identifier)를 통해 식별되고 관리된다.

- parent, child의 자원 공유 옵션

  - parent, child가 모든 자원을 공유한다.
  - child는 parent의 자원의 부분집합을 공유한다.

- 실행 옵션
  - parent, child는 병행하게 실행된다.
  - parent는 child가 종료될 때까지 기다린다.

## 프로세스의 종료

- 프로세스는 자신의 마지막 명령문을 실행하고 `exit()` syscall을 사용해 OS에게 삭제 요청을 한다. 이후 해당 프로세스의 자원은 OS에게 반환된다.
- 부모는 `abort()` syscall을 사용해 child 프로세스의 실행을 끝낼 수 있다. 이렇게 해야 하는 몇 가지 이유는 아래와 같다.
  - Child가 필요한 자원보다 더 많은 자원이 child에게 할당되었다.
  - Child에게 배정된 task가 더 이상 필요하지 않다.
  - Parent가 종료 중에 있다.(parent가 먼저 종료되면 해당 프로세스의 child process의 실행은 허용되지 않는다.)

### 프로세스 간 통신

- 시스템 내의 프로세스는 서로 독립적이거나 협력적일 수 있다.

- 협력적 프로세스는 공유 데이터를 포함한 다른 프로세스에게 영향을 주거나 받을 수 있다.  
  아래와 같은 이유로 협력적 프로세스가 필요하다.

  - 정보 공유
  - 계산 속도 향상
  - 모듈성
  - 편리함

- 협력적 프로세스는 IPC(Inter process communication)이 필요하다.  
  IPC의 두 가제 모델로는 공유 메모리(shared memory)와 메시지 전달(message passing)이 있다.

### 메시지 전달 모델

- 적은 양의 데이터 전달
- 분산 시스템에서 구현하기 쉽다.
- Syscall을 사용해 구현한다.

- 서로 협력하는 프로세스 간에 통신 수단을 제공해 프로세스끼리 통신하고 서로의 행동을 동기화한다.
- `send(message)`, `receive(message)`

- 두 개의 프로세스 P, Q가 통신하길 원한다면 아래와 같은 작업을 해야 한다.

  - 둘 사이에 communication link 설정
  - send/receive를 통해 메시지 교환

- 직접 통신 방법

  - 프로세스가 서로 상대방을 명확하게 지정한다. `send(P, message)`, `receive(Q, message)`
  - 통신을 원하는 각 프로세스들 사이에 연결이 자동으로 구축되고, 이 프로세스는 통신하기 위해 서로의 pid만 알면 된다.
  - 단점: 프로세스 지정으로 인해 제한된 모듈성이 있다. 예를 들어 pid가 바뀌면 프로세스를 지정하는 모든 부분을 검사하고 바꿔야 한다.

- 간접 통신 방법

  - 메시지들을 mailbox 혹은 port로 송신 및 수신한다.
  - mailbox는 추상적인 개념으로 프로세스들에 의해 메시지가 넣어지고 제거될 수 있는 객체를 뜻한다.
  - 각 mailbox는 고유 ID를 가지며, 프로세스는 공유하는 mailbox가 있어야만 통신할 수 있다.
  - 특징: 연결이 두 개 이상의 프로세스들과 연관될 수 있다.

### 공유 메모리 모델

- 공유메모리 영역을 구축할 때만 syscall을 호출한다.
- 공유메모리 영역이 구축되면 모든 접근은 일반적인 메모리 접근으로 취급되어 커널의 도움이 필요하지 않다.

- 생산자, 소비자 문제

  - 협력적 프로세스의 전형젹인 예시로 생산자는 정보를 생산하고 그 정보는 소비자 프로세스에 의해 소비된다.

  - 해결책: 공유 메모리를 사용해 생상자는 정보를 채워 넣고, 소비자가 소모할 수 있는 항목들의 버퍼를 사용하도록 한다.
  - 생산자와 소비자가 반드시 동기화되어야 생산되지 않은 항목들을 소비자가 소비하는 것으로부터 막을 수 있다.

  - 무한 버퍼: 버퍼 크기 제한 X, 소비자는 새로운 항목을 기다릴 수도 있지만 생상자는 언제든지 생산할 수 있다.
  - 유한 버퍼: 버퍼 크기 고정, 버퍼가 비어있으면 소비자는 대기하며 모든 버퍼가 채워졌다면 생산자는 대기한다.

- 공유 메모리를 사용한 IPC는 OS가 아니라 사용자 프로세스의 통제 하에 이뤄진다.

### 동기화

- 프로세스는 `send()`, `receive()`를 호출해 서로 통신하는데, 메시지 전달은 blocking 또는 nonblocking 방식일 수 있다.

- Blocking(synchronous)

  - Blocking send: 송신자는 메시지가 수신될 때까지 실행이 멈춰진다.
  - Blocking receive: 수신자는 메시지가 생길 때까지 실행이 멈춰진다.

- Non-blocking(asynchronous)

  - Non-blocking send: 송신자는 메시지를 보내고 다른 작업을 계속한다.
  - Non-blocking receive: 수신자는 유효한 메시지를 수신하고, 그 사이에 다른 작업을 계속한다.

- `send()`, `receive()`가 모두 blocking이면 이를 랑데부(rendezvous)라 한다.

### Buffering

- 통신이 직접적이든 간접적이든 프로세스들 간에 교환되는 메시지는 임시 큐에 존재한다.  
  이런 큐를 구현하는 방식은 세 가지가 있다.

  - Zero capacity: 메시지를 큐에 저장하지 않는다. 즉 송신자는 수신자가 메시지를 받을 때까지 기다려야 한다.
  - Bounded capacity: n개의 메시지를 저장할 수 있는 길이의 큐를 제공하고, 송신자는 큐가 가득찬 경우 기다려야한다.
  - Unbounded capacity: 무한개의 메시지를 저장할 수 있는 길이의 큐로, 송신자는 절대 기다리지 않는다.
