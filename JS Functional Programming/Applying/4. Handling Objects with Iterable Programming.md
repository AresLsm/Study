# 객체를 이터러블 프로그래밍으로 다루기

<h2>values</h2>

- 아래 객체가 있다고 하자.

```js
const obj1 = {
  a: 1,
  b: 2,
  c: 3,
  d: 4,
};

console.log(Object.values(obj1)); // [1, 2, 3, 4]

_.go(
  obj1,
  Object.values,
  _.map((a) => a + 10),
  _.reduce((a, b) => a + b),
  console.log
); // 50
```

- 위 코드의 `Object.values`를 함수형으로 다시 구현해보자.

```js
L.values = function* (obj) {
  for (const k in obj) {
    yield obj[k];
  }
};
```

- `L.values`가 효율적인 이유는 아래 코드를 보면 알 수 있다.

```js
var it = L.values(obj1);
it = L.take(2, it);
[...it];
```

- `[...it]`로 인해 iterator내의 모든 값이 평가될 때, `L.take()`가 값을 평가해야 하므로  
  `L.values`의 yield가 실행된다. 즉, `L.take()`가 가져갈 개수 만큼만 값이 평가되기에  
  `Object.entries` 보다 효율적인 것이다.

```js
_.go(
  obj1,
  L.values,
  _.map((a) => a + 10),
  _.reduce((a, b) => a + b),
  console.log
); // 50
```

- 이렇게 key:value의 쌍으로 된 객체를 더 효율적으로 다룰 수 있다.

<hr/>

<h2>entries</h2>

- 이번에는 key, value를 모두 꺼내오는 `Object.entries` 를 효율화해보자.

```js
L.entries = function* (obj) {
  for (const k in obj) {
    yield [k, obj[k]];
  }
};

_.go(
  obj1,
  L.entries,
  L.filter(([_, v]) => v % 2),
  _.each(console.log)
); // ["a", 1], ["c", 3]

_.go(
  obj1,
  L.entries,
  L.filter(([_, v]) => v % 2),
  L.map(([k, v]) => ({ [k]: v })),
  _.reduce(Object.assign),
  console.log
); // { a: 1, c: 3 }
```

- 위 코드에서는 obj1이 어떤 형식이던지 상관 없이 `L.entries`를 통해 뒤의 함수들이  
  이터러블 프로그래밍을 할 수 있게 해준다.

<hr/>

<h2>keys</h2>

- `Object.keys`를 지연적으로 구현해보자.

```js
L.keys = function* (obj) {
  for (const k in obj) {
    yield k;
  }
};

_.go(obj1, L.keys, _.each(console.log)); // "a", "b", "c", "d"
```

<hr/>

<h2>어떠한 값이든 이터러블 프로그래밍으로 다루기</h2>

- 지금까지는 JavaScript에 원래 있는 iterable 값들에 대해서만 이터러블 프로그래밍을 했는데,  
  바로 위에서 `L.values`, `L.entries`, `L.keys`를 구현함으로써 객체를 generator를  
  이용해서 iterator로 만들어서 이터러블 프로그래밍을 할 수 있도록 했다.  
  이는 곧 **어떤 generator든 iterator로 만들어서 이터러블 프로그래밍을 할 수 있다** 는 이야기이다.

- 아래 코드 처럼 즉시 실행되는 Generator 함수가 있다고 해보자.

```js
const it = (function* () {
  yield 10;
  yield 20;
  yield 30;
})();

console.log([...it]); // [10, 20, 30]
```

- 아래와 같이 문장형으로 된 Generator 함수를 자유롭게 사용할 수도 있다.

```js
const g1 = function* (stop) {
  let i = -1;
  while (i++ < stop) {
    yield 10;
    if (false) yield 20 + 30;
    yield 30;
  }
};

console.log([...g1(3)]); // [10, 30, 10, 30, 10, 30]
```

- 이렇게 어떠한 값이든 iterator로 만들어서 이터러블 프로그래밍을 할 수 있다.

<hr/>

<h2>object</h2>

- `[['a', 1], ['b', 2], ['c', 3]]`인 값을 `{a: 1, b: 2, c: 3}`으로 만드는 `object()`  
  함수를 만들어보자.

```js
const a = [
  ["a", 1],
  ["b", 2],
  ["c", 3],
];
const object = (entries) =>
  _.go(
    entries,
    L.map(([k, v]) => ({ [k]: v })),
    _.reduce(Object.assign)
  );

console.log(object(a)); // { a: 1, b: 2, c: 3 }
```

- 다른 방식으로도 구현해보자.

```js
const object1 = (entries) =>
  _.reduce((obj, [k, v]) => ((obj[k] = v), obj), {}, entries);

console.log(object1(a)); // { a: 1, b: 2, c: 3 }

console.log(object1(L.entries({ b: 2, c: 3 }))); // { b: 2, c: 3 }
```

- 아래와 같은 Map 자료구조가 있고, 이를 객체화하고 싶다고 해보자.  
  놀랍게도 이미 만든 `object()` 함수에 넣어주면 된다.

```js
let m = new Map();
m.set("a", 1);
m.set("b", 2);
m.set("c", 3);

console.log(object(m)); // { a: 1, b: 2, c: 3 }
```

- 이게 가능한 이유는 `Map`이 Iterator / Iterable Protocol을 따르기 때문이다.

- 이렇게 위에서 작성한 `object()`, `object1()` 함수는 Iterator / Iterable Protocol을 따르는  
  값이 전달된다면 무엇이든지 객체로 만들 수 있다는 매우 높은 다형성을 띈다.

<hr/>
