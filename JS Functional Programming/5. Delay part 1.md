# 지연성 part 1.

<h2>range</h2>

- 숫자 하나를 받고, 그 숫자의 크기만한 배열을 반환하는 `range()` 함수를 만들어보자.

```js
const range = (length) => {
  let i = -1;
  let res = [];
  while (++i < length) {
    res.push(i);
  }
  return res;
};

console.log(range(5)); // [0, 1, 2, 3, 4]
```

- 이제 `range()`로 받은 배열 내의 모든 원소를 더하는 코드를 작성해보자.

```js
const add = (a, b) => a + b;
const list = range(4);
console.log(list); // [0, 1, 2, 3]
console.log(reduce(add, list)); // 6
```

<hr/>

<h2>Lazy range</h2>

- 위의 `range()`와 동일한 작동을 하지만, 조금 다른 방식으로 구현해보자.

```js
const L = {};
L.range = function* (length) {
  let i = -1;
  while (++i < length) {
    yield i;
  }
};

const list = L.range(4);
console.log(list); // L.range {<suspended>}

console.log(reduce(add, list)); // 6
```

- `range()`와 `L.range()`를 호출했을 때의 결과는 동일하다.  
  하지만 이 둘은 차이점이 있는데, list를 찍어보았을 때의 결과가 다르다는 것이다.  
  `L.range()`로 만들어진 list는 iterator를 반환하게 된다.  
  `reduce(add, list)`가 동일한 결과를 나타낸 이유는 `reduce()`가  
  iterable을 받기 때문이다. 즉 `range()`가 반환하는 배열도 iterable이고,  
  `L.range()`가 반환하는 iterator도 iterable이기 때문에 동일한 것이다.

- 좀 더 차이를 근본적으로 알아보자. `range(4)`로 만들어진 list는 `reduce()`에  
  인자로 전달되기 전에 이미 `[0, 1, 2, 3]`의 값을 가지게 된다.  
  반면, `L.range(4)`로 만들어진 list는 `reduce()`에 인자로 전달되기 전에는  
  아직 값이 평가되기 전의 상태이다. 실제로 `L.range()` 함수 몸체의 어디에 로그를 찍어봐도  
  아무런 값도 출력되지 않는다. 실제로 값이 평가되는 시점은 iterator가 내부를 순회할 때 이다.  
  즉, `list.next()`가 호출될 때 값이 1개씩 평가된다는 뜻이다.

- `range()`는 바로 배열을 만들어서 반환하는 반면, `L.range()`는 값이 필요할 때에  
  값을 평가하기 때문에 더 효율적이다. 실제로 이 둘의 효율성이 어떻게 차이가 있는지 보자.

```js
function test(name, time, fn) {
  console.time(name);
  while (time--) fn();
  console.timeEnd(name);
}

test("range", 10, () => reduce(add, range(100000)));
test("L.range", 10, () => reduce(add, L.range(100000)));
```

- 실제로 결과값을 보면 아래와 같다.

```
range: 66.968ms
L.range: 39.169ms
```

<hr/>

<h2>take</h2>

```js
const take = (limit, iterable) => {
  let res = [];
  for (const a of iterable) {
    res.push(a);
    if (res.length === limit) return res;
  }
  return res;
};
```

- 위처럼 `take()`는 2개의 인자를 받고, iterable 인자를 limit 만큼 순회하다가 결과를 반환한다.

```js
console.log(take(5, range(100))); // [0, 1, 2, 3, 4, ...99 ]
console.log(take(5, L.range(100))); // [0, 1, 2, 3, 4, ...99]
```

- `L.lazy()`와 같이 지연성을 가지는 값을 iterator로 만든다면, 다른 함수가 iterable protocol만 따른다면  
  다른 함수에서도 아무런 문제 없이 사용할 수 없다.

- `take(5, range(100))`의 같은 경우, `range(100)`가 값을 이미 평가한 상태에 `take()`의 인자로 전달된다.  
  하지만 `take(5, L.range(100))`의 경우에는 최대 5번의 순회를 할 수 있지만, 순회할 시에 값이 평가되므로  
  훨씬 효율적이다.
