# Nearby Friends

- 이번 장에서는 가까운 친구들의 목록을 알려주는 _"Nearby friends"_ 기능을 포함한 확장 가능한 백엔드 시스템을 구현해보자.  
  위치 정보에 대한 접근 권한을 허가한 사용자들에 대해서 모바일 클라이언트는 지리적으로 가까운 친구들의 목록을 보여주게 된다.  
  예를 들어 Facebook에서도 이러한 기능을 제공한다.

- 이전에 본 Proximity Service와 상당히 유사하다는 것을 느낄 수 있겠지만, 자세히 생각해보면 이 둘은 꽤나 큰 차이점이 많다.  
  Proximity Service에서 각 장소의 위치 정보는 변하지 않기에 정적인 반면, Nearby Friends에서는 사용자의 위치가 자주 바뀌기 때문에  
  위치 정보가 더욱 동적이다.

## 문제 이해 및 설계 범위 확정

- 이번에 설계할 시스템의 요구사항은 아래와 같다.

  - 5miles 내에 있어야 _"nearby"_ 하다고 취급한다.
  - 사용자들 간의 거리는 일직선 상의 거리로 계산한다.
  - 사용자 수는 1억 명이며, 이 중 10%만이 Nearby Friends 기능을 사용한다.
  - 위치 정보는 머신 러닝 등을 위해 저장되어야 한다.
  - 10분 이상 활동을 하지 않는 사용자는 인접 친구 목록에 뜨지 않는다.
  - 개인 정보 보호 법 등의 법규에 대한 신경은 쓰지 않아도 된다.

- 추가적으로 아래의 요구 사항들이 있다.

  - 사용자는 모바일 애플리케이션 상에서 가까운 친구들의 목록을 볼 수 있어야 한다. 각 친구들에 대해서는 일직선 상의 거리와 마지막으로 거리가  
    갱신된 timestamp를 나타내준다.
  - 가까운 친구들의 목록은 몇 초 마다 갱신되어야 한다.
  - Low latency: 친구들의 위치 정보를 빠르게 갱신하기 위해 지연 시간이 낮아야 한다.
  - Reliability: 시스템은 전체적으로 안정적이어야 하고, 가끔 어쩔 수 없는 데이터의 손실은 허용된다.
  - Eventual Consistency: 위치 정보의 저장소는 강한 일관성(strong consistency)를 필요로 하지 않는다.  
    다른 replica들로부터 위치 정보를 조회해 발생하는 몇 초의 delay는 허용된다.

- 이제 위의 요구사항들에 기반해 필요한 정보들을 수치화해보자.

  - 가까운 친구들은 5 mile 반경 내에 있는 친구들로 정의된다.
  - 사용자의 위치 정보는 매 30초마다 갱신된다. 30초라는 숫자가 나온 이유는 사람의 걷는 속도가 느리기 때문이다.  
    30초 동안 걷는다고 했을 때, 걷기 전의 위치와 30초 후의 위치는 그렇게 큰 차이가 없다.
  - 평균적으로 매일 1000만 명의 사용자가 "Nearby Friends" 기능을 사용한다.
  - 동시 접속자의 수는 DAU의 10%라고 해보자. 따라서 동시 접속자 수는 100만 명이다.
  - 평균적으로 한 사용자는 400명의 친구가 있다. 그리고 이 400명 모두가 "Nearby Friends" 기능을 사용한다 가정한다.
  - 앱은 한 페이지당 20명의 가까운 친구들을 표시하며, 추가적인 요청에 의해 더 많은 가까운 친구들을 불러올 수 있다.
  - QPS를 계산하는 과정은 아래와 같다.
    - DAU: 1000만 명
    - 동시 접속자 수: `1000만 * 10% = 100만`
    - 사용자는 자신의 위치 정보를 30초마다 갱신시킨다.
    - 위치 정보 갱신의 QPS는 `100만 / 30 = 334,000` 이다.

---

## 개략적 설계안 제시 및 동의안 구하기

- 이번에는 아래의 내용들을 다뤄보자.

  - 개략적 설계
  - API 설계
  - 데이터 모델

- 보통 개략적 설계안을 생각하기 전에 API와 데이터 모델을 먼저 하지만, 이 시스템의 경우 사용자의 위치 정보를 모든 친구들에게 보내야(push)하기 때문에  
  client, server 사이의 평범한 HTTP Protocold을 사용하지 않을 수도 있다. 개략적 설계안을 이해하기 전에 API를 먼저 보면 더 이해가 어렵기에  
  개략적 설계안 부터 보자.

### 개략적 설계

- 개략적인 관점에서 봤을 때 이 시스템은 message를 쉽게 전달할 수 있어야 한다. 개념적으로 한 사용자는 모든 가까운 친구들의 위치 정보가 갱신되는 것을  
  알아야 한다. 이론적으로는 peer-to-peer로 구현 가능하다. Peer-to-peer에서는 아래 그림과 같이 사용자가 모든 가까운 친구들과  
  persistent한 connection을 맺는다.

![picture 1](/images/SDI2_NF_1.png)

- 하지만 배터리 소모량이 많고 가끔씩 connection이 끊기는 일이 발생하기에 Peer-to-peer 를 사용하는 방식은 여기에서는 적합하지 않다.

- 조금 더 괜찮은 방식은 아래처럼 Backend를 활용하는 방식일 것이다.

![picture 2](/images/SDI2_NF_2.png)

- 위 그림에서 Backend의 책임은 아래와 같다.

  - 모든 활성 사용자들의 위치 정보 갱신을 처리한다.
  - 위치 정보 갱신을 처리할 때마다 이 정보를 받아야할 해당 사용자의 가까운 활성 친구들에게 전달한다.
    - 활성 친구들 중 가까운 친구들(이 시스템에서는 5 miles 이내)에게만 전달한다.

- 위 아키텍쳐를 사용하는 것은 꽤나 간단해 보인다. 무엇이 문제일까? 바로 쉽게 확장할 수 없다는 것이다.  
  이 시스템은 1000만 명의 활성 사용자가 있다. 각 사용자가 30초마다 자신의 위치 정보를 갱신하면 1초 당 약 334,000개의 갱신이 발생한다.  
  평균적으로 한 사용자는 400명의 친구가 있고, 이들 중 10%가 활성이며 가깝게 있다면 총 일어나는 위치 갱신은 `334,000 _ 400 _ 10% = 1400만`이다.

### 계략적 설계안

- 우선 이 시스템의 개략적 설계안을 보자. 이후에 확장을 쉽게 할 수 있도록 최적화를 진행해보자.

- 아래 그림은 요구사항을 어느 정도 만족하는 기본적인 설계안이다.

![picture 3](/images/SDI2_NF_3.png)

- 각 컴포넌트들을 하나씩 살펴보자.

#### Load Balancer

- Load balancer는 RESTful API 서버들과 stateful하며 양방향 통신을 제공하는 WebSocket 서버들 앞에 위치한다.  
  트래픽을 이들 서버로 분산시켜주는 역할을 담당한다.

#### RESTful API Servers

- RESTful API 서버는 일반적인 request/response 형태의 트래픽을 처리하는 stateless한 HTTP 서버들의 클러스터이다.  
  API 요청의 흐름은 아래 그림에서 확인할 수 있다. API layer에서 친구 추가, 삭제, 사용자 프로필 갱신 등을 처리한다.  
  이런 요청은 매우 흔하므로 더 깊게 살펴보지 않겠다.

![picture 4](/images/SDI2_NF_4.png)

#### WebSocket Servers

- WebSocket 서버는 친구들의 위치 정보 갱신을 거의 실시간으로 처리해내는 stateful 서버들의 클러스터이다. 각 클라이언트는 이 서버들 중 하나의  
  서버와 persistent한 WebSocket connection을 맺고 있다. 검색 반경 내에 있는 친구로부터 위치 정보 갱신이 발생하면, 이 갱신된 정보가  
  클라이언트에게 해당 connection으로 전달된다.

- WebSocket server의 또다른 큰 책임은 "Nearby Friends" 기능을 사용하기 위해 클라이언트의 초기화를 처리하는 것이다.  
  즉 모든 가까운 활성 친구들의 목록을 클라이언트에게 초기에 전달해줘야 한다.

#### Redis Location Cache

- 여기서 Redis는 각 활성 사용자의 가장 최근 위치 정보를 저장하기 위해 사용된다. Cache의 entry 각각에는 TTL이 설정되고, 이 TTL이  
  만료되면 해당 사용자는 더 이상 활성으로 간주되지 않고 위치 정보가 cache에서 제거된다. 위치 정보의 갱신은 TTL도 함께 갱신한다.  
  TTL이 핵심이기에 TTL 기능을 제공하는 다른 Key-Value store도 Redis 대신 사용 가능하다.

#### User Database

- User database는 사용자 정보와 사용자의 친구 관계를 저장한다. RDB 또는 NoSQL Database 모두가 사용될 수 있다.

#### Location History Database

- Location history database는 사용자의 위치 정보들을 기록한다. 이 컴포넌트는 "Nearby Friends" 기능과 직접적으로 연관되지는 않는다.

#### Redis Pub/Sub Server

- Redis Pub/Sub는 굉장히 가벼운 message bus이다. Redis Pub/Sub은 Channel을 통해 message들을 주고 받는데, 이 Channel을 만드는  
  비용도 매우 저렴하다. GB 단위의 메모리를 사용하는 최신 Redis server는 수천만개의 channel을 관리할 수 있다.  
  아래 그림은 Redis Pub/Sub이 어떻게 동작하는지를 개략적으로 나타낸다.

![picture 5](/images/SDI2_NF_5.png)

- 이 설계에서 WebSocket server가 수신한 위치 정보 갱신은 Redis Pub/Sub server를 사용해 해당 사용자의 Channel로 전달된다.  
  이 channel에 구독하는 것은 해당 사용자의 친구가 WebSocket server와 맺은 connection을 통해 WebSocket server가 담당한다.  
  위치 정보 갱신이 발생하면 WebSocket의 handler가 호출되고, 각 활성 친구들에 대해 함수가 일직선 상의 거리를 다시 계산한다.  
  새롭게 계산된 거리가 검색 반경(5 miles) 내에 있으면 새로운 위치 정보와 timestamp가 WebSocket을 통해 각 친구의 단말로 전송된다.  
  꼭 Redis Pub/Sub가 아닌 다른 경량화된 channel과 message bus를 제공하는 솔루션도 사용 가능하다.

#### 주기적인 위치 정보 갱신 처리 흐름

- 주기적으로 위치 정보가 갱신될 때의 흐름을 조금 더 자세히 살펴보자. 기본적으로 모바일 클라이언트는 WebSocket server와의 persistent한  
  connection 상으로 주기적으로 갱신되는 위치 정보를 보낸다. 아래 그림은 전체적인 흐름을 나타낸다.

![picture 6](/images/SDI2_NF_6.png)

- (1) 모바일 클라이언트가 위치 정보 갱신 요청을 Load Balancer에게 보낸다.
- (2) Load Balancer는 위치 정보 갱신 요청을 해당 클라이언트가 WebSocket과 수립한 persistent connection을 사용해 WebSocket  
  Server로 전달한다.
- (3) WebSocket server는 위치 정보를 Location History Database에 저장한다.
- (4) WebSocket Server는 Location Cache에 해당 사용자의 위치 정보를 갱신된 정보로 업데이트한다.  
  이 갱신 작업은 해당 entry의 TTL도 함께 갱신시킨다. 이후 WebSocket Server는 새로운 위치 정보를 거리 계산 과정의 최적화를 위해  
  해당 사용자가 사용하는 WebSocket connection에 특정 변수로 저장한다.
- (5) WebSocket server는 새로운 위치 정보를 해당 사용자의 Redis Pub/Sub Server channel로 publish한다.  
  (3) ~ (5)는 병렬적으로 수행될 수 있다.
- (6) Redis Pub/Sub Server의 channel이 새로운 위치 정보를 수신하면 이 갱신 작업을 해당 channel의 모든 구독자(subscriber)들에게  
  전달한다. 이 경우, 구독자들은 사용자의 활성인 친구들이다. 각 구독자의 WebSocket handler가 위치 정보 갱신을 처리한다.
- (7) 메시지를 수신하면 connection handler가 위치한 WebSocket server가 구독자(활성 친구)와 위치 정보를 갱신한 사용자와의 거리를  
  계산한다. 구독자의 위치 정보는 WebSocket connection handler의 변수에 저장되어 있고, 사용자의 새로운 위치 정보는 message에 담겨 있다.
- (8) 이 단계는 그림에는 없다. 사용자와 구독자의 거리가 검색 반경(5 miles)을 초과하지 않는다면 새로운 위치 정보와 갱신된 timestamp가  
  구독자의 클라이언트(단말)로 전달되며, 초과한다면 이 단계는 수행되지 않는다.

- 이 모든 과정을 이해하는 것이 매우 중요하기에 더 구체적인 예시를 통해 살펴보자.

- 시작하기 전, 몇 가지 가정을 하고 넘어가자.
  - `User 1`의 친구들은 `User 2`, `User 3`, 그리고 `User 4`이다.
  - `User 5`의 친구들은 `User 4`와 `User 6`이다.

![picture 7](/images/SDI2_NF_7.png)

- (1) `User 1`의 위치가 변경되면 `User 1`과의 connection을 맺고 있는 WebSocket server로 위치 정보 갱신 요청이 전달된다.
- (2) 위치 정보는 Redis Pub/Sub server에서 `User 1`이 사용하는 channel로 전달된다.
- (3) Redis Pub/Sub server는 해당 channel을 구독 중인 모든 subscriber들에게 갱신된 위치 정보를 전달한다.  
  여기서 subscriber들은 `User 1`의 친구들이 WebSocket server와 맺은 connection이다.
- (4) 위치 정보를 보내는 사용자(`User 1`)와 구독자 각각에 대해 거리를 계산하고, 이 거리가 특정 범위(5 miles)를 넘지 않는다면  
  새로운 위치가 구독자의 클라이언트에게 전달된다. 이 경우 `User 2`만 거리가 범위 내에 있다고 하자.

- 위 과정은 channel의 모든 구독자들에 대해 수행된다. 초기에 요구사항에서 각 사용자는 평균적으로 400명의 친구가 있고, 이들 중 10%가  
  활성이며 "Nearby Friends" 기능을 사용한다고 가정했기에 한 사용자가 위치 정보를 갱신하면 위 과정은 40번 수행될 것이다.

### API 설계

- 개략적 설계안을 살펴보았으니, 필요한 API들을 보자.

#### WebSocket

- 사용자는 WebSocket protocol을 사용해 위치 정보 갱신을 보내고, 수신한다.  
  최소한으로 아래의 API들이 필요할 것이다.

  - 주기적 위치 정보 갱신
    - Request: 클라이언트가 위도, 경도와 timestamp를 보낸다.
    - Response: Nothing
  - 클라이언트가 위치 정보 갱신을 수신
    - 전달되는 데이터: 친구의 위치 정보와 timestamp
  - WebSocket 초기화 과정
    - Request: 클라이언트가 위도, 경도와 timestamp를 보낸다.
    - Response: 클라이언트가 친구들의 위치 정보를 받는다.
  - 새로운 친구 구독
    - Request: WebSocket server가 친구의 ID를 보낸다.
    - Response: 해당 친구의 가장 최근 위도, 경도 그리고 timestamp
  - 친구 구독 취소
    - Request: WebSocket server가 친구의 ID를 보낸다.
    - Response: Nothing

#### HTTP Requests

- API Server는 친구 추가, 삭제, 사용자 프로필 갱신 등의 요청을 처리한다.

### 데이터 모델

- 데이터 모델 또한 꽤나 고려해야 하는 요소이다. User Database에 대해서는 개략적 설계 부분에서 살펴보았으니 여기서는 Location Cache와  
  Location History Database를 중점적으로 다뤄보자.

#### Location Cache

- Location Cache는 활성 사용자 중 Nearby Friends 기능이 켜져 있는 모든 사용자들의 가장 최근 위치 정보를 저장한다.  
  여기서는 Redis를 사용하기로 했다. 아래는 Redis에 들어가는 key-value paird의 구조이다.

|   key   |              value               |
| :-----: | :------------------------------: |
| user_id | {latitude, longitude, timestamp} |

##### 왜 사용자 정보를 저장하는 데 DB를 사용하지 않을까?

- Nearby Friends 기능은 오로지 특정 사용자의 **현재 위치**만을 필요로 한다. 따라서 한 사용자 당 하나의 위치 정보만 저장하면 된다.  
  이때 Redis는 굉장히 빠른 read, write 연산 속도를 제공하기 때문에 아주 좋은 선택지가 될 것이다. 또한 TTL도 제공하기에  
  cache에 위치 정보가 없는 사용자를 비활성 사용자로 처리하게끔 할 수도 있다. 가장 최근 위치 정보는 꼭 내구성 있게 저장될 필요가 없다.  
  만약 Redis 인스턴스에 장애가 난다면 단순히 아무런 정보가 없는 새로운 인스턴스로 교체하고, 새로운 위치 정보가 오면 해당 정보들로  
  cache를 채우도록 하면 된다. 물론 Redis에 장애가 나면 활성 사용자들은 1 또는 2번의 주기 동안 위치 정보를 못 불러올 수 있다.  
  하지만 이는 납득 가능한 tradeoff이다.

#### Location History Database

- Location History Database는 사용자의 모든 위치 정보들을 저장한다. 스키마는 아래와 같다.

| user_id | latitude | longitude | timestamp |
| :-----: | :------: | :-------: | :-------: |

- 여기에 사용할 데이터베이스는 많은 write 연산을 처리할 수 있고 수평적 확장이 가능해야 한다. Cassandra가 좋은 선택지가 될 것이다.  
  RDB를 사용할 수도 있지만, 모든 위치 정보를 한 대의 RDB가 처리하기는 어려울 수 있으므로 데이터를 sharding해야 한다.  
  가장 기본적인 접근 법은 사용자 ID로 sharding을 하는 것이다. 이렇게 sharding하면 부하가 shard들로 골고루 분산됨이 보장되고,  
  유지보수하기도 쉽다.

---

## 상세 설계

- 개략적 설계안에서 설계한 시스템은 대부분의 경우 잘 동작하겠지만, 이 시스템의 요구사항을 만족시키기엔 조금 부족할 수 있다.  
  이번에는 scale을 높이면서 마주칠 수 있는 병목 현상들을 생각해보고, 그 병목 지점들을 어떻게 처리해갈지 자세히 살펴보자.

### 각 컴포넌트가 얼마나 쉽게 확장할 수 있는가?

#### API Servers

- RESTful API tier를 확장하기 위한 방법들은 매우 많다. 이들은 모두 stateless한 서버들이고 CPU 사용량, 부하, 또는 IO 등을 기준으로  
  클러스터를 auto-scale하는 방법 또한 매우 많다.

#### WebSocket Servers

- WebSocket cluster는 사용량에 따라 auto scaling하기 어렵지 않다. 하지만 WebSocket server들은 stateful하므로 존재하는 node를  
  삭제할 때 주의 깊게 처리해야 한다.

- 특정 node가 제거되기 전에, 해당 node에 붙어 있는 connection들이 끊겨질 수 있는 상황이 되어야 한다.(connection drain)  
  이를 구현하기 위해 해당 node를 _"draining"_ 상태로 변경해 load balancer가 새로운 WebSocket connection을 해당 node와  
  수립하지 않도록 할 수 있다. 해당 node에 수립된 모든 connection들이 닫히면, 그제서야 해당 node는 삭제될 수 있다.

- Node 삭제 뿐만 아니라 WebSocket server를 새롭게 배포할 때도 동일한 로직이 적용되어야 한다.

- 즉 stateful server들의 원활한 auto scaling을 수행하려면 **Load Balancer가 이를 잘 처리해야 한다.**  
  대부분의 cloud load balancer들은 이를 매우 잘 처리한다.

##### Client Initialization

- 모바일 클라이언트는 실행 시 WebSocket server들 중 하나와 persistent한 WebSocket connection을 수립한다. 각 connection은 오랫동안  
  유지되고 사용된다. 대부분의 현대 프로그래밍 언어들은 오랫동안 사용되는 connection을 많이, 그리고 적은 메모리로 잘 관리할 수 있도록 한다.

- WebSocket connection이 초기화되면 클라이언트는 해당 사용자의 초기 위치 정보를 보내고, 이 정보를 받은 WebSocket connection handler는  
  아래의 작업들을 수행한다.

  - (1) Location Cache에서 사용자의 위치 정보 갱신
  - (2) 거리 계산을 용이하게 하기 위해 connection handler의 변수에 사용자의 위치를 저장한다.
  - (3) User Database에서 사용자의 모든 친구들을 불러온다.
  - (4) (3)에서 찾은 모든 친구들의 위치 정보를 조회하는 batch request를 Location Cache에 보낸다.  
    Location Cache의 각 entry에는 TTL이 있고, 만약 친구의 위치 정보가 Location Cache에 없다면 해당 친구는 비활성 상태인 것이다.
  - (5) Location Cache로부터 반환된 각 위치 정보에 대해 해당 사용자와 친구의 거리를 계산한다. 만약 거리가 주어진 요구사항 내에 있다면  
    친구 정보, 위치 정보, 그리고 마지막 갱신된 timestamp가 WebSocket connection을 통해 client에게 전달된다.
  - (6) 각 친구에 대해 서버는 Redis Pub/Sub server에 있는 친구의 channel에 subscribe(구독)한다.  
    새로운 channel을 만드는 비용이 매우 적으니, 사용자는 활성이든 비활성이든 관계없이 모든 친구들의 channel에 구독한다.  
    비활성 상태인 친구들은 Redis Pub/Sub Server에서 적은 양의 메모리를 차지하겠지만, 활성이 되기 전까지 CPU나 I/O는 소모하지 않는다.
  - (7) 사용자의 현재 위치를 Redis Pub/Sub Server에 있는 해당 사용자의 channel에 publish한다.

#### User Database

- User Database는 크게 두 가지 데이터를 저장한다.

  - 사용자 프로필(user ID, username, profile URL 등)
  - 친구 관계

- 이 데이터는 한 대의 RDB instance로 쉽게 확장하기 어렵다. 대신 User ID를 기준으로 sharding을 수행하면 된다.  
  RDB Sharding은 매우 흔히 사용되는 기술이다.

- 추가적으로 사용자와 친구 관계 데이터는 특정 팀에 의해 관리되고, 내부 API(Internal API)로 조회할 수 있을 수도 있다.  
  이전에 WebSocket Server가 사용자 정보와 친구들을 불러오기 위해 데이터베이스에 직접 query한다고 했는데, 이 대신 internal API를  
  호출할 수도 있을 것이다. Internal API를 사용하든 데이터베이스에 직접 query하든 성능이나 요구사항 만족 면에서는 아무런 차이가 없다.

#### Location Cache

- 이전에 모든 활성 사용자의 위치 정보를 저장하기 위해 Redis를 사용한다고 했다. 각 entry(key)에는 TTL이 지정된다.  
  그리고 위치 정보가 갱신되면 TTL도 함께 갱신된다. 이는 Redis가 사용할 수 있는 최대 메모리에 제한을 거는 것과 마찬가지 효과를 발생시킨다.  
  최대 1000만 사용자가 있고, 각 사용자의 위치 정보가 100byte를 차지한다 했을 때 GB 단위의 메모리를 사용하는 최신 Redis Server는  
  이를 쉽게 처리할 수 있을 것이다.

- 하지만 peak에는 1000만 사용자가 자신의 위치 정보를 30초마다 갱신시키게 된다. 즉 Redis server가 1초당 약 334,000건의 요청을  
  처리해야할 수도 있다는 것이다. 이는 최신 Redis를 사용하더라도 부하를 발생시킬 수 있다. 이럴 때는 cache data도 sharding하면 된다.  
  사용자의 위치 정보들은 서로 독립적이기 때문에 User ID를 기반으로 쉽게 여러 대의 Redis Server들로 정보를 분산시킬 수 있다.

- 가용성을 향상시키기 위해 각 shard에 저장된 위치 정보들을 standby node에 복제시킬 수도 있다.  
  이렇게 하면 Primary node가 죽으면 standby node가 재빠르게 primary로 승급되어 downtime을 최소화할 수 있을 것이다.

#### Redis Pub/Sub Server

##### Redis Pub/Sub Server가 얼마나 필요할까?

- 메모리 사용량
- CPU 사용량
- 분산된 Redis Pub/Sub Server Cluster
- Redis Pub/Sub Server 확장 시 고려해야하는 사항
- Redis Pub/Sub Server 운영 시 고려해야하는 사항
- 친구 추가 및 삭제
- 친구가 매우 많은 사용자
- 주변에 있는 random 사용자 보여주기
- Redis Pub/Sub 의 대안들

---
