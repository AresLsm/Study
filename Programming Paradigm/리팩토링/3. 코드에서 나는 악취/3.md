# 코드에서 나는 악취(3)

<h2>메시지 체인</h2>

- 메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤, 방금 얻은 객체에  
  또다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.  
  가령 `getSomething()` 같은 geter가 꼬리에 꼬리를 물고 이어지거나, 임시 변수들이  
  줄줄이 나열되는 코드가 있다. 이는 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미한다.  
  그래서 내비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야 한다.

- 이 문제는 **위임 숨기기**로 해결한다. 이 리팩토링은 메시지 체인의 다양한 연결점에  
  적용할 수 있다. 원칙적으로 체인을 구성하는 모든 객체에 적용할 수 있지만, 그러다 보면 중간 객체들이  
  모두 중개자가 돼버리기 쉽다. 그러니 **최종 결과 객체가 어떻게 쓰이는지부터 살펴보는게 좋다.**  
  **함수 추출하기**로 결과 객체를 사용하는 코드 일부를 따로 빼낸 다음 **함수 옮기기**로  
  체인을 숨길 수 있는지 살펴보자. 체인을 구성하는 객체 중 특정 하나를 사용하는 클라이언트 중  
  그 이후의 객체들도 사용하길 원하는 클라이언트가 제법 많다면, 이 요구를 처리해줄 메소드를 추가한다.

- **위임 숨기기**는 이해하기 난해할 수 있는 방법이니, 예시를 살펴보자.  
  우선 아래 코드가 메시지 체인의 전형적인 예시이다.

```js
const managerName = person.department.manager.name;
```

- _"체인을 구성하는 모든 객체에 위임 숨기기를 적용할 수 있다."_ 고 함은 managerName을  
  바로 반환하는 메소드를 `Person` 클래스에 추가할 수도 있고, `Department` 클래스에  
  추가할 수도 있다는 뜻이다.

```js
// Manager의 존재를 숨김
const managerName = person.department.managerName;

// Department의 존재를 숨김
const managerName = person.manager.name;

// Department, Manager의 존재를 모두 숨김
const managerName = person.managerName;
```

- 이 체인의 최종 결과 객체는 결국 `Manager.name`이다.  
  이 객체가 다음처럼 쓰인다고 해보자.

```js
const managerName = person.department.manager.name;
let report = `${managerName}의 보고서 ~~~~`;
console.log(report);
```

- 여기서 report 생성 로직을 함수로 추출한 다음 적당한 모듈로 옮기면 체인의 존재가 감춰진다.

```js
console.log(reportGenerator.report(person));
```

- 마지막으로 체인의 중간 단계인 `Department` 정보를 얻어 사용하는 다수의 클라이언트가 `Manager.name`도  
  함께 사용한다면 `Department` 클래스에 `managerName()` 메소드를 추가하여 체인을 단축할 수 있다.

<hr/>

<h2>중개자</h2>

- 객체의 대표적인 기능 하나로, 외부로부터 세부사항을 숨겨주는 **캡슐화**가 있다.  
  캡슐화하는 과정에서는 **위임**이 자주 활용된다. 예를 들어 여러분이 팀장에게 미팅을  
  요청한다 해보자. 팀장은 자신의 일정을 확인한 후 답을 준다. 이러면 끝이다.  
  팀장이 종이 다이어리를 쓰든, 일정 서비스를 쓰든 이는 알바가 아니다.

- 하지만 지나치면 문제가 된다. 클래스가 제공하는 메소드 중 절반 이상이 다른 클래스에  
  구현을 위임하고 있다면 어떨까? 이럴 때는 **중개자 제거하기**를 활용하여 실제로 일을 하는 객체와  
  직접 소통하게 하자. 위임 메소드를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인하자.(**함수 인라인하기**)

<hr/>
