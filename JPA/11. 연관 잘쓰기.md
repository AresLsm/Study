<h1>연관 잘 쓰기</h1>

<h2>연관의 복잡성</h2>

* 모든 Entity가 서로 연관된 모델을 사용하는 경우가 있다. JPA의 연관을 사용하면 관련 데이터에 쉽게 접근할 수 있다. 아래 예시를 보자.
```java
Order order = entityManager.find(Order.class, orderId);
List<OrderLine> orderLines = order.getOrderLines();
for(OrderLine line : orderLines) {
    Content content = line.getProduct().getContent();
    // content 사용
}
```

* 위 코드는 `Order` Entity에서 `OrderLine`, `Product`를 거쳐 `Content`까지 접근하고 있다. 모든 연관을 즉시 로딩으로 설정했다면   
  `Order`를 로딩하는 시점에 나머지 Entity들을 로딩하기 위한 query도 같이 수행될 것이다. 하지만 `Order` Entity 하나를 로딩하는데   
  연관된 모든 Entity를 로딩하는 것은 비효율적이다. 이럴 때에 Entity를 어떤 식으로 사용할지를 미리 고려햐여 지연 로딩과 즉시 로딩을   
  적절하게 사용해야 한다.

* 하지만 지연 로딩과 즉시 로딩을 적절하게 섞어 사용하는 것이 쉽지만은 않다. 상황에 따라 필요한 연관 객체가 다르기 때문이다.

<h3>편리한 객체 탐색과 높은 결합도</h3>

* 모든 Entity를 연관으로 연결하면 객체 탐색을 통해서 쉽게 원하는 객체에 접근할 수 있다. 만약 `Order`와 `User`가 연관으로   
  연결되어 있다면 아래와 같이 `Order`객체의 메소드에서 `User`객체의 정보를 변경하는 것이 가능하다.
```java
public class Order {

    private User owner;  // User와 연관

    public void changeShippingAddress(Address newAddress, boolean useUserAddress) {
        this.shippingAddress = newAddress;
        if(useUserAddress) {
            // 연관된 User의 데이터 변경
            owner.setAddress(newAddress);
        }
    }
}
```
* 위와 같이 연관된 객체를 사용하면 처음에는 편리하게 기능을 구현할 수 있지만, 이는 `Order`가 `User`에 강하게 영향을 받게 한다.   
  예를 들어 `User#setAddress()`가 `Address` 대신에 다른 타입을 필요로 하면 `Order#changeShippingAddress()`의 인수도 그에 맞게   
  변경되어야 한다. 반대로 `Order`가 `shippingAddress()`의 타입을 `Address`가 아닌 다른 타입으로 변경하는 경우에도   
  `orderer#changeShippingAddress()`에 관련 코드를 추가해야 한다.

* 사실 `Order`의 입장에서 배송지 주소 변경 기능 자체는 `User`의 주소 변경과 관련이 없다. `Order`는 주문과 관련된 배송지 주소   
  변경 로직만 구현하면 된다. 단지 연관된 객체를 이용하면 기능을 구현하기 쉽기에 `Order`의 배송지 주소를 변경하면서 연관된   
  `User`객체의 주소도 함께 변경한 것이다.

* 이렇게 한 Entity에서 다른 Entity의 상태를 변경하는 기능을 실행하면 Entity가 서로 강하게 엮이게 되면서 서로 수정을 어렵게   
  만드는 원인이 될 수 있다.
<hr/>

<h2>연관 범위 한정과 식별자를 통한 간접 참조</h2>

* Entity간의 참조가 많아질수록 한 Entity의 기능을 변경할 때 여러 Entity를 함께 수정해야할 가능성이 커진다. 이는 코드 변경을   
  어렵게 하는 원인이 되는데, 이를 해결하는 방법은 아래의 두 가지를 사용하면 된다.
  * 연관의 범위를 도메인을 기준으로 한정
  * 도메인을 넘어서는 Entity간에는 식별자를 이용한 간접 참조 사용

* 위의 방식을 사용하면 특정 영역 안에서는 연관을 이용해서 직접 참조를 유지하지만, 영역을 벗어나는 관계에 대해서는 식별자를 이용해서   
  간접적으로 참조할 수 있게 된다.
```java
public class Order {

    private List<OrderLine> orderLines;  // 영역 내의 모델은 직접 참조
    private String userId;  // 영역 밖의 Entity는 식별자로 참조
}
```
  * 위 코드에서 `Order`는 `OrderLine`을 직접 참조했지만, 다른 영역에 위치한 `User`는 식별자 값만 갖게 된다.

* `Order`에서 `User`를 식별자로 참조했기에 더 이상 `Order`에서 `User`의 주소를 변경할 수 없다. 대신 응용 서비스 코드에서 두   
  Entity를 로딩해서 각 Entity의 값을 변경하는 방식으로 바뀐다.
```java
public class ShippingAddressService {

    public void changeShippingAddress(String orderId, Address newAddress, boolean useUserAddress) {

        Order order = findOrder(orderId);
        if(order == null) throw new OrderNotFoundException();

        order.changeShippingAddress(newAddress);
        if(useUserAddress) {
            User user = findUser(order.getUserId());
            user.setAddress(newAddress);
        }
    }
}
```

* 식별자를 통한 간접 참조 방식을 사용하면 식별자로 연관된 Entity를 검색하는 과정이 추가되기에 다소 코드가 길어지지만, 식별자를 통한   
  간접 참조를 사용하면 로딩 설정의 어려움, Entity간의 결합도 증가 문제를 완화할 수 있다.
  * 먼저 로딩과 관련된 문제가 단순해진다. 식별자를 사용하기에 위 서비스 코드처럼 명시적으로 연관된 Entity를 구한다. 이는 연관된   
    Entity를 지연 로딩으로 조회하는 것과 동일하다. 로딩 설정으로 고민할 필요가 없는 만큼 매핑 설정 코드도 단순해진다.
  * 두 번째로 Entity간의 강한 결합도 줄어든다. `Order` Entity에서 다른 영역에 위치한 `User` Entity의 메소드를 실행할 일이   
    없어지므로 `Order` Entity는 `User` Entity 수정에 영향을 받지 않는다.
<hr/>

