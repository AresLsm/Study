# Asynchronous Programming Techniques

- 개발자들은 개발을 하면서 Application이 블로킹되는 현상을 막기 위해 다양한 노력을 했다.  
  어떠한 유형의 애플리케이션을 개발하더라도 사용자가 오래동안 기다리게 하면 안되고, 애플리케이션이 탄력적으로  
  확장/축소할 수 있게끔 해야 했다.

- 아래는 이러한 문제를 해결하기 위해 나온 것들이다.

  - Threading
  - Callbacks
  - Future, Promise, others
  - Reactive Extensions
  - Coroutines

<h2>Threading</h2>

- Threading은 애플리케이션 블로킹 현상을 피하기 위해 가장 잘 알려진 방법이다.

```kt
fun postItem(item: Item) {
    val token = preparePost()
    val post = submitPost(token, item)
    processPost(post)
}

fun preparePost(): Token {
    // Request를 만들고 Main Thread를 block한다.
    return token
}
```

- 위 코드에서 `preparePost()` 메소드가 상당히 오래 걸리는 프로세스라면 사용자의 인터페이스도 그만큼 블로킹될 것이다.  
   여기서 우리가 할 수 있는 방법 중 하나는 다른 thread에서 이 작업을 하도록 하는 것이다. 이렇게 한다면 UI가 같이 blocking되는  
   현상은 피할 수 있다. 이는 가장 흔한 기술이지만, 아래의 단점들을 가진다.
  - Thread는 가벼운 리소스가 아니다. Thread를 다루려면 Context-Switching이 발생하는데, 매우 큰 연산 비용이 소모되는 작업이다.
  - Thread는 무한정 사용할 수 있는 것이 아니다. 기반 OS에 따라 사용할 수 있는 Thread의 최대 개수가 한정되며,  
    Server Side Application의 경우 이는 매우 큰 문제를 발생시킬 수 있다.
  - Thread는 항상 사용할 수 없다. JavaScript의 경우에는 Thread 자체를 제공하지 않는다.
  - Thread를 다루는 것은 결코 쉽지 않다. Thread를 디버깅하고, 경합 현상을 피해야 하는 것은 multi-thread programming에서  
   우리가 항상 겪는 문제이다.
  <hr/>

<h2>Callbacks</h2>

- Callback은 하나의 함수를 또다른 함수의 인자로 전달하여, 내부의 프로세스가 끝나면 인자로 전달된 함수를 실행하는 것이다.

```kt
fun postItem(item: Item) {
    preparePostAsync { token ->
        submitPostAsync(token, item) { post ->
	    processPost(post)
	}}
}

fun preparePostAsync(callback: (Token) -> Unit) {
    // Request를 만들고 즉각 return한다.
    // callback 메소드가 나중에 호출되도록 한다.
}
```

- 괜찮은 방법 같아 보이지만, 아래의 이슈들이 존재한다.

  - 중첩된 callback들은 다루기가 어렵다. 보통 callback으로 사용되는 함수는 그 함수 자체의 callback도 요구한다.  
    이는 callback들의 중첩을 야기하며, 이는 코드의 구조 뿐만 아니라 가독성도 매우 떨어뜨려 다루기가 어려워진다.
  - 중첩되는 만큼 에러 처리도 번거로워진다.

- Callback은 Event-Loop기반의 아키텍쳐를 사용하는 JavaScript와 같은 언어에서는 흔히 사용하지만,  
 그 언어에서도 사용자들은 이제 Promise 또는 Reactive Extensions를 사용한다.
<hr/>

<h2>Futures, Promises, and others</h2>

- Future와 Promise의 기반이 되는 idea를 살펴보자.
  > 우리가 언젠가 호출(call)을 하면, 우리는 이 코드가 언젠가 `Promise`라는 객체로 응답할 것이라 약속(Promise)한다.

```kt
fun postItem(item: Item) {
    preparePostAsync()
	.thenCompose { token ->
	    submitPostAsync(token, item)
	}
	.thenAccept { post ->
	    processPost(post)
	}
}

fun preparePostAsync(): Promise<Token> {
    // Request를 생성하고 나중에 반환될 객체를 담은 Promise 반환
    return promise
}
```

- 이 접근 방법은 개발을 할 때 여러 가지 고려할 점들을 만든다.

  - 다른 프로그래밍 모델을 사용해야 한다. Callback과 비슷하게, 이 접근법은 항상 연쇄 호출(chained call)을 해야 한다.  
    그러면 반복문, 에러처리와 같은 기본적인 프로그래밍 구조를 사용할 수 없게 된다.
  - 일단 `thenCompose`, `thenAccept`와 같은 API를 익히는데 시간이 소요된다.
  - `preparePostAsync()`와 같이 실제 반환되는 타입을 `Promise` 객체로 넣어서 반환해야 하기 때문에 개발자가 직접  
    어느정도 타입 유추를 해야 한다.
  - 에러 처리가 복잡해질 수 있다. Method Chaining을 하는 상황에서 에러는 항상 다음 메소드로 넘어간다는 것이 보장되지 않는다.

<hr/>

- 참고 문서: <a href="https://kotlinlang.org/docs/async-programming.html">Link</a>
