# object 키워드를 통한 클래스 선언과 인스턴스 생성

- 코틀린에서는 object 키워드를 다양한 상황에서 사용하지만 모든 경우  
  **클래스를 정의하면서 동시에 인스턴스를 생성한다는 공통점이 있다.**  
  object 키워드를 사용하는 여러 상황을 살펴보자.

  - **객체 선언(object declaration)** : 싱글톤을 정의하는 방법 중 하나
  - **동반 객체(companion object)** : 인스턴스 메소드는 아니지만, 어떤 클래스와 관련 있는 메소드와  
    팩토리 메소드를 담을 때 사용한다. 동반 객체 메소드에 접근할 때는 동반 객체가 포함된 클래스의 이름을  
    사용할 수 있다.
  - 객체 식은 Java의 무명 내부 클래스(anonymous inner class) 대신 쓰인다.

## 객체 선언: 싱글톤을 쉽게 만들기

- 객체지향 시스템을 설계하다 보면, 인스턴스가 단 하나만 필요한 클래스가 유용한 경우가 많다.  
  Java에서는 보통 클래스의 생성자를 private으로 제한하고, 정적인 필드에 그 클래스의 유일한  
  객체를 저장하는 싱글톤 패턴(Singleton Pattern)을 통해 이를 구현한다.

- 코틀린은 **객체 선언** 기능을 통해 싱글톤을 언어 차원에서 기본 지원한다. 객체 선언은 클래스 선언과  
  그 클래스에 속한 **단일 인스턴스**의 선언을 합친 선언이다.

- 예를 들어, 객체 선언을 사용해 회사 급여 대장을 만들 수 있다. 한 회사에 여러 개의 급여 대장이 필요하진  
  않을 테니 싱글톤을 쓰는 게 정당해보인다.

```kt
object Payroll {
    val allEmployees = arrayListOf<Person>()

    fun calculateSalary() {
	for(person in allEmployees) {
	    //..
	}
    }
}
```

- 객체 선언은 object 키워드로 시작한다. 객체 선언은 클래스를 정의하고 그 클래스의 인스턴스를 만들어서 변수에  
  저장하는 모든 작업을 단 한 문장으로 처리한다.

- 클래스와 마찬가지로 객체 선언 안에도 프로퍼티, 메소드, 초기화 블록 등이 들어갈 수 있다.  
  하지만 **생성자는 주 생성자, 부 생성자 모두 객체 선언에 쓸 수 없다.** 일반 클래스 인스턴스와 달리  
  싱글톤 객체는 객체 선언문이 있는 위치에서 생성자 호출 없이 즉시 만들어진다. 따라서 객체 선언에는  
  생성자 정의가 필요 없다.

- 사용하는 부분을 보자.

```kt
Payroll.allEmployees.add(Person(/* .. */))
Payroll.calculateSalary();
```

- 객체 선언도 클래스나 인스턴스를 상속할 수 있다. 프레임워크를 사용하기 위해 특정 인터페이스를 구현해야하는데,  
  그 구현 내부에 다른 상태가 필요하지 않은 경우에 이런 기능이 유용하다. `java.util.Comparator`를 살펴보자.  
  `Comparator`의 구현은 두 객체를 인자로 받아 그중 어느 객체가 더 큰지 알려주는 정수를 반환한다.  
  `Comparator` 안에는 데이터를 저장할 필요가 없다. 따라서 어떤 클래스에 속한 객체를 비교할 때 사용하는  
  `Comparator`는 보통 클래스마다 단 하나씩만 있으면 된다. 따라서 `Comparator` 인스턴스를 만드는 방법으로는  
  객체 선언이 가장 좋은 방법이다.

- 두 파일 경로를 대소문자 관계없이 비교해주는 `Comparator`를 구현해보자.

```kt
object CaseInsensitiveFileComparator : Comparator<File> {
    override fun compare(file1: File, file2: File): Int {
	return file1.path.compareTo(file2.path, ignoreCase = true)
    }
}
```

- 일반 객체(클래스 인스턴스)를 사용할 수 있는 곳에서는 항상 싱글톤 객체를 사용할 수 있다.  
  예를 들어, 이 객체를 `Comparator`를 인자로 받는 함수에게 인자로 건넬 수 있다.

```kt
val files = listOf(File("/z"), File("/a"))
println(files.sortedWith(CastInsensitiveFileComparator))
```

- 위 예시 코드는 전달받은 `Comparator`에 따라 리스트를 정렬하는 `sortedWith()`를 사용한다.

- 클래스 안에서도 객체 선언을 할 수 있다. 그런 객체도 인스턴스는 단 하나뿐이다. 예를 들어, 어떤 클래스의  
  인스턴스를 비교하는 `Comparator`를 클래스 내부에 정의하는 게 더 바람직하다.

```kt
data class Person(val name: String) {
    object NameComparator : Comparator<Person> {
	override fun compare(p1: Person, p2: Person): Int {
	    return p1.name.compareTo(p2.name)
	}
    }
}
```

> **코틀린 객체를 Java에서 사용하기**
>
> - 코틀린 객체 선언은 유일한 인스턴스에 대한 정적 필드가 있는 Java 클래스로 컴파일된다.  
>   이때 인스턴스 필드명은 항상 INSTANCE이다. 싱글톤 패턴을 Java에서 구현해도 비슷한 필드가  
>   필요하다. Java코드에서 코틀린 싱글톤 객체를 사용하려면, 정적인 INSTANCE를 통하면 된다.
>
> ```java
> CaseInsensitiveFileComparator.INSTANCE.compare(file1, file2);
> ```

<hr/>
