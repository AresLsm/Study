# 실행 시 제네릭의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터

## 실행 시점의 제네릭: 타입 검사와 캐스트

- Java와 마찬가지로 코틀린 제네릭 타입 인자 정보는 runtime에 지워진다. 이는 제네릭 클래스 인스턴스가 그 인스턴스를 생성할 때 쓰인  
  타입 인자에 대한 정보를 유지하지 않는다는 뜻이다. 예를 들어 `List<String>` 객체를 만들고 그 안에 문자열을 여럿 넣더라도  
  실행 시점에는 그 객체를 오직 `List`로만 볼 수 있다. 그 `List` 객체가 어떤 타입의 원소를 저장하는지는 실행 시점에 알 수 없다.

- 아래 코드를 실행할 때 두 개의 리스트에 어떤 일이 벌어지는지 생각해보자.

```kt
val list1: List<String> = listOf("a", "b")
val list2: List<Int> = listOf(1, 2, 3)
```

- 컴파일러는 두 리스트를 서로 다른 타입으로 인식하지만, 실행 시점에 그 둘은 완전히 같은 타입의 객체다.  
  그럼에도 불구하고 보통은 `List<String>`에는 문자열만 들어있고 `List<Int>`에는 정수만 들어있다고 가정할 수 있는데,  
  이는 컴파일러가 타입 인자를 알고 올바른 타입의 값만 각 리스트에 넣도록 보장해주기 때문이다.

- 다음으로 타입 소거로 인해 생기는 한계를 살펴보자. 타입 인자를 따로 저장하지 않기 때문에, 실행 시점에 타입 인자를 검사할 수 없다.  
  예를 들어 어떤 리스트가 문자열로 이뤄진 리스트인지, 다른 객체로 이뤄진 리스트인지를 실행 시점에 검사할 수 없다.  
  일반적으로 말하자면 `is` 검사에서 타입 인자로 지정한 타입을 검사할 수는 없다.  
  아래 코드는 컴파일 오류를 발생시킨다.

```kt
if(value is List<String>) { /* ... */ }
// ERROR: Cannot check for instance of erased type
```

- 실행 시점에 어떤 값이 `List`인지의 여부는 확실히 알아낼 수 있지만, 그 리스트가 `String`의 리스트인지, `Person`의 리스트인지,  
  혹은 다른 어떤 타입의 리스트인지는 알 수가 없다. 그런 정보는 지워진다. 다만 저장해야 하는 타입 정보의 크기가 줄어들어서 전반적인  
  메모리 사용량이 줄어든다는 제네릭 타입 소거 나름의 장점이 있다.

- 앞서 본대로 코틀린에서는 타입 인자를 명시하지 않고 제네릭 타입을 사용할 수 없다.  
  그렇다면 어떤 값이 set이나 map이 아니라 list라는 사실을 어떻게 확인할 수 있을까?  
  이때 바로 **star projection** 을 사용하면 된다.

```kt
if (value is List<*>) { /* ... */ }
```

- 타입 파라미터가 2개 이상이라면 모든 타입 파라미터에 `*`를 포함시켜야 한다. Star projection에 대해서는 후에 더 자세히 다룬다.  
  지금은 인자를 알 수 없는 제네릭 타입을 표현할 때(Java의 `List<?>`와 유사) star projection을 사용한다고만 알아두자.  
  위 예시 코드에서는 value가 `List`임을 알 수는 있지만, 그 원소 타입은 알 수 없다.

- `as`나 `as?` 캐스팅에도 여전히 제네릭 타입을 사용할 수 있다. 하지만 기저 클래스는 같지만 타입 인자가 다른 타입으로 캐스팅해도 여전히  
  캐스팅에 성공한다는 점을 조심해야 한다. 실행 시점에는 제네릭 타입의 타입 인자를 알 수 없으므로, 캐스팅은 항상 성공할 수밖에 없다.  
  그런 타입 캐스팅을 사용하면 컴파일러가 "unchecked cast" 라는 경고를 준다. 하지만 컴파일러는 단순히 경고만 하고, 컴파일을 진행하므로  
  아래 코드처럼 값을 원하는 제네릭 타입으로 캐스팅해 사용할 수 있다.

```kt
fun printSum(c: Collection<*>) {
	val intList = c as? List<Int> ?: throw IllegalArgumentException("List is expected")
	println(intList.sum())
}

printSum(listOf(1, 2, 3)) // 6
```

- 컴파일러가 캐스팅 관련 경고를 한다는 점을 제외하면, 모든 코드가 문제없이 컴파일된다.  
  정수 리스트나 정수 set에 대해 `printSum()`을 호출하면 예상처럼 작동한다. 정수 리스트에 대해서는 합계를 출력하고, 정수 set에  
  대해서는 `IllegalArgumentException`이 발생한다. 하지만 잘못된 타입의 원소가 들어 있는 리스트를 전달하면  
  실행 시점에 `ClassCastException`이 발생한다.

```kt
printSum(setOf(1, 2, 3)) // IllegalArgumentException: List is expected
printSum(listOf("a", "b", "c")) // ClassCastException
```

- 문자열 리스트를 `printSum()`에 전달하면 발생하는 예외에 대해 좀 더 보자.  
  어떤 값이 `List<Int>`인지 검사할 수는 없으므로 `IllegalArgumentException`이 발생하지는 않는다.  
  따라서 `as?` 캐스트가 성공하고, 문자열 리스트에 대해 `sum()`이 호출된다. 예외는 `sum()`이 실행되는 도중에 발생한다.  
  `sum()`은 `Number` 타입의 값을 리스트에서 가져와 서로 더하려고 시도하기 때문이다.

- 코틀린 컴파일러는 컴파일 시점에 타입 정보가 주어진 경우에는 `is` 검사를 수행하게 허용할 수 있을 정도로 똑똑하다.

```kt
fun printSum(c: Collection<Int>) {
	if (c is List<Int>) {
		println(c.sum())
	}
}
```

- 위 코드에서는 컴파일 시점에 c가 `Int` 값을 저장한다는 사실이 알려져 있으므로 c가 `List<Int>` 인지 검사할 수 있다.

- 일반적으로 코틀린 컴파일러는 안전하지 못한 검사와 수행할 수 있는 검사를 알려주기 위해 최대한 노력하므로, 컴파일러 경고의 의미와  
  어떤 연산이 안전한지에 대해 알아야 한다.

## 실체화한 타입 파라미터를 사용한 함수 선언

- 이전에 봤듯이 코틀린 제네릭 타입의 타입 인자 정보는 실행 시점에 지워진다. ㄸ
