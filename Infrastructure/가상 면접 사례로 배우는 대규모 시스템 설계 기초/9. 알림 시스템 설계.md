# 알림 시스템 설계

- Notification System(알림 시스템)은 최근 많은 프로그램이 채택한 인기 있는 기능이다.  
  이 기능을 갖춘 애플리케이션은 최신 뉴스, 제품 업데이트, 이벤트, 선물 등 고객에게 중요할 만한 정보를 비동기적으로 제공한다.  
  이 기능은 이미 우리 일상생활에 중요한 부분으로 자리잡았다. 이 시스템을 설계해보자.

- 알림 시스템은 단순히 Mobile Push Notification에 한정되지 않는다. 사실 알림 시스템은 Mobile Push Notification,  
  SMS Message, 그리고 이메일로 분류할 수 있다.

---

## 문제 이해 및 설계 범위 확정

- 이번에 설계할 알림 시스템의 세부 설계사항은 아래와 같다.

  - Soft real-time system: 알림은 가능한 한 빨리 전달돼야 하지만, 시스템에 높은 부하가 걸렸을 때 약간의 지연은 무방하다.
  - iOS, Android, Laptop/Desktop을 지원해야 한다.
  - 사용자에게 보낼 알림은 클라이언트 애플리케이션 프로그램일 수도 있고, 서버 측 스케쥴링일 수도 있다.
  - 사용자가 알림을 받지 않도록 설정하면 알림을 받지 않도록(Opt-out) 할 수 있어야 한다.
  - 하루에 1000만건의 mobile push notification, 100만건의 메시지, 500만건의 이메일을 보낼 수 있어야 한다.

---

## 개략적 설계안 제시 및 동의 구하기

- iOS, Android push notification, SMS, email을 지원하는 알림 시스템의 개략적 설계안을 보자.

  - 알림 유형별 지원 방안
  - 연락처 정보 수집 절차
  - 알림 전송 및 수신 절차

### 알림 유형별 지원 방안

- 우선 각각의 알림 메커니즘이 어떻게 동작하는지 보자.

#### iOS Push Notification

- iOS에서 푸시 알림을 보내기 위해서는 아래 그림의 3개 컴포넌트가 필요하다.

![picture 11](/images/SDI_PNS_1.png)

- 알림 제공자(provider): 알림 요청(notification request)을 만들어 APNS(Apple Push Notification Service)로 보내는 주체.  
  알림 요청을 만들려면 아래와 같은 데이터가 필요하다.

  - Device token(단말 토큰): 알림 요청을 보내는 데 필요한 고유 식별자
  - Payload: 알림 내용을 담은 JSON dictionay

  ```json
  {
    "aps": {
      "alert": {
        "title": "Game Request",
        "body": "Bob wants to play poker with you",
        "action-loc-key": "PLAY"
      },
      "badge": 1
    }
  }
  ```

- APNS: Apple이 제공하는 원격 서비스로 푸시 알림을 iOS 장치로 보내는 역할을 담당한다.
- iOS Device: 푸시 알림을 수신하는 사용자 단말이다.

#### Android Push Notification

- 안드로이드 푸시 알림도 iOS와 비슷한 절차로 전송된다.  
  APNS 대신 FCM(Firebase Cloud Messaging)을 사용한다는 점만 다르다.

![picture 12](/images/SDI_PNS_2.png)

#### SMS

- SMS 메시지를 보낼 때는 보통 Twilio, Nexmo와 같은 제3 사업자의 서비스를 많이 이용한다.  
  이런 서비스들은 대부분 상용 서비스라서 이용 요금을 내야한다.

![picture 13](/images/SDI_PNS_3.png)

#### Email

- 대부분의 회사는 고유 이메일 서버를 구축할 역량을 갖추고 있다. 그럼에도 많은 회사가 상용 이메일 서비스를 이용한다.  
  그중 유명한 서비스로 Sendgrid, Mailchimp가 있다. 전송 성공률도 높고, 데이터 분석 서비스(analytics)도 제공한다.

![picture 22](/images/SDI_PNS_4.png)

- 아래 그림은 지금까지 살펴본 알림 유형 전부를 한 시스템으로 묶은 결과이다.

![picture 15](/images/SDI_PNS_5.png)

### 연락처 정보 수집 절차

- 알림을 보내려면 모바일 단말 토큰, 전화번호, 이메일 주소 등의 정보가 필요하다. 아래 그림과 같이 사용자가 우리 앱을 설치하거나  
  처음으로 계정을 등록하면 API 서버는 해당 사용자의 정보를 수집해 데이터베이스에 저장한다.

![picture 16](/images/SDI_PNS_6.png)

- 이 데이터베이스에 연락처 정보를 저장할 테이블 구조는 아래 그림과 같다. 아래 그림은 필수 정보만 담은 개략적인 설계안으로서,  
  이메일 주소와 전화번호는 user 테이블에 저장하고, 단말 토큰은 device 테이블에 저장한다. 한 사용자가 여러 단말을 가질 수 있고,  
  알림은 모든 단말에 전송되어야 한다는 점을 고려했다.

![picture 17](/images/SDI_PNS_7.png)

### 알림 전송 및 수신 절차

- 우선 개략적인 설계안부터 살펴보고, 점차적으로 최적화해 나가보자.

#### 개략적 설계안(초안)

- 아래 그림은 개략적 설계 초안이다.

![picture 18](/images/SDI_PNS_8.png)

- 각 시스템 컴포넌트에 대해 알아보자.

  - 1부터 N까지의 서비스: 이 서비스 각각은 micro service일 수도 있고, cron job일 수도 있고, 분산 시스템 컴포넌트일 수도 있다.  
    사용자에게 납기일을 알리고자 하는 billing service, 배송 알림을 보내려는 쇼핑몰 웹사이트 등이 그 예시이다.

  - 알림 시스템(notification system): 알림 시스템은 알림의 전송, 수신 처리의 핵심이다. 우선은 1개의 서버만 사용하는 시스템이라 가정해보자.  
    이 시스템은 서비스 1~N에 알림 전송을 위한 API를 제공해야 하고, 제3자 서비스에 전달할 알림 payload를 만들어낼 수 있어야 한다.

  - 제3자 서비스(third party services): 이 서비스들은 사용자에게 알림을 실제로 전달하는 역할을 한다. 제3자 서비스와의 통합을 진행할 때  
    유의할 것은 확장성이다. 즉 쉽게 새로운 서비스를 통합하거나 기존 서비스를 제거할 수 있어야 한다는 뜻이다. 또 하나 고려할 것으로는, 어떤  
    서비스는 다른 시장에서는 사용할 수 없을 수도 있다는 것이다. 가령 FCM은 중국에서는 사용할 수 없다. 따라서 중국 시장에서는 Jpush, PushY와  
    같은 서비스를 사용해야만 한다.

  - iOS, android, sms, email 단말: 사용자는 자신의 단말에서 알림을 수신해야 한다.

- 위 설계안에는 몇 가지 문제점들이 있다.

  - SPOF: 알림 서비스에 서버가 하나 밖에 없다는 것은 해당 서버에 장애가 생기면 전체 서비스의 장애로 이어진다는 뜻이다.
  - 규모 확장성: 한 대의 서비스로 푸시 알림에 관련된 모든 것을 처리하므로, 데이터베이스나 캐시 등 중요 컴포넌트들의 규모를 개별적으로 늘릴 방법이 없다.
  - 성능 병목: 알림을 처리하고 보내는 것은 자원을 많이 필요로 하는 작업일 수 있다. 예를 들어 HTML 페이지를 만들고 제3자 서비스의 응답을 기다리는 일은  
    시간이 많이 걸릴 가능성이 있는 작업이다. 따라서 모든 것을 하나의 서버로 처리하면 사용자 트래픽이 많이 몰리는 시간에는 시스템이 과부하 상태에 빠질 수 있다.

#### 개략적 설계안(개선된 버전)

- 초안의 문제점들을 보았으니, 아래와 같은 방향으로 개선해보자.

  - 데이터베이스와 캐시를 알림 시스템의 주 서버에서 분리한다.
  - 알림 서버를 증설하고 자동으로 수평적 규모 확장이 이뤄질 수 있도록 한다.
  - 메시지 큐를 사용해 시스템 컴포넌트 사이의 강한 결합을 끊는다.

- 아래 그림은 위 아이디어들을 적용한 시스템 개선안을 보여준다.

![picture 21](/images/SDI_PNS_9.png)

- 1~N의 서비스: 알림 시스템 서버의 API를 통해 알림을 보낼 서비스들이다.
- 알림 서버(notification server)

  - 알림 전송 API: 스팸 방지를 위해 보통 사내 서비스 또는 인증된 클라이언트만 이용 가능하다.
  - 알림 검증(validation): 이메일 주소, 전화번호 등에 대한 기본적인 검증 수행
  - 데이터베이스 또는 캐시 query: 알림에 포함시킬 데이터를 가져오는 기능
  - 알림 전송: 알림 데이터를 메시지 큐에 넣는다. 이 설계안의 경우, 하나 이상의 메시지 큐를 사용하므로 알림을 병렬적으로 처리할 수 있다.

- 아래는 이메일 형태의 알림을 보내는 데 사용하는 API 예시이다.  
  `POST https://api.example.com/v/sms/send`

```json
{
  "to": [
    {
      "user_id": 123456
    }
  ],
  "from": {
    "email": "from_address@example.com"
  },
  "subject": "Hello world",
  "content": [
    {
      "type": "text/plain",
      "value": "Hello world"
    }
  ]
}
```

- 캐시(cache): 사용자 정보, 단말 정보, 알림 template 등을 캐시한다.
- 데이터베이스: 사용자, 알림, 설정 등 다양한 정보를 저장한다.
- 메시지 큐(message queue): 시스템 컴포넌트 간의 의존성을 제거하기 위해 사용한다. 다량의 알림이 전송되어야 하는 경우를 대비한 buffer의  
  역할도 한다. 이 설계안에서는 알림의 종류별로 각각 메시지 큐를 사용하였기에 제3자 서비스 가운데 하나에 장애가 발생해도 다른 종류의 알림은  
  정상 동작한다.
- 작업 서버(workers): 메시지 큐에서 전송할 알림을 꺼내 제3자 서비스로 전달하는 역할을 담당하는 서버이다.
- 제3자 서비스: APNS, FCM 등
- iOS, Android, SMS, Email 단말: 알림을 수신할 단말

- 이제 이 컴포넌트들이 어떻게 협력해 알림을 전송하는지 순서를 보자.

  - (1) API를 호출해 알림 서버로 알림을 보낸다.
  - (2) 알림 서버는 사용자 정보, 단말 토큰, 알림 설정 등의 metadata를 cache나 database에서 가져온다.
  - (3) 알림 서버는 전송할 알림에 맞는 이벤트를 만들어 해당 이벤트를 위한 메시지 큐에 넣는다.
  - (4) 작업 서버는 메시지 큐에서 알림 이벤트를 꺼낸다.
  - (5) 작업 서버는 알림을 제3자 서비스로 보낸다.
  - (6) 제3자 서비스는 사용자 단말로 알림을 전송한다.

---
