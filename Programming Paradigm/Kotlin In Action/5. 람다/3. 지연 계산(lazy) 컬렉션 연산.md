# 지연 계산(lazy) 컬렉션 연산

- 앞에서 본 `map()`, `filter()` 같은 컬렉션 함수는 결과 컬련을 **즉시(eagerly)** 생성한다.  
  이는 곧 컬렉션 함수를 연쇄하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는다는 말이다.  
  **시퀀스(sequence)** 를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄할 수 있다.

- 아래 예시를 보자.

```kt
people.map(Person::name).filter { it.startsWith("A") }
```

- 코틀린 표준 라이브러리 참조 문서에는 `filter()`와 `map()`이 `List`를 반환한다고 써 있다.  
  이는 이 연쇄 호출이 리스트를 2개 만든다는 뜻이다. 한 리스트는 `filter()`의 결과를 담고, 다른  
  하나는 `map()`의 결과를 담는다. 만약 원본 리스트에 원소가 수백만개 된다면 효율이 엄청 떨어질 것이다.

- 이를 더 효율적으로 만들기 위해서는 각 연산이 컬렉션을 직접 사용하는 대신, 시퀀스를 사용하게 해야 한다.

```kt
people
    .asSequence()
    .map(Person::name)
    .filter { it.startsWith("A") }
    .toList()
```

- 전체 연산을 수행한 결과는 이름이 A로 시작하는 사람의 목록으로, 이전 예시와 동일하다.  
  하지만 이 예시에서는 중간 결과를 저장하는 컬렉션이 생기지 않기 때문에 원소가 많은 경우 성능이 눈에  
  띄게 좋아진다.

- 코틀린의 지연 계산 시퀀스는 `Sequence` 인터페이스에서 시작한다. 이 인터페이스는 단지 한 번에 하나씩  
  열거될 수 있는 원소의 시퀀스를 표현할 뿐이다. `Sequence` 안에는 `iterator()`라는 단 하나의 메소드가 있다.  
  이 메소드를 통해 시퀀스로부터 원소 값을 얻을 수 있다.

- `Sequence` 인터페이스의 강점은 그 인터페이스 위에 구현된 연산이 계산을 수행하는 방법 덕분에 생긴다.  
  시퀀스의 원소는 필요할 때 비로소 계산된다. 따라서 중간 처리 결과를 저장하지 않고도 연산을 연쇄적으로 적용해서  
  효율적으로 계산을 수행할 수 있다.

- `asSequence()` 확장함수를 호출하면 어떤 컬렉션이든 시퀀스로 바꿀 수 있다. 시퀀스를 리스트로 만들 때는  
  `toList()`를 사용한다.

- 왜 시퀀스를 다시 컬렉션으로 되돌려야 할까? 컬렉션보다 시퀀스가 훨씬 더 낫다면 그냥 시퀀스를 쓰는 편이 낫지 않을까?  
  이 질문의 답은 "항상 그렇지는 않다." 이다. 시퀀스의 원소를 차례대로 순회해야 한다면 시퀀스를 직접 써도 된다.  
  하지만 시퀀스 원소를 인덱스를 사용해 접근하는 등의 다른 API 메소드가 필요하다면 시퀀스를 리스틀로 변환해야 한다.

```kt
public interface Sequence<out T> {
    /**
     * Returns an [Iterator] that returns the values from the sequence.
     *
     * Throws an exception if the sequence is constrained to be iterated once and `iterator` is invoked the second time.
     */
    public operator fun iterator(): Iterator<T>
}
```

<hr/>
