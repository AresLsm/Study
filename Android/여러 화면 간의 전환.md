여러 화면 간 전환
======

<h2>Layout Inflation</h2>

* 기본적으로 제공되는 `MainActivity.java`의 코드를 보자.
```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}
```
* `setContentView()` 메소드의 인자로 들어간 값이 `R.layout.activity.main` 인데, 이는 `MainActivity.java`가   
  `activity_main.xml` 파일의 기능을 담당한다는 것이다. R은 `res` 폴더를 의미하고, `layout`은 그 하위의 `layout`폴더를,   
  그리고 `activity.main`은 xml 파일명을 가리킨다.

* 실제 App을 실행하면, XML Layout을 소스코드에서 사용한다. 즉, App이 실행될 때 __XML Layout의 내용이 메모리에 객체화 되고__,   
  __객체화된 XML Layout을 소스 파일에서 사용__ 한다. 이렇게 XML Layout이 메모리에 객체화되는 과정을 __Inflation__ 이라 한다.

* XML Layout은 __App이 실행되는 시점에 메모리에 객체화__ 된다. 즉, `setContentView()` __가 호출되기 전에 XML의 객체를 참조하면 app은 중지된다__. 
  * 위의 경우 Logcat에 뜨는 예외 : `NullPointerException`

* `setContentView()` 메소드는 메모리에 객체화하는 역할도 수행하지만, 화면에 나타낼 View를 지정하는 역할도 한다.   
  아래는 이 메소드가 오버로딩 된 형태이다.
```java
public void setContentView(int layoutResID);
public void setContentView(View view[, ViewGroup.LayoutParams params]);
```

* `setContentView()`는 Activity의 화면 전체(Main Layout)를 설정하는 역할만을 수행한다. 즉 이 메소드는 부분 화면을   
  메모리에 객체화할 수는 없다. __부분 화면을 메모리에 객체화하려면 Inflater를 사용해야 한다__. 안드로이드는 이를 위해 시스템 서비스로   
  `LayoutInflater` 클래스를 제공한다. 시스템 서비스로 제공하는 클래스이므로 `getSystemService()`로 `LayoutInflater` 객체를 참조한 후   
  사용해야 한다.
```java
getSystemService(Context.LAYOUT_INFLATER_SERVICE);
```

* `app/res/layout/activity_menu.xml` 파일이 아래와 같이 있다.
```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Click button to add part-screen."
        android:textSize="20sp"
        android:id="@+id/textView"/>
    <Button
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/button"
        android:text="ADD" />
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:id="@+id/container"
        android:orientation="vertical">

    </LinearLayout>
</LinearLayout>
```
* 아래는 `app/res/layout/sub1.xml` 파일이다.
```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    
    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/textView"
        android:text="Part Screen1"
        android:textSize="30sp"/>
    <CheckBox
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/checkBox"
        android:text="AGREE"/>

</LinearLayout>
```
* 위의 `sub1.xml`은 전체 layout인 `activity_menu.xml`의 "ADD" Button을 클릭하여 안쪽 LinearLayout에 추가하기 위해 만들었다.   
  아래 소스 코드는 전체 layout에 부분 layout을 추가하는 코드이다.
```java
// MenuActivity.java
public class MenuActivity extends AppCompatActivity {

    LinearLayout container;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_menu);
        
        container = findViewById(R.id.container);
        
        Button button = findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                LayoutInflater inflater = (LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
                inflater.inflate(R.layout.sub1, container, true);
                CheckBox checkBox = container.findViewById(R.id.checkBox);
                checkBox.setText("LOADED");
            }
        });
    }
}
```
* 위 코드는 `activity_menu.xml`의 id가 container인 안쪽 LinearLayout을 container라는 변수에 저장한다.   
  그리고 `getSystemService()` 메소드를 통해 `LayoutInflater` 객체를 참조한다. 참조한 객체에 대해 `inflate()` 메소드를 호출하는데,   
  파라미터로 `R.layout.sub1, container,true`를 전달한다. 이 호출부분이 container를 id로 갖는 LinearLayout 객체에 sub1.xml의   
  Layout을 설정하는 것이다. 이 과정을 통해 `sub.xml`에 정의된 View들이 메모리에 로딩되며 객체화 과정을 거치게 된다.   
  이제 `sub.xml` 파일이 객체화되었으므로, 이 파일 내의 `TextView` 와 `CheckBox`는 `container.findViewById()`로 참조할 수 있다.

* 참고 : 위 코드에서는 `getSystemService()`로 `LayoutInflater` 객체를 참조했지만, 다음 메소드로 참조할 수 도 있다.
```java
static LayoutInflater LayoutInflater.from(Context context);
```
<hr/>

<h2>여러 화면 생성 및 화면 간 전환</h2>

* 대부분의 App은 여러 화면으로 구성돼 있고 화면을 전환하며 실행된다. 그리고 화면은 Activity로 구현한다.   
  즉, 화면을 필요에 따라 띄우거나 닫는 과정은 Activity를 전환하는 것과 같다.

* Android App을 구성하는 기본 구성 요소 네 가지는 다음과 같다.
  * Activity
  * Service
  * BroadCast 수신자
  * 내용 제공자
* 위의 구성요소들은 Android System이 이 요소에 대한 정보를 요구한다. 이 정보들은 `AndroidManifest.xml` 파일에 담겨있다.   
  예를 들어 이 파일 내의 `<Activity>` 태그는 Activity들에 대한 정보를 포함한다.

* 소스 코드에서 Activity를 띄울 때는 `startActvity()`를 사용할 수 있는데, 이 메소드는 단순히 Activity를 띄워 화면에 출력한다.   
  하지만 실제 App에는 MainActivity에서 띄워야할 화면이 많아져 띄웠던 화면을 닫고, 원래의 메인 화면으로 돌아올 때   
  data를 새로 적용해야 하는 경우가 자주 생긴다. 즉, __단순히 Activty를 띄워주는 것이 아니라 어떤 Activity를 띄운 것인지,__   
  __그리고 띄웠던 Activity로부터 다시 원래의 Activity로 돌아오면서 응답을 받아 처리하는 코드가 필요__ 하다.   
  이런 기능은 Activity를 소스 코드에서 띄울 때 `startActivity()` 가 아닌 `startActivityForResult()` 메소드를 사용하면 된다.
```java
starActivityForResult(Intent intent, int requestCode);
```
* 이 메소드에 전달되는 파라미터는 intent와 requestCode인데, requestCode는 일반적으로 각각의 Activity를 구별하기 위해 사용된다.   
  예를 들어, 어떤 Activity로부터 응답을 받은 것인지를 구별할 때 사용할 수 있다.

* 새로운 Android Project를 만들 때, Activity Name을 `MenuActivity`로 바꾼 후 `/app/manifests/AndroidManifest.xml`파일을 보면   
  `<activity>` 태그의 속성 중 `android:name`이 ".MenuActivity"로 설정돼 있다. `android:label`와 `android:theme`를 추가하자.
```xml
<!-- /app/manifests/AndroidManifest.xml -->
<!-- 생략 -->
<activity 
    android:name=".MenuActivity"
    android:label="MENU ACTIVITY"
    android:theme="@style/Theme.AppCompat.Dialog">        
</activity>
```
* `android:label`은 화면의 제목을 설정하며, `android:theme`은 테마를 설정할 때 사용한다.   
  위의 경우는 `@style/Theme.AppCompat.Dialog`를 속성값으로 지정했는데, 이는 Activity를 대화상자 형태로 나타낸다.
* `activity_menu.xml`에 아래와 같이 Button 하나를 추가하자.
```xml
<Button
        android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="RETURN"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
```
* 다음으로는 `MenuActivity.java` 파일을 작성하여 버튼 클릭 시, 원래 Activity로 돌아가도록 구현해보자.
```java
public class MenuActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_menu);
        
        Button button = findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Intent intent = new Intent();
                intent.putExtra("name", "sangwoo");
                // 위 코드는 intent 객체를 생성하고, 값을 집어넣는다.
                setResult(RESULT_OK, intent);
                // 위 코드는 응답을 보낸다.
                finish();
                // 위 코드는 현재 Activity를 없앤다.
            }
        });
    }
}
```
* `setResult()`는 응답 코드와 Intent 객체를 파라미터로 전달하는데, 이 메소드는 새로 띄운 Activity에서 이전 Activity로   
  Intent를 전달하고 싶을 때 사용한다.
* `finish()` 메소드는 Activity를 화면에서 없애고 싶을 때 사용한다.
* `putExtra()` 메소드는 `Intent` 객체에 Key, Value의 쌍으로 값을 넣을 때 사용한다.

* `app/res/layout/activity_main.xml`에는 id가 button인 Button 객체가 하나 있다고 하자.
* 다음은 `MainActvity.java` 코드이다.
```java
public class MainActivity extends AppCompatActivity {

    public static final int REQUEST_CODE_MENU = 101;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        Button button = findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Intent intent = new Intent(getApplicationContext(), MenuActivity.class);
                startActivityForResult(intent, REQUEST_CODE_MENU);
            }
        });
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if(requestCode == REQUEST_CODE_MENU) {
            Toast.makeText(getApplicationContext(), "request code : " + REQUEST_CODE_MENU, Toast.LENGTH_LONG).show();
        }
        if(resultCode == RESULT_OK) {
            String name = data.getStringExtra("name");
            Toast.makeText(getApplicationContext(), "Sended name as response:" + name, Toast.LENGTH_LONG).show();
        }
    }
}
```
* 위 코드에서는 새로운 Activity를 띄울 때 `startActivityForResult()` 메소드를 호출했다. 이 메소드는 새 Activity를 띄우는데,   
  `startActivity()`와는 다르게 새로운 Activity로부터 응답을 받을 수 있다고 했다.
* `onActivityResult()` 메소드는 새로 띄웠던 `MenuActivity`가 응답을 보내면, 그 응답을 처리하기 위해 사용한다.   
  requestCode 인자는 어떤 Activity로부터 응답을 받은 것인지 구분하기 위해 사용되며,   
  resultCode는 새 Activity로부터 전달된 응답 코드이며, 이 값은 새 Activity에서 처리한 결과가 정상인지 아닌지를 구분하는데 사용된다.   
  마지막 Intent data 파라미터는 새 Activity로부터 전달 받은 Intent 객체이다.
<hr/>

<h2>Intent</h2>

* `Intent`는 위에서 다른 Activity를 띄우거나 기능을 동작시키기 위한 수단으로 사용했다.   
  즉, 무언가 작업을 수행하기 위해 사용되는 일종의 명령 또는 데이터를 전달하는데 사용했다.   
  먼저 `Intent` 객체를 만든 후 `startActivity()`나 `startActivityForResult()` 메소드의 인자로 전달하여 Intent를 시스템에 전달했다.

<hr/>

<h3>Intent의 역할과 사용 방식</h3>

* Intent는 `android.content` 패키지 내에 정의되어 있는데, App의 구성 요소 간에 작업 수행을 위한 정보를 전달하는 역할을 한다.   
  다른 App 구성 요소에 Intent를 전달하는 대표적인 메소드들은 다음과 같다.
  * `startActivity()`, `startActivityForResult()`
  * `startService()`, `bindService()`
  * `broadcastIntent()`

* Intent의 기본 구성 요소는 `Action`과 `Data` 이다.   
  Action은 수행할 기능이고, Data는 액션이 수행될 대상의 데이터를 의미한다.   
  대표적인 Action으로는 `ACTION_VIEW`, `ACTION_EDIT` 등이 있다.

* Action, Data를 이용해 Intent를 만들고 필요한 Activity를 띄워주는 대표적인 경우
<table>
    <tr>
        <td>ACTION_DIAL tel:01011111111</td>
        <td>주어진 전화번호를 이용해 전화걸기 화면을 보여준다.</td>
    </tr>
    <tr>
        <td>ACTION_VIEW tel:01011112222</td>
        <td>주어진 전화번호를 이용해 전화걸기 화면을 보여준다. URI값의 유형에 따라 VIEW Action이 다른 기능을 수행한다.</td>
    </tr>
    <tr>
        <td>ACTON_EDIT content://contacts/people/2</td>
        <td>전화번호부 DB에 있는 정보 중 ID가 2인 정보를 편집하기 위한 화면을 보여준다.</td>
    </tr>
    <tr>
        <td>ACTION_VIEW content://contacts/people</td>
        <td>전화번호부 DB의 내용을 보여준다.</td>
    </tr>
</table>

* Intent에 포함된 Data는 그 포맷을 시스템이 확인하고, 적절한 Activity를 자동으로 찾아 띄워주기도 한다.   
  만약 데이터가 "http://" 로 시작하는 문자열이면 웹 페이지의 주소를 나타내는 URL로 인식한다.

* Intent 객체의 생성자들은 다음과 같다.
```java
Intent()
Intent(Intent o)
Intent(String action [,Uri uri]);
Intent(Context packageContext, Class<?> cls);
Intent(String action, Uri uri, Context packageContext, Class<?> cls);
```
* Intent에 Class 객체나 컴포넌트명을 지정하여 호출할 대상을 확실히 알 수 있는 경우를 `Explicit Intent(명시적 intent)`라 하며,   
  Action과 Data를 지정하긴 했지만 호출 대상이 달라질 수 있는 경우를 `Implicit Intent(암시적 intent)`라 한다.   
  암시적 intent는 MIME 타입에 따라 시스템에서 적절한 다른 app의 Activity를 찾은 후 띄우는 방식을 사용한다.
<hr/>

<h3>Category</h3>

* Category는 Action이 실행되는데 필요한 추가적인 정보를 제공한다. 예를 들어 `CATEGORY_LAUNCHER`는 최상위 APP으로   
  설치된 app들의 목록을 보여주는 Application Launcher 화면에 이 app을 보여줘야함을 의미한다.
<hr/>

<h3>Type</h3>

* Type은 Intent에 들어가는 Data의 MIME 타입을 명시적으로 지정한다.
<hr/>

<h3>Component</h3>

* Component는 Intent에 사용될 컴포넌트 클래스명을 명시적으로 지정한다. 보통 이 정보는 Intent의 다른 정보에 의해 결정되는데,   
  이 속성을 지정할 경우에는 지정된 컴포넌트가 실행되도록 한다.
<hr/>

<h3>Extra Data</h3>

* Intent는 추가적인 정보를 넣을 수 있도록 `Bundle` 객체를 담고 있다. 이 객체를 통해 Intent 내에 더 많은 정보를 넣어 다른 App의   
  구성 요소에 전달할 수 있다.
<hr/>

* `activity_main.xml`에 id가 editText인 `EditText` 태그가 있으며, id가 button인 `Button` 태그가 있다 하자.   
  여기서 button을 클릭하면 editText의 값을 읽어와 전화를 거는 화면으로 넘어가도록 구현할 것이다.
* `MainActivity.java` 코드를 보자.
```java
public class MainActivity extends AppCompatActivity {

    EditText editText;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        editText = findViewById(R.id.editText);
        
        Button button = findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
               
               // data에 EditText에서 가져온 문자열을 저장한다. 
               String data = editText.getText().toString();
               
               // 전화걸기 화면을 보여줄 Intent 객체 생성
               Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(data));
               
               // Activity를 띄운다.
               startActivity(intent);
            }
        });
    }
}
```

* Component를 Intent 객체에 설정할 수 있다. `activity_main.xml`에 id가 button2이고, 이 버튼을 누르면   
  `MenuActivity.java`, `activity_menu.xml`로 이동하도록 구현해보자.
```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {

        //..


        Button button2 = findViewById(R.id.button2);
        button2.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Intent intent = new Intent();
                ComponentName name = new ComponentName("org.techtown.sampleintent", "org.techtown.sampleintent.MenuActivity");
                intent.setComponent(name);
                startActivityForResult(intent, 101);
            }
        });
    }
}
```
* 위 코드에서 컴포넌트의 이름은 `ComponentName` 객체를 만들어 Intent에 설정했다.   
  `ComponentName`의 생성자의 파라미터는 각각 패키지명, 클래스명이다.
* 주의 : `ComponentName`객체를 만들어 대상 Activity의 이름을 지정할 때에도 패키지명까지 함께 사용한다.
<hr/>

<h2>Flag와 부가 데이터 사용하기</h2>

* 위에서 