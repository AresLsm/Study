# 포인터

## 빠른 포인터 입문

- 포인터는 간단히 말해 값이 저장된 메모리의 위치 값을 갖는 변수이다.

```go
var x int32 = 10
var y bool = true
```

- 모든 변수는 하나 혹은 그 이상의 연속적인 메모리 공간에 저장되는데, 그것을 **주소**라 한다. 서로 다른 타입의 변수들은 서로 다른 양의 메모리를  
  차지한다. 예를 들어 x는 int32이므로 4바이트가 필요하고, y는 bool이기에 1비트만 필요하다.(주소 지정을 통해 가질 수 있는 최소 공간은 1바이트이다.)

- 포인터는 단순히 다른 변수가 저장된 주소를 내용으로 갖는 변수이다.

```go
var x int32 = 10
var y bool = true
pointerX := &x
pointerY := &y
var pointerZ *string
```

- 서로 다른 타입은 서로 다른 수의 메모리를 차지하지만, 모든 포인터는 어떤 타입을 가리키던 간에 항상 같은 크기를 가지는데, 그 수는 데이터가 저장된  
  메모리의 위치를 가질 만큼이다. 예를 들어 위 코드에서 x가 1번지~4번지를(4byte) 차지하고, y가 5번지(1byte)를 차지한다고 해보자.  
  그리고 pointerX기 메모리의 6번지에 저장되었다고 하면 값으로는 x의 주소인 1을 갖는다. 비슷하게 y를 가리키는 pointer가 10번지에 저장되었다 하면  
  값으로는 y의 주소인 5를 갖는다. 마지막으로 pointerZ는 어딘가에 저장되긴 하지만, 아무것도 가리키지 않기에 0의 값을 가진다.

- 포인터의 zero value는 nil이다. nil은 slice, map, 함수를 위한 zero value이기도 하다. 추가로 channel, interface가 있는데 이들 모두  
  포인터로 구현되어 있다. nil은 특정 값의 부재를 표현하는 타입이 지정되지 않은 식별자이다. C언어의 NULL과 다르게, nil은 0의 다른 이름이 아니다.  
  그래서 nil을 숫자로 바꾸거나 숫자를 nil로 바꿀 수 없다.

> 이전에 보았듯이 nil은 Universe Block에 정의되어 있다. 즉, shadowing될 수 있다는 뜻이다.  
> 따라서 절대 함수나 변수명을 nil로 지정하지 말자.

- Go의 포인터 구문은 일부 C와 C++에서 차영했다. Go는 GC를 갖기에 메모리 관리에 대한 고통이 거의 사라졌다. 게다가 포인터 산술을 포함한 C와 C++에서  
  포인터를 갖고 할 수 있는 기교 중 일부는 Go에서는 허용되지 않는다.

- `&`는 주소 연산자로, 변수 앞에 `&`를 붙이면 해당 변수의 값이 저장된 메모리 위치의 주소를 반환하게 된다.

```go
x := "hello"
pointerToX := &x
```

- `*`는 간접 연산자로, 포인터 타입의 변수 앞에 붙이면 가리키는 값을 반환하게 된다. 이를 **역참조(dereferencing)** 라 한다.

```go
x := 10
pointerToX := &x
fmt.Println(pointerToX) // x의 메모리 주소
fmt.Println(*pointerToX) // 10
z := 5 + *pointerToX
fmt.Println(z) // 15
```

- 포인터를 역참조하기 전에 꼭 pointer가 nil이 아닌지 확인해야 한다. 만약 nil을 갖는 포인터를 역참조하면, 프로그램은 panic을 일으킨다.

```go
var x *int
fmt.Println(x == nil) // true
fmt.Println(*x) // Panic
```

- **포인터 타입**은 포인터가 어떤 타입을 가리키는지 나타낸다. 타입 이름 앞에 `*`를 사용해 작성한다.

```go
x := 10
var pointerX *int
pointerToX := &x
```

- 내장 함수 `new()`는 포인터 변수를 생성하는데, 제공된 타입의 zero value를 가리키는 포인터를 반환한다.

```go
var x = new(int)
fmt.Println(x == nil) // false
fmt.Println(*x) // 0
```

- `new()`는 드물게 사용된다. 구조체를 위해 포인터 인스턴스를 만들려면 구조체 리터럴 앞에 `&`를 사용한다. 기본 타입 리터럴이나 상수 앞에는  
  메모리 주소를 갖지 않기에 `&`를 사용할 수 없다. 이들은 단지 컴파일 과정에 존재하기 때문이다. 기본 타입을 위한 포인터가 필요하면, 변수를  
  선언하고 해당 변수를 가리키게끔 하도록 하자.

```go
x := &Foo{}
var y sring
z := &y
```

- 상수의 주소를 가질 수 없기에 때로는 불편함을 야기하기도 한다. 하나의 구조체 내에 기본 타입을 가리키는 포인터가 있다면, 리터럴을 해당 항목에  
  직접 할당할 수 있다.

```go
type person struct {
	FirstName string
	MiddleName *string
	LastName string
}

p := person{
	FirstName: "Pat",
	MiddleName: "Perry", // Compile Error
	LastName: "Peterson",
}
```

- 위 코드는 p변수 중 MiddleName에 값을 할당하는 과정에서 컴파일 에러가 발생한다. `MiddleName: &"Perry"`로도 에러는 해결되지 않는다.

- 이 문제를 회피하기 위한 두 가지 방법이 있는데, 첫 번째는 변수에 상수의 값을 들고 있게끔 하는 것이다.  
  두 번째는 helper 함수를 작성해 불리언, 숫자, 문자열 타입을 파라미터로 받아 해당 타입의 포인터를 반환하도록 하는 방법이다.

```go
func stringp(string s) *string {
	return &s
}
```

- 위 함수로 문제가 된 구조체를 다시 작성해보자.

```go
p := person{
	FirstName: "Pat",
	MiddleName: stringp("Perry"),
	LastName: "Peterson",
}
```

- 위 방식이 왜 동자할까? 상수를 함수로 전달했을 때, 상수는 파라미터로 복사된다. 그것은 변수이기 때문에 메모리에서 주소를 갖는다.  
  즉 `stringp()`는 변수의 메모리 주소를 반환하게 되는 것이다.

---
