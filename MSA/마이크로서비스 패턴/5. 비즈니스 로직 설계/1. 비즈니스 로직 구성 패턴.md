# 비즈니스 로직 구성 패턴

- 비즈니스 로직이 여러 서비스에 흩어져 있는 MSA는 복잡한 비즈니스 로직을  
  개발하기가 까다롭다. 골치 아픈 문제는 크게 두 가지가 있다.

  - (1) **도메인 모델은 대부분 상호 연관된 클래스가 거미줄처럼 뒤얽혀 있다.**  
    모놀리틱 애플리케이션에서는 대수롭지 않은 일이지만, 클래스가 여러 서비스에 산재된  
    MSA에서는 서비스 경계를 넘나드는 객체 레퍼런스를 제거해야 한다.

  - (2) **MSA 특유의 트랜잭션 관리 제약 조건하에서도 작동되는 비즈니스 로직을**  
    **설계해야 한다.** ACID 트랜잭션이 서비스 내부에서 보장되면 참 좋겠지만,  
    여러 서비스에 걸쳐 데이터 일관성을 유지하려면 Saga 패턴을 적용해야만 한다.

- 다행이 위 두 문제는 서비스 비즈니스 로직을 여러 Aggregate로 구성하는 DDD의  
  Aggregate(집합체) 패턴으로 해결할 수 있다. Aggregate는 한 단위로 취급 가능한  
  객체를 모아 놓은 것이다. MSA에서 비즈니스 로직을 개발할 때에는 아래 두 개의 이유로  
  Aggregate가 요긴하게 쓰인다.

  - Aggregate를 사용하면 객체 레퍼런스가 서비스 경계를 넘나들 일이 없다.  
    객체 참조 대신 기본키(PK)를 사용하여 Aggregate가 서로 참조하기 때문이다.

  - 한 트랜잭션으로 하나의 Aggregate만 생성, 수정할 수 있다. 따라서 Aggregate는  
    마이크로서비스 트랜잭션 모델의 제약 조건에 잘 맞는다.

- 따라서 ACID 트랜잭션은 반드시 하나의 서비스 내부에만 걸리게 된다.

# 비즈니스 로직 구성 패턴

- 주문 서비스는 중심에 비즈니스 로직이 있고, inbound/outbound 어댑터가 주변을 감싼  
  Hexagonal 아키텍쳐의 구조이다. 인바운드 어댑터는 클라이언트의 요청을 받아 비즈니스  
  로직을 호출하고, 비즈니스 로직은 다시 아웃바운드 어댑터를 호출하여 다른 서비스 및  
  애플리케이션을 실행한다.

- 주문 서비스는 비즈니스 로직과 아래의 어댑터들로 구성된다.

  - REST API 어댑터: 비즈니스 로직을 호출하는 REST API가 구현된 인바운드 어댑터
  - `OrderCommandHandlers`: 메시지 채널에서 들어온 커맨드 메시지를 받아  
    비즈니스 로직을 호출하는 인바운드 어댑터
  - DB 어댑터: 비즈니스 로직이 DB 접근을 위해 호출하는 아웃바운드 어댑터
  - 도메인 이벤트 발행 어댑터: 이벤트를 메시지 브로커에 발행하는 아웃바운드 어댑터

- 일반적으로 비즈니스 로직은 서비스에서 가장 복잡한 부분이다.  
  따라서 어떻게하면 애플리케이션에 가장 적절한 방법으로 비즈니스 로직을 구성, 개발할 수  
  있을지 의식적으로 고민해야 한다. 객체지향 언어를 사용한다고 해서 무조건 비즈니스 로직도  
  객체 지향적으로 설계되는 것은 아니다. _비즈니스 로직을 객체 지향적으로 개발할 것인가,_  
  _절차적인 방식으로 개발할 것인가_ 의 문제는 매우 중요한 의사 결정 항목이다.  
  비즈니스 로직은 절차적 트랜잭션 스크립트 패턴과 객체 지향적 도메인 모델 패턴의  
  두 가지 패턴으로 구성된다.

<h2>비즈니스 로직 설계: 트랜잭션 스크립트 패턴</h2>

- 객체 지향 접근 방식은 좋지만, 매우 간단한 비즈니스 로직을 개발할 때에는 오히려  
  객체지향이 조금 지나칠 수도 있다. 이런 경우에는 차라리 **트랜잭션 스크립트 패턴**을  
  적용하여 절차적인 코드를 작성하는 것이 더 합리적이다. 객체지향 설계를 하지 않고  
  트랜잭션 스크립트라는 메소드를 작성하여 표현 계층에서 들어온 요청을 처리하는 것이다.  
  이 방법은 **동작(behavior)이 구현된 클래스와 상태(state)를 보관하는 클래스가 따로**  
  **존재한다**는 중요한 특징이 있다.

> 트랜잭션 스크립트 패턴: 비즈니스 로직을 요청 타입별로 하나씩 매핑된 절차적  
> 트랜잭션 스크립트 뭉치로 구성한다.

- 이런 고도의 절차적인 설계 방식은 객체지향 프로그래밍 언어의 기능에는 거의 의존하지  
  않는다. 사실 절차적 설계가 더 적합한 경우라면 굳이 주저할 필요는 없다.  
  복잡한 비즈니스 로직에는 안 맞을지 몰라도 단순한 비즈니스 로직에는 아주 잘 통하기 때문이다.

<hr/>

<h2>비즈니스 로직 설계: 도메인 모델 패턴</h2>

- 절차적 접근 방식은 클래스를 어떻게 구성할지 고민하지 않고 단순하게 코딩할 수 있는  
  매력이 있지만, 비즈니스 로직이 복잡해지면 거의 관리 불가능한 상태로 악화된다.  
  모놀리틱 애플리케이션이 점점 비대해지는 경향이 있듯이 트랜잭션 스크립트도 같은  
  문제점이 있다. 지극히 단순한 애플리케이션 개발이 아니라면, 절차적 코드 작성의  
  치명적인 매력에 사로잡히지 말고, 도메인 모델 패턴을 응용한 객체 지향 설계를  
  하는 것이 좋다.

> 도메인 모델 패턴: 비즈니스 로직을 상태와 동작을 가진 클래스로 구성된  
> 객체 모델로 구성한다.

- 객체지향적으로 설계한 비즈니스 로직은 비교적 작은 클래스가 그물망처럼 얽힌  
  객체 모델로 구성된다. 이런 클래스는 제각기 문제 영역(Problem Domain) 개념에  
  직접 대응된다. 상태, 동작 둘 중 하나만 있는 클래스도 있지만 대부분 상태, 동작  
  모두를 갖고 있다. 이것이 잘 설계된 클래스의 특징이기도 하다.

- 트랜잭션 스크립트 패턴을 적용하면 `OrderService` 클래스는 각 요청 및 시스템  
  작업마다 하나의 메소드를 갖지만, 도메인 모델 패턴을 정의하면 서비스 메소드가  
  단순해진다. **서비스 메소드가 거의 항상 비즈니스 로직이 잔뜩 포함된 영속화 도메인**  
  **객체에 위임하기 때문**이다. 서비스 메소드는 DB에서 도메인 객체를 로드하고,  
  메소드들 중 하나를 호출한다. 따라서 동작, 상태를 모두 가진 `Order` 클래스의  
  상태 값은 private 해서 메소드를 통한 간접 접근만 가능하다.

- 객체지향 설계를 하면 여러모로 좋은 점이 많다. 첫째, **설계를 이해, 관리하기 쉽다.**  
  만사를 관장하는 하나의 거대한 클래스 대신 소수의 책임만 맡은 아담한 여러 클래스들로  
  구성되기 때문이다. 둘째, **테스트하기 쉽다.** 각 클래스는 독립적으로 테스트할 수 있고,  
  또 마땅히 그래야 한다. 셋째, **객체지향 설계는 잘 알려진 설계 패턴을 응용할 수 있기에**  
  **확장하기 쉽다.** 가령 전략 패턴, 템플릿 메소드 패턴을 적용하면 코드를 변경하지 않아도  
  컴포넌트를 확장할 수 있다.

- 하지만 도메인 모델 패턴도 MSA에서는 해결해야 할 문제가 많기 때문에 OOD를 개선한  
  DDD가 필요하다.

<hr/>

<h2>도메인 주도 설계 개요</h2>

- DDD는 복잡한 비즈니스 로직을 개발하기 위해 OOD를 개선한 접근 방식이다.  
  DDD 방식으로 설계하면 각 서비스는 자체 도메인 모델을 가지며, 애플리케이션  
  전체 도메인 모델의 문제점을 방지할 수 있다. 하위 도메인과 이에 관련된 경계 컨텍스트  
  (Bounded Context)는 DDD 패턴의 양대 전략이다.

- 아래는 DDD에서 도메인 모델을 구축하는 데 흔히 쓰이는 빌딩 블록이다.  
  각 클래스가 도메인 모델에서 수행하는 역할과 클래스의 특징을 정의한다.

  - **엔티티(Entity)** : 영속적 신원을 가진 객체로, 두 엔티티는 속성 값이 동일해도  
    엄연히 다른 객체이다. Java는 JPA의 `@Entity`를 붙여 DDD Entity를 나타낸다.

  - **값 객체(Value Object)** : 여러 값을 모아 놓은 객체로, 속성 값이 동일한 두  
    값 객체는 서로 바꿔 사용할 수 있다.

  - **팩토리(Factory)** : 일반 생성자로 직접 만들기에 복잡한 객체의 생성 로직이 구현된  
    객체 또는 메소드로, 인스턴스로 생성할 구상 클래스를 감출 수 있으며, 클래스의 정적  
    메소드로 구현할 수 있다.

  - **레포지토리(Repository)** : 엔티티를 저장하는 DB 접근 로직을 캡슐화한 객체

  - **서비스(Service)** : 엔티티, 값 객체에 속하지 않은 비즈니스 로직 구현 객체

- 이 밖에 JPA, Spring 등 프레임워크에서 지원되는 빌딩 블록도 있고, DDD에서 제공하는  
  Aggregate도 있다.

<hr/>
