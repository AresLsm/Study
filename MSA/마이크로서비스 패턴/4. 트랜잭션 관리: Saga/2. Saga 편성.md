# Saga 편성

- Saga는 단계를 편성하는 로직으로 구성된다. 시스템 커맨드가 Saga를 시작할 때  
  이 편성 로직은 첫 번째 Saga 참여자를 정하여 로컬 트랜잭션 실행을 지시하고,  
  트랜잭션이 완료되면 그 다음 Saga 참여자를 호출하는 과정이 모든 단계가 실행될  
  때까지 반복된다. 도중 하다라도 로컬 트랜잭션이 실패하면, Saga는 보상 트랜잭션을  
  역순으로 실행한다. Saga 편성 로직은 두 가지 종류가 있다.

  - **코레오그래피(Choreography)** : 의사 결정과 순서화를 Saga 참여자에게  
    맡긴다. Saga 참여자는 주로 이벤트 교환 방식으로 통신한다.
  - **오케스트레이션(Orchestration)** : Saga 편성 로직을 Saga 오케스트레이터에  
    중앙화한다. Saga 오케스트레이터는 Saga 참여자에게 커맨드 메시지를 보내  
    수행할 작업을 지시한다.

<h2>코레오그래피 Saga</h2>

- 코레오크래피 방식은 Saga 참여자에게 할 일을 알려주는 중앙 편성자가 없다.  
  그 대신 Saga 참여자가 서로 이벤트를 구독해서 그에 따라 반응하게 한다.

<h3>주문 생성 Saga 구현: 코레오그래피 스타일</h3>

- 코레오그래피 스타일로 주문 생성 Saga를 설계해보자. Saga 참여자는 서로 이벤트를  
  주고받으며 소통한다. 주문 서비스를 시작으로 각 참여자는 자신의 DB를 업데이트하고  
  다음 참여자를 트리거하는 이벤트를 발행한다.

- 별 문제가 없다면 아래 순서대로 진행될 것이다.

  - (1) 주문 서비스: 주문을 `APPROVAL_PENDING` 상태로 생성 => _주문 생성_ 이벤트 발행
  - (2) 소비자 서비스: _주문 생성_ 이벤트 수신 => 소비자가 주문 가능한지 확인 =>  
    _소비자 확인_ 이벤트 발행
  - (3) 주방 서비스: _주문 생성_ 이벤트 수신 => 주문 내역 확인 => 티켓을 `CREATE_PENDING`  
    상태로 생성 => _티켓 생성됨_ 이벤트 발행
  - (4) 회계 서비스: _주문 생성_ 이벤트 수신 => 신용카드 승인을 `PENDING` 상태로 생성
  - (5) 회계 서비스: _티켓 생성됨_ 및 _소비자 확인_ 이벤트 수신 => 소비자 신용카드 과금 =>  
    _신용카드 승인됨_ 이벤트 발행
  - (6) 주방 서비스: _신용카드 승인됨_ 이벤트 수신 => 티켓 상태를 `AWAITING_ACCEPTANCE`로 변경
  - (7) 주문 서비스: _신용카드 승인됨_ 이벤트 수신 => 주문 상태를 `APPROVED`로 변경 =>  
    _주문 승인됨_ 이벤트 발행

- 주문 생성 Saga는 어떤 Saga 참여자가 주문을 거부해서 실패 이벤트가 발행되는 경우  
  (소비자 신용카드 승인 거부 등)를 대비해야 한다. 이런 일이 발생하면 Saga는 어떻게든 보상 트랜잭션을  
  가동하여 이미 수행한 작업을 undo 해야 한다. 예를 들어, 회계 서비스에서 소비자 신용카드가  
  승인 거부된 경우, 이벤트 순서는 아래와 같다.

  - (1) 주문 서비스: 주문을 `APPROVAL_PENDING` 상태로 생성 => _주문 생성_ 이벤트 발행
  - (2) 소비자 서비스: _주문 생성_ 이벤트 수신 => 소비자가 주문 가능한지 확인 =>  
    _소비자 확인_ 이벤트 발행
  - (3) 주방 서비스: _주문 생성_ 이벤트 수신 => 주문 내역 확인 => 티켓을 `CREATE_PENDING`  
    상태로 생성 => _티켓 생성됨_ 이벤트 발행
  - (4) 회계 서비스: _주문 생성_ 이벤트 수신 => 신용카드 승인을 `PENDING` 상태로 생성
  - (5) 회계 서비스: _티켓 생성됨_ 및 _소비자 확인_ 이벤트 수신 => 소비자 신용카드 과금 =>  
    _신용카드 승인 실패_ 이벤트 발행
  - (6) 주방 서비스: _신용카드 승인 실패_ 이벤트 수신 => 티켓 상태를 `REJECTED`로 변경
  - (7) 주문 서비스: _신용카드 승인 실패_ 이벤트 수신 => 주문 상태를 `REJECTED`로 변경

- 위 과정에서 알 수 있듯이 코레오크래피 saga 참여자는 발행/구독 방식으로 소통한다.  
  그런데 Saga에서 발행/구독 방식으로 통신하면 어떤 문제점이 있을까?

<h3>확실한 이벤트 기반 통신</h3>

- 코레오그래피 방식으로 Saga를 구현하려면 두 가지 통신 이슈를 고려해야 한다.  
  첫째, **Saga 참여자가 자신의 DB를 업데이트하고, DB 트랜잭션의 일부로 이벤트를 발행** 해야 한다.  
  코레오그래피 saga는 단계별로 DB를 업데이트한 후 이벤트를 발행한다. 가령, 주문 생성 saga에서  
  주방 서비스는 _소비자 확인_ 이벤트를 받아 티켓을 생성한 후 _티켓 생성_ 이벤트를 발행한다.  
  여기서 DB를 업데이트하는 작업과 이벤트를 발행하는 작업은 원자적으로 일어나야 한다.  
  따라서 saga 참여자가 서로 확실하게 통신하려면 **트랜잭셔널 메시징**을 사용해야 한다.

- 둘째, **saga 참여자는 자신이 수신한 이벤트와 가진 데이터를 연관지을 수 있어야 한다.**  
  가령 _신용카드 승인됨_ 이벤트를 받은 주문 서비스는 여기에 해당하는 주문을 찾을 수 있어야 한다.  
  해결책은 데이터를 매핑할 수 있도록 다른 saga 참여자가 상관관계 ID가 포함된  
  이벤트를 발행하는 것이다.

- 이를테면 주문 생성 saga에서 각 참여자가 `orderId`를 상관관계 ID로 삼아 다른 참여자에게  
  건네주면 된다. _신용카드 승인됨_ 이벤트를 받은 주문 서비스는 `orderId`로 주문 정보를  
  받아올 수 있고, 주방 서비스도 같은 방법으로 티켓 정보를 가져올 수 있을 것이다.

<h3>코레오그래피 saga의 장단점</h3>

- 코레오그래피 saga는 아래와 같은 장점들이 있다.

  - **단순함** : 비즈니스 객체를 생성, 수정, 삭제할 때 서비스가 이벤트를 발행한다.
  - **느슨한 결합** : 참여자는 이벤트를 구독할 뿐, 서로를 직접 알지 못한다.

- 하지만 아래와 같은 단점들도 있다.

  - **이해하기 어렵다** : 오케스트레이션 saga와 달리, saga를 어느 한 곳에 정의한 것이  
    아니라서 여러 서비스에 구현 로직이 흩어져 있다. 어떤 saga가 어떻게 작동되는지 개발자가  
    이해하기 어려운 편이다.
  - **서비스 간 순환 의존성** : 참여자가 서로 이벤트를 구독하는 특성상, *순환 의존성*이  
    발생하기 쉽다. 주문 생성 Saga 과정만 보더라도 주문 서비스 => 회계 서비스 => 주문 서비스로  
    순환 의존성이 형성되어 있다. 이것이 반드시 문제라고 할 수는 없지만, 순환 의존성은  
    잠재적인 설계 취약점이다.
  - **단단히 결합될 위험성** : Saga 참여자는 각자 자신에게 영향을 미치는 이벤트를 모두 구독해야 한다.  
    이를테면 회계 서비스는 소비자 신용카드를 과금/환불 처리하게 만드는 모든 이벤트를 구독해야 한다.  
    따라서 이 서비스는 주문 서비스에 구현된 주문 주기와 맞물려 업데이트되어야 하는 위험성이 있다.

- 간단한 saga라면 코레오그래피 방식으로도 충분하지만, 복잡한 saga는 아무래도  
  오케스트레이션 방식이 적합하다.

<hr/>
