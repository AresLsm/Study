<h1>연관 잘 쓰기</h1>

<h2>연관의 복잡성</h2>

* 모든 Entity가 서로 연관된 모델을 사용하는 경우가 있다. JPA의 연관을 사용하면 관련 데이터에 쉽게 접근할 수 있다. 아래 예시를 보자.
```java
Order order = entityManager.find(Order.class, orderId);
List<OrderLine> orderLines = order.getOrderLines();
for(OrderLine line : orderLines) {
    Content content = line.getProduct().getContent();
    // content 사용
}
```

* 위 코드는 `Order` Entity에서 `OrderLine`, `Product`를 거쳐 `Content`까지 접근하고 있다. 모든 연관을 즉시 로딩으로 설정했다면   
  `Order`를 로딩하는 시점에 나머지 Entity들을 로딩하기 위한 query도 같이 수행될 것이다. 하지만 `Order` Entity 하나를 로딩하는데   
  연관된 모든 Entity를 로딩하는 것은 비효율적이다. 이럴 때에 Entity를 어떤 식으로 사용할지를 미리 고려햐여 지연 로딩과 즉시 로딩을   
  적절하게 사용해야 한다.

* 하지만 지연 로딩과 즉시 로딩을 적절하게 섞어 사용하는 것이 쉽지만은 않다. 상황에 따라 필요한 연관 객체가 다르기 때문이다.

<h3>편리한 객체 탐색과 높은 결합도</h3>

* 모든 Entity를 연관으로 연결하면 객체 탐색을 통해서 쉽게 원하는 객체에 접근할 수 있다. 만약 `Order`와 `User`가 연관으로   
  연결되어 있다면 아래와 같이 `Order`객체의 메소드에서 `User`객체의 정보를 변경하는 것이 가능하다.
```java
public class Order {

    private User owner;  // User와 연관

    public void changeShippingAddress(Address newAddress, boolean useUserAddress) {
        this.shippingAddress = newAddress;
        if(useUserAddress) {
            // 연관된 User의 데이터 변경
            owner.setAddress(newAddress);
        }
    }
}
```
* 위와 같이 연관된 객체를 사용하면 처음에는 편리하게 기능을 구현할 수 있지만, 이는 `Order`가 `User`에 강하게 영향을 받게 한다.   
  예를 들어 `User#setAddress()`가 `Address` 대신에 다른 타입을 필요로 하면 `Order#changeShippingAddress()`의 인수도 그에 맞게   
  변경되어야 한다. 반대로 `Order`가 `shippingAddress()`의 타입을 `Address`가 아닌 다른 타입으로 변경하는 경우에도   
  `orderer#changeShippingAddress()`에 관련 코드를 추가해야 한다.

* 사실 `Order`의 입장에서 배송지 주소 변경 기능 자체는 `User`의 주소 변경과 관련이 없다. `Order`는 주문과 관련된 배송지 주소   
  변경 로직만 구현하면 된다. 단지 연관된 객체를 이용하면 기능을 구현하기 쉽기에 `Order`의 배송지 주소를 변경하면서 연관된   
  `User`객체의 주소도 함께 변경한 것이다.

* 이렇게 한 Entity에서 다른 Entity의 상태를 변경하는 기능을 실행하면 Entity가 서로 강하게 엮이게 되면서 서로 수정을 어렵게   
  만드는 원인이 될 수 있다.
<hr/>

<h2>연관 범위 한정과 식별자를 통한 간접 참조</h2>

