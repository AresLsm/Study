# 지연성 2

<h2>결과를 만드는 함수 reduce, take</h2>

- 기존의 `reduce()`, `take()` 함수를 보자.

```js
const take = curry(limit, iterable) => {
  let res = [];
  for(const a of iterable) {
    res.push(a);
    if(res.length === limit) return res;
  }
  return res;
});

const reduce = curry((fn, start, iterable) => {
  if(!iterable) {
    iterable = start[Symbol.iterator]();
    start = iterable.next().value;
  }
  for(const a of iterable) {
    start = fn(start, a);
  }
  return start;
});
```

- `reduce()`, `take()`는 최종적으로 어떤 함수의 결과를 만드는 함수라고 할 수 있다.  
  이들은 iterable이나 배열의 값들을 꺼내서 특정 연산을 하는 식으로 값을 변경 후 다시 iterable 또는 배열에  
  넣는 것이 아니라, 값을 빼내서 그 값을 깨뜨려야 하기에 최종적으로 결과를 만드는 함수라고 할 수 있다.  
  즉, 연산을 시작하는 함수라고 할 수 있다.

- `take()`도 조건에 맞으면 yield 시키도록 하여 지연성을 줄 수 있지만, 몇 개의 원소를 가지는지 모르는 배열 또는 iterable을  
  전달받아 특정 개수의 배열로 축약을 하고 완성을 지어버리는 성질을 가지기에 `take()` 자체에는 지연성을 주는 것보다  
  실제로 `take()`가 수행될 때 값이 평가되도록 다른 함수들에 지연성을 주는 것이 중요하다.

<hr/>

<h2>queryStr 함수 만들기</h2>

- `reduce()`를 활용한 함수를 만들어보자.  
  이 함수는 객체로부터 URL의 query string 부분을 만들어 내는 함수이다.

```js
const queryStr = (obj) =>
  go(
    obj,
    Object.entries,
    map(([k, v]) => `${k}=${v}`),
    reduce((a, b) => `${a}&${b}`)
  );

console.log(queryStr({ limit: 10, offset: 10, type: "notice" }));
// limit=10&offset=10&type=notice
```

- obj를 받아 첫 번째 인자로 obj를 그대로 전달하기에 아래처럼 해도 된다.

```js
const queryStr = (obj) =>
  pipe(
    Object.entries,
    map(([k, v]) => `${k}=${v}`),
    reduce((a, b) => `${a}&${b}`)
  );
```

<hr/>
