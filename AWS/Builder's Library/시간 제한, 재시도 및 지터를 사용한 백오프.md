# 시간 제한, 재시도 및 지터를 사용한 백오프

- <a href="https://aws.amazon.com/ko/builders-library/timeouts-retries-and-backoff-with-jitter/?did=ba_card&trk=ba_card">Amazon Builder's Library</a>

## 장애 발생 및 복원력

- 서비스는 서버, 네트워크, 로드 밸런서, 운영자의 실수까지 등 많은 요인들로부터 장애가 발생할 수 있다.  
  장애 가능성이 낮은 시스템을 설계할 수 있으나, 결코 실패하지 않는 시스템을 구축하는 것은 불가하다.

> - 복원력: 시스템의 장애 가능성을 줄이고, 실패를 허용하는 시스템을 설계해 **작은 규모의 장애가 전면적인 가동 중단으로 확대되는 것을 방지하는 능력**

- AWS에서는 _복원력_ 이 우수한 시스템을 구축하기 위해 **시간 제한, 재시도, 백오프** 를 제시한다.

- 이 각각을 AWS에서는 어떻게 처리하는 지에 대해 보기전에, 개념을 간단히 훑어보자.

### 시간 제한

- 수많은 장애 유형은 **요청이 평소보다 오래 걸리고 완료되지 않을 때** 명확히 확인된다.  
  요청이 오래 걸리면 클라이언트는 요청을 위한 리소스를 오랜 시간 붙잡고 이써야 하고, 서버에서도 마찬가지로 리소스 부족 현상이  
  발생할 수 있다. 이러한 문제를 해결하기 위해 클라이언트는 **시간 제한**을 설정한다.  
  이는 즉 **클라이언트가 요청이 완료될 때까지 기다리는 최대 시간** 이다.

### 재시도

- 실패한 요청을 동일하게 다시 시도했을 때 성공하는 경우도 있지만, *부분적이거나 일시적인 장애*가 더 발생하기 쉽다.

  - **부분적인 장애** : 일정 비율의 요청이 성공하는 것
  - **일시적인 장애** : 잠시 동안 모든 요청이 실패하는 것

- **재시도** : 클라이언트가 동일한 요청을 다시 전송해 부분적인 장애와 단기적인 일시적 장애 상황을 해결하는 방법

- 하지만 재시도가 항상 안전하진 않다. 시스템이 오버로드에 가까워져 이미 장애가 발생한 경우, 재시도로 인해 호출 중인 시스템의  
  로드가 증가할 수 있다. 이러한 문제를 방지하는 방법이 **백오프** 이다. 백오프를 사용하면 장애 이후 수행되는 재시도 간의  
  대기 시간이 증가해 백엔드의 부하가 일정하게 유지된다.

- 시스템 오버로드 뿐만 아니라, 재시도는 일부 원격 호출에 부작용이 수반된다는 문제점이 있다.  
  물론 이를 방지하는 가장 좋은 방법은 **API를 멱등하게 설계하여** 안전하게 재시도할 수 있도록 하는 것이다.

### 지터

- 시스템 부하로 인해 오류가 발생했을 때, 모든 클라이언트가 동시에 재시도하게 되므로 재시도가 비효율적일 수 있다.  
  이를 방지하기 위해 **지터** 를 적용한다.

- **지터** : 임의로 지정한 시간, 이 시간이 지나면 도착률을 분산시켜 대량의 burst를 방지하도록 요청을 작성하거나 재시도하게 된다.

<hr/>

## 시간 제한 (Timeout)

- AWS가 사용하는 모범 사례는 아래와 같다.

  - 모든 원격 호출, 심지어는 동일한 시스템의 경우에도 프로세스 간의 모든 호출에는 일반적으로 시간 제한을 설정한다.  
    (연결 시간 제한, 요청 시간 제한 모두 포함)

- 그렇다면 설정할 timeout 값은 어떻게 결정할까?  
  너무 높게 설정하면 클라이언트가 대기하는 시간 내에서도 리소스가 사용되기에 유용성이 떨어지고, 너무 낮게 설정하면  
  재시도 회수가 많아져 백엔드의 트래픽과 대기 시간이 증가하며, 모든 요청의 재시도가 시작되기에 백엔드의 규모가 작을 경우  
  지연 시간의 증가가 완전한 가동 중단을 일으킬 수 있다.

- AWS Region 내의 요청에 대한 timeout을 정하는 좋은 방법으로 AWS는 downstream service의 latency metric을  
  볼 것을 추천한다. 예를 들어보자. 하나의 서비스가 다른 서비스로 요청할 때, _허용 가능한 가짜 timeout의 비율_ 을 설정한다.  
  이 비율이 0.1% 라고 해보자. 그런 다음, 해당 요청을 처리하는 downstream service의 latency metric을 측정한다.  
  이 예시 상황에서는 p99.9 를 측정할 것이다. p99.9의 latency가 1초 라고 했다면, 이 경우 timeout은 1초로 설정할 것이다.

- 하지만 이 방식은 아래와 같은 몇 가지 함정 및 신경써야 할 점들이 있다.

  - 인터넷을 사용하는 등 클라이언트가 상당한 네트워크 대기시간을 갖게될 경우에는 부적합하다.  
    이러한 경우, 클라이언트가 전 세계에서 요청을 할 수 있음을 염두에 두고 합리적인 수준으로 최악의 네트워크 대기 시간까지 고려해야 한다.

  - latency의 범위가 좁은 서비스(예를 들어 p99.9와 p50이 별반 다를게 없는 경우)에는 적합하지 않다.  
    이런 서비스의 경우, 평균 latency에 전후로 시간을 조금 추가해 latency가 조금만 증가해서 timeout이 많이  
    발생하는 상황을 방지할 수 있다.

  - timeout을 구현할 때도 주의해야 할 점이 몇 가지 있다. Linux의 SO_RCVTIMEO는 강력하지만 단점 또한 있어 end-to-end  
    socket timeout으로 사용하기엔 좋지 않다. Java의 경우에는 timeout 제어 메커니즘을 드러내는 반면, Go 등의 언어에서는  
    보다 강력한 timeout 메커니즘을 제공한다.

  - timeout이 DNS 작업에 소요되는 시간, TLS Handshake에 소요되는 시간 등 원격 호출의 모든 과정을 포함하지 않는 경우가 있다.  
    AWS에서는 일반적으로 timeout을 결정할 때 socket 관련하여 소요되는 시간과 실제 작업 수행 시간을 파악하는 데 집중한다고 한다.

<hr/>

## 재시도(Retry)와 Backoff
