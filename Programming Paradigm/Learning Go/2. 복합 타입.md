# 복합 타입

## 배열

- Go도 배열을 갖지만, 직접 배열을 사용하는 경우는 드물다.

- 배열의 모든 요소는 지정된 타입이어야 한다. 배열을 선언하는 방법에는 몇 가지가 있는데, 첫 번째는 아래처럼 배열의 크기와 요소 타입을  
  지정하는 방법이다.

```go
var x [3]int
```

- 위 선언은 3개의 정수 요소를 갖는 배열을 생성한다. 값은 지정하지 않았기에 배열의 모든 위치에는 각각 정수의 zero value인 0이  
  들어간다. 배열에 초기값을 주려면 **배열 리터럴**로 요소 값을 넣을 수 있다.

```go
var x = [3]int{10, 20, 30}
```

- **희소 배열** (대부분의 값이 0으로 설정된 배열)을 만든다면, 배열 리터럴 내에 지정된 index의 값만 설정할 수 있다.

```go
var x = [12]int{1, 5: 4, 6, 10: 100, 15}
```

- 위 선언은 `[1, 0, 0, 0, 0, 5, 6, 0, 0, 0, 100, 15]`의 값을 갖는 배열을 생성한다.

- `==`와 `!=`를 사용해 배열 간의 비교도 가능하다.

```go
var x = [...]int{1, 2, 3}
var y = [3]int{1, 2, 3}
fmt.Println(x == y) // true
```

- Go에서 다차원 배열은 배열의 요소로 다른 배열을 포함하는 배열이다.

```go
var x [2][3]int
```

- 위에서 길이가 2인 정수 배열은 길이가 3인 정수 배열을 요소로 갖는다.  
  마지막으로 아래처럼 괄호를 사용해 값을 읽거나 쓸 수 있다.

```go
x[0] = 10
fmt.Println(x[2])
```

- 배열에서 배열의 끝을 넘어서거나 음수의 index를 사용해 값을 읽거나 쓸 수 없다. 이를 상수나 리터럴 index로 한다면 컴파일 오류가 발생한다.  
  범위를 넘어서는 값을 가진 변수를 통해 배열을 읽거나 쓰기를 시도한다면 컴파일은 되겠지만, 실행 중에 panic이 발생하며 실행이 중단된다.

- 마지막으로 내장 함수인 `len()`으로 배열의 길이를 알 수 있다.

```go
fmt.Println(len(x))
```

- 위에서 말했듯이 Go에서 배열은 거의 사용되지 않는다. 이유는 Go에서 배열의 크기를 배열 타입의 일부로 간주한다는 제한이 있기 때문이다.  
  예를 들어 `[3]int`로 선언된 배열은 `[4]int`와 다른 타입으로 만든다. 이는 곧 배열의 크기를 지정하기 위해 변수를 사용할 수  
  없다는 뜻이다. 왜냐면 타입은 실행 중이 아니라 컴파일 과정에서 반드시 해석되어야 하기 때문이다.

- 또한 동일한 타입을 가진 다른 크기의 배열 간에 타입 변환을 시도할 수도 없다. 크기가 다른 배열을 서로 변환할 수는 없기에  
  어떤 크기의 배열로도 실행 가능한 함수를 작성할 수 없으며, 동일한 변수에 크기가 다른 배열을 할당할 수 없다.

- 이러한 제약들 때문에 정확히 미리 필요한 크기를 아는 경우가 아니라면, 배열을 사용하지 않도록 한다.

---

## slice

TODO: p.69

---

## string, rune, byte

- Go의 문자열이 rune으로 만들어진다고 생각할 수 있지만, 실제로 그렇지 않다.  
  내부적으로 Go는 문자열을 표현하기 위해 일련의 byte를 사용한다. 이 byte는 어느 특정한 문자 인코딩을 가지진 않지만,  
  몇몇의 Go 라이브러리 함수는 문자열이 UTF-8 encoding으로 구성되어 있다고 간주한다.

> Go 언어 스펙에 따르면, Go 소스 코드는 항상 UTF-8로 쓰여진다. 문자열 리터럴에 16진수 escape를 사용하지  
> 않는다면, 문자열 리터럴은 UTF-8로 쓰여진다.

- 배열이나 slice에서 단일 값을 추출하는 것과 같이, 문자열도 index 표현으로 값을 꺼내올 수 있다.

```go
var s string = "Hello there"
var b byte = s[6]
```

- 배열, slice 처럼 문자열 index는 0부터 시작한다.  
  또한 slice 표기법은 문자열에서도 통용된다.

```go
var s string = "Hello there"
var s2 string = s[4:7] // "o t"
var s3 string = s[:5] // "Hello"
var s4 string = s[6:] // "there"
```

- Go에서 문자열에 개별 요소를 꺼내기 위해 index 표기법을 사용하고, 하위 문자열을 만들기 위해 slice 표기법을 사용하도록 하는 것은  
  매우 편리하지만, 매우 조심스럽게 다뤄야 한다. 문자열은 변경이 불가하기 때문에, slice의 slice에서 발생한 수정 문제와 같은 것은  
  없다. 하지만 다른 문제가 있다. **문자열은 일련의 byte로 구성되는데, UTF-8 코드는 1에서 4byte로 어디든 위치할 수 있기 때문이다.**  
  예를 들어, 영어가 아닌 다른 나라의 언어나 이모티콘을 처리하려 할 때, 여러 byte에 걸쳐 UTF-8의 코드를 사용해 코드를 수행해야 한다.

```go
var s string = "Hello 🥳"
var s2 string = s[4:7]
var s3 string = s[:5]
var s4 string = s[6:]
```

- s의 마지막에는 이모티콘이 있는데, 위 코드를 수행하면 원하는 대로 결과가 나오지 않게 된다.  
  이모티콘의 첫 번째 byte만 복사해 유효하지 않은 코드가 되었기 때문이다.

- Go는 내장 함수 `len()`에 문자열을 넘겨 해당 문자열의 길이를 알아낼 수 있다.  
  문자열 index와 slice 표현식이 위치를 byte 단위로 계산한다는 것을 생각하면, `len()`을 통해 반환된 길이는 코드 단위가 아니라  
  byte 단위라는 것을 알 수 있다.

```go
var s string = "Hello 🥳"
fmt.Println(len(s)) // 10
```

- rune, string, byte 사이의 복잡한 관계 때문에 Go는 이런 타입들 간에 변환할 수 있는 기능을 제공한다.  
  아래처럼 단일 rune 또는 byte는 string으로 변환이 가능하다.

```go
var a rune = 'x'
var s string = string(a)
var b byte = 'y'
var s2 string = string(b)
```

> 타입 변환으로 정수를 문자열로 변경하지 말자. 아래 코드를 보자.
>
> ```go
> var x int = 65
> var y = string(x)
> fmt.Println(y) // A
> ```

- string은 byte slice나 rune slice로 변환이 가능하다.

```go
var s string = "Hello 🥳"
var bs []byte = []byte(s)
var rs []rune = []rune(s)
```

- Go에서 대부분의 데이터는 일련의 byte로 읽거나 쓸 수 있어서, 대부분의 일반 string은 byte slice로 타입 변환이 가능하다.  
  rune slice로의 변환은 드문 경우이다.

- 문자열을 slice와 index 표현법으로 사용하기 보다는, 표준 라이브러리인 `strings`나 `unicode/utf8` 패키지에 있는  
  함수를 사용해 하위 문자열이나 코드 포인트를 추출해 사용하자.

---

## map

---

## struct

---
