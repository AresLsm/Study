## 질의 함수와 변경 함수 분리하기

```js
// 리팩토링 적용 전
function getTotalOutstandingAndSendBill() {
  const result = customer.invoices.reduce(
    (total, each) => each.amount + total,
    0
  );
  sendBill();
  return result;
}

// 리팩토링 적용 후
function totalOutstanding() {
  return customer.invoices.reduce((total, each) => each.amount + total, 0);
}

function sendBill() {
  emailGateway.send(formatBill(customer));
}
```

### 배경

- 우리는 외부에서 관찰할 수 있는 겉보기 부수효과(Observable side effect)가 전혀 없이 값을 반환해주는  
  함수를 추구해야 한다. 이런 함수는 어느 때든 원하는만큼 호출해도 아무런 문제가 없다. 호출하는 문장의  
  위치를 호출하는 함수 안 어디로든 옮겨도 되며 테스트하기도 쉽다. 한마디로, 이용할 때 신경 쓸 거리가 매우 적다.

- 겉보기 부수효과가 있는 함수와 없는 함수는 명확히 구분하는 것이 좋다. 이를 위한 한 가지 방법은  
  _'질의 함수(읽기 함수)는 모든 부수효과가 없어야 한다'_ 는 규칙을 따르는 것이다. 이를  
  **명령-질의 분리(Command-Query Seperation)** 라 하는데, 이 규칙을 100% 따르려 노력하자.

- 값을 반환하면서 부수 효과도 있는 함수를 발견하면 상태를 변경하는 부분과 질의하는 부분을 분리하자.

- _겉보기_ 부수효과라고 하는 데는 이유가 있다. 흔히 쓰는 최적화 기법 중 요청된 값을 캐싱해두고  
  다음번 호출 때 빠르게 응답하는 방법이 있는데, 이러한 캐싱도 객체의 상태를 변경하지만 객체 밖에서는  
  관찰할 수 없다. 즉, 겉보기 부수효과 없이 어떤 순서로 호출하든 모든 호출에 항상 똑같은 값을 반환할 뿐이다.

### 절차

- (1) 대상 함수를 복제하고 질의 목적에 충실한 이름을 짓는다.  
  함수 내부를 살펴 무엇을 반환하는지 찾고, 만약 어떤 변수의 값을 반환한다면 그 변수명이  
  훌륭한 단초가 된다.

- (2) 새 질의 함수에서 부수효과를 모두 제거한다.

- (3) 정적 검사 수행

- (4) 원래 함수(변경 함수)를 호출하는 곳을 모두 찾아낸다. 호출하는 곳에서 반환 값을 사용한다면  
  질의 함수를 호출하도록 바꾸고, 원래 함수를 호출하는 코드를 바로 아래줄에 새로 추가한다.  
  하나 수정할 때마다 테스트한다.

- (5) 원래 함수에서 질의 관련 코드를 제거한다.

- (6) 테스트한다.

### 예시

- 이름 목옥을 훑어 악당을 찾는 함수를 보자. 악당을 찾으면 그 사람의 이름을 반환하고 경고를 울린다.

```js
function alertForMiscreant(people) {
  for (const p of people) {
    if (p === "JOKER") {
      setOffAlarms();
      return "JOKER";
    }
    if (p === "EVIL") {
      setOffAlarms();
      return "EVIL";
    }
  }
  return "";
}
```

- 첫 단계는 _(1) 함수를 복제하고 질의 목적에 맞는 이름짓기다._

```js
function findMiscreant(people) {
  for (const p of people) {
    if (p === "JOKER") {
      setOffAlarms();
      return "JOKER";
    }
    if (p === "EVIL") {
      setOffAlarms();
      return "EVIL";
    }
  }
  return "";
}
```

- 다음으로 _(2) 새 질의 함수에서 부수효과를 낳는 부분을 제거_ 한다.

```js
function findMiscreant(people) {
  for (const p of people) {
    if (p === "JOKER") {
      return "JOKER";
    }
    if (p === "EVIL") {
      return "EVIL";
    }
  }
  return "";
}
```

- 이제 _(4) 원래 함수를 호출하는 곳을 모두 찾아 새로운 질의 함수를 호출하도록 하고_,  
  _이어서 원래의 변경 함수를 호출하는 코드를 바로 아래 삽입한다._

```js
// client(before)
const found = alertForMiscreant(people);

// client(after)
const found = findMiscreant(people);
alertForMisceant(people);
```

- 마지막으로 _(5) 원래의 변경 함수에서 질의 관련 코드를 제거한다._

```js
function alertForMiscreant(people) {
  for (const p of people) {
    if (p === "JOKER") {
      setOffAlarms();
      return;
    }
    if (p === "EVIL") {
      setOffAlarms();
      return;
    }
  }
  return;
}
```

#### 더 가다듬기

- 이번 아이템은 여기서 끝이지만, 변경 함수의 새로운 질의 함수에는 중복 코드가 많아 보인다.  
  이번 경우에는 변경 함수에서 질의 함수를 사용하도록 고치면 된다.(**알고리즘 교체하기**)

```js
function alertForMiscreant(people) {
  if (findMiscreant(people) !== "") setOffAlarms();
}
```

<hr/>
