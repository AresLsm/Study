# 클래스, 객체, 인터페이스

- 이번 장에서는 코틀린 클래스를 다루는 방법을 더 깊이 알아보자.

- 코틀린의 클래스와 인터페이스는 Java 클래스, 인터페이스와는 약간 다르다.  
  예를 들어, 인터페이스에 프로퍼티 선언이 들어갈 수 있다. Java와 달리 코틀린 선언은  
  기본적으로 final이며 public이다. 게다가 중첩 클래스는 기본적으로는 내부 클래스가  
  아니다. 즉, 코틀린 중첩 클래스에서는 외부 클래스에 대한 참조가 없다.

- 짧은 주 생성자 구문으로도 거의 모든 경우를 잘 처리할 수 있다. 하지만 복잡한 초기화  
  로직을 수행하는 경우를 대비한 완전한 문법도 있다. 프로퍼티도 마찬가지다. 간결한 프로퍼티  
  구문으로도 충분히 제 몫을 하지만, 필요하면 접근자를 직접 정의할 수 있다.

- 코틀린 컴파일러는 번잡스러움을 피하기 위해 유용한 메소드를 자동으로 만들어준다. 클래스를 data로  
  선언하면 컴파일러가 일부 표준 메소드를 생성해준다. 그리고 코틀린 언어가 제공하는 위임(delegation)을  
  사용하면, 위임을 처리하기 위한 준비 메소드를 직접 작성할 필요가 없다.

- 코틀린에서는 클래스와 인스턴스를 동시에 선언하면서 만들 수 있는 object 키워드가 있다.  
  싱글톤 클래스, 동반 객체(companion object), 객체 식(object expression, Java의 익명 클래스)을  
  표현할 때 object 키워드를 쓴다.

<hr/>

## 요약

- 코틀린의 인터페이스는 Java 인터페이스와 비슷하지만, 디폴트 구현을 포함할 수 있고(Java는 Java8부터 지원),  
  프로퍼티도 포함할 수 있다.

- 모든 코틀린 선언 기본적으로 final이며 public이다.

- 선언이 final이 되지 않게 만들려면 open 키워드를 사용한다.

- internal 선언은 같은 모듈 안에서만 볼 수 있다.

- 중첩 클래스는 기본적으로 내부 클래스가 인다. 바깥쪽 클래스에 대한 참조를 중첩 클래스 안에 포함시키려면  
  inner 키워드를 중첩 클래스 선언 앞에 붙여서 내부 클래스로 만들어야 한다.

- sealed 클래스를 상속하는 클래스를 정의하려면 반드시 부모 클래스 정의 안에 중첩 또는 내부 클래스로  
  정의해야 한다.(Kotlin 1.1부터는 같은 파일 내에만 있으면 된다.)

- 초기화 블록과 부 생성자를 활용해 클래스 인스턴스를 더 유연하게 초기화할 수 있다.

- field 식별자를 통해 프로퍼티 접근자(getter, setter) 안에서 프로퍼티의 데이터를  
  저장하는 데 쓰이는 backing field를 참조할 수 있다.

- 데이터 클래스를 사용하면 컴파일러가 `equals()`, `hashCode()`, `toString()` 메소드를 자동으로 생성해준다.

- 클래스 위임을 사용하면(by 키워드) 위임 패턴을 구현할 때 필요한 수많은 성가신 준비 코드를 줄일 수 있다.

- 객체 선언을 사용하면 코틀린답게 싱글톤 클래스를 정의할 수 있다.

- 패키지 수준 함수와 프로퍼티, 및 동반 객체와 더불어 동반 객체는 Java의 정적 메소드와  
  필드 정의를 대신한다.

- 동반 객체도 다른 싱글톤 객체와 마찬가지로 인터페이스를 구현할 수 있다. 외부에서 동반 객체에 대한  
  확장 함수와 프로퍼티를 정의할 수 있다.

- 코틀린의 객체 식은 Java의 무명 내부 클래스를 대신한다. 하지만 코틀린 객체 식은 여러 인스턴스를  
  구현하거나, 객체가 포함된 영역(scope)에 있는 변수의 값을 변경할 수 있는 등 Java의 무명 내부  
  클래스보다 더 많은 기능을 제공한다.

<hr/>
