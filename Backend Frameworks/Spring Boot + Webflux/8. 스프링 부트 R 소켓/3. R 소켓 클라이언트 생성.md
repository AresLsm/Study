# R Socket 클라이언트 생성

- R Socket 클라이언트는 외부로부터 HTTP 요청을 받아서 R Socket 연결을 통해 백엔드 서버로  
  요청을 전달한다. 그래서 HTTP 요청을 받을 수 있는 Webflux 컨트롤러가 필요하다.  
  WebSocket을 사용해서 브라우저와 백엔드 서버가 통신하는 것만큼 복잡하지는 않을 것이다.

- 우선 컨트롤러 클래스를 만들어보자.

```kt
@RestController
class RSocketController(
    private val builder: RSocketRequester.Builder // (1)
) {

    private val requester: Mono<RSocketRequester> = builder
        .dataMimeType(MediaType.APPLICATION_JSON) // (2)
        .metadataMimeType(parseMediaType(WellKnownMimeType.MESSAGE_RSOCKET_ROUTING.toString())) // (3)
//            .connectTcp("localhost", 7000)
//            .retry(5)
//            .cache()
        .tcp("localhost", 7000) // (4)
        .toMono()
	.retry(5) // (5)
	.cache() // (6)
}
```

> 주석 처리한 부분은 Deprecated된 부분이다.

- 위 코드에서는 `RSocketRequester`를 `Mono`로 감싸서 R Socket에 연결된 코드가 클라이언트가  
  구독할 때마다 호출되도록 했다.

  - (1) Spring Boot는 `RSocketRequesterAutoConfiguration` 정책 안에서 `RSocketRequester.Builder` bean을 만들어준다.  
    Jackson을 포함해서 여러 가지 encoder, decoder를 사용할 수 있다.
  - (2) `dataMimeType()`을 이용해서 데이터의 미디어 타입을 지정해준다. 여기서는 `application/json`을 나타내는  
    Spring 상수를 사용했다.
  - (3) 라우팅 정보와 같은 메타데이터 값을 R Socket의 표준인 `message/x.rsocket.routing.v0`로 지정한다.
  - (4) TCP를 사용하므로 hostname과 port number를 지정하고, `tcp()`를 호출해서 7000번 포트를 사용하는  
    R Socket 서버에 연결한다.
  - (5) 견고성을 높이기 위해 메시지 처리 실패 시 `Mono`가 5번까지 재시도할 수 있도록 지정한다.
  - (6) 요청 `Mono`를 Hot Source로 전환한다. Hot Source에서는 가장 최근의 신호는 캐시되어 있을 수도  
    있으며, 구독자는 사본을 갖고 있을 수도 있다. 이 방식은 다수의 클라이언트가 동일한 하나의 데이터를  
    요구할 때 효율성을 높일 수 있다.

- `RSocketRequester`는 JavaDoc에 따르면 _R Socket에 무언가를 보낼 때 사용하는 얇은 포장재_ 와 같다.  
  결국 R Socket의 API는 프로젝트 리액터를 사용한다.

- R Socket에 Spring 메시징 패러다임은 포함되지 않았다. `RSocketRequester`를 사용해야  
  스프링 프레임워크와 연동된다. 이렇게 하면 도착지를 기준으로 메시지를 라우팅할 수 있다.  
  그리고 추가적으로 트래픽의 encoding, decoding도 쉽게 할 수 있다.  
  `RSocketRequester`를 사용하지 않으면, 클라이언트와 서버 양쪽의 R Socket 연결에서 데이터를  
  직접 관리해야 한다.

- 그런데 왜 `RSocketRequester`를 `Mono`로 감싸는 것일까? 리액터의 `Mono` 패러다임은  
  연결(connection)을 R Socket 연결의 세부 정보를 포함하는 지연 구조체(lazy construct)로 전환한다.  
  아무도 연결하지 않으면 R Socket은 열리지 않는다. 누군가가 구독을 해야지만 세부정보가 여러 구독자에게  
  공유될 수 있다.

- 하나의 R Socket만으로 모든 구독자에게 서비스할 수 있다는 점도 중요하다. R Socket을 구독자마다  
  1개씩 만들 필요가 없다. 대신에 하나의 R Socket 파이프에 대해 구독자별로 하나의 연결을 생성한다.

- 이렇게 준비 과정을 마쳐야 R Socket이 네트워크를 통해 오가는 데이터 프레임을 리액티브하게 전송하고  
  배압을 처리하는 데 집중할 수 있다. Spring 프레임워크는 데이터 encoding, decoding과 라우팅을  
  담당할 수 있다. 리액터는 요청 처리 전 과정을 지연 방식으로 수행할 수 있어서 자원의 효율성을  
  높일 수 있다.

## Webflux 요청을 RSocket 요청-응답으로 변환

-
