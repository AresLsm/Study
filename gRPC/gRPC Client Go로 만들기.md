# gRPC Client Go로 만들기

- [원본 코드](https://github.com/Example-Collection/go-grpc-client)

- Proto 파일을 컴파일하고 import하는 과정은 [여기](https://github.com/sang-w0o/Study/blob/master/gRPC/gRPC%20Server%20Go%EB%A1%9C%20%EB%A7%8C%EB%93%A4%EA%B8%B0.md#grpc-server-go%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0)에서 확인할 수 있다.

<details><summary>Proto File</summary>

<p>

```proto
syntax = "proto3";

package proto;

option go_package="github.com/Example-Collection/go-grpc-client/proto";

service PersonService {
  // 사용자 정보 저장 요청, Unary RPC
  rpc GetPersonInformation(PersonRequest) returns (PersonResponse) {}

  // email이 일치하는 모든 사용자 정보 요청, Server Streaming RPC
  rpc ListPersons(ListPersonRequest) returns (stream PersonResponse) {}

  // 다수의 사용자 저장 요청, Client Streaming RPC
  rpc savePersons(stream PersonRequest) returns (BasicResponse) {}

  // 사용자 정보 실시간 요청, Bidirectional Streaming RPC
  rpc askAndGetPersons(stream PersonRequest) returns (stream PersonResponse) {}
}

message PersonRequest {
  string name = 1;
  int64 age = 2;
  string email = 3;
  string password = 4;
}

message PersonResponse {
  string name = 1;
  int64 age = 2;
  string email = 3;
  string message = 4;
}

message ListPersonRequest {
  string email = 1;
}

message BasicResponse {
  string message = 1;
}
```

</p></details>

## Client 구축하기

- Client를 실행하기 위한 코드부터 보자.

```go
var (
	serverAddr = flag.String("addr", "localhost:8081", "The server address in the format of host:port")
)

func main() {

  // Create gRPC Channel
	conn, err := grpc.Dial(*serverAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Fatalf("failed to dial: %v", err)
	}

  // Close gRPC Channel when function main() ends.
	defer conn.Close()

  // Get Stub, which is generated by protoc.
	client := pb.NewPersonServiceClient(conn)

	// Unary RPC
	personRequest := &pb.PersonRequest{
		Name:     "Sangwoo",
		Age:      25,
		Email:    "robbyra@gmail.com",
		Password: "sangwooPassword",
	}
	printResponseAfterCallingGetPersonInformation(client, personRequest)
}
```

- Service 메소드를 클라이언트에서 호출하기 위해서는 우선 특정 host, port에 대해 *gRPC Channel*을 만들어야 한다.  
  gRPC Channel은 `grpc.Dial()`을 통해 gRPC Channel을 만들 수 있다.
  그리고 `main()`이 종료되면 꼭 Channel이 _closed_ 상태로 바뀔 수 있도록 `defer conn.Close()`를 추가했다.

> gRPC Channel: gRPC 서버의 특정 host, port에 대한 connection

- Channel이 만들어졌다면, 다음으로는 클라이언트에서 service에 정의된 메소드를 구현한 *Stub*을 사용해 RPC를  
  수행할 수 있어야 한다. 이는 proto file을 컴파일해 나온 `NewPersonServiceClient()`를 사용해 가져올 수 있다.

### Unary RPC

- 가장 먼저 Unary RPC인 `GetPersonInformation`을 구현해보자.  
  아래 코드의 핵심은 Stub인 `pb.PersonServiceClient`에 대해 `GetInformation()`을 호출했다는 것이다.  
  호출 전, 호출 후에는 콘솔에 내용을 출력하도록 했다.

```go
func printResponseAfterCallingGetPersonInformation(client pb.PersonServiceClient, req *pb.PersonRequest) {

  // Print to console beefore sending request.
	log.Printf("Sending request to save person (name: %v, age: %d, email: %v)", req.Name, req.Age, req.Email)

  // Create context with deadline.(10 seconds)
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

  // Call RPC
	response, err := client.GetPersonInformation(ctx, req)
	if err != nil {
		log.Fatalf("%v.GetPersonInformation(_) = _, %v", client, err)
	}
	log.Printf("Response: Person(name: %v, message: %v", response.Name, response.Message)
}
```

- `context.WithTimeout()`으로는 10초의 Deadline이 있는 `Context`를 만들었다.  
  만약 서버에서 10초 내에 응답이 오지 않으면, 아래의 예외가 발생한다.

```
2022/01/06 14:55:05 &{0x140001b2000}.GetPersonInformation(_) = _, rpc error: code = DeadlineExceeded desc = context deadline exceeded
```

- 위에서 만든 `Context`와 request 파라미터(`*pb.PersonRequest`)와 함께 stub에 대해 `GetPersonInformation()`을 호출한다.  
   그리고 마지막에 응답이 오면 콘솔에 출력한다.

- 성공적으로 완성된 RPC는 아래와 같은 결과가 콘솔에 출력된다.

```
2022/01/06 14:58:38 Sending request to save person (name: Sangwoo, age: 25, email: robbyra@gmail.com)
2022/01/06 14:58:38 Response: Person(name: Sangwoo, message: Successfully saved!(name:Sangwoo)
```

### Server Streaming RPC

- 이제 Server Streaming RPC를 구현해보자. Server Streaming RPC는 서버에서 단일 응답을 주는게 아니라 일련의 message들을  
  담은 Stream을 반환한다. 따라서 stream에서 message들을 하나씩 읽어오는 부분을 유의해서 보자.

```go
func printResponseAfterCallingListPersons(client pb.PersonServiceClient, req *pb.ListPersonRequest) {
	log.Printf("Sending request to get all persons with email: %v", req.Email)

  // Deadline: 1 hour
	ctx, cancel := context.WithTimeout(context.Background(), time.Hour)
	defer cancel()

  // Get stream
	stream, err := client.ListPersons(ctx, req)
	if err != nil {
		log.Fatalf("%v.ListPersons(_) = _, %v", client, err)
	}

  // Read messages from stream
	for {
    // Read single message
		person, err := stream.Recv()

    // If err is EOF, break for statement.
		if err == io.EOF {
			break
		}

		if err != nil {
			log.Fatalf("%v.ListPersons(_) = _, %v", client, err)
		}
		log.Printf("Response: Person(name: %v, message: %v)", person.Name, person.Age)
	}
}
```

- 생각보다 단순한데, stub에 대해 Server Streaming RPC인 `ListPersons()`를 호출하면 stream이 반환된다.  
  그리고 for문을 이용해 한 번 반복될 때마다 stream의 `Recv()`를 이용해 message를 꺼내온다.  
  이때, 메시지가 더이상 없다면 `EOF` 값을 담은 error가 반환되기에, 이 경우를 검사해 break를 지정해주었다.

- 정상적으로 요청이 수행되면, 서버에서 1초 간격으로 stream에 message를 담게 했기에 아래 내용이 콘솔에도 1초 간격으로 출력된다.

```
2022/01/06 15:19:07 Response: Person(name: sangwooAged25, message: 25)
2022/01/06 15:19:08 Response: Person(name: sangwooAged26, message: 26)
2022/01/06 15:19:09 Response: Person(name: sangwooAged27, message: 27)
```

### Client Streaming RPC

- Server Streaming RPC와 반대로 Client Streaming RPC에서는 클라이언트가 서버에게 일련의 message들을 담은 stream을 전달한다.  
  서버는 message를 뽑아 읽을 것이며, 클라이언트 측에서는 message를 stream으로 전달하면 된다.

- 항상 하던대로 stub를 호출해주면 되는데, 이번에는 조금의 dummy data를 전달해보자.

```go
func savePersons(client pb.PersonServiceClient) {

	// 요청 보낼 dummy data 들.
	requests := []*pb.PersonRequest{
		{
			Email:    "email1@test.com",
			Age:      1,
			Name:     "name1",
			Password: "password1",
		},
		{
			Email:    "email2@test.com",
			Age:      2,
			Name:     "name2",
			Password: "password2",
		},
		{
			Email:    "email3@test.com",
			Age:      3,
			Name:     "name3",
			Password: "password3",
		},
	}

	// stub에 대해 `SavePersons()`를 호출해 stream을 반환받는다.
	stream, err := client.SavePersons(context.Background())
	if err != nil {
		log.Fatalf("%v.SavePersons(_) = _, %v", client, err)
	}

	// dummy data들을 하나씩 순회하며 1초 간격으로 stream에 message로 전송한다.
	for _, req := range requests {
		time.Sleep(time.Second)
		if err := stream.Send(req); err != nil {
			log.Fatalf("%v.Send(%v) = %v", stream, req, err)
		}
	}

	// 서버가 보내는 단일 response를 받고 stream을 닫는다.
	response, err := stream.CloseAndRecv()
	if err != nil {
		log.Fatalf("%v.CloseAndRecv() got error %v, want %v", stream, err, nil)
	}
	log.Printf("SavePersons() response: %v\n", response)
}
```

- 이제 이를 호출하면 서버에서는 모든 메시지를 읽는 데에 3초가 소요되기 때문에(클라이언트에서 1초에 1개씩 보내므로)  
  3초 후에 응답이 콘솔에 출력된다.

```
2022/01/09 15:06:53 SavePersons() response: message:"All requests saved!"
```

---

### Bidirectional Streaming RPC

- Bidirectional Streaming RPC에서는 서버, 클라이언트 모두 서로 독립적으로 message를 send, receive할 수 있는  
  stream을 사용한다.

- 이번에는 message를 보내는 작업과 받는 작업이 서로 비동기적으로 수행될 수 있게 해보자.  
  메시지를 받는 작업을 위해서만 새로운 Goroutine을 사용하도록 해보자.

```go
func printResponseInAskAndGetPersons(client pb.PersonServiceClient) {

	// dummy data들
	requests := []*pb.PersonRequest{
		// 사전에 보낼 dummy data들의 속성
	}

	ctx, cancel := context.WithTimeout(context.Background(), time.Second*10)
	defer cancel()

	// stream 획득
	stream, err := client.AskAndGetPersons(ctx)
	if err != nil {
		log.Fatalf("%v.AskAndGetPersons(_) = _, %v", client, err)
	}

	// Goroutine의 실행 완료 여부를 확인하기 위한 channel
	waitChannel := make(chan struct{})

	// Stream의 message를 읽는 작업만을 하는 Goroutine 생성
	go func() {
		for {
			res, err := stream.Recv()

			if err == io.EOF {
				// Close channel
				close(waitChannel)
				return
			}
			if err != nil {
				log.Fatalf("Failed to receive PersonResponse : %v", err)
			}
			log.Printf("PersonResponse(email: %v, name: %v, age: %d) arrived.\n", res.Email, res.Name, res.Age)
		}
	}()

	// request를 1초에 하나씩 stream에 send.
	for _, req := range requests {
		time.Sleep(time.Second)
		log.Printf("PersonRequest(email: %v, name: %v, age: %d) sent.", req.Email, req.Name, req.Age)
		if err := stream.Send(req); err != nil {
			log.Fatalf("Failed to send PersonRequest: %v", err)
		}
	}

	// 여기까지 오면 read, write할 message가 모두 stream에 더이상 없으므로 stream을 close한다.
	stream.CloseSend()

	// channel을 이용해 Goroutine의 작업이 끝날 때까지 대기(Channel synchronization)
	<-waitChannel
}
```

- 결과는 아래와 같다.

```
2022/01/09 17:34:27 PersonRequest(email: email1@test.com, name: name1, age: 1) sent.
2022/01/09 17:34:27 PersonResponse(email: email1@test.com, name: name1, age: 1) arrived.
2022/01/09 17:34:28 PersonRequest(email: email2@test.com, name: name2, age: 2) sent.
2022/01/09 17:34:28 PersonResponse(email: email2@test.com, name: name2, age: 2) arrived.
2022/01/09 17:34:29 PersonRequest(email: email3@test.com, name: name3, age: 3) sent.
2022/01/09 17:34:29 PersonResponse(email: email3@test.com, name: name3, age: 3) arrived.
```

- 위 예시에서 Channel Synchronization의 필요성이 느껴지게끔 하기 위해, 서버에서 request를 받으면 1초 동안  
  sleep하게 바꿔보자. 그리고 channel 관련된 코드를 모두 지워보면, 아래처럼 출력된다.

```
2022/01/09 17:35:44 PersonRequest(email: email1@test.com, name: name1, age: 1) sent.
2022/01/09 17:35:45 PersonRequest(email: email2@test.com, name: name2, age: 2) sent.
2022/01/09 17:35:45 PersonResponse(email: email1@test.com, name: name1, age: 1) arrived.
2022/01/09 17:35:46 PersonRequest(email: email3@test.com, name: name3, age: 3) sent.

Process finished with the exit code 0
```

- 즉 message를 send하는 작업과 receive하는 작업은 여전히 비동기적으로 진행되지만, `main()`에서  
  수행할 request를 보내는 작업이 끝나면 Goroutine의 작업을 기다려주지 않고 프로그램이 종료되는 것이다.

- 따라서 기존처럼 channel을 만들고, Goroutine의 작업이 끝나면 해당 channel을 close하는 패턴을 사용해  
  Goroutine의 작업이 끝날 때까지 기다려준 것이다. channel이 있는 코드를 실행하면 아래처럼 된다.

```
2022/01/09 17:42:56 PersonRequest(email: email1@test.com, name: name1, age: 1) sent.
2022/01/09 17:42:57 PersonRequest(email: email2@test.com, name: name2, age: 2) sent.
2022/01/09 17:42:57 PersonResponse(email: email1@test.com, name: name1, age: 1) arrived.
2022/01/09 17:42:58 PersonRequest(email: email3@test.com, name: name3, age: 3) sent.
2022/01/09 17:42:58 PersonResponse(email: email2@test.com, name: name2, age: 2) arrived.
2022/01/09 17:42:59 PersonResponse(email: email3@test.com, name: name3, age: 3) arrived.
```

---
