# 코틀린의 원시 타입

## 원시 타입: `Int`, `Boolean` 등

- Java는 원시 타입(primitive type)과 참조 타입(reference type)을 구분한다.  
  원시 타입의 변수에는 그 값이 직접 들어가지만, 참조 타입의 변수에는 메모리상의 객체 위치가 들어간다.

- 원시 타입의 값을 더 효율적으로 저장하고 여기저기 전달할 수 있다. 하지만 그런 값에 대해 메소드를  
  호출하거나 컬렉션에 원시 타입 값을 담을 수는 없다. Java는 참조 타입이 필요한 경우, 특별한  
  wrapper type(`java.lang.Integer` 등)으로 원시 타입 값을 감싸서 사용한다.  
  따라서 정수의 컬렉션을 정의하려면 `Collection<int>`가 아니라 `Collection<Integer>`를 사용해야 한다.

- 코틀린은 원시 타입과 참조 타입을 구분하지 않으므로 항상 같은 타입을 사용한다.

```kt
val i: Int = 1
val list: List<Int> = listOf(1, 2, 3)
```

- Wrapper 타입을 따로 구분하지 않으면 편리하다. 더 나아가 코틀린에서는 숫자 타입 등 원시 타입의 값에 대해  
  메소드를 호출할 수 있다. 예를 들어, 아래 코드는 표준 라이브러리 함수인 `coerceIn()`을 사용해 값을 특정 범위로 제한한다.

```kt
fun showProgress(progress: Int) {
    val percent = progress.coerceIn(0, 100)
    println("$percent%")
}
```

- 원시 타입과 참조 타입이 같다면 코틀린은 항상 그들을 객체로 표현하는 걸까? 그렇게 한다면 비효율적이지 않을까?  
  실제로도 항상 객체로 표현한다면 비효율적이겠지만, 코틀린은 그러지 않는다.

- 실행 시점에 숫자 타입은 가능한 한 가장 효율적인 방식으로 표현된다. 대부분의 경우(변수, 프로퍼티, 파라미터 등)  
  코틀린의 `Int`는 Java의 int로 변환된다. 이런 컴파일이 불가능한 경우는 컬렉션과 같은 제네릭 클래스를 사용하는  
  경우 뿐이다. 예를 들어, `Int` 타입을 컬렉션의 타입 파라미터로 넘기면 그 컬렉션에는 `Int`의 wrapper 타입에  
  해당하는 `java.lang.Integer` 객체가 들어간다.

- Java 원시 타입에 해당하는 타입은 아래와 같다.

  - 정수 타입: `Byte`, `Short`, `Int`, `Long`
  - 부동소수점 수 타입: `Float`, `Double`
  - 문자 타입: `Char`
  - 불리언 타입: `Boolean`

- `Int`와 같은 코틀린 타입에는 null 참조가 들어갈 수 없기에 쉽게 그에 상응하는 Java 원시 타입으로 컴파일할 수 있다.  
  마찬가지로 반대로 Java의 원시 타입은 절대 null이 될 수 없으므로 Java 원시 타입을 코틀린에서 사용할 때도  
  플랫폼 타입이 아니라, null이 될 수 없는 타입으로 취급할 수 있다.

<hr/>

## nullable한 원시 타입: `Int?`, `Boolean?` 등

- null 참조를 Java의 참조 타입 변수에만 대입할 수 있기에 null이 될 수 있는 코틀린 타입은 Java의 원시 타입으로  
  표현할 수 없다. 따라서 코틀린에서 nullable한 원시 타입을 사용하면, 그 타입은 Java의 wrapper type으로 컴파일된다.

```kt
data class Person(val name: String, val age: Int? = null) {
    fun isOlderThan(other: Person): Boolean? {
	if(age == null || other.age == null) return null
	return age > other.age
    }
}
```

- 위 코드에서 null 가능성 관련 규칙을 어떻게 적용하는지 살펴보자. null이 될 가능성이 있으므로 `Int?` 타입의  
  두 값을 직접 비교할 수는 없다. 먼저 두 값이 모두 null이 아닌지 검사해야 한다. 컴파일러는 null 검사를 마친  
  다음에야 두 값을 일반적인 값처럼 다루게 허용한다.

- `Person`에 선언된 age 프로퍼티의 값은 `java.lang.Integer`로 저장된다. 하지만 그런 자세한 사항은 Java에서  
  가져온 클래스를 다룰 때만 문제가 된다. 코틀린에서 적절한 타입을 찾으려면 그 변수나 프로퍼티에 null이 들어갈 수  
  있는지만 고민하면 된다.

- 앞서 본 대로 제네릭 클래스의 경우, wrapper 타입을 사용한다. 어떤 클래스의 타입 인자로 원시 타입을 넘기면, 그 타입에  
  대한 Boxed type을 사용한다. 예를 들어, 아래 코드에서는 null이나 nullable한 타입을 전혀 사용하지 않았지만,  
  만들어지는 리스트는 `Integer` 타입으로 이뤄진 리스트다.

```kt
val listOfInts = listOf(1, 2, 3)
```

- 이렇게 컴파일되는 이유는 JVM에서 제네릭을 구현하는 방법 때문이다. JVM은 타입 인자로 원시 타입을 허용하지 않는다.  
  따라서 Java, 코틀린 모두에서 제네릭 클래스는 항상 boxed type을 사용해야 한다. 원시 타입으로 이뤄진 대규모 컬렉션을  
  효율적으로 저장해야 한다면 원시 타입으로 이뤄진 효율적인 컬렉션을 제공하는 서드 파티 라이브러리를 사용하거나, 배열을  
  사용해야 한다.

<hr/>
