# API에서 DSL로

- DSL에 대해 보기 전에, 우리가 해결하려 하는 문제에 대해 더 자세히 알아보자. 궁극적인 목표는 코드의 가독성과 유지보수성을  
  가장 좋게 유지하는 것이다. 그런 목표를 달성하려면 개별 클래스에 집중하는 것만으로는 충분하지 않다. 클래스에 있는 코드 중  
  대부분은 다른 클래스와 상호작용한다. 따라서 그런 상호작용이 일어나는 연결 지점(interface)을 살펴봐야 한다.  
  즉, 클래스의 API를 살펴봐야 한다는 것이다.

- 라이브러리를 만드는 사람들에게만 API를 훌륭하게 만들 책임이 있는 것이 아니라는 사실이 중요하다. 사실 모든 개발자는 API를  
  훌륭하게 만들기 위해 노력해야 한다. 라이브러리가 외부 사용자에게 프로그래밍 API를 지원하는 것처럼 애플리케이션 안의 모든  
  클래스는 다른 클래스에게 자신과 상호작용할 수 있는 가능성을 제공한다. 이런 상호작용을 이해하기 쉽고 명확하게 표현할 수 있어야  
  프로젝트를 쉽게 계속 유지 보수할 수 있다.

- 지금까지 이 책에서 클래스를 위한 API를 깔끔하게 작성할 수 있게 도와주는 여러 코틀린 특성을 살펴보았다.  
  그렇다면 _API가 깔끔하다_ 는 말은 말은 어떤 뜻일까? 이 말에는 아래의 두 가지 뜻이 있다.

  - 코드를 읽는 독자들이 어떤 일이 벌어질지 명확히 이해할 수 있어야 한다. 이름과 개념을 잘 선택하면 이런 목적을 달성할 수 있다.  
    어떤 언어를 사용하든 이름을 잘 붙이고 적절한 개념을 사용하는 것은 매우 중요하다.

  - 코드가 간결해야 한다. 불필요한 구문이나 번잡한 준비 코드가 가능한 한 적어야 한다.  
    깔끔한 API는 언어에 내장된 기능과 거의 구분할 수 없다.

- 아래 표는 코틀린이 _간결한 구문_ 을 어떻게 제공하는지의 예시를 담은 것이다.

| 일반 구문                        | 간결한 구문                             | 사용한 언어 특성               |
| :------------------------------- | --------------------------------------- | ------------------------------ |
| `StringUtil.capitalize(s)`       | `s.capitalize()`                        | 확장 함수                      |
| `l.to("one")`                    | `l to "one"`                            | 중위 호출                      |
| `set.add(2)`                     | `set += 2`                              | 연산자 오버로딩                |
| `map.get("key")`                 | `map["key"]`                            | `get()` 메소드에 대한 관례     |
| `file.use((f -> f.read()))`      | `file.use { it.read() }`                | 람다를 괄호 밖으로 빼내는 관례 |
| `sb.append("a"); sb.append("b")` | `with(sb) { append("a"); append("b") }` | 수신 객체 지정 람다            |

- 여기서는 깔끔한 API에서 한걸음 더 나아가 DSL 구축을 도와주는 코틀린 기능을 살펴본다.  
  코틀린 DSL은 간결한 구문을 제공하는 기능과 그런 구문을 확장해 여러 메소드의 호출을 조합함으로써 구조를 만들어내는 기능에 의존한다.  
  그 결과로 DSL은 메소드 호출만을 제공하는 API에 비해 더 표현력이 풍부하고 사용하기 편해진다.

- 코틀린 언어의 다른 특성과 마찬가지로, 코틀린 DSL도 온전히 컴파일 시점에 타입이 정해진다. 따라서 컴파일 시점 오류 감지, IDE 지원 등 모든  
  정적 타입 지정 언어의 장점을 코틀린 DSL을 사용할 때도 누릴 수 있다.

- 예시로 코틀린 DSL이 할 수 있는 일을 몇 가지 살펴보자.  
  아래 식은 시간을 되돌려서 하루 전 날을 반환한다.

```kt
val yesterday = 1.days.ago
```

- 아래 함수는 HTML Table을 생성한다.

```kt
fun createSimpleTable = createHTML().
	table {
		tr {
			td { +"cell" }
		}
	}
```

- 이 장에서는 위와 같은 예제들을 어떻게 구현하는지 살펴본다.  
  구현 부분을 보기 전에, 먼저 DSL이 무엇인지부터 알아보자.

---

## DSL: Domain Specific Language
