# R Socket

## R Socket 개요

- 지금까지 배운 모든 것은 결국 현재 자원을 잘 활용해서 더 높은 확장성을 가진  
  Reactive Application을 만드는 방법이다. 그중에서도 배압(backpressure)은  
  **Reactive Stream**의 근간을 이루는 핵심 개념이며, 이를 통해 확장성 있는  
  애플리케이션을 만들 수 있다.

- 배압을 이해하고 나면 무언가를 조회하기 위해 네트워크 경계를 넘나들어야 하는데, 주로 HTTP를  
  기반으로 하는 원격 기술을 사용한다. OSI Layer 7에 위치하고 있는 HTTP는 이미 우리 일상에  
  깊숙이 스며들어서 HTTP가 없던 시절을 떠올리는 것조차 쉽지 않다.

> 배압(Backpressure): Resistance of force apposing the desired **flow of data through software**.

- 하지만 HTTP는 리액티브하지 않다. HTTP는 _'하나만 더 보내줘.'_, _'남은 것 다 보내줘.'_  
  와 같은 메시지를 표현할 수도, 이해할 수도 없다. HTTP는 요청-응답 패러다임에 뿌리를 두고 있다.  
  사람들은 HTTP를 통해 단순한 요청-응답을 넘어서 터널로 서로 연결하는 방법을 고민해 왔고,  
  그 첫번째 해답은 **클라이언트가 서버에게 요청을 보낸 후에 즉각적인 대답을 기대하지 않고,**  
  **오래 기다리더라도 언제든 서버가 데이터를 보낼 준비가 됐을 때 서버로부터 응답을 받으면**  
  **응답을 처리하고, 바로 새로운 요청을 서버에게 보내서 또 오래 기다리는 식**으로 연결 지속성을  
  확보하는 **롱 폴링(Long Polling)** 이다. Long Polling은 Comet이라 부르기도 한다.

- 이 방식은 기대한 대로 동작은 하지만 자원을 점유한다는 한계가 있었고, 이는 WebSocket의 등장을  
  앞당겼다. WebSocket도 OSI Layer 7에 위치하며, 2011년에 표준화된 최신 프로토콜이다.  
  WebSocket은 요청-응답 방식의 HTTP와는 다르게 양방향이다. WebSocket은 가볍고 양방향  
  비동기 통신을 지원하지만, 배압 개념이 없으므로 리액티브하지 않다.

- 앞서 본 것처럼 **API가 비동기 방식이라고 해서 전체 과정이 리액티브한 것은 아니다.**  
  그래서 진정한 해결책이 나오려면 새로운 프로토콜이 필요하다.  
  리액티브 스트림을 근간으로 하는 새로운 프로토콜, 바로 **RSocket**이다.

<hr/>

## Reactive Protocol의 탄생

- RSocket은 HTTP, WebSocket과 마찬가지로 OSI 7 계층 프로토콜이다. VMWare, Facebook,  
  Netlify, Alibaba를 비롯한 여러 회사가 설립한 리액티브 재단(Reactive Foundation)에서  
  공통으로 만들었다.

- RSocket은 Java 뿐만 아니라 JavaScript, Go, .NET, Kotlin 을 지원하는 명세를 포함한다.

> RSocket에서 사용되는 리액티브 스트림 Java 구현체는 리액터다.

- 리액티브 프로토콜을 만들려면 어떤 점들이 고려돼야 할까?

- RSocket은 WebSocket, TCP, Aeron 등 여러 가지 프로토콜 위에서 동작하도록 설계됐다.  
  WebSocket에 대해서는 이미 짧게 언급했는데, 정리하자면 WebSocket은 아주 가볍고 유연해서  
  RSocket이 필요로 하는 모든 것을 지원한다.

- TCP(Transmission Control Protocol)는 OSI 4 계층에 위치하는 강력한 프로토콜이다.  
  HTTP는 TCP의 연결 관리를 사용해서 TCP 위에서 동작한다. RSocket도 TCP를 사용해서  
  장애 내성(fault-tolerant)과 확장성을 가진 리액티브 연결을 만들 수 있다.

- Aeron은 UDP 위에서 동작하는 메시징 프로토콜이다. UDP(User Datagram Protocol)는 신뢰성 있는  
  연결을 필요로 하지 않는 프로토콜이다. 리액터 애플리케이션은 작업 부하(workload) 사이를 오가는  
  worker 스레드를 사용하므로, 작업 부하가 여러 가지 메시지로부터 만들어진다는 사실은 어렵지 않게  
  유추할 수 있다.

- 여기서는 TCP를 기반으로 하는 RSocket을 이용해서 서로 다른 시스템을 리액티브하게  
  연결하는 방법에 집중한다.

<hr/>

## RSocket 패러다임

- RSocket은 당연하지만 Socket을 전제로 한다. Socket은 연결을 맺고, 데이터를 송수신하는 데  
  신뢰성이 입증된 방식이다. RSocket은 단순히 연결에 사용되는 채널(channel)에 다른 API를  
  추가한 것이라 이해할 수 있다. 하지만 먼저 아래와 같은 RSocket의 패러다임을 이해하는 것이 중요하다.

  - 요청-응답(Request-Response) - 1개의 스트림
  - 요청-스트림(Request-Stream) - 다수의 유한한 스트림
  - 실행 후 망각(Fire-And-Forget) - 무응답
  - 채널(Channel) - 양방향

### 요청-응답(Request-Response)

- 최신 프로토콜인 RSocket을 소개하는데 오래돼서 고풍스럽기까지 한 HTTP의 요청-응답 패러다임을  
  첫 번째로 언급하는 것이 역설적이기도 하지만, 실제로 통신에서 일반적으로 필요한 요구사항의  
  80%는 이 요청-응답 방식으로 해결할 수 있다. 요청-응답을 수행하려면 여러 가지 작업을  
  수행해야 한다. 원격 서비스에 데이터를 요청하고, 새 데이터를 전송하고 확정을 기다리는 등  
  여러 작업이 요청-응답을 통해 수행된다.

- HTTP는 오직 요청-응답 방식만 지원한다는 점이 문제라고 할 수 있다.  
  그래서 이를 보완할 수 있는 전략이 필요하다.

### 요청-스트림(Request-Stream)

- 요청-스트림 방식은 한 번의 요청을 보내고 스트림 형태로 응답을 계속 받을 수 있으므로 좀 더 효율적인  
  요청 방식이라 할 수 있다. Long Polling(Comet)은 응답을 받을 때마다 처리를 하고,  
  응답을 받은 후에 다시 요청을 보내는 일을 반복해야 한다. 이렇게 비슷한 처리 작업을 위해 요청-응답을  
  반복하는 것은 많은 오버헤드를 유발한다. 응답을 기다리면서 스레드가 점유되므로 트래픽이 많은  
  상황에서는 지연이 발생하는 주요 원인이 되기도 한다.

- RSocket은 채널을 열고 요청을 보낸 후에 스레드를 점유하지 않고 스트림 형태로 응답을 받을 수 있다.

- 주식 종목의 가격 정보를 요청하고, 변화되는 주식 가격을 스트림 형태로 계속 응답받는 상황이  
  요청-스트림 방식의 대표적인 사례라고 할 수 있다. 개발자는 가격 변동 정보가 언제 도착하는지  
  신경 쓸 필요 없으며, 가격이 변동될 때마다 언제든지 받을 수 있다. 물론 그렇다고 해서 서버가  
  10만개의 가격 정보를 업데이트할 때 한 번에 전송해도 된다는 뜻은 아니다.

- RSocket을 바탕으로 리액티브 프로그래밍을 사용하면 _'다음 10개 정보를 보내줘.'_ 라고 요청할 수 있다.

### 실행 후 망각(Fire and Forget)

- 실행 후 망각은 요청을 보내고 나서 응답은 신경 쓰지 않는 뒤끝 없는 방식이지만 별로 대단해 보이지는 않을 수 있다.  
  그냥 언어적 축약 표현인 것일까? 응답을 무시한다는게 어려운 일일까?

- 실행 후 망각은 단순한 응답 무시라고 할 수만은 없다. 비동기 전송 방식으로 요청-응답을 주고받으면  
  응답은 원래의 요청과 연관돼야 한다. 그래서 연관 ID(Correlation ID)를 사용하기도 하는데,  
  이 과정에서 여러 가지 복잡성이 생겨난다. 간과해서는 안될 것은 지금 배우는 것이 리액티브 스트림이라는 것이다.  
  **어떤 것도 스레드를 점유해서는 안된다.**

- RSocket은 모든 요청이 응답 결과를 항상 필요로 하는 것은 아니라는 점을 충분히 활용하면서  
  앞서 본 연관성 유지에 의해 발생하는 오버헤드를 제거할 수 있다.

### 채널(Channel)

- RSocket의 세 가지 패러다임에서는 요청을 보내는 클라이언트와, 요청을 처리하는 서버가 등장한다.  
  클라이언트와 서버는 아래 세 가지의 선택지를 가지고 있다.

  - 응답 대기
  - 응답 대기 안함
  - 무한 응답 대기

- 어느 쪽이든 요청을 보내는 것은 클라이언트라는 사실에는 변함이 없다.

- 채널 패러다임은 이런 틀을 깨고 진정한 **메시지 지향(Message-Driven) 양방향 통신 채널을 실현**한다.  
  채널의 어느 쪽이든 상대방에게 메시지를 전송할 수 있고, 양쪽 모두 리액티브 메시지 리스너(listener)를  
  반드시 등록해야 한다.

- 이전에 RabbitMQ를 리액터와 함께 사용해봤는데, 이를 위한 설정이 결코 단순하지 않다.  
  하지만 RSocket을 사용하면 그런 설정이 전혀 필요 없다. 게다가 RSocket에는 배압 기능도 포함돼 있다.

- 요청-응답, 요청-스트림, 실행 후 망각, 채널, 이렇게 네 가지 방식에 대한 예제를 다뤄보자.

<hr/>
