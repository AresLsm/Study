# Composing Suspending Functions

<h2>Sequential by default</h2>

- 어딘가에 아래와 같이 2개의 suspending function이 정의되어 있다고 하자.  
  오래 걸리는 작업을 하는 것처럼 하기 위해 내부에서 1초 동안 delay를 주게 했다.

```kt
suspend fun doSomethingUsefulOne(): Int {
    delay(1000L)
    return 13
}

suspend fun doSomethingUsefulTwo(one: Int): Int {
    delay(1000L)
    return if(one == 13) 29
    else 0
}
```

- 만약 `doSomethingUsefuleOne()`이 먼저 실행된 후에 `doSomethingUsefulTwo()`가 실행되기를 바란다면 어떨까?  
  두 번째로 실행되는 함수의 동작이 첫번째로 실행되는 함수의 결과에 의존하는 경우 등 말이다.

- 이 경우에 우리는 그냥 평소처럼 코드를 작성하면 된다. 그 이유는 Coroutine 내부의 코드들은 다른 일반적인 코드들과 같이  
  기본적으로 순차적으로 실행되기 때문이다. 아래의 예시는 이것을 실행 시간을 측정함으로써 보여준다.

```kt
suspend fun main() {
    val time = measureTimeMillis {
        val one = doSomethingUsefulOne()
        val two = doSomethingUsefulTwo()
        println("The answer is ${one + two}")
    }
    println("Completed in $time ms")
}

/*
Output:
The answer is 42
Completed in 2024 ms
*/
```

- 42가 출력되었다는 것은 `doSomethingUsefulTwo()`가 `doSomethingUsefulOne()`의 실행이 끝난 뒤에 호출되어  
 실행되었다는 의미이다.
<hr/>
