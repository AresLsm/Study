# 기본적인 리팩토링(2)

<h2>매개변수 객체 만들기</h2>

```js
// 리팩토링 적용 전
function amountInvoiced(startDate, endDate) {
  /* ... */
}
function amountReceived(startDate, endDate) {
  /* ... */
}
function amountOverdue(startDate, endDate) {
  /* ... */
}

// 리팩토링 적용 후
function amountInvoiced(dateRange) {
  /* ... */
}
function amountReceived(dateRange) {
  /* ... */
}
function amountOverdue(dateRange) {
  /* ... */
}
```

<h3>배경</h3>

- 데이터 항목 여러 개가 이 함수에서 저 함수로 함께 몰려다니는 경우는 자주  
  볼 수 있다. 이런 경우, 데이터 무리를 발견하면 하나의 데이터 구조로  
  모아주자.

- 데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해진다는  
  이점을 얻는다. 게다가 함수가 이 데이터 구조를 받게 하면 매개변수의  
  수가 줄어든다. 같은 데이터 구조를 사용하는 모든 함수가 원소를  
  참조할 때 항상 똑같은 이름을 사용하기에 일관성도 높여준다.

- 하지만 이 리팩토링의 진정한 힘은 **코드를 더 근본적으로 바꿔준다**는 데 있다.  
  이런 데이터 구조를 새로 발견하면, 이 데이터 구조를 활용하는 형태로 프로그램을  
  재구성할 수 있다. 데이터 구조에 담길 데이터에 공통으로 적용되는 동작을  
  추출해서 함수로 만드는 것이다. 이 과정에서 새로 만든 데이터 구조가 문제 영역을  
  훨씬 간결하게 표현하는 새로운 추상 개념으로 격상되면서, 코드의 개념적인 그림을  
  다시 그릴 수도 있다. 그러면 놀라울 정도로 강력한 효과를 낸다.  
  하지만 이 모든것의 시작은 매개변수 객체 만들기부터다.

<h3>절차</h3>

- (1) 적당한 데이터 구조가 아직 마련되어 있지 않다면 새로 만든다.

- (2) 테스트한다.

- (3) 함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가한다.

- (4) 테스트한다.

- (5) 함수 호출 시 새로운 데이터 구조 인스턴스를 넘기도록 수정한다.  
  하나씩 수정할 때마다 테스트한다.

- (6) 기존 매개변수를 사용하던 코드를 새 데이터 구조의 원소를 사용하도록 바꾼다.

- (7) 다 바꿨다면 기존 매개변수를 제거하고, 테스트한다.

- 이 리팩토링은 새로 생성한 객체로 동작까지 옮기는 더 큰 작업의  
  첫 단계로 수행될 때가 많기 때문에 JS의 객체가 아닌 클래스로  
  데이터 구조를 만들도록 하자.

- 또한 새로 생긴 데이터 구조는 값 객체로 만들 가능성이 높기 때문에  
  getter만 제공하자.(setter는 제공하지 않아도 된다).  
  물론 값 객체가 아니라면 필요한 메소드를 제공해야 한다.

<hr/>
