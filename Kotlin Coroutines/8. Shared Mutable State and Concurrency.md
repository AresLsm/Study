# Shared Mutable State and Concurrency

- Coroutine들은 `Dispatchers.Default`와 같은 multi-threaded dispatcher를 사용해 병렬적으로 수행될 수 있다.  
  하지만 모든 동시성 문제도 함께 안고 간다. 그중 가장 큰 문제점은 공유되는 가변 상태(shared mutable state)에 대한 접근을 동기화하는 것이다.  
  이를 해결하기 위해 coroutine이 선택한 방법은 multi-thread와 비슷한 것도 있지만, coroutine에 unique한 것도 있다.

## The Problem

- 동일한 동작을 1000번 수행하는 coroutine을 100개 실행시켜보자.

```kt
suspend fun massiveRun(action: suspend() -> Unit) {
	val n = 100
	val k = 1000
	val time = measureTimeMillis {
		coroutineScope {
			repeat(n) {
				launch {
					repeat(k) { action() }
				}
			}
		}
	}
	println("Completed ${n * k} actions in $time ms")
}

var counter = 0

fun main() = runBlocking {
	withContext(Dispatchers.Default) {
		massiveRun {
			counter++
		}
	}
	println("Counter = $counter")
}
```

- 위 코드는 절대 counter값이 100000에 도달하지 않는다. 이론 상으로라면 `1000 * 100 = 100000`이어야 하는데, 왜 그럴까?  
  바로 100개의 coroutine들이 여러개의 thread에서 동기화 없이 counter 변수에 동시에 접근하기 때문이다.

---

## Volatiles are no of help

- 변수를 volatile 키워드를 적용한 채 선언하면, 이 문제가 해결될 것이라는 잘못 알려진 상식이 있다.  
  실제로 아래 코드를 실행해 봐도, counter는 절대 100000에 도달하지 못한다.

```kt
@Volatile
var counter = 0

fun main() = runBlocking {
	withContext(Dispatchers.Default) {
		massiveRun {
			counter++
		}
	}
	println("Counter = $counter")
}
```

- 위 코드는 counter에 `@Volatile`이 적용되지 않은 코드보다 수행 시간은 길지만, 역시 counter는 100000에 도달하지 못한다.  
  이는 volatile이 선형적인(linearizable, atomic) read, write 연산에 대한 순서는 보장하지만, 위 코드에서 발생한  
  increment 등의 더 큰 action에 대한 atomicity(원자성)은 보장하지 않기 때문이다.

---
