# 최소 신장 트리, 크루스칼 알고리즘

## 최소 신장 트리란?

- Spanning Tree 또는 신장 트리라고 불린다.
- 원래의 그래프의 모든 node가 연결되어 있으면서 트리의 속성을 만족하는 그래프
- 신장 트리의 조건
  - 본래의 그래프의 모든 node를 포함해야 한다.
  - 모든 node가 서로 연결되어 있다.
  - Tree의 속성을 만족시킨다.(acyclic)

![picture 1](/images/OTHERS_ALGO_MST_1.png)

- 최소 신장 트리는 Minimum Spanning Tree(MST)라고 불린다.
- 가능한 모든 spanning tree들 중 간선의 가중치 합이 최소인 spanning tree를 지칭한다.

![picture 2](/images/OTHERS_ALGO_MST_2.png)

---

## 최소 신장 트리 알고리즘

- 그래프에서 MST를 구할 수 있는 여러 가지 알고리즘이 존재한다.  
  그중 대표적으로 크루스칼 알고리즘(Kruskal's Algorithm)과 프림 알고리즘(Prim's Algorithm)이 있다.

---

## 크루스칼 알고리즘(Kruskal's Algorithm)

- (1) 모든 정점을 독립적인 집합으로 만든다.
- (2) 모든 간선을 비용을 기준으로 정렬하고, 비용이 적은 간선부터 양 끝의 두 정점을 비교한다.
- (3) 두 정점의 최상위 정점을 확인하고, 서로 다를 경우 두 정점을 연결한다.(MST는 acyclic하므로 cycle이 생기지 않도록 하는 것이다.)

> 탐욕 알고리즘을 기초로 하고 있다.(당장 눈 앞의 최소 비용을 선택해 결과적으로 최적의 솔루션을 찾는다.)

- 아래 그래프를 예시로 크루스칼 알고리즘을 이해해보자.

  ![picture 3](/images/OTHERS_ALGO_MST_3.png)

  - 간선들을 가중치가 적은 순으로 정렬하고, 그 중 하나를 선택한다.  
    위 그래프에서 가장 가중치가 적은 것은 `A-D`, `E-C`이다. 이 중 `A-D`를 선택했다고 해보자.

  ![picture 4](/images/OTHERS_ALGO_MST_4.png)

  - 다음으로 가중치가 적은 간선은 `E-C`이므로 이를 선택한다.

  ![picture 5](/images/OTHERS_ALGO_MST_5.png)

  - 그 다음으로 가중치가 적은 간선은 가중치가 6인 `D-F`인데, 선택된 것들 중 `A-D`가 있으므로 이를 위의 아래 부분처럼 구성한다.

  ![picture 6](/images/OTHERS_ALGO_MST_6.png)

  - 다음으로 작은 간선은 가중치가 7인 `A-B`, `D-E`, `B-E`이다. `A-B`를 선택했다고 하자.

  ![picture 7](/images/OTHERS_ALGO_MST_7.png)

  - 남은 최소 가중치 간선 `D-E`, `B-E` 중 `B-E`를 선택했다 하자.

  ![picture 8](/images/OTHERS_ALGO_MST_8.png)

  - 남은 최소 가중치 간선은 가중치가 7인 `D-E`인데, 이를 연결하면 `A-B-E-D-A`로 cycle이 생기게 된다.  
    따라서 `D-E`는 선택되지 못하고, 다음으로 최소 가중치를 가진 간선인 `B-C`, `F-E` 중 선택을 해야하는데 `B-C`를 선택하면 `B-C-E-B`의  
    cycle이 생기게 된다. `F-E`를 선택해도 `A-B-E-F-D-A`의 cycle이 생기게 되므로 선택되지 못한다. 결국 다시 다음 최소 가중치를 가진  
    간선은 가중치가 9인 `G-E`, `D-B`가 남는데, `D-B`는 `A-B-D-A`의 cycle을 만들고 `G-E`는 아무런 cycle을 만들지 못한다.  
    따라서 `G-E`가 선택된다.

  - 여기까지 했을 때 모든 node들이 연결되어 있고 cycle이 없으므로 이를 MST라고 할 수 있다.

- 이를 구현할 때 가장 신경써야할 부분은 cycle의 생성 유무를 판단하는 것이다. 이를 위해 Union-Find Algorithm을 사용할 수 있다.

---
