# 코드에서 나는 악취(3)

<h2>메시지 체인</h2>

- 메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤, 방금 얻은 객체에  
  또다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.  
  가령 `getSomething()` 같은 geter가 꼬리에 꼬리를 물고 이어지거나, 임시 변수들이  
  줄줄이 나열되는 코드가 있다. 이는 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미한다.  
  그래서 내비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야 한다.

- 이 문제는 **위임 숨기기**로 해결한다. 이 리팩토링은 메시지 체인의 다양한 연결점에  
  적용할 수 있다. 원칙적으로 체인을 구성하는 모든 객체에 적용할 수 있지만, 그러다 보면 중간 객체들이  
  모두 중개자가 돼버리기 쉽다. 그러니 **최종 결과 객체가 어떻게 쓰이는지부터 살펴보는게 좋다.**  
  **함수 추출하기**로 결과 객체를 사용하는 코드 일부를 따로 빼낸 다음 **함수 옮기기**로  
  체인을 숨길 수 있는지 살펴보자. 체인을 구성하는 객체 중 특정 하나를 사용하는 클라이언트 중  
  그 이후의 객체들도 사용하길 원하는 클라이언트가 제법 많다면, 이 요구를 처리해줄 메소드를 추가한다.

- **위임 숨기기**는 이해하기 난해할 수 있는 방법이니, 예시를 살펴보자.  
  우선 아래 코드가 메시지 체인의 전형적인 예시이다.

```js
const managerName = person.department.manager.name;
```

- _"체인을 구성하는 모든 객체에 위임 숨기기를 적용할 수 있다."_ 고 함은 managerName을  
  바로 반환하는 메소드를 `Person` 클래스에 추가할 수도 있고, `Department` 클래스에  
  추가할 수도 있다는 뜻이다.

```js
// Manager의 존재를 숨김
const managerName = person.department.managerName;

// Department의 존재를 숨김
const managerName = person.manager.name;

// Department, Manager의 존재를 모두 숨김
const managerName = person.managerName;
```

- 이 체인의 최종 결과 객체는 결국 `Manager.name`이다.  
  이 객체가 다음처럼 쓰인다고 해보자.

```js
const managerName = person.department.manager.name;
let report = `${managerName}의 보고서 ~~~~`;
console.log(report);
```

- 여기서 report 생성 로직을 함수로 추출한 다음 적당한 모듈로 옮기면 체인의 존재가 감춰진다.

```js
console.log(reportGenerator.report(person));
```

- 마지막으로 체인의 중간 단계인 `Department` 정보를 얻어 사용하는 다수의 클라이언트가 `Manager.name`도  
  함께 사용한다면 `Department` 클래스에 `managerName()` 메소드를 추가하여 체인을 단축할 수 있다.

<hr/>

<h2>중개자</h2>

- 객체의 대표적인 기능 하나로, 외부로부터 세부사항을 숨겨주는 **캡슐화**가 있다.  
  캡슐화하는 과정에서는 **위임**이 자주 활용된다. 예를 들어 여러분이 팀장에게 미팅을  
  요청한다 해보자. 팀장은 자신의 일정을 확인한 후 답을 준다. 이러면 끝이다.  
  팀장이 종이 다이어리를 쓰든, 일정 서비스를 쓰든 이는 알바가 아니다.

- 하지만 지나치면 문제가 된다. 클래스가 제공하는 메소드 중 절반 이상이 다른 클래스에  
  구현을 위임하고 있다면 어떨까? 이럴 때는 **중개자 제거하기**를 활용하여 실제로 일을 하는 객체와  
  직접 소통하게 하자. 위임 메소드를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인하자.(**함수 인라인하기**)

<hr/>

<h2>내부자 거래</h2>

- 소프트웨어 개발자는 모듈 사이에 벽을 두껍게 세우는 것을 좋아하며, 그래서 모듈 사이의 데이터 거래가  
  많으면 결합도가 높아진다고 주장한다. 일을 돌아가게 하려면 거래가 많아질 수 밖에 없지만,  
  그 양을 최소로 줄이고 모두 투명하게 처리해야 한다.

- 커피 자판기 옆에서 은밀히 데이터를 주고받는 모듈들이 있다면 **함수 옮기기**와 **필드 옮기기**로  
  떼어놓아서 사적으로 처리하는 부분을 줄인다. 여러 모듈이 같은 관심사를 공유한다면 공통 부분을  
  정식으로 처리하는 제3의 모듈을 새로 만들거나 **위임 숨기기**를 이용하여 다른 모듈이  
  중간자 역할을 하게 만든다.

- 상속 구조에서는 부모 자식 사이에 결탁이 생길 때가 있다.  
  자식 클래스는 항상 부모 클래스가 공개하고 싶은 것 이상으로 부모에 대해 알려고 한다.  
  그러다가 부모 품을 떠나야할 때가 온다면 **서브클래스를 위임으로 바꾸기**나 **슈퍼클래스를 위임으로 바꾸기**를 활용하자.

<hr/>

<h2>거대한 클래스</h2>

- 한 클래스가 너무 많은 일을 하려다보면 필드 수가 상당히 늘어난다.  
  그리고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.

- 이럴 때는 **클래스 추출하기**로 필드들 일부를 따로 묶자. 같은 컴포넌트에 모아두는 것이 합당해 보이는  
  필드들을 선택하면 된다. 가령 `depositAmount`와 `depositCurrency` 필드는 같은 컴포넌트에  
  두는 것이 좋을 것이다. 더 일반적으로는, 한 클래스 안에서 접두어나 접미어가 같은 필드들이  
  함께 추출할 후보들이다. 이렇게 분리할 컴포넌트를 원래 클래스와 상속 관계로 만드는게 좋다면  
  **클래스 추출하기** 보다는 **슈퍼클래스 추출하기**나, 실질적으로 서브클래스 추출하기에 해당하는  
  **타입코드를 서브클래스로 바꾸기**를 적용하는 편이 더 쉬울 것이다.

- 클래스가 항시 모든 필드를 사용하지 않을 수도 있다.  
  이럴 때는 앞서 언급한 추출 기법들을 여러 차례 수행해야 할지도 모른다.

- 필드가 너무 많은 클래스와 마찬가지로 코드량이 너무 많은 클래스도 중복 코드와 혼동을  
  일으킬 여지가 크다. 가장 간단한 해법은 그 클래스 안에서 자체적으로 중복을 제거하는 것이다.  
  가령 부분부분 상당량의 로직이 똑같은 100줄짜리 메소드가 5개가 있다면 각각의 공통 부분을  
  작은 메소드들로 뽑아내자. 그러면 원래의 다섯 메소드들에는 작은 메소드를 호출하는  
  코드 10줄만 남게 될지도 모른다.

- 클라이언트들이 거대 클래스를 이용하는지 패턴을 파악하여 그 클래스를 어떻게 쪼갤지  
  단서를 얻을 수도 있다. 먼저 클라이언트들이 거대 클래스의 특정 기능 그룹만 주로 사용하는지 살피자.  
  이때, 그렇게 발견된 각각의 기능 그룹이 개별 클래스로 추출될 후보이다. 유용한 기능 그룹을 찾았다면  
  **클래스 추출하기**, **슈퍼클래스 추출하기**, **타입코드를 서브클래스로 바꾸기** 등을 활용해서  
  여러 클래스로 분리하자.

<hr/>
