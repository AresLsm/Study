# 고차 함수 내에서의 흐름 제어

- Loop와 같은 명령형 코드를 람다로 바꾸기 시작하면 종종 return 문제에 부딪히곤 한다. loop의 중간에 있는 return문의  
  의미를 이해하기는 쉽다. 하지만 그 loop를 `filter()`와 같이 람다를 호출하는 함수로 바꾸고 인자로 전달하는 람다  
  안에서 return을 사용하면 어떤 일이 벌어질까?

### 람다 안의 return: 람다를 둘러싼 함수로부터의 반환

- 아래 코드를 보면 이름이 Alice인 경우에 `lookForAlice()` 함수로부터 반환된다는 사실을 분명히 알 수 있다.

```kt
data class Person(val name: String, val age: Int)

val people = listOf(Person("Alice", 29), Person("Bob", 31))

fun lookForAlice(people: List<Person>) {
    for(person in people) {
	if(person.name == "Alice") {
	    println("Found")
	    return
	}
    }
    println("Alice is not found")
}
```

- 위 코드를 `forEach()`를 쓰도록 바꿔도 될까? `forEach()`에 넘긴 람다 안에 있는 return도 위 코드와  
  같은 의미일까? 정답은 그렇다. `forEach()`를 대신 써도 안전하다.

```kt
fun lookForAlice(peopl: List<Person>) {
    people.forEach {
	if(it.name == "Alice") {
	    println("Found")
	    return
	}
    }
    println("Alice is not found")
}
```

- **람다 안에서 return을 사용하면 람다로부터만 반환되는 것이 아니라, 그 람다를 호출하는 함수가 실행을**  
  **끝내고 반환된다.** 그렇게 자신을 둘러싸고 있는 블록보다 더 바깥에 있는 다른 블록을 반환하게 만드는  
  return문을 **non-local return**이라 한다.

- 이 규칙 뒤에 숨어있는 로직을 이해하려면 Java 메소드에 있는 for loop나 synchronized 블록 안에서  
  return 키워드가 어떻게 동작하는지 살펴보면 된다. 그런 경우 return은 for loop나 synchronized 블록을  
  끝내지 않고 메소드를 반환시킨다. 코틀린에서는 언어가 제공하는 기본 구성 요소가 아니라 람다를 받는 함수로  
  for나 synchronized와 같은 기능을 구현한다. 코틀린은 그런 함수 안에서 쓰이는 return이 Java의 return과  
  같은 의미를 갖게 허용한다.

- 이렇게 **return이 바깥쪽 함수를 반환시킬 수 있는 때는 람다를 인자로 받는 함수가 인라인 함수인 경우 뿐**이다.  
  위 코드의 `forEach()`는 인라인 함수이므로 람다 본문과 함께 인라이닝된다. 따라서 return식이 바깥쪽 함수를  
  반환시키도록 쉽게 컴파일할 수 있다. 하지만 인라이닝되지 않는 함수에 전달되는 람다 안에서 return을 사용할 수는 없다.  
  인라이닝되지 않는 함수는 람다를 변수에 저장할 수도 있고, 바깥쪽 함수로부터 반환된 뒤에 저장해 둔 람다가 호출될 수도 있다.  
  그런 경우 람다 안의 return이 실행되는 시점이 바깥쪽 함수를 반환시키기엔 너무 늦은 시점일 수도 있다.

<hr/>
