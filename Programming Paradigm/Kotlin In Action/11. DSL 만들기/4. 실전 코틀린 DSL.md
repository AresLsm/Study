# 실전 코틀린 DSL

## 중위 호출 연쇄: 테스트 프레임워크와 `should()`

- 깔끔한 구문은 Internal DSL의 핵심 특징 중 하나다. DSL을 깔끔하게 만들려면 코드에 쓰이는 기호의 수를 줄여야 한다.  
  대부분의 Internal DSL은 메소드 호출을 연쇄시키는 형태로 만들어지기 때문에 메소드 호출 시 발생하는 잡음을 줄여주는  
  기능이 있다면 큰 도움이 될 수 있다. 코틀린에서는 이전에 봤던 람다 호출을 간결하게 해주는 기능이나 중위 함수 호출이  
  메소드 호출에 따른 잡음을 줄여주는 기능이다.

- 이번에는 DSL에서 중위 호출을 어떻게 활용하는지 살펴보자. Kotlintest DSL에서 중위 호출을 어떻게 하는지 살펴보자.

```kt
s should startWith("kot")
```

- s에 들어있는 값이 "kot"로 시작하지 않으면 이 assertion은 실패한다. 이 코드는 거의 자연스러운 영어 문장처럼 읽힌다.  
  이런 목적을 달성하기 위해 `should()` 함수 선언 앞에 infix 변경자를 붙여야 한다.

```kt
infix fun <T> T.shouldBe(matcher: Matcher<T>) = matcher.test(this)
```

- `should()` 함수는 `Matcher`의 인스턴스를 요구한다. `Matcher`는 값에 대한 assertion을 표현하는 제네릭 인터페이스이다.  
  `startWith()`는 `Matcher`를 구현하며, 어떤 문자열이 주어진 문자열로 시작하는지 검사한다.

```kt
interface Matcher<T> {
	fun test(value: T)
}

class startWith(val prefix: String) : Matcher<String> {
	override fun test(value: String) {
		if(!value.startsWith(prefix)) {
			throw AssertionError("String $value does not start with $prefix")
		}
	}
}
```

- 평범한 프로그램이라면 `startWith` 클래스의 첫 글자를 대문자로 명명했어야 한다. 하지만 DSL에서는 그런 일반적인 명명 규칙을 벗어나야 할  
  때가 많다. 위 코드는 DSL에서 아주 쉽게 중위 호출을 적용할 수 있다는 사실을 보여주며, 중위 호출이 코드의 잡음을 효과적으로 줄여준다는  
  사실도 보았다. 약간 더 기교를 부리면 잡음을 더 많이 감소시킬 수 있다.

```kt
"kotlin" should start with "kot"
```

- 위 문장은 처음 코틀린 문장처럼 전혀 보이지 않는다. 이 문장이 어떻게 작동하는지 이해하려면 중위 호출을 일반 메소드 호출로 바꿔봐야 한다.

```kt
"kotlin".should(start).with("kot")
```

- 위 코드를 보면 `should()`와 `with()`라는 두 메소드를 연쇄적으로 중위 호출한다는 사실과 start가 `should()`의 인자라는 사실을 알 수 있다.  
  여기서 start는 싱글톤 객체 선언을 참조하며, `should()`와 `with()`는 중위 호출 구문으로 쓰인 함수다.

- `should()` 함수 중에는 start 객체를 파라미터 타입으로 사용하는 특별한 오버로딩 버전이 있다.  
  이 오버로딩한 `should()` 함수는 중간 wrapper 객체를 돌려주는데, 이 wrapper 객체 안에는 중위 호출 가능한 `with()` 메소드가 들어있다.

```kt
object start

infix fun String.should(x: start): StartWrapper = StartWrapper(this)

class StartWrapper(val value: String) {
	infix fun with(prefix: String) =
		if (!value.startsWith(prefix))
			throw AssertionError("String does not start with $prefix: $value")
		else
			Unit
}
```

- DSL이라는 맥락 밖에서는 object로 선언한 타입을 파라미터 타입으로 사용할 이유가 거의 없다. 싱글톤 객체에는 인스턴스가 단 하나밖에 없기 때문에  
  굳이 그 객체를 인자로 넘기지 않아도 직접 그 인스턴스에 접근할 수 있다. 하지만 여기서는 객체를 파라미터 타입으로 사용한 타당한 이유가 있다.  
  여기서 `start` 객체는 함수에 데이터를 넘기기 위해서가 아니라 DSL의 문법을 정의하기 위해 사용된다. `start`를 인자로 넘김으로써  
  `should()`를 오버로딩한 함수 중에서 적절한 함수를 선택할 수 있고, 그 함수를 호출한 결과로 `StartWrapper` 인스턴스를 받을 수 있다.  
  `StartWrapper` 클래스에는 assertion의 검사를 수행하기 위해 필요한 값을 인자로 받는 `with()`라는 멤버가 있다.

- Kotlintest 라이브러리는 다른 `Matcher`도 지원하며, 그 `Matcher`들은 모두 일반 영어 문장처럼 보이는 assertion을 구성한다.

```kt
"kotlin" should end with "in"
"kotlin" should have substring "otl"
```

- 이런 문장을 지원하기 위해 `should()`에는 `end`나 `have` 같은 싱글톤 객체 인스턴스를 취하는 오버로딩 버전이 더 존재한다.  
  이들은 싱글톤의 종류에 따라 각각 `EndWrapper`와 `HaveWrapper` 인스턴스를 반환한다.

- 이렇게 중위 호출과 object로 정의한 싱글톤 객체 인스턴스를 조합하면 DSL에 상당히 복잡한 문법을 도입할 수 있고, 그런 문법을 사용하면  
  DSL 구문을 깔끔하게 만들 수 있다.

---
