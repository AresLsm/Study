## 조건문 분해하기

```js
// 리팩토링 적용 전
if (!date.isBefore(plan.summerStart) && !date.isAfter(plan.summerEnd)) {
  charge = quantity * plan.summerRate;
}

// 리팩토링 적용 후
if (summer()) {
  charge = summerCharge();
} else {
  charge = regularCharge();
}
```

### 배경

- 복잡한 조건부 로직은 프로그램을 복잡하게 만드는 가장 흔한 원흉에 속한다. 다양한 조건, 그에 따라  
  동작도 다양한 코드를 작성하면 순식간에 꽤 긴 함수가 탄생한다. 긴 함수는 그 자체로 읽기가 어렵지만,  
  조건문은 그 어려움을 한층 가중시킨다. 조건을 검사하고 그 결과에 따른 동작을 표현하는 코드는 무슨  
  일이 일어나는지는 이야기해주지만, _'왜'_ 일어나는지는 제대로 말해주지 않을 때가 많은 것이 문제다.

- 거대한 코드 블록이 주어지면, 코드를 부위별로 분해한 다음 해체된 코드 덩어리들을 각 덩어리의 의도를  
  살린 이름의 함수 호출로 바꿔주자. 그러면 전체적인 의도가 더 확실히 드러난다. 이렇게 해주면 해당 조건이  
  무엇인지를 강조하고, 그래서 무엇을 분기했는지가 명백해진다. 분기한 이유 역시 더 명확해진다.

- 이 리팩토링은 자신의 코드에 **함수 추출하기**를 적용하는 한 사례라 할 수 있다.

### 절차

- (1) 조건식과 그 조건식에 딸린 조건절 각각을 **함수로 추출** 한다.

### 예시

- 여름철이라면 할인율이 달라지는 어떤 서비스의 요금을 계산한다 해보자.

```js
if (!date.isBefor(plan.summerStart) && !date.isAfter(plan.summerEnd)) {
  charge = quantity * plan.summerRate;
} else {
  charge = quantity * plan.regularRate + plan.regularServiceCharge;
}
```

- 우선 _(1) 조건 부분(조건식)을 별도 함수로 추출하자._

```js
if (summer()) {
  charge = quantity * plan.summerRate;
} else {
  charge = quantity * plan.regularRate + plan.regularServiceCharge;
}

function summer() {
  return !date.isBefore(plan.summerStart) && !date.isAfter(plan.summerEnd);
}
```

- 그런 다음 조건을 만족했을 때의 로직도 또 다른 함수로 추출한다.  
  조건을 만족하지 않았을 때의 로직도 함수로 추출해주자. 사이에 테스트를 해야 한다.

```js
if (summer()) {
  charge = summerCharge();
} else {
  charge = regularCharge();
}

function summer() {
  return !date.isBefore(plan.summerStart) && !date.isAfter(plan.summerEnd);
}

function summerCharge() {
  return quantity * plan.summerRate;
}

function regularCharge() {
  return quantity * plan.regularRate + plan.regularServiceCharge;
}
```

- 취향에 따라 삼항 연산자로 바꿀 수도 있다.

```js
charge = summer() ? summerCharge() : regularCharge();
```

<hr/>
