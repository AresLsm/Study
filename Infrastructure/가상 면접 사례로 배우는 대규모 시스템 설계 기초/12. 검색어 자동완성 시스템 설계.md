# 검색어 자동완성 시스템 설계

- 이번에는 입력 중인 글자에 맞는 검색어를 자동으로 완성시켜 표시해주는 검색어 자동완성 시스템을 설계해보자.

## 문제 이해 및 설계 범위 확정

- 아래는 이번에 설계할 검색어 자동완성 시스템의 요구 사항이다.

  - 빠른 응답 속도: 사용자가 검색어를 입력함에 따라 자동완성 검색어도 충분히 빨리 표시되어야 한다. Facebook 검색어 자동완성 시스템의 경우,  
    시스템 응답속도는 100ms 이내이다. 그렇지 않으면 시스템 이용이 불편해진다.

  - 연관성: 자동완성되어 출력되는 검색어들은 사용자가 입력한 단어와 연관된 것이어야 한다.

  - 정렬: 시스템의 계산 결과는 popularity(인기도) 등의 ranking model(순위 모델)에 의해 정렬되어 있어야 한다.

  - 규모 확장성: 시스템은 많은 트래픽을 감당할 수 있도록 확장 가능해야 한다.

  - 고가용성: 시스템의 일부에 장애가 발생하거나, 느려지거나, 예상치 못한 네트워크 문제가 생겨도 시스템은 계속 사용 가능해야 한다.

### 개략적 규모 추정

- DAU는 1000만 명으로 간주한다.
- 평균적으로 한 사용자는 매일 10건의 검색을 수행한다.
- 질의할 때마다 평균적으로 20byte의 데이터를 입력한다고 가정한다.
  - 문자 encoding 방법으로는 ASCII를 사용한다. 따라서 `1문자 = 1byte` 이다.
  - 질의문은 평균적으로 4개 단어로 이뤄진다고 가정할 것이며, 각 단어는 평균적으로 5개 글자로 구성된다고 가정할 것이다.
  - 따라서 질의당 평균 `4 * 5 = 20` byte이다.
- 검색창에 글자를 입력할 때마다 클라이언트는 검색어 자동완성 백엔드에 요청을 보낸다. 따라서 평균적으로 1회 검색당 20건의 요청이 발생한다.  
  예를 들어 dinner라고 입력한다면, 아래의 6개 요청이 순차적으로 발생한다.
  - `search?q=d`
  - `search?q=di`
  - `search?q=din`
  - `search?q=dinn`
  - `search?q=dinne`
  - `search?q=dinner`
- 대략 초당 24,000건의 질의(QPS)가 발생할 것이다.
- 최대 QPS는 `QPS * 2 = 대략 48,000` 이다.
- 질의 가운데 20% 정도는 신규 검색어라고 가정한다.  
  따라서 대략 0.4GB 정도이며, 이는 곧 매일 0.4GB의 신규 데이터가 시스템에 추가된다는 뜻이다.

---

## 개략적 설계안 제시 및 동의 구하기

- 개략적으로 보면 시스템은 크게 두 부분으로 나뉜다.

- 데이터 수집 서비스(Data gathering service): 사용자가 입력한 질의를 실시간으로 수집하는 시스템이다. 데이터가 많은 애플리케이션에  
  실시간 시스템은 그다지 바람직하지 않지만, 설계안을 만드는 출발점으로는 괜찮을 것이다.

- 질의 서비스(Query service): 주어진 질의에 다섯 개의 인기 검색어를 정렬해 내놓는 서비스이다.

### Data gathering service

- 데이터 수집 서비스가 어떻게 동작하는지 간단한 예제를 통해 살펴보자. Query문과 사용 빈도를 저장하는 Frequency table(빈도 테이블)이 있다고 해보자.

![picture 1](/images/SDI_SKAS_1.png)

- 이 테이블은 처음에 비어있는데, 사용자가 "twitch", "twitter", "twitter", "twilo"를 순서대로 검색하면 그 상태가 위처럼 바뀌어 나가게 된다.

### Query service

- 아래 표와 같은 빈도 테이블이 있는 상태라고 해보자. 2개의 필드가 있음을 확인할 수 있다.

| query          | frequency |
| -------------- | --------- |
| twitter        | 35        |
| twitch         | 29        |
| twilight       | 25        |
| twin peak      | 21        |
| twitch prime   | 18        |
| twitter search | 10        |
| twin peack sf  | 8         |

- 이 상태에서 사용자가 "tw"를 검색창에 입력하면, 아래의 "top 5" 자동완성 검색어가 표시되어야 한다.  
  "top 5"는 위의 빈도 테이블에 기록된 수치를 사용해 계산한다고 가정한다.

![picture 2](/images/SDI_SKAS_2.png)

- 가장 많이 사용된 5개 검색어는 아래의 SQL문을 통해 계산할 수 있다.

```sql
SELECT * FROM frequency_table
WHERE query LIKE 'prefix%'
ORDER BY frequency DESC
LIMIT 5;
```

- 이와 같은 접근법은 데이터 양이 적을 때는 나쁘지 않다. 하지만 데이터가 아주 많아지면 데이터베이스가 병목이 될 수 있다.  
  상세 설계안을 준비하면서 이 문제를 해결할 방법을 알아보자.

---
