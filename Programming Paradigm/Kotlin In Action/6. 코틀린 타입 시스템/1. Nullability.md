# Nullability(Null 가능성)

- Nullability는 NPE(`NullPointerException`)을 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다.

- 코틀린을 비롯한 최신 언어에서 null에 대한 접근 방법은 가능한 한 이 문제를 실행 시점에서  
  컴파일 시점으로 옮기는 것이다. Null이 될 수 있는지 여부를 타입 시스템에 추가함으로써 컴파일러가  
  여러 가지 오류를 컴파일 시 미리 감지해서 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다.

## Nullable 타입

- 코틀린과 Java의 첫 번째이자 가장 중요한 차이는 **코틀린 타입 시스템은 null이 될 수 있는 타입을 명시적으로 지원한다**는  
  점이다. null이 될 수 있는 타입이란, 프로그램 안의 프로퍼티나 변수에 null을 허용하게 만드는 방법이다.  
  어떤 변수가 null이 될 수 있다면 그 변수에 대해 메소드를 호출하면 NPE가 발생할 수 있으므로 안전하지 않다.  
  코틀린은 그런 메소드 호출을 금지함으로써 많은 오류를 방지한다. null이 될 수 있는 타입의 동작을 배우기 위해  
  아래의 Java 함수를 살펴보자.

```java
int strlen(String s) {
    return s.length();
}
```

- 위 함수는 안전할까? 위 함수에 null을 건네면 NPE가 발생한다. 그렇다면 이 함수에서 s가 null인지를 꼭 검사해야 할까?  
  검사가 필요할지 여부는 이 함수를 사용하는 의도에 따라 달라진다.

- 이 함수를 코틀린으로 다시 작성해보자. 코틀린에서 이런 함수를 작성할 때 가장 먼저 질문해야 할 것은  
  _"이 함수가 null을 인자로 받을 수 있는가?"_ 이다. 여기서 null을 인자로 받을 수 있다는 말은 `strlen(null)`처럼  
  직접 null 리터럴을 사용하는 경우 뿐만 아니라, 식의 값이 실행 시점에 null이 될 수 있는 경우를 모두 포함한다.

- null이 인자로 들어올 수 없다면, 코틀린에서는 아래처럼 함수를 정의할 수 있다.

```kt
fun strlen(s: String) = s.length
```

- 이제 위 `strlen()`에 null이거나, null이 될 수 있는 인자를 넘기는 것은 금지되며, 혹시 그런 값을 넘기게 된다면  
  컴파일 시점에 오류가 발생한다.

- `strlen()`에서 파라미터 s의 타입은 `String`인데, 코틀린에서 이는 _s가 항상 `String`의 인스턴스여야 한다_ 는 뜻이다.  
  이때, 컴파일러는 null이 될 수 있는 값을 `strlen()`에 인자로 넘기지 못하게 만든다. 따라서 `strlen()`이 결코  
  실행 시점에 NPE를 발생시키지 않으리라 장담할 수 있다.

- 위 함수가 null을 받을 수 있도록 하려면 아래처럼 바꾼다.

```kt
fun strlen(s: String?) = /* ... */
```

- `String?`, `Int?`, `MyCustomType?` 등 어떠한 타입이든 타입 이름 뒤에 물음표를 붙이면 그 타입의 변수나  
  프로퍼티에 null 참조를 저장할 수 있다는 뜻이 된다.

- nullable한 변수가 있다면, 그에 대해 수행할 수 있는 연산이 제한된다. 예를 들어 nullable 타입의 변수에 대해  
  `변수.메소드()` 처럼 메소드를 직접 호출할 수는 없다.

- nullable 값을 null이 될 수 없는 타입의 변수에 대입할 수 없다.

```kt
val x: String? = null
var y: String = x // error
```

- nullable한 타입의 값을 null이 될 수 없는 타입의 파라미터를 받는 함수에 전달할 수 없다.

```kt
val x: String? = null
strlen(x) // error
```

- 이렇게 제약이 많다면 nullable한 타입의 값으로 대체 뭘 할 수 있을까? 가장 중요한 일은 바로  
  **null과 비교하는 것**이다. 일단 null과 비교하고 나면, 컴파일러는 그 사실을 기억하고 null이 아님이  
  확실한 영역에서는 해당 값을 null이 될 수 없는 타입의 값처럼 사용할 수 있다.

```kt
fun strlenSafe(s: String?): Int = if(s != null) s.length else 0

// client
val x: String? = null
println(strlenSafe(x)) // 0

println(strlenSafe("abc")) // 3
```

<hr/>
