# 중급 문법

## 프로젝션과 결과 반환 - 기본

- 프로젝션(Projection): `SELECT`절에 어떤 것을 가져올지 지정하는 것

### 프로젝션 대상이 하나인 경우

```kt
@Test
fun singleProjection() {
val result: List<String> = query
        .select(member.username)
        .from(member)
        .fetch()
}
```

- 위 코드는 `member.username`만 가져오고 싶어 한다. 여러 개의 row 중 하나의  
  컬럼만 가져올 때, 위처럼 **타입을 명확하게 지정할 수 있다.**

- 하지만, 프로젝션 대상이 둘 이상일 때는 `Tuple` 또는 직접 만든 DTO로 조회할 수 있다.

```kt
@Test
fun multipleProjection() {
    val result: List<Tuple> = query
        .select(member.username, member.age)
        .from(member)
        .fetch()

    for(tuple in result) {
        val username: String? = tuple.get(member.username)
        val age: Int? = tuple.get(member.age)
        println("$username $age")
    }
}
```

- 위처럼 프로젝션 대상이 여러 개 일때는 `Tuple`로 담아 사용할 수 있다.

- 참고로, `Tuple`을 Repository Layer에서 사용하는건 좋지만, Business(Domain) layer에까지  
  `Tuple` 타입이 그대로 사용되는 것은 좋지 못한 설계이다. 핵심 비즈니스 로직이 담긴 Business layer의  
  입장에서 하위 layer인 Repository Layer가 구현되어 있는 방식을 알게되기 때문이다.  
  그렇게 해야 상위 layer인 Business Layer가 하위 layer인 Repository Layer에 강한 결합성을  
  갖게 되는 것을 방지할 수 있다.

<hr/>

## 프로젝션과 결과 반환 - DTO로 조회하기

- 기존 JPQL로 데이터를 직접 만든 DTO로 조회할 때는 아래와 같이 해주었다.  
  `Member`의 정보를 담는 `MemberDto`와 이 DTO class를 사용하는 JPQL의 예시이다.

```kt
// MemberDto
data class MemberDto(
    val username: String,
    val age: Int
)

// JPQL Code
@Test
fun jpa_to_dto() {
    val result: List<MemberDto> = entityManager
        .createQuery("select new com.example.dto.MemberDto(m.username, m.age) from Member m", MemberDto::class.java)
        .resultList
    for(memberDto in result) {
        println(memberDto)
    }
}
```

- 위처럼 JPQL의 결과를 DTO Class에 넣기에는 아래와 같은 단점들이 있다.

  - 항상 JPQL에 `new` 키워드를 사용해야 한다.
  - 패키지명을 모두 명시해줘야 한다.
  - 생성자 방식만 지원한다.

### Querydsl Bean 생성(Bean Population)

- Querydsl Bean은 쿼리 수행 결과를 DTO로 반환받고 싶을 때 사용한다.  
  아래의 세 가지 방법을 지원한다.

  - 프로퍼티 접근
  - 필드 직접 접근
  - 생성자 사용

#### 프로퍼티 접근

```kt
@Test
fun queryDslDtoBySetter() {
    val result: List<MemberDto> = query
        .select(Projections.bean(MemberDto::class.java, member.username, member.age))
        .from(member)
        .fetch()

    for(memberDto in result) {
        println(memberDto)
    }
}
```

- `Projections.bean()`을 사용하면 각 프로퍼티에 값들이 standard setter를 사용해 들어가게 된다.

#### 필드 직접 접근

```kt
@Test
fun queryDslDtoByFieldAccess() {
    val result: List<MemberDto> = query
        .select(Projections.fields(MemberDto::class.java, member.username, member.age))
        .from(member)
        .fetch()

    for(memberDto in result) {
        println(memberDto)
    }
}
```

- 프로퍼티 접근, 필드 접근 방식에서 주의점은 **생성자에 들어간 필드명과 생성자 호출 시 넣어주는 변수명이 동일해야 값이 들어간다**는 점이다.  
  예를 들어, 아래의 Dto가 있다 해보자.

```kt
data class ExampleDto(
    val name: String = "",
    val age: Int = 0,
)
```

- 이제 위 테스트 코드에서 `Projections.fields(ExampleDto::class.java, member.username, member.age)`를 사용하면  
  `ExampleDto` 인스턴스들의 name 필드는 모두 null이 되어 있다.

- 위처럼 null이 들어가기에, `as()`로 필드명을 아래처럼 바꿔주면 된다.

```kt
Projections.fields(ExampleDto::class.java, member.username.`as`("name"), member.age)
```

- 이를 해결하는 두 번째 방식으로는 `ExpressionUtils.as(source, alias)`가 있는데, 이를 사용하면  
  필드명 또는 서브 쿼리에 별칭을 적용함으로써 해결할 수 있다.

- 예를 들어, 가져온 모든 데이터의 age가 최대 age이게 하기 위해 서브 쿼리를 사용하면, 아래와 같이 하면 된다.

```kt
@Test
fun queryDslToDtoSubQuery() {
    val subMember = QMember("memberSub")
    val result: List<MemberDto> = query
        .select(Projections.fields(MemberDto::class.java,
            member.username,
            ExpressionUtils.`as`(
                JPAExpressions
                    .select(subMember.age.max())
                    .from(subMember), "age"))
            )
            .from(member)
            .fetch()
}
```

> 서브 쿼리를 사용하지 않는 한, `.as(alias)` 방식이 더 깔끔하다.

#### 생성자 사용

```kt
@Test
fun queryDslDtoByConstructor() {
    val result: List<MemberDto> = query
        .select(Projections.constructor(MemberDto::class.java, member.username, member.age))
        .from(member)
        .fetch()

    for(memberDto in result) {
        println(memberDto)
    }
}
```

- 역시 다른 점은 `Projections.constructor()`를 사용했다는 점이다.  
  DTO Class를 첫 번째 인자로 전달하고, 나머지 인자들은 생성자에 들어갈 값들을 알맞게  
  지정해준 것이다. `MemberDto`는 생성자로 username, age를 받기에 위 코드는  
  잘 동작하지만, 만약 `Projections.constructor(MemberDto::class.java, member.username, member.team)`를  
  사용하면 알맞은 생성자를 찾을 수 없다면서 에러가 난다.

<hr/>
