# Nullability(Null 가능성)

- Nullability는 NPE(`NullPointerException`)을 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다.

- 코틀린을 비롯한 최신 언어에서 null에 대한 접근 방법은 가능한 한 이 문제를 실행 시점에서  
  컴파일 시점으로 옮기는 것이다. Null이 될 수 있는지 여부를 타입 시스템에 추가함으로써 컴파일러가  
  여러 가지 오류를 컴파일 시 미리 감지해서 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다.

## Nullable 타입

- 코틀린과 Java의 첫 번째이자 가장 중요한 차이는 **코틀린 타입 시스템은 null이 될 수 있는 타입을 명시적으로 지원한다**는  
  점이다. null이 될 수 있는 타입이란, 프로그램 안의 프로퍼티나 변수에 null을 허용하게 만드는 방법이다.  
  어떤 변수가 null이 될 수 있다면 그 변수에 대해 메소드를 호출하면 NPE가 발생할 수 있으므로 안전하지 않다.  
  코틀린은 그런 메소드 호출을 금지함으로써 많은 오류를 방지한다. null이 될 수 있는 타입의 동작을 배우기 위해  
  아래의 Java 함수를 살펴보자.

```java
int strlen(String s) {
    return s.length();
}
```

- 위 함수는 안전할까? 위 함수에 null을 건네면 NPE가 발생한다. 그렇다면 이 함수에서 s가 null인지를 꼭 검사해야 할까?  
  검사가 필요할지 여부는 이 함수를 사용하는 의도에 따라 달라진다.

- 이 함수를 코틀린으로 다시 작성해보자. 코틀린에서 이런 함수를 작성할 때 가장 먼저 질문해야 할 것은  
  _"이 함수가 null을 인자로 받을 수 있는가?"_ 이다. 여기서 null을 인자로 받을 수 있다는 말은 `strlen(null)`처럼  
  직접 null 리터럴을 사용하는 경우 뿐만 아니라, 식의 값이 실행 시점에 null이 될 수 있는 경우를 모두 포함한다.

- null이 인자로 들어올 수 없다면, 코틀린에서는 아래처럼 함수를 정의할 수 있다.

```kt
fun strlen(s: String) = s.length
```

- 이제 위 `strlen()`에 null이거나, null이 될 수 있는 인자를 넘기는 것은 금지되며, 혹시 그런 값을 넘기게 된다면  
  컴파일 시점에 오류가 발생한다.

- `strlen()`에서 파라미터 s의 타입은 `String`인데, 코틀린에서 이는 _s가 항상 `String`의 인스턴스여야 한다_ 는 뜻이다.  
  이때, 컴파일러는 null이 될 수 있는 값을 `strlen()`에 인자로 넘기지 못하게 만든다. 따라서 `strlen()`이 결코  
  실행 시점에 NPE를 발생시키지 않으리라 장담할 수 있다.

- 위 함수가 null을 받을 수 있도록 하려면 아래처럼 바꾼다.

```kt
fun strlen(s: String?) = /* ... */
```

- `String?`, `Int?`, `MyCustomType?` 등 어떠한 타입이든 타입 이름 뒤에 물음표를 붙이면 그 타입의 변수나  
  프로퍼티에 null 참조를 저장할 수 있다는 뜻이 된다.

- nullable한 변수가 있다면, 그에 대해 수행할 수 있는 연산이 제한된다. 예를 들어 nullable 타입의 변수에 대해  
  `변수.메소드()` 처럼 메소드를 직접 호출할 수는 없다.

- nullable 값을 null이 될 수 없는 타입의 변수에 대입할 수 없다.

```kt
val x: String? = null
var y: String = x // error
```

- nullable한 타입의 값을 null이 될 수 없는 타입의 파라미터를 받는 함수에 전달할 수 없다.

```kt
val x: String? = null
strlen(x) // error
```

- 이렇게 제약이 많다면 nullable한 타입의 값으로 대체 뭘 할 수 있을까? 가장 중요한 일은 바로  
  **null과 비교하는 것**이다. 일단 null과 비교하고 나면, 컴파일러는 그 사실을 기억하고 null이 아님이  
  확실한 영역에서는 해당 값을 null이 될 수 없는 타입의 값처럼 사용할 수 있다.

```kt
fun strlenSafe(s: String?): Int = if(s != null) s.length else 0

// client
val x: String? = null
println(strlenSafe(x)) // 0

println(strlenSafe("abc")) // 3
```

<hr/>

## 타입의 의미

- 타입의 정의 중 하나는 아래와 같다.

> - 타입: 타입은 분류(Classification)로, 타입은 어떤 값들이 가능한지와 그 타입에 대해 수행할 수 있는  
>   연산의 종류를 결정한다.

- 위의 정의를 Java 타입 중 몇 가지에 대해 적용해보자. 먼저 double 을 본다면, double은 64비트 부동소수점 수다.  
  double 타입의 값에 대해 일반 수학 연산을 수행할 수 있다. double 타입에 속한 값이라면 어떤 값이든 관계없이  
  모든 일반 수학 연산 함수를 적용할 수 있다. 따라서 double 타입의 변수가 있고, 그 변수에 대한 연산을 컴파일러가  
  통과시킨 경우 그 연산이 성공적으로 실행되리라는 사실을 확신할 수 있다.

- 이제 double과 `String`을 비교해보자. Java에서 `String` 타입 변수에는 `String`이나 null의 두 가지 종류의  
  값이 들어갈 수 있다. 이 두 종류의 값은 서로 완전히 다르다. 심지어 Java 자체의 instanceof 연산자도 null이  
  `String`이 아니라 한다. 실제 `String`이 들어있는 변수에 대해서는 `String` 클래스에 정의된 모든 메소드를  
  호출할 수 있다. 하지만 null이 들어있는 경우에는 사용할 수 있는 연산이 많지 않다.

- 이는 Java의 타입 시스템이 null을 제대로 다루지 못한다는 것을 보여준다. 변수에 선언된 타입이 있지만, null 여부를  
  추가로 검사하기 전까지는 그 변수에 대해 어떤 연산을 수행할 수 있을지 알 수 없다. 프로그램의 데이터 흐름 속에서  
  특정 위치에 특정 변수가 절대로 null일 수 없다는 사실을 확신하고 이런 검사를 생략하는 경우가 자주 있지만, 만약  
  이 생각이 틀렸다면 실행 시점에 NPE가 발생할 수 있다.

> Java에서 NPE를 다루기 위해 `@Nullable`, `@NotNull` 등의 어노테이션을 활용하는 방법이 있지만,  
> 이 방식은 표준 Java 컴파일 절차의 일부가 아니기에 일관성 있게 적용된다는 보장을 할 수 없다. 또한 서드파티 라이브러리에  
> 이런 장치가 잘 되어있다 보장할 수도 없다. 가장 최선의 방법은 null을 감싸는 `Optional`을 사용하는 것이다.

<hr/>

## 안전한 호출 연산자 `?.`

- 코틀린이 제공하는 가장 유용한 도구 중 하나는 안전한 호출 연산자(Safe Call Operator)인 `?.`이다.  
  `?.`은 null 검사와 메소드 호출을 한 번의 연산으로 수행한다. 예를 들어. `s?.toUpperCase()`는  
  훨씬 더 복잡한 `if(s!= null) s.toUpperCase() else null`과 같다.

- 호출하려는 값이 null이 아니라면, `?.`는 일반 메소드 호출처럼 작동한다. 호출하려는 값이 null이면  
  이 호출은 무시되고, null이 결과값이 된다.

- 안전한 호출의 결과 타입도 null이 될 수 있는 타입이라는 사실에 유의하자. `String#toUpperCase()`는  
  `String` 타입의 경우 `String` 타입의 값을 반환하지만, nullable한 타입을 받는 경우  
  `s?.toUpperCase()` 식의 결과 타입은 `String?`이다.

```kt
fun printAllCaps(s: String?) {
    val allCaps = s?.toUpperCase()
    println(allCaps)
}

printAllCaps("Kotlin") // KOTLIN

printAllCaps(null) // null
```

- 메소드 호출 뿐만 아니라 프로퍼티를 읽거나 쓸 때도 안전한 호출을 사용할 수 있다. 아래 예시는 null이 될 수 있는  
  프로퍼티가 있는 간단한 코틀린 클래스로, 프로퍼티 접근 시 안전한 호출을 사용하는 방법을 보여준다.

```kt
class Employee(val name: String, val manager: Employee?)

fun managerName(employee: Employ): String? = employee.manager?.name

// client
val ceo = Employee("Da Boss", null)
val developer = Employee("Bob Smith", ceo)
println(managerName(developer)) // Da Boss
println(managerName(ceo)) // null
```

- 객체 그래프에서 nullable한 중간 객체가 여러개 있다면, 한 식 안에서 안전한 호출을 연쇄해서 사용하면 편할 때가 자주 있다.

```kt
class Address(val streetAddress: String, val zipCode: Int, val city: String, val country: String)

class Company(val name: String, val address: Address?)

class Person(val name: String, val company: Company?)

fun Person.countryName(): String {
    val country = this.company?.address?.country
    return if (country != null) country else "Unknown"
}

// client

val person = Person("Dmitry", null)
println(person.countryName()) // Unknown
```

- Null 검사가 들어간 호출이 연달아 있는 경우를 Java 코드에서 자주 볼 수 있다. 하지만 코틀린에서는 훨씬 간결하게  
  null 검사를 할 수 있다. 위 코드를 보면, country가 null인지 검사해서 정상적인 country 값을 반환하거나  
  null인 경우에 대응하는 "Unknown"을 반환한다.

<hr/>

## 엘비스 연산자 `?:`

- 엘비스 연산자는 코틀린이 null 대신 사용할 디폴트 값을 편리하게 지정하게끔 지원해주는 연산자다.  
  `?:` 처럼 생겼으며, 아래는 사용하는 예시다.

```kt
fun foo(s: String?) {
    val t: String = s ?: ""
}
```

- 코틀린에서는 return이나 throw 등의 연산도 _식_ 이다. 따라서 엘비스 연산자의 우항에 return, throw 등의  
  연산을 넣을 수 있으며, 엘비스 연산자를 더욱 편하게 사용할 수 있다. 그런 경우, 엘비스 연산자의 좌항이 null이면  
  함수가 즉시 어떤 값을 반환하거나, 예외를 던진다.

<hr/>

## 안전한 캐스트: `as?`

- 이전에 코틀린 타입 캐스트 연산자인 as에 대해 살펴봤다. Java 타입 캐스트와 마찬가지로 대상 값을 as로  
  지정한 타입으로 바꿀 수 없으면 `ClassCastException`이 발생한다. 물론 as를 사용할 때마다 is를 통해  
  미리 as로 변환 가능한 타입인지 검사해볼 수도 있다. 하지만 코틀린에서 이보다 더 좋은 방법을 사용할 수 있다.

- `as?` 연산자는 어떤 값을 지정한 타입으로 캐스트한다. 이때, as와는 달리 `as?`는 대상 타입으로 변환할 수  
  없으면 null을 반환한다.

- 안전한 캐스트를 사용할 때 일반적인 패턴은 캐스트를 수행한 뒤에 엘비스 연산자를 사용하는 것이다. 예를 들어  
  `equals()`를 구현할 때 이런 패턴이 유용하다.

```kt
class Person(val firstName: String, val lastName: String) {
    override fun equals(o: Any?): Boolean {
	val otherPerson = o as? Person ?: return false
	return otherPerson.firstName == firstName && otherPerson.lastName == lastName
    }
}
```

- 이 패턴을 사용하면 파라미터로 받은 값이 원하는 타입인지 쉽게 검사하고 캐스트할 수 있고, 타입이 맞지 않으면  
  쉽게 false를 반환할 수 있다. 이 모든 동작을 위처럼 단 하나의 식으로 해결 가능하다.

<hr/>

## null 아님 단언: `!!`

- null 아님 단언(Not-null Assertion)은 코틀린에서 nullable한 타입의 값을 다룰 때 사용할 수 있는 도구 중  
  가장 단순하면서도 무딘 도구다. `!!`를 사용하면, 어떤 값이든 null이 될 수 없는 타입으로 강제로 바꿀 수 있다.  
  실제 null에 대해 `!!`를 적용하면 NPE가 발생한다.

```kt
fun ignoreNulls(s: String?) {
    val sNotNull: String = s!!
    println(sNotNull.length)
}
```

- `ignoreNulls(null)`을 호출하면 NPE가 발생하지만, 이 예외가 발생하는 곳은 `sNotNull.length`가 아니라  
  `!!`가 호출된 부분이다. 근본적으로 `!!`는 컴파일러에게 _"나는 이 값이 null이 아님을 확신한다."_ 를 알려주는 것이다.

<hr/>
