<h1>Entity 간의 1:1 연관, 그리고 즉시 및 지연 로딩</h1>

<h2>키를 참조하는 1:1 연관 매핑</h2>

* 구현을 하다보면, 같은 키를 가지고 연관 관계를 이루는 테이블이 자주 등장하게 된다.   
  예를 들어, 회원 카드인 membership_card 테이블은 회원의 주요 키(ex.이메일) 를 외래키로 참조해야 한다.
* JPA를 사용하면 간단한 설정으로 위 두개의 테이블에 대한 Entity 객체 간의 1:1 연관을 처리할 수 있다.
<hr/>

<h2>참조키를 이용한 1:1 단방향 연관</h2>

* membership_card 테이블이 user 테이블의 email 컬럼을 user_email로 참조하고 있다고 가정하자.   
  이를 위한 매핑 설정을 간단한다. 아래 코드를 보자.
```java
@Entity
@Table(name = "membership_card")
public class MembershipCard {
    @Id
    @Column(name = "card_number")
    private String number;

    @OneToOne
    @JoinColumn(name = "user_email")
    private User owner;

    @Temporal(TemporalType.DATE)
    @Column(name = "expiry_date")
    private Date expiryDate;
    private boolean enabled;

    public MembershipCard() {}

    public MembershipCard(String number, User owner, Date expiryDate) {
        this.number = number;
        this.owner = owner;
        this.expiryDate = expiryDate;
    }
}
```

* 위 코드의 owner 필드는 아래의 두 어노테이션을 사용하여 매핑을 설정하고 있다.
  * `@OneToOne` : owner 필드가 User Entity와 1:1 연관을 가짐을 설정한다.
  * `@JoinColumn` : User 객체의 식별자에 해당하는 참조키로 user_email을 설정한다.

* `MemberShipCard` Entity가 `User` Entity를 참조하려면 `User` Entity의 식별자 값을 구해야하는데, 이 식별자를 담고 있는   
  컬럼을 지정할 때 `@JoinColumn` 어노테이션을 사용한다. membership_card 테이블에서 user 테이블에 대한 참조키로 사용하는   
  컬럼이 user_email 이므로 `@JoinColumn` 어노테이션의 값으로 "user_email"을 사용했다.

* `MembershipCard` Entity가 `User` Entity를 참조하므로 `MembershipCard` 객체를 생성할 때 참조할 `User` Entity 객체를   
  아래와 같이 전달할 수 있다.
```java
User owner = entityManager.find(User.class, "email");

Date expiryDate = new /* .. */;

MembershipCard memCard = new MembershipCard("1234", owner, expiryDate);
entityManager.persist(memCard);
```
  * 위 코드에서 식별자가 "1234"인 `MembershipCard` 객체를 생성할 때 `EntityManager`로 구한 owner를 두 번째 인자로   
    전달하고 있다. 생성한 `MembershipCard` 객체는 `EntityManager#persist()`를 이용하여 영속 컨텍스트에 보관한다.

* 위 코드를 수행한 query 로그를 보면, 아래와 같다.
```sql
INSERT INTO membership_card (expiry_date, user_email, card_number, enabled) VALUES (?,?,?,?);
```
  * 즉, `@OneToOne`으로 연관된 객체의 식별자를 `@JoinColumn`으로 설정한 컬럼에 저장하는 것을 알 수 있다.

* 반대로 DB에 저장된 객체를 로딩하면, 저장할때와 반대로 `@JoinColumn`에 지정한 컬럼을 이용하여 `@OneToOne`으로   
  연관된 Entity를 로딩한다. 실제 JPA는 __`@OneToOne`으로 연관된 객체를 위한 데이터도 모두 함께 조회__ 한다.

* 위에서 작성한 `MemberShipCard` 클래스에 아래의 두 가지 메소드를 추가해보자.
```java
public class MembershipCard {

    //..

    // 신규 사용자에게 미리 등록된 카드를 발급하는 메소드
    public void assignTo(User owner) {
        if(this.owner != null) throw new AlreadyAssignedCardException();
        this.owner = owner;
    }

    // 사용자가 등록된 카드에서 사용자를 제거하는 메소드
    public void cancelAssignment() { this.owner = null; }
}
```

  * 아래와 같이 `assignTo()`의 인자로 null을 전달해보자.
  ```java
  MembershipCard memCard = entityManager.find(MembershipCard.class, "1234");
  User user = null;
  memCard.assignTo(null);
  entityManager.persist(user);
  ```
    * 위 코드의 결과, `@JoinColumn`으로 매핑한 user_email 필드에 null이 할당된다.
  * 이번엔 아래와 같이 `cancelAssignment()` 메소드를 호출하여 owner 필드에 null을 할당하고, transaction commit 시에   
    `@JoinColumn`으로 매핑한 user_email 컬럼을 null로 수정해보자. 만약 `@JoinColumn`으로 매핑한 컬럼 값이 null이면,   
    __연관된 객체도 null이 된다__. 즉, membership_card 테이블의 user_email이 null인 데이터를 로딩하면, 이 경우   
    __owner 필드에는 null이 할당된다__.

* __연관에 사용할 Entity 객체는 반드시 영속 상태(Managed 상태)로 존재해야 한다.__
<hr/>

<h2>1:1 연관의 즉시 로딩과 지연 로딩</h2>

* `EntityManager#find()`를 이용하여 `MembershipCard` 객체를 구하면, 아래와 같이 유사한 outer join을 사용하여   
  `MembershipCard` 객체와 함께 연관된 `User` 객체를 한 query로 함께 로딩한다.
```sql
SELECT m.card_number, m.expiry_date, m.user_email, u.email, u.create_date, u.name
    FROM membership_card m LEFT OUTER JOIN user u ON m.user_email = u.email
        WHERE m.card_number = ?
```
  * 이와 같이 __연관된 객체를 함께 로딩하는 것을 `즉시 로딩(Eager Loading)`__ 이라 한다. Hibernate는 즉시 로딩을 구현하기 위해   
    위 코드처럼 JOIN을 이용하여 1:1로 연관된 객체를 함께 로딩한다.
  * 즉시 로딩은 연관된 객체를 함께 불러오는데, 이는 연관된 객체를 함께 사용하지 않으면 곧 필요없는 객체를 로딩함을 의미한다.   
    만약 연관된 객체가 필요하지 않다면, `지연 로딩(Lazy Loading)`을 사용해서 연관된 객체가 필요할 때만 로딩할 수 있다.

* `Lazy Loading`은 __연관 객체를 실제 사용하는 시점에 로딩하는 방식__ 이다. 지연 로딩을 설정하는 방법은 아래와 같이   
  `@OneToOne`어노테이션의 fetch 속성값으로 `FetchType.LAZY`를 지정하면 된다.
```java
@OneToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "user_email")
private User owner;
```

* `@OneToOne` 어노테이션의 fetch 속성은 `FetchType.EAGER`, 즉 즉시 로딩을 기본값으로 갖는다.   
  따라서 fetch 속성을 따로 지정하지 않으면 Entity를 로딩할 때 `@OneToOne`으로 매핑한 연관 객체도 함께 로딩한다.   
  또한 hibernate는 1:1 연관 객체를 즉시로딩하기 위해 위에서 봤던것과 같이 OUTER JOIN을 사용한다.
<hr/>

<h2>참조키를 이용한 1:1 양방향 연관</h2>

