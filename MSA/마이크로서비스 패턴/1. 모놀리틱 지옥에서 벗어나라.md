# 모놀리틱 지옥에서 벗어나라

<h2>서서히 모놀리틱 지옥에 빠져들다</h2>

<h3>모놀리틱 아키텍쳐의 장점</h3>

- 개발이 간단하다: IDE 등 개발 툴은 단일 애플리케이션 구축에 초점이 맞추어져 있다.
- 애플리케이션을 쉽게 변경할 수 있다: 코드, DB 스키마를 변경해서 빌드, 배포하기 용이하다.
- 테스트하기 쉽다
- 배포하기 쉽다
- 확장하기 쉽다: Load balancer의 뒷면에 애플리케이션 인스턴스를 여러 개 실행할 수 있다.

<h3>모놀리틱 지옥의 실상</h3>

- 모놀리틱 아키텍쳐는 근본적인 한계점이 있다. 덩치가 계속 커지는 애플리케이션은 모놀리틱 아키텍쳐라는 옷이  
  더 이상 맞지 않게 커진다. 개발 팀이 sprint를 할 때마다 추가 구현할 기능이 늘어났고, 그만큼 코드베이스와  
  관리 오버헤드 역시 증가한다.

- 하나의 애플리케이션에 계속해서 기능을 추가하다보면, 초반에는 소수였던 개발 팀도 나중에는 기능 분야가 특화된  
  scrum 팀들로 분리될 때, 코드가 너무 많아 버그를 고치고 새로운 기능을 정확하게 구현해가기 힘들고,  
  시간도 오래 걸린다. 또한 당연하게도 빌드 시간도 계속해서 길어질 것이고, 이는 곧 개발자의 생산성을 떨어뜨린다.

- 애플리케이션은 모듈 단위로 분리할 수 있는데, 모듈 A는 인메모리 데이터베이스를 사용하기 때문에 메모리 성능이 좋아야 하고,  
  모듈 B는 CPU를 많이 소모해서 CPU 코어 수가 많은 서버에 배포하는 것이 좋다고 해보자. 이렇게 같은 애플리케이션이라도  
  리소스 요건이 상이한 모듈이 존재하게 되면 서버 구성 시 리소스 배분에 신경 써야 하며, 이는 확장을 어렵게 만든다.

- 애플리케이션 자체가 워낙 덩치가 커서 철저하게 테스트하기 어렵고, 이는 곧 프로덕션에 버그가 발생할 가능성을 높인다.

<hr/>

<h2>MSA가 답이다</h2>

- 소프트웨어 아키텍쳐는 기능 요건과는 거의 무관하다. 애플리케이션의 기능 요건(Functional requirement), 즉 use case는  
  그 어느 아키텍쳐든 구현할 수 있다. 그러나 아키텍쳐는 **~성(~ibility)으로 끝나는 갖가지 서비스 품질 요건에 영향을 미친다**.  
  예를 들어, 소프트웨어의 관리성(maintainability), 확장성(extensibility), 테스트성(testability) 등이 있다.

<h3>확장 큐브와 마이크로서비스</h3>

- MSA의 여러 가지 정의론 중, 확장 큐브를 생각해보자.

> 확장 큐브는 애플리케이션을 확장하는 세 가지 방법을 정의한다.
> X축 확장은 동일한 다중 인스턴스에 들어온 요청을 부하 분산한다.  
> Z축 확장은 요청의 속성에 따라 요청을 라우팅하며, Y축 확장은 애플리케이션을  
> 기능에 따라 서비스로 분해한다.

- 이 모델에 따르면 애플리케이션을 X, Y, Z의 3가지 방향으로 확장시킬 수 있다.

<h4>X축 확장: 다중 인스턴스에 고루 요청 분산</h4>

- X축 확장은 일반적인 모놀리틱 애플리케이션의 확장 수단이다.  
  Load Balancer의 뒷단에 애플리케이션의 인스턴스를 N개 띄워 놓고 Load balancer는  
  들어온 요청을 이들 인스턴스에 골고루 분배한다. 이는 애플리케이션의 능력과 가용성을 개선할 수 있는 좋은 방법이다.

<h4>Z축 확장: 요청 속성별 라우팅</h4>

- 모놀리틸 애플리케이션의 다중 인스턴스를 실행하는 것은 X축 확장과 같지만, 인스턴스별로 주어진 데이터 하위 집합(subset)만  
  처리하도록 설정하는 방법이다. 인스턴스의 앞면에 위치한 라우터는 요청의 속성에 알맞은 인스턴스로 요청을 라우팅한다.  
  userId에 따라 요청을 분산하는 경우를 생각해보자. 각 애플리케이션 인스턴스는 자신에게 배정된 사용자 하위 집합만 처리한다.  
  라우터는 요청 헤더 중 Authorization에 포함된 userId를 보고 N개의 동일한 애플리케이션 인스턴스 중 하나를 선택한다.  
  이렇게 Z축 확장은 애플리케이션을 확장해서 증가하는 트랜잭션 및 데이터 볼륨을 처리하기 좋은 수단이다.  
  여러 개의 인스턴스 중 1번 인스턴스는 userId가 a-g인 요청을 받고, 2번 인스턴스는 userId가 h-n인 요청을 받고,  
  3번 인스턴스는 o-z인 요청을 처리한다.

<h4>Y축 확장: 기능에 따라 애플리케이션을 서비스로 분해</h4>

- X, Z축 확장을 하면 애플리케이션 능력과 가용성은 개선되지만, 애플리케이션이 점점 복잡해지는 문제는 해결되지 않는다.  
  따라서 Y축 확장, 즉 기능 분해가 필요하다.

- 쇼핑몰을 생각해보자. 각 서비스를 주문 관리, 고객 관리 등 지엽적 기능이 구현된 미니 애플리케이션으로 나눌 수 있을 것이다.  
  서비스에 따라 X, Z축 확장도 가능하다.

- 이렇게 MSA는 고수준에서 바라보면 하나의 애플리케이션을 여러 서비스로 기능 분해하는 아키텍쳐 스타일이다.  
  여기서 중요한 것은 크기가 아니라, 각 서비스가 집중(focus), 응집(cohesive)된 책임을 맡고 있다는 사실이다.

<h3>마이크로서비스의 모듈성</h3>

- 모듈성(Modularity)는 크고 복잡한 애플리케이션을 개발할 때 꼭 필요한 특성이다.  
  요즘 애플리케이션은 규모가 방대하고 내용이 너무 복잡해서 어느 한 개인이 전부 다 이해하고 개발할 수 없다.  
  따라서 여러 사람들이 이해하고 개발할 수 있게끔 애플리케이션을 여러 모듈로 분해한다.

- MSA에서는 모듈성의 단위가 서비스가 된다. 각 서비스는 다른 서비스가 함부로 규칙을 거기고 침투하지 못하게끔  
  API라는 경계선을 갖고 있어서 다른 서비스 API를 우회하여 그 내부 클래스에 마음대로 접근할 수 없다.  
  따라서 시간이 지나도 애플리케이션의 모듈성을 유지하기에 훨씬 수월하다.  
  또 서비스를 각각 독립적으로 배포, 확장할 수 있는 부가적인 장점도 있다.

<h3>서비스마다 DB가 따로 있다</h3>

- 마이크로서비스는 서로 느슨하게 결합되어 있고, **오직 API를 통해서만 통신** 이 가능하다.  
  이렇게 느슨하게 결합된 서비스는 각각 자체 DB를 갖게 된다.  
  서비스마다 다른 DB를 사용한다면 개발 단계에서 다른 서비스 개발자와 일일이 협의하지 않고도 개발자 본인이 담당한  
  서비스 스키마를 변경할 수 있다. 런타임에 서비스는 서로 완전히 분리되어 있기 때문에, 이를테면 다른 서비스가 DB Lock을  
  획득해 서비스를 blocking하는 일은 일어나지 않는다.

<h3>마이크로서비스 아키텍쳐와 SOA</h3>

- SOA(Self Oriented Architecture)와 MSA는 아래의 근본적인 차이점들이 있다.

<h4>서비스 간의 통신</h4>

- SOA 애플리케이션은 SOAP 및 WS 표준 등 무거운 기술들을 주로 사용하고, 서비스를 통합하는 비즈니스와  
  메시지 처리 로직이 포함된 ESB라는 Smart Pipe를 사용한다.  
  반면, MSA에서 애플리케이션은 대개 가벼운 오픈 소스 기술을 사용하며, Message Broker, REST, gRPC와 같이  
  가벼운 프로토콜을 위주의 Dumb Pipe를 사용하여 서비스 간의 통신을 진행한다.

<h4>데이터</h4>

- SOA는 보통 전역 데이터 모델링을 하고, DB도 공유하지만 MSA는 각각 자체의 DB, 자체의 도메인 모델을 소유한다.

<h4>서비스의 크기</h4>

- SOA는 대부분 크고 복잡한 모놀리틱 애플리케이션들을 통합하는 용도로 사용된다.  
  마이크로서비스라고 해서 항상 작은 것은 아니지만, 대체로 SOA보다는 훨씬 규모가 작다.  
  SOA 애플리케이션은 덩치가 큰 서비스 몇 개로 구성되지만, 마이크로서비스 애플리케이션은 이보다 작은  
  수십 ~ 수백개의 서비스로 구성된다.
