# 복합 타입

## 배열

- Go도 배열을 갖지만, 직접 배열을 사용하는 경우는 드물다.

- 배열의 모든 요소는 지정된 타입이어야 한다. 배열을 선언하는 방법에는 몇 가지가 있는데, 첫 번째는 아래처럼 배열의 크기와 요소 타입을  
  지정하는 방법이다.

```go
var x [3]int
```

- 위 선언은 3개의 정수 요소를 갖는 배열을 생성한다. 값은 지정하지 않았기에 배열의 모든 위치에는 각각 정수의 zero value인 0이  
  들어간다. 배열에 초기값을 주려면 **배열 리터럴**로 요소 값을 넣을 수 있다.

```go
var x = [3]int{10, 20, 30}
```

- **희소 배열** (대부분의 값이 0으로 설정된 배열)을 만든다면, 배열 리터럴 내에 지정된 index의 값만 설정할 수 있다.

```go
var x = [12]int{1, 5: 4, 6, 10: 100, 15}
```

- 위 선언은 `[1, 0, 0, 0, 0, 5, 6, 0, 0, 0, 100, 15]`의 값을 갖는 배열을 생성한다.

- `==`와 `!=`를 사용해 배열 간의 비교도 가능하다.

```go
var x = [...]int{1, 2, 3}
var y = [3]int{1, 2, 3}
fmt.Println(x == y) // true
```

- Go에서 다차원 배열은 배열의 요소로 다른 배열을 포함하는 배열이다.

```go
var x [2][3]int
```

- 위에서 길이가 2인 정수 배열은 길이가 3인 정수 배열을 요소로 갖는다.  
  마지막으로 아래처럼 괄호를 사용해 값을 읽거나 쓸 수 있다.

```go
x[0] = 10
fmt.Println(x[2])
```

- 배열에서 배열의 끝을 넘어서거나 음수의 index를 사용해 값을 읽거나 쓸 수 없다. 이를 상수나 리터럴 index로 한다면 컴파일 오류가 발생한다.  
  범위를 넘어서는 값을 가진 변수를 통해 배열을 읽거나 쓰기를 시도한다면 컴파일은 되겠지만, 실행 중에 panic이 발생하며 실행이 중단된다.

- 마지막으로 내장 함수인 `len()`으로 배열의 길이를 알 수 있다.

```go
fmt.Println(len(x))
```

- 위에서 말했듯이 Go에서 배열은 거의 사용되지 않는다. 이유는 Go에서 배열의 크기를 배열 타입의 일부로 간주한다는 제한이 있기 때문이다.  
  예를 들어 `[3]int`로 선언된 배열은 `[4]int`와 다른 타입으로 만든다. 이는 곧 배열의 크기를 지정하기 위해 변수를 사용할 수  
  없다는 뜻이다. 왜냐면 타입은 실행 중이 아니라 컴파일 과정에서 반드시 해석되어야 하기 때문이다.

- 또한 동일한 타입을 가진 다른 크기의 배열 간에 타입 변환을 시도할 수도 없다. 크기가 다른 배열을 서로 변환할 수는 없기에  
  어떤 크기의 배열로도 실행 가능한 함수를 작성할 수 없으며, 동일한 변수에 크기가 다른 배열을 할당할 수 없다.

- 이러한 제약들 때문에 정확히 미리 필요한 크기를 아는 경우가 아니라면, 배열을 사용하지 않도록 한다.

---

## slice

---

## string, rune, byte

---

## map

---

## struct

---
