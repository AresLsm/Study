# 코드에서 나는 악취(1)

- 리팩토링을 어떻게 하는지는 알았을 것이지만, **언제** 해야할지를 판단하는 것은 쉽지 않다.  
  이 부분에서는 리팩토링을 해야할 징후들을 나열한다.

<h2>기이한 이름</h2>

- 추리 소설이라면 무슨 일이 전개되는지 궁금증을 자아낼수록 좋지만, 코드는 아니다.  
  코드는 단순하고 명료하게 작성해야 한다. 코드를 명료하게 표현하는 데 가장 중요한  
  요소 하나는 바로 _이름_ 이다. 그래서 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도  
  각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확하게 알 수 있도록 매우 신경써서  
  네이밍을 해야 한다.

- 하지만 이름 짓기는 프로그래밍에서 가장 어렵기로 손꼽히는 문제점 중 하나이다.  
  그 때문에 우리가 가장 많이 사용하는 리팩토링도 **함수 선언 바꾸기(함수명을 바꿀때도 사용한다)** ,  
  **변수 이름 바꾸기**, **필드 이름 바꾸기** 처럼 이름을 바꾸는 리팩토링이다.  
  굳이 그럴 가치가 없다는 생각에 이름 바꾸기를 꺼리는 사람들도 많은데, 이름만 잘 지어도 나중에  
  문맥을 파악하느라 헤매는 시간을 크게 절약할 수 있다.

- 이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니다. 마땅한 이름이 떠오르지 않는다면  
  설계에 더 근본적인 문제가 숨어 있을 가능성이 높다. 그래서 혼란스러운 이름을 잘 정리하다보면  
  코드가 훨씬 간결해질 때가 많다.

<hr/>

<h2>중복 코드</h2>

- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.  
  코드가 중복되면 각각을 볼 때마다 서로 차이점은 없는지 주의 깊게 살펴봐야 하는 부담이 생긴다.  
  그중 하나를 변경할 때는 다른 비슷한 코드들도 모두 살펴보고 적절히 수정해야 한다.

- 가장 간단한 코드 중복의 예시로, 한 클래스에 딸린 두 개의 메소드가 똑같은 표현식을 사용하는 경우가 있다.  
  이럴 때는 **함수 추출하기**로 양쪽 모두 추출된 메소드를 호출하도록 바꾸면 된다.  
  코드가 비슷하긴 한데 완전히 똑같진 않다면 **문장 슬라이드하기**로 비슷한 부분을 한 곳에 모아  
  함수 추출하기를 더 쉽게 적용할 수 있는지 살펴보자. 같은 부모로부터 파생된 서브클래스들에  
  코드가 중복되어 있다면 각자 따로 호출하지 않도록 **메소드 올리기**를 적용해 부모로 옮기자.

<hr/>

<h2>긴 함수</h2>

- 오랜 기간 잘 활용되는 프로그램들은 하나같이 다 짧은 함수들로 구성됐다.  
  짧은 함수들로 구성된 코드베이스를 얼핏 훑으면 연산하는 부분이 하나도 없어보인다.  
  코드가 끝없이 위임하는 방식으로 작성되어 있기 때문이다. 이런 코드들의 장점은 간접 호출의 효과, 즉  
  코드를 이해하고, 공유하고, 선택하기 쉬워지는 것인데 이는 함수를 짧게 구성할 때 나온다.

- 코드를 읽는 사람 입장에서는 함수가 하는 일을 파악하기 위해 여러 개의 다른 함수들도 왔다 갔다 해야하므로  
  부담이 된다. 다행이 함수 호출부와 선언부 사이를 빠르게 이동하거나 호출과 선언을 동시에 보여주는  
  개발 환경을 이용하면 이 부담은 줄어들지만, 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은  
  좋은 이름이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다.

- 그러기 위해서는 훨씬 적극적으로 함수를 쪼개야 한다. 필자는 주석을 달아야할만한 부분은 무조건  
  함수로 만든다. 그 함수 본문에는 원래 주석으로 설명하려던 코드가 담기고, 함수명은 동작 방식이 아닌  
  *의도*가 드러나게 짓는다. 이렇게 함수로 묶는 코드는 여러 줄일 수도 있고, 단 한 줄일 수도 있다.  
  심지어 원래 코드보다 길어지더라도 함수로 뽑는다. 단 **함수 이름에 코드의 목적을 드러내야 한다.**  
  여기서 핵심은 함수의 길이가 아닌 함수의 목적과 구현 코드의 괴리감이 얼마나 큰가다.  
  즉, *무엇을 하는지*를 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리하다.

- 함수를 짧게 만드는 작업의 99%는 **함수 추출하기**가 차지한다.  
  함수 본문에서 따로 묶어 빼내면 좋은 코드 덩어리를 찾아 새로운 함수로 만드는 것이다.

- 함수가 매개변수와 임시변수를 많이 사용한다면 추출 작업에 방해가 된다.  
  이런 상황에서 함수를 추출하다 보면 추출된 함수에도 매개변수가 많아져 추출하기 전보다 난해할 수 있다.  
  그렇다면 **임시변수를 질의함수로 바꾸기**로 임시 변수의 수를, **매개변수 객체 만들기**와  
  **객체 통째로 넘기기**로 매개변수의 수를 줄일 수 있을 것이다.

- 이 리팩토링 기법들을 적용해도 여전히 임시 변수와 매개변수가 너무 많다면 더 큰 수술이라  
  할 수 있는 **함수를 명령으로 바꾸기**를 고려해보자.

- 그렇다면 추출할 코드 덩어리는 어떻게 찾아낼까? 한 가지 좋은 방법은 **주석**을 참고하는 것이다.  
  주석은 코드만으로는 목적을 이해하기 어려운 부분에 달려 있는 경우가 많다. 이런 주석을 찾으면 주석이 설명하는  
  코드와 함께 함수로 빼내고, 함수 이름은 주석 내용을 토대로 짓는다. 코드가 단 한줄이어도  
  따로 설명할 필요가 있다면 함수로 추출하는게 좋다.

- **조건문이나 반복문**도 추출 대상의 실마리를 제공한다. 조건문은 **조건문 분해하기**로 대응한다.  
  거대한 switch문을 구성하는 case마다 **함수 추출하기**를 적용해서 각 case의 본문을 함수 호출문 하나로  
  바꾼다. 같은 조건을 기준으로 나뉘는 switch문이 여러 개라면 **조건문을 다형성으로 바꾸기**를 적용한다.

- 반복문도 그 안의 코드와 함께 추출해서 독립된 함수로 만든다. 추출한 반복문 코드에 적합한 이름이  
  떠오르지 않는다면 성격이 다른 두 가지 작업이 섞여 있기 때문일 수 있다. 이럴 때는 과감히 **반복문 쪼개기**를  
  적용해서 작업을 분리하자.

<hr/>

<h2>긴 매개변수 목록</h2>

- 매개변수 목록이 길다면 그 자체로 코드를 이해하기 어려울 때가 많다.

- 종종 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 수 있는데, 이런 매개변수는  
  **매개변수를 질의 함수로 바꾸기**로 제거할 수 있다. 사용 중인 데이터 구조에서 값들을 뽑아 각각을  
  별개의 매개변수로 전달하는 코드라면 **객체 통째로 넘기기**를 적용해서 원본 데이터 구조를 그대로 전달한다.  
  항상 함께 전달되는 매개변수들은 **매개변수 객체 만들기**로 하나로 묶어버린다. 함수의 동작 방식을 정하는  
  플래그 역할의 매개변수는 **플래그 인수 제거하기**로 없애준다.

- 클래스는 매개변수 목록을 줄이는 데 효과적인 수단이기도 하다.  
  특히 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 유용하다.  
  이럴 때는 **여러 함수를 클래스로 묶기**를 이용하여 공통 값들을 클래스의 필드로 정의한다.

<hr/>

<h2>전역 데이터</h2>

- 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없는게 문제다.  
  그래서 마치 _유령 같은 원격작용_ 처럼, 버그는 끊임없이 발생하는 데 그 원인이 되는 코드를  
  찾아내기가 굉장히 어렵다. 전역 데이터의 대표적인 형태는 전역 변수이지만 클래스 변수와  
  Singleton에서도 같은 문제가 발생한다.

- 이를 방지하기 위한 대표적인 리팩토링으로는 **변수 캡슐화하기**가 있다. 다른 코드에서 오염시킬 수 있는  
  가능성이 있는 데이터를 발견할 때마다 이 기법을 가장 먼저 적용하자. 이런 데이터를 함수로  
  감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다.  
  더 나아가 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록  
  접근 범위를 최소로 줄이는 것도 좋다.

- 전역 데이터가 가변(mutable)이라면 특히나 다루기 까다롭다. 프로그램이 구동된 후에는 값이  
  바뀌지 않는다고 보장할 수 있는 전역 데이터는 그나마 안전한 편이다. 물론 언어에서 이 기능을 제공해야 한다.

- 전역 데이터가 아무리 적다 하더라도 캡슐화하자!

<hr/>

<h2>가변 데이터</h2>

- 데이터를 변경했더니 예상치 못한 결과나 버그로 이어지는 경우가 종종 있다.  
  코드의 다른 곳에서는 다른 값을 기대한다는 사실을 인식하지 못한 채 수정해버리면 프로그램은 오작동한다.  
  특히 이 문제가 아주 드문 조건에서만 발생한다면 원인을 알아내기가 매우 어렵다.  
  이런 이유로 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시  
  원래 데이터는 그대로 둔 채 변경하려는 값에 해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼는다.

- 하지만 함수형 언어가 프로그래밍에서 차지하는 비중은 여전히 적고 변수 값을 바꿀 수 있는  
  언어를 사용하는 프로그래머가 더 많다. 그렇다고 해서 불변성이 주는 장점을 포기할 필요는 없다.  
  무분별한 데이터 수정에 따른 위험을 줄이는 방법은 얼마든지 있다.

- 가령 **변수 캡슐화하기**를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면  
  값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다. 하나의 변수에 용도가 다른 값들을  
  저장하느라 값을 갱신하는 경우라면 **변수 쪼개기**를 이용하여 용도별로 독립 변수에 저장하게 하여  
  값 갱신이 문제를 일으킬 여지를 없애자. 갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋다.  
  그러기 위해 **문장 슬라이드하기**와 **함수 추출하기**를 이용해서 무언가를 갱신하는 코드로부터  
  부작용이 없는 코드를 분리한다. API를 만들 때는 **질의 함수와 변경 함수 분리하기**를  
  활용해서 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게 한다.  
  저자는 가능하면 **세터 제거하기**도 적용한다. 간혹 setter를 호출하는 클라이언트를 찾는 것만으로도  
  변수의 유효범위를 줄이는 데 도움이 될 때가 있다.

- 값을 다른 곳에서 설정할 수 있는 가변 데이터가 풍기는 악취는 특히 고약하다.  
  혼동과 버그, 야근을 부를 뿐만 아니라 쓸데없는 코드이기도 하다.  
  이럴 때는 **파생 변수를 질의 함수로 바꾸기**를 적용해주자.

- 변수의 유효범위가 단 몇줄 뿐이라면 가변 데이터라해도 문제를 일으킬 일이 별로 없다.  
  하지만 나중에 유효범위가 넓어질 수도 있고, 그러면 위험도 덩달아 커진다.  
  따라서 **여러 함수를 클래스로 묶기**나 **여러 함수를 변환 함수로 묶기**를 활용해서  
  변수를 갱신하는 코드들의 유효범위를 클래스나 변환으로 제한한다.  
  구조체처럼 내부 필드에 데이터를 담고 있는 변수라면 일반적으로 **참조를 값으로 바꾸기**를 적용하여  
  내부 필드를 직접 수정하지 말고 구조체를 통째로 교체하는 편이 낫다.

<hr/>

<h2>뒤엉킨 변경</h2>

- 뒤엉킨 변경은 SRP(Single Responsibility Principle)가 제대로 지켜지지 않을 때 나타난다.  
  즉 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.  
  예를 들어 지원해야할 데이터베이스가 추가될 때마다 함수 세 개를 바꿔야 하고,  
  금융 상품이 추가될 때마다 또다른 함수 네개를 바꿔야 하는 모듈이 있다면 뒤엉킨 변경이  
  발생했다는 뜻이다. 데이터베이스 연동과 금융 상품 처리는 서로 다른 맥락에서 이뤄지므로  
  독립된 모듈로 분리해야 프로그래밍이 편하다. 그래야 무언가를 수정할 때 해당 맥락의 코드만  
  이해해도 진행할 수 있다.

- 데이터베이스에서 데이터를 가져와서 금융 상품 로직에서 처리해야하는 일처럼 순차적으로  
  실행되는게 자연스러운 맥락이라면, 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아  
  전달하게 하는 식으로 단계를 분리한다.(**단계 쪼개기**) 전체 처리 과정 곳곳에서  
  각기 다른 맥락의 함수를 호출하는 빈도가 높다면 각 맥락에 해당하는 적당한 모듈을 만들어서  
  관련 함수들을 모은다(**함수 옮기기**). 그러면 처리 과정이 맥락별로 구분된다.  
  이때 여러 맥락의 일에 관여하는 함수가 있다면 옮기기 전에 **함수 추출하기**부터 수행하자.  
  모듈이 클래스라면 **클래스 추출하기**가 맥락별 분리 방법을 잘 안내해줄 것이다.

<hr/>

<h2>산탄총 수술</h2>

- 산탄총 수술은 뒤엉킨 변경과 비슷하면서도 정반대다.

- 이 냄새는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다.  
  변경할 부분이 코드 전반에 퍼져있다면 찾기도 어렵고 꼭 수정해야할 곳을 지나치기 쉽다.

- 이럴 때는 함께 변경되는 대상들을 **함수 옮기기**와 **필드 옮기기**로 모두 한 모듈에 묶어두면  
  좋다. 비슷한 데이터를 다루는 함수가 많다면 **여러 함수를 클래스로 묶기**를 적용한다.  
  데이터 구조를 변환하거나 보강하는 함수들에는 **여러 함수를 변환 함수로 묶기**를 적용한다.  
  이렇게 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면 **단계 쪼개기**를  
  적용한다.

- 어설프게 분리된 로직은 **함수 인라인하기**나 **클래스 인라인하기** 같은 인라인 리팩토링으로  
  하나로 합치는 것도 산탄총 수술에 대처하는 좋은 방법이다. 메소드나 클래스가 비대해지지만, 나중에  
  추출하기 리팩토링으로 더 좋은 형태로 분리할 수도 있다.

- 작은 함수와 클래스에 지나칠 정도로 집착하지만 코드를 재구성하는 중간 과정에서는  
  큰 덩어리로 뭉쳐지는데 개의치 말자.

<hr/>
