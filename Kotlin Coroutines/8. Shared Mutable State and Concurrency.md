# Shared Mutable State and Concurrency

- Coroutine들은 `Dispatchers.Default`와 같은 multi-threaded dispatcher를 사용해 병렬적으로 수행될 수 있다.  
  하지만 모든 동시성 문제도 함께 안고 간다. 그중 가장 큰 문제점은 공유되는 가변 상태(shared mutable state)에 대한 접근을 동기화하는 것이다.  
  이를 해결하기 위해 coroutine이 선택한 방법은 multi-thread와 비슷한 것도 있지만, coroutine에 unique한 것도 있다.

## The Problem

- 동일한 동작을 1000번 수행하는 coroutine을 100개 실행시켜보자.

```kt
suspend fun massiveRun(action: suspend() -> Unit) {
	val n = 100
	val k = 1000
	val time = measureTimeMillis {
		coroutineScope {
			repeat(n) {
				launch {
					repeat(k) { action() }
				}
			}
		}
	}
	println("Completed ${n * k} actions in $time ms")
}

var counter = 0

fun main() = runBlocking {
	withContext(Dispatchers.Default) {
		massiveRun {
			counter++
		}
	}
	println("Counter = $counter")
}
```

- 위 코드는 절대 counter값이 100000에 도달하지 않는다. 이론 상으로라면 `1000 * 100 = 100000`이어야 하는데, 왜 그럴까?  
  바로 100개의 coroutine들이 여러개의 thread에서 동기화 없이 counter 변수에 동시에 접근하기 때문이다.

---

## Volatiles are no of help

- 변수를 volatile 키워드를 적용한 채 선언하면, 이 문제가 해결될 것이라는 잘못 알려진 상식이 있다.  
  실제로 아래 코드를 실행해 봐도, counter는 절대 100000에 도달하지 못한다.

```kt
@Volatile
var counter = 0

fun main() = runBlocking {
	withContext(Dispatchers.Default) {
		massiveRun {
			counter++
		}
	}
	println("Counter = $counter")
}
```

- 위 코드는 counter에 `@Volatile`이 적용되지 않은 코드보다 수행 시간은 길지만, 역시 counter는 100000에 도달하지 못한다.  
  이는 volatile이 선형적인(linearizable, atomic) read, write 연산에 대한 순서는 보장하지만, 위 코드에서 발생한  
  increment 등의 더 큰 action에 대한 atomicity(원자성)은 보장하지 않기 때문이다.

---

## Thread-Safe Data Structures

- Thread와 Coroutine의 동시성 문제를 모두 해결할 수 있는 가장 일반적인 해결책으로 thread-safe(synchronized, atomic, linearizable)한  
  자료구조를 사용할 수 있다. 이 자료구조는 공유 상태(shared state)에 대한 연산을 모두 동기화해준다.

- 위 예시에서의 counter 변수에 대해서는 `AtomicInteger` 클래스를 사용할 수 있다.

```kt
var counter = AtomicInteger()

fun main() = runBlocking {
	withContext(Dispatchers.Default) {
		massiveRun {
			counter.incrementAndGet()
		}
	}
	println("Counter = $counter")
}
```

- `AtomicInteger`를 사용하는 것은 이 문제에 대한 해결책 중 하나다. 이렇게 thread-safety를 보장하는 자료구조를 사용하는 것은 일반적인 counter연산,  
  컬렉션, queue 등의 자료구조에 대한 기본적인 연산에 대한 동기화를 수행할 수 있다. 하지만 복잡한 state나 복잡한 연산을 수행할 때 쉽게 thread-safe하게  
  만들기가 꽤나 까다롭다.

---
