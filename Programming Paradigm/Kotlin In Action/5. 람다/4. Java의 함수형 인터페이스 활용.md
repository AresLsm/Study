# Java의 함수형 인터페이스 활용

- 코틀린 라이브러리와 람다를 사용하는 것은 멋지지만, 우리가 다뤄야 하는 API 중 상당수는 코틀린이 아니라 Java로  
  작성된 API일 가능성이 높다. 다행인 점은 코틀린 람다를 Java API에 사용해도 아무런 문제가 없다는 것이다.

- 이전에 본 Java 메소드에 람다를 넘기는 예제를 보자.

```kt
button.setOnClickListener { /* 클릭 시 수행할 동작 */ }
```

- `Button` 클래스는 `setOnClickListener()` 메소드를 사용해 버튼의 리스너를 설정한다.  
  이때 인자의 타입은 `OnClickListener`이다.

```java
public class Button {
    public void setOnClickListener(OnClickListener listener) {
	// ...
    }
}
```

- `OnClickListener` 인터페이스는 `onClick()`이라는 메소드만 선언된 인터페이스다.

```java
public interface OnClickListener {
    void onClick(View v);
}
```

- Java8 이전의 Java에서는 `setOnClickListener()`에게 인자로 넘기기 위해 무명 클래스 인스턴스를 만들어야했다.

```java
button.setOnClickListener(new OnClickListener() {
    @Override public void onClick(View v) {
	// 클릭 시 수행할 동작
    }
})
```

- 코틀린에서는 무명 클래스 인스턴스 대신 람다를 넘길 수 있다.

```kt
button.setOnClickListener { view -> /* .. */ }
```

- `OnClickListener`를 구현하기 위해 사용한 람다에는 view 파라미터가 있다. 이 파라미터의 타입은 `View`이다.  
  이는 `onClick()`의 인자 타입과 같다.

- 이런 코드가 작동하는 이유는 `OnClickListener` 인터페이스에 추상 메소드가 단 하나만 있기 때문이다.  
  이런 인터페이스를 **함수형 인터페이스(Functional Interface)** 혹은 **SAM 인터페이스** 라고 한다.  
  SAM은 **단일 추상 메소드(Single Abstract Method)** 라는 뜻이다. Java API에는 `Runnable`이나  
  `Callable` 같은 함수형 인터페이스와 그런 함수형 인터페이스를 활용하는 메소드가 많다. 코틀린은 함수형 인터페이스를  
  인자로 취하는 Java 메소드를 호출할 때 람다를 넘길 수 있게 해준다. 따라서 코틀린 코드는 무명 클래스 인스턴스를  
  정의하고 활용할 필요가 없어 여전히 깔끔하며 코틀린다운 코드로 남아있을 수 있다.
