# 비격리 문제 처리

- ACID의 격리성(I, Isolation)은 동시에 실행 중인 여러 트랜잭션의 결과가  
  어떤 순서대로 실행된 결과와 동일함을 보장하는 속성이다. 그래서 각 ACID 트랜잭션이  
  DB 데이터에 배타적으로 접근하듯이 동작하고, 개발자는 동시 실행되는 비즈니스  
  로직을 쉽게 작성할 수 있다.

- 그런데 Saga의 문제는 바로 이 `I`가 빠져 있다는 것이다.  
  실제로 Saga의 한 트랜잭션이 커밋한 변경분을 다른 Saga가 즉시 바라볼 수 있다.  
  이는 두 가지 문제를 야기한다. 첫째, **한 saga가 실행 중에 접근하는 데이터를 도중에 다른**  
  **saga가 바꿔치기할 수 있다.** 둘째, **한 saga가 업데이트를 하기 이전의 데이터를 다른 Saga가**  
  **읽을 수 있어서 데이터 일관성이 깨질 수 있다.** Saga는 사실 ACD 트랜잭션으로 봐야 한다.

  - **원자성(Atomicity)** : Saga는 트랜잭션을 모두 완료하거나 모든 변경분을 undo해야 한다.
  - **일관성(Consistency)**: 서비스 내부의 참조 무결성은 로컬 DB가, 여러 서비스에 걸친  
    참조 무결성은 서비스가 처리한다.
  - **지속성(Durability)** : 로컬 DB로 처리한다.

- 격리가 안되면 DB 용어로 _비정상(anomaly)_ 이 나타날 가능성이 있다. 트랜잭션이  
  차례대로 실행되지 않는 것처럼 데이터를 읽고 쓰게 되는 형상이다. 그래서 Saga를 동시 실행한  
  결과와 순차 실행한 결과가 달라질 수 있다.

- 비격리는 도저히 용납되지 못할 문제처럼 보이지만, 실제로 성능 향상을 위해 격리 수준을  
  낮추어 개발하는 경우가 흔하다. RDBMS는 격리 수준을 트랜잭션마다 다르게 지정할 수 있고,  
  기본적으로 완전 격리(Full Isolation)보다 약한 격리 수준을 적용한다.  
  그러나 실무에서는 ACID 트랜잭션과 다른 DB 트랜잭션을 사용할 때가 많다.

<h2>비정상 개요</h2>

- 비격리로 인한 비정상은 아래와 같이 정리할 수 있다.

  - **소실된 업데이트(lost updates)** : 한 Saga의 변경분을 다른 Saga가 미처 못 읽고  
    덮어쓴다.
  - **Dirty Reading** : Saga 업데이트를 하지 않은 변경분을 다른 트랜잭션이나 Saga가 읽기 쉽다.
  - **fuzzy/반복 불가능한 읽기(nonrepeatable reads)** : 한 Saga의 상이한 두 단계가  
    같은 데이터를 읽어도 결과가 달라지는 형상으로, 다른 Saga가 그 사이 업데이트를 했기에 생기는 문제이다.

- 소실된 업데이트, Dirty Reading은 가장 흔하지만 처리하기는 가장 까다로운 비정상 현상이다.

<h3>소실된 업데이트</h3>

- 소실된 업데이트는 한 Saga의 변경분을 다른 Saga가 덮어 쓸 때 발생한다.

  - (1) 주문 생성 Saga 첫 번째 단계에서 주문을 생성한다.
  - (2) Saga 실행 도중 주문 취소 Saga가 주문을 취소한다.
  - (3) 주문 생성 Saga의 마지막 단계에서 주문을 승인한다.

- 주문 생성 Saga는 주문 취소 Saga가 업데이트한 데이터를 덮어쓰게 되고,  
  결국 고객은 자신이 주문 취소한 음식을 배달받게 될 것이다.

<h3>Dirty Reading</h3>

- Dirty Reading은 한 Saga가 업데이트 중인 데이터를 다른 Saga가 읽을 때 발생한다.  
  예를 들어, 배달 음식 애플리케이션의 소비자는 각각 신용 한도가 정해져 있고, 주문 취소 Saga는  
  아래와 같은 트랜잭션으로 구성된다.

  - 소비자 서비스: 신용 잔고를 늘린다.
  - 주문 서비스: 주문을 취소 상태로 변경한다.
  - 배달 서비스: 배달을 취소한다.

- 주문 취소 Saga와 주문 생성 Saga의 실행이 서로 겹쳐 실행중인데, 소비자가 배달을  
  취소하기에는 너무 늦어서 주문 취소 Saga가 롤백되는 경우를 생각해보자.  
  소비자 서비스를 호출하는 트랜잭션 순서가 아래처럼 엉켜버릴 수 있을 것이다.

  - 주문 취소 Saga: 신용 잔고를 늘린다.
  - 주문 생성 Saga: 신용 잔고를 줄인다.
  - 주문 취소 Saga: 신용 잔고를 줄이는 보상 트랜잭션이 가동된다.

- 주문 생성 Saga는 Dirty Reading을 하게 되고, 소비자는 신용 한도를 초과하는 주문도  
  할 수 있게 될 것이다. 실제로 이런 일이 발생하면 매우 곤란할 것이다.

<hr/>

<h2>비격리 대책</h2>

- 개발자는 비격리로 인한 비정상을 방지하고, 비즈니스에 미치는 영향을 최소화하는 방향으로  
  Saga를 작성해야 한다. 이미 앞서 나왔던 `APPROVAL_PENDING` 처럼 `*_PENDING` 상태도  
  이런 현상을 예방하는 전략 중 하나이다. 주문 생성 Saga처럼 주문을 업데이트하는 Saga는  
  일단 주문을 `*_PENDING` 상태로 두고 시작한다. 현재 주문을 Saga로 업데이트하는 중이니  
  그에 맞게 행동하라고 다른 Saga에게 알리는 것이다.

- 이런 식으로 `*_PENDING` 상태를 두는 것은 시맨틱 락 대책(Semantic Lock Contermeasure)이라  
  칭한 기법의 일례이다. 이를 다루는 논문에는 분산 트랜잭션을 사용하지 않는 다중 DB 아키텍쳐에서  
  트랜잭션 비격리 문제를 처리하는 방법 등 Saga 설계 시 도움이 될만한 내용이 많다.

  - **시맨틱 락(Semantic Lock)** : 애플리케이션 수준의 락
  - **교환적 업데이트(Commutative Updates)** : 업데이트 작업은 어떤 순서로 실행해도  
    되게끔 설계한다.
  - **비관적 관점(Pessimistic View)** : Saga 단계 순서를 재조정하여 비즈니스 리스크를 최소화한다.
  - **값 다시 읽기(Re-read Value)** : 데이터를 덮어쓸 때 그 전에 변경된 내용은 없는지 값을  
    다시 읽고 확인하여 Dirty Writing을 방지한다.
  - **버전 파일(Version File)** : 순서를 재조정할 수 있도록 업데이트를 기록한다.
  - **값에 의한(By Value)** : 요청별 비즈니스 위험성을 기준으로 동시성 메커니즘을 동적으로 선택한다.

- 비격리 대책을 자세히 살펴보기 전에, 먼저 Saga의 구조를 나타내는 용어를 보자.

<h3>Saga의 구조</h3>

- Saga는 아래의 3가지 트랜잭션으로 구성된다.

  - **보상 가능 트랜잭션(Compensatable Transaction)** : 보상 트랜잭션으로 롤백 가능한 트랜잭션
  - **피봇 트랜잭션(Pivot Transaction)** : Saga의 진행/중단 지점으로, 피봇 트랜잭션이 커밋되면  
    Saga는 완료될 때까지 실행된다. 피봇 트랜잭션은 보상 가능 트랜잭션, 재시도 가능 트랜잭션 중 그 어느쪽도  
    아니지만, 최종 보상 가능 트랜잭션 또는 최초 재시도 가능 트랜잭션이 될 수는 있다.
  - **재시도 가능 트랜잭션(Retriable Transaction)** : 피봇 트랜잭션 직후의 트랜잭션으로,  
    반드시 성공하는 트랜잭션이다.

- 주문 생성 Saga에서 주문을 생성하는 `createOrder()`, 소비자 정보를 확인하는 `verifyCustomerDetails()`,  
  티켓을 생성하는 `createTicket()`은 모두 보상 가능 트랜잭션이다. `createOrder()`, `createTicket()`은  
  자신의 업데이트를 undo 하는 보상 트랜잭션을 각각 `rejectOrder()`, `rejectTicket()`으로 가지고 있으며  
  `verifyConsumerDetails()`는 읽기 전용이기에 따로 보상 트랜잭션이 필요 없다. 이 Saga의 피봇 트랜잭션은  
  신용카드 승인을 하는 `authorizeCreditCard()`이다. 소비자 신용카드가 승인되면, 이 Saga는 반드시 완료된다.  
  `approveTicket()`, `approveOrder()`는 피봇 트랜잭션 이후의 재시도 가능 트랜잭션이다.

- 보상 가능 트랜잭션과 재시도 가능 트랜잭션의 차이점은 특히 잘 알아두어야 한다.  
  트랜잭션 종류마다 대책에서 하는 역할이 다르기 때문이다. 마이크로서비스로 전환 시  
  모놀리틱도 Saga에 참여해야 하는 경우도 있고, 모놀리틱이 재시도 가능 트랜잭션만  
  실행하면 처리하기가 아주 간단해진다.

<h3>대책: 시맨틱 락</h3>

- 시맨티 락(Semantic Lock)은 보상 가능 트랜잭션이 생성/수정하는 레코드에 무조건  
  플래그를 세팅하는 대책이다. 레코드가 아직 커밋 전이라서 변경될지 모른다는 표시를 하는 것이다.  
  플래그를 세팅해서 다른 트랜잭션이 레코드에 접근하지 못하게 lock을 걸어 놓거나,  
  다른 트랜잭션이 해당 레코드를 처리할 때 조심하도록 경고하는 것이다.  
  플래그는 재시도 가능 트랜잭션(Saga 완료) 또는 보상 트랜잭션(Saga 롤백)에 의해 해제된다.

- `Order.state` 필드가 좋은 예시이다. `*_PENDING` 상태가 바로 이 시맨틱 락을 구현한 것이다.  
  이 필드를 이용하여 주문에 접근하는 다른 Saga에 현재 어떤 Saga가 주문을 업데이트하고 있음을  
  알린다. 가령 주문 생성 Saga의 첫 번째 단계(`createOrder()`, 보상 가능 트랜잭션)는  
  `APPROVAL_PENDING` 상태로 주문을 생성하고, 마지막 단계(`approveOrder()`, 재시도 가능 트랜잭션)는  
  이 필드를 다시 `APPROVED`로 변경한다. 보상 트랜잭션은 이 필드를 `REJECTED`로 변경한다.

- Lock도 관리해야 하지만 잠금된 레코드를 어떻게 Saga로 처리할지 사례별로 결정해야 한다.  
  예를 들어, 클라이언트가 `cancelOrder()`를 호출해서 `APPROVAL_PENDING` 상태의 주문을  
  취소하려면 어떻게 해야할까?

- 해결 방법은 몇 가지 있다. 먼저 `cancelOrder()`를 실패 처리하고, 클라이언트에게 나중에 다시  
  시도하라고 알리는 것이다. 구현하기는 간단해서 좋지만, 재시도 로직까지 구현해야 하므로  
  클라이언트가 복잡해진다.

- Lock이 해제될 때까지 `cancelOrder()`를 블로킹하는 방식도 있다. 시맨틱 락을 사용하면  
  ACID 트랜잭션 고유의 격리 기능을 되살릴 수 있다. 같은 레코드를 업데이트하는 Saga를  
  직렬화시킬 수 있어 프로그래밍 부담이 확 줄어들고, 클라이언트가 재시도 해야하는 부담도 덜 수 있다.  
  물론 애플리케이션에서 lock을 관리하는 부담은 감수해야 한다. 또 deadlock 감지 알고리즘을  
  구현해서 deadlock이 발생하면 Saga를 롤백시켜 deadlock을 해소하고 재실행할 수 있게 조치해야 한다.

<h3>대책: 교환적 업데이트</h3>

- 업데이트를 *교환적*으로, 즉 어떤 순서로도 실행 가능하게 설계하면 소실된 업데이트 문제를  
  방지할 수 있다. 이를테면 `Account`의 `debit()`(인출), `credit()`(입금)은  
  서로 교환적인 작업이다.(마이너스 통장이 아니라는 가정 하에)

- 보상 가능 트랜잭션이 계좌를 인출(debit) 또는 입금(credit) 후 Saga를 롤백시켜야 하는  
  상황이라면 보상 트랜잭션은 단순히 계좌를 입금 또는 인출해서 업데이트를 undo하면 된다.  
  다른 Saga의 업데이트를 덮어쓸 일은 전혀 없다.

<h3>대책: 비관적 관점</h3>

- 비관적 관점(Pessimistic View)은 Dirty Reading으로 인한 비즈니스 리스크를 최소화하기 위해  
  Saga 단계의 순서를 재조정하는 것이다. Dirty Reading 예시를 한 번 더 생각해보자.  
  주문 취소 Saga 단계를 아래와 같이 재조정하면 주문 생성 Saga가 신용 잔고를 Dirty Reading해서  
  소비자 신용 한도를 초과하는 주문을 생성할 위험성을 줄일 수 있다.

- 기존 Saga 단계

  - 소비자 서비스: 신용 잔고를 늘린다.
  - 주문 서비스: 주문을 취소 상태로 변경한다.
  - 배달 서비스: 배달을 취소한다.

- 바꾼 Saga 단계

  - 주문 서비스: 주문을 취소 상태로 변경한다.
  - 배달 서비스: 배달을 취소한다.
  - 회계 서비스: 신용 잔고를 늘린다.

- 이렇게 순서를 바꾸면 신용 잔고는 재시도 가능 트랜잭션에서 증가하므로  
  Dirty Reading 가능성은 사라진다.

<h3>대책: 값 다시 읽기</h3>

- 값 다시 읽기(Re-Read Value)는 소실된 업데이트를 방지하는 대책이다. Saga가 레코드를  
  업데이트하기 전에 값을 다시 읽어 값이 변경되지 않았는지 확인하는 것이다. 값을 다시 읽었더니  
  변경되었다면 Saga를 중단하고 나중에 재시작한다. 이 대책은 일종의 낙관적 오프라인 락  
  (Optimistic Offline Lock) 패턴이다.

- 이 대책을 주문 생성 Saga에 적용하면 주문이 승인되는 도중 취소되는 불상사를 방지할 수 있다.  
  주문 승인 트랜잭션은 해당 주문이 처음 생성된 이후 이전 Saga 단계에서 변경되었는지 확인한다.  
  변경되지 않았으면 주문을 승인 처리하고, 주문이 취소되었으면 Saga를 멈추고 보상 트랜잭션을  
  가동한다.

<h3>대책: 버전 파일</h3>

- 버전 파일은 레코드에 수행한 작업을 하나하나 기록하는 대책이다.  
  즉, 비교환적 작업을 교환적으로 변환하는 방법이다. 가령 주문 생성 Saga와 주문 취소 Saga가  
  동시 실행된다고 해보자. 시맨틱 락 대첵을 쓰지 않으면 주문 생성 Saga가 소비자 신용카드를  
  승인하기 전에 주문 취소 Saga가 해당 신용카드를 승인 취소하는 말도 안되는 상황이  
  벌어질 수 있다.

- 순서가 안 맞는 요청을 회계 서비스가 받아 처리하려면, 작업이 도착하면 기록해 두었다가  
  정확한 순서대로 실행하면 된다. 방금 전 같은 경우에는 회계 서비스는 일단 승인 취소 요청을  
  기록하고, 나중에 신용카드 승인 요청이 도착하면 이미 승인 취소 요청이 도착한 상태이니  
  승인 작업은 생략해도 되겠다고 인지하는 것이다.

<h3>대책: 값에 의한</h3>

- 값에 의한 대책은 비즈니스 위험성을 기준으로 동시성 메커니즘을 선택하는 것이다.  
  애플리케이션 차원에서 각 요청의 속성을 보고 Saga를 쓸지, 아니면 분산 트랜잭션을 쓸지  
  판단하는 것이다. 위험성이 낮은 요청은 지금까지 본 대채깅 적용된 Saga를, 위험성이 큰  
  요청은 분산 트랜잭션을 실행한다.

- 애플리케이션이 비즈니스 위험성, 가용성, 확장성을 능동적으로 저울질할 수 있는 전략이다.

<hr/>
